Mac DND bug

compare two identical operations, Linux, Mac:

* open app
* drag ColdHot color spec on top of ROYGBIV
* choose Move

on Linux, it moves after ROYGBIV, as expected

on Mac:
* the ColdHot item "disappears" from main tree
* is still in the list, in slot 0
* if you BrowseMe, you see ColdHost in slot0 in new tree



Crash on close of 12ax proj

* save a version that saves all units
* run then stop the network
* browse all the specs and all the layers
* close the project

crashes in:

  Network::CutLinks
  specs.CutLinks
  specs.RemoveAll
  RemoveIdx(0)
  El_disOwn for el
  el::Destroying
   el.dl->DataDestroying
   while removing clients: note that size=172!!!!
    (therefore, occurring for item idx=172 that was just popped)
   dlc->RemoveDataLink -- CRASH

notes: 
  the dl itself seems ok (ex. the clients list seems sensible)
  the dlc gives error "Cannot access memory at..."
  the dlc addr itself seems valid, but looks to have been already 
    destructed 

Invariants:

* DataLink and DLC are supposed to have an invariant relationship
  that makes it impossible for either to destroy w/o properly
  decoupling from the other


Summary:

* a UnitSpec-derivitive is crashing during Network::specs.CutLinks
  seemingly because a DataLinkClient it is trying to remove from
  its spec's reference has already destroyed


"no datalink" err msg

* create Network, UnitSpec, then click it to view props
* you get the "Attempt to add ... " for no datalink

occurs in member:
  bias_spec.spec



Tree Browsing Show/Hide

Program Reset bug

crash occurs as follows, in load of lib:

Program::Reset
  vars.Reset
  removal of item ProgVar
  ProgVar issues its DataDestroying
  a RefList gets the DLDestroying
  RL removes the el
  RL disown/unref of item calls item.RemoveDataClient
  item.RDC gets its link reference (the one that is invalid)
  dl.RDB crashes when accessing the list of clients, because dl is invalid
  NOTE: occurs on last ProgVar removal from vars, "trial"

      
it is actually the DataLink itself that must be invalid, since it has
several illegal values (prob random memory)

therefore, the taBase guy has his dl in his dl slot, when the dl is
invalid

How To Invoke the bug:

 * open leabra_ra.proj
 * select LeabraEpoch and Browse Me
 * on first LE, do Reset
 * you get the crash

Mystery To Solve

the "guy" in question is a ProgVar

How can a ProgVar get into a state whereby the dl field is non-null
(indicates an object) yet that address does not point to a valid DataLink?

1. ProgVar itself is not a valid object (ie, bad pointer)
  2. ProgVar has deleted, and we are still accessing it
  3. dl field is not properly initialized to NULL
4. dl field does not get set to NULL when its referent deletes
5. dl field somehow gets set to a bad pointer, or already deleted DataLink
6. (maybe a variant on something above) dl was valid at a point on call chain,
   but a destroy action of some kind during the chain has invalidated the dl
  7. memory corruption, perhaps caused by a bug in Load code
  8. some other obscure issue of corruption or invalidness due to load code

1. 
  this is quite unlikely -- all the stuff from the obj is showing
  in the gui, meaning all the accesses, fields, typeinfo, taiv's etc.
  all had to be valid
  * if object somehow deleted early, then the Destroy would have run,
  and the dl should have been delete, 

2.
  for this to happen, the mlink field would still need to be unNULLed
  since i put in a check for non-null, and object::delete calls the
  link code on delete, this cannot be the one

3. very unlikely, since taOBase.Initialize sets dl to NULL

4.
  this would require a bad reference address in the first place,
  note that the original creation code was responsible for setting
  the link

7, 8: Load not needed 

Description of Delete of CutLinks process for taOBase

* Destroy always invokes CutLinks...
* CutLinks: if there is a dl, call dl->DataDestroying
* dl->DataDestroying pops all clients, calling their notify routine
  when the list is empty, the link itself deletes
  the link uses its address of its ref to null that ref
Invariant: the link ref in host is valid, right up to point
  where DataLink destroys; in ~DL, it nulls the ref

DataLink invariants:

* only one constructor, which requires a ref address 
  2 params means can never be called implicitly
* NOTE: creation doesn't set the ref instance!


TRY

* disable the CtrlPanel refreshing altogether, but still
  put all the ProgVar guys on the RefList
  * does not crash

debug T3 selection

leabra_ra.proj


if you delete top layer, then next layer
then select bottom layer,
you get a segfault on bottom layer in the 
iTabView::GetDataPanel() routine, for i = 5

caused because the i=5 panel is the one created for the item
previously selected then deleted -- that panel should
no longer be on the list, because the item i


after deleting the layer, when you click on the next layer,
the iTabView::AddPanel gets called twice with the same panel

an issue if we try to ActivatePanel based on link,
but we aren't matching panel exactly

why wasn't GetDataPanel returning the panel, based on link?
context:



* select Input layer

If you then delete it:

1. you don't get a Deselect event (so the T3 select list will now contain a zombie entry)
2. you get the following errors:
  removeChild: tried to remove non existent T3LayerNode
  removeChild: tried to remove non existent T3PrjnNode

2 implies that the node is being autodeleted before it is being manually deleted



calls to AddRemove:
w/ NetView
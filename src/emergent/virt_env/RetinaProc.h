// Copyright 2013-2018, Regents of the University of Colorado,
// Carnegie Mellon University, Princeton University.
//
// This file is part of The Emergent Toolkit
//
//   This library is free software; you can redistribute it and/or
//   modify it under the terms of the GNU Lesser General Public
//   License as published by the Free Software Foundation; either
//   version 2.1 of the License, or (at your option) any later version.
//
//   This library is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//   Lesser General Public License for more details.

#ifndef RetinaProc_h
#define RetinaProc_h 1

// parent includes:
#include <taNBase>
#include "network_def.h"

// smartptr, ref includes
#include <taSmartRefT>

// member includes:
#include <VisRegionSpecBaseList>
#include <float_Matrix>
#include <taImageProc>


// declare all other types mentioned but not required to include:
class VisRegionSpecBase; // 
class taImage; // 
class DataTable; // 


eTypeDef_Of(RetinaProc);

class E_API RetinaProc : public taNBase {
  // #STEM_BASE ##CAT_Image ##DEF_CHILD_regions ##DEF_CHILDNAME_Regions full specification of retinal filtering -- takes raw input images, applies various transforms, and then runs through filtering -- first region is used for retina size and other basic params
INHERITED(taNBase)
public:
  taImageProc::EdgeMode edge_mode;      // how to deal with edges in processing the raw images in preparation for presentation to the filters -- each region has its own filter-specific edge mode which is not automatically sync'd with this one (and they can be different).  if mode = WRAP, and scaled image is smaller than the retina, then BORDER is actually used instead to prevent the weird tiling effect that otherwise occurs
  int                   fade_width;     // #CONDSHOW_ON_edge_mode:BORDER for border mode -- how wide of a frame to fade in around the border at the end of all the operations 
  VisRegionSpecBaseList regions;        // defines regions of the visual input where the processing actually takes place -- most of the specification is at this level -- first region is used for retina size and other basic params

  float_Matrix          raw_image_r;    // #READ_ONLY #NO_SAVE current raw input image presented to system, for right eye or only eye if monocular
  float_Matrix          raw_image_l;    // #READ_ONLY #NO_SAVE current raw input image presented to system, for left eye -- only if binocular

  float_Matrix          xform_image_r;  // #READ_ONLY #NO_SAVE current transformed version of raw image presented to system, for right eye or only eye if monocular
  float_Matrix          xform_image_l;  // #READ_ONLY #NO_SAVE current transformed version of raw image presented to system, for left eye -- only if binocular

  virtual VisRegionSpecBase* AddRegion()        { return (VisRegionSpecBase*)regions.New(1); }
  // #BUTTON #CAT_Filter add a new region -- type is whatever the default is for this type of retina processor

  ///////////////////////////////////////////////////////////////////////
  // Basic functions operating on float image data: transform image, apply filters

  virtual bool  Init();
  // #BUTTON initialize the filters, data table, etc -- call this in the init_code of any Program that is using this object

  virtual bool  TransformImageData(float_Matrix* right_eye_image,
                                   float_Matrix* left_eye_image = NULL, 
                                   float move_x=0.0f, float move_y=0.0f,
                                   float scale = 1.0f, float rotate = 0.0f);
  // #CAT_Transform transform image data in matrix format, with retina centered at given normalized offsets from center of image (move -1=far left edge, 0=ctr, 1=far right edge), scaled by given factor (1=same size, .5 = half size, 2 = double size), rotated by normalized units (1=360deg)

  virtual bool  LookAtImageData(float_Matrix* right_eye_image,
                                float_Matrix* left_eye_image = NULL, 
                                VisRegionParams::Region region = VisRegionParams::FOVEA,
                                float box_ll_x=0.0f, float box_ll_y=0.0f,
                                float box_ur_x=1.0f, float box_ur_y=1.0f,
                                float move_x=0.0f, float move_y=0.0f,
                                float scale = 1.0f, float rotate = 0.0f);
  // #CAT_Transform transform image data in matrix format, with region of retina centered and scaled to fit the box coordinates given in 0-1 normalized units (ll=lower-left, ur=upper-right); additional scale, rotate, and move params applied after foveation scaling and offsets

  virtual bool  FilterImageData(bool motion_only = false);
  // #CAT_Filter filter retinal image data -- operates on images that were generated from prior Transform or LookAt calls -- must call one of those first -- if motion_only = true, then only process up to level of motion, for faster processing of initial frames of motion sequence


  ///////////////////////////////////////////////////////////////////////
  // Transform Routines taking different sources for image input data

  virtual bool  ConvertImageToMatrix(float_Matrix& img_data, taImage* img, 
                                     VisRegionParams::Color color);
  // #CAT_Image convert image file to img_data float matrix, converting to color or monochrome as specified

  virtual bool  TransformImage(taImage* right_eye_image, taImage* left_eye_image = NULL,
                               float move_x=0, float move_y=0,
                               float scale = 1.0f, float rotate = 0.0f);
  // #CAT_Transform transform image/s in image format, with retina centered at given normalized offsets from center of image (move -1=far left edge, 0=ctr, 1=far right edge), scaled by given factor (1=same size, .5 = half size, 2 = double size), rotated by normalized units (1=360deg)

  virtual bool  TransformImageName(const String& right_eye_img_fname,
                                   const String& left_eye_img_fname = "",
                                   float move_x=0, float move_y=0,
                                   float scale = 1.0f, float rotate = 0.0f);
  // #BUTTON #CAT_Transform #FILE_DIALOG_LOAD load image/s from file/s and transform image data, with retina centered at given normalized offsets from center of image (move: -1=far left edge, 0=ctr, 1=far right edge), scaled by given factor (zoom), rotated by normalized units (1=360deg)

  virtual bool  LookAtImage(taImage* right_eye_image,
                            taImage* left_eye_image = NULL, 
                            VisRegionParams::Region region = VisRegionParams::FOVEA,
                            float box_ll_x=0.0f, float box_ll_y=0.0f,
                            float box_ur_x=1.0f, float box_ur_y=1.0f,
                            float move_x=0.0f, float move_y=0.0f,
                            float scale = 1.0f, float rotate = 0.0f);
  // #CAT_Transform transform image/s in image format, with region of retina centered and scaled to fit the box coordinates given in 0-1 normalized units (ll=lower-left, ur=upper-right); additional scale, rotate, and move params applied after foveation scaling and offsets

  virtual bool  LookAtImageName(const String& right_eye_img_fname,
                                const String& left_eye_img_fname = "",
                                VisRegionParams::Region region = VisRegionParams::FOVEA,
                                float box_ll_x=0.0f, float box_ll_y=0.0f,
                                float box_ur_x=1.0f, float box_ur_y=1.0f,
                                float move_x=0, float move_y=0,
                                float scale = 1.0f, float rotate = 0.0f);
  // #BUTTON #CAT_Filter #FILE_DIALOG_LOAD load image/s from file/s and transform image data, with region of retina centered and scaled to fit the box coordinates given (ll=lower-left coordinates, in pct; ur=upper-right); additional scale, rotate, and offset params add to foveation scaling and offsets

  ///////////////////////////////////////////////////////////////////////
  // Misc other processing operations

  virtual bool  AttendRegion(DataTable* dt, VisRegionParams::Region region = VisRegionParams::FOVEA);
  // #CAT_Filter apply attentional weighting filter to filtered values, with radius = given region

  // todo: need a checkconfig here..

  taList_impl*  children_() override {return &regions;} 
  Variant      Elem(const Variant& idx, IndexMode mode = IDX_UNK) const override
  { return regions.Elem(idx, mode); }

  void  Initialize();
  void  Destroy() { };
  TA_SIMPLE_BASEFUNS(RetinaProc);
protected:
  void  UpdateAfterEdit_impl() override;
  void CheckChildConfig_impl(bool quiet, bool& rval) override;

  virtual bool  TransformImageData_impl(float_Matrix& eye_image,
                                        float_Matrix& xform_image,
                                        float move_x=0.0f, float move_y=0.0f,
                                        float scale = 1.0f, float rotate = 0.0f);
  // implementation function that processes an eye input image into an xform output image

  virtual bool  LookAtImageData_impl(float_Matrix& eye_image,
                                     float_Matrix& xform_image,
                                     VisRegionParams::Region region = VisRegionParams::FOVEA,
                                     float box_ll_x=0.0f, float box_ll_y=0.0f,
                                     float box_ur_x=1.0f, float box_ur_y=1.0f,
                                     float move_x=0.0f, float move_y=0.0f,
                                     float scale = 1.0f, float rotate = 0.0f);
  // implementation function that processes an eye input image into an xform output image

};

SMARTREF_OF(E_API, RetinaProc); // RetinaProcRef

eTypeDef_Of(DoGRegionSpec);
eTypeDef_Of(DoGRetinaProc);

class E_API DoGRetinaProc : public RetinaProc {
  // Difference-of-Gaussians version of retinal filtering -- takes raw input images, applies various transforms, and then runs through filtering -- first region is used for retina size and other basic params
INHERITED(RetinaProc)
public:
  VisRegionSpecBase* AddRegion() override
  { return (VisRegionSpecBase*)regions.New(1, &TA_DoGRegionSpec); }

  void  Initialize();
  void  Destroy() { };
  TA_BASEFUNS_NOCOPY(DoGRetinaProc);
};

eTypeDef_Of(V1RegionSpec);
eTypeDef_Of(V1RetinaProc);

class E_API V1RetinaProc : public RetinaProc {
  // V1 version of retinal filtering -- takes raw input images, applies various transforms, and then runs through filtering -- first region is used for retina size and other basic params
INHERITED(RetinaProc)
public:
  VisRegionSpecBase* AddRegion() override
  { return (VisRegionSpecBase*)regions.New(1, &TA_V1RegionSpec); }

  void  Initialize();
  void  Destroy() { };
  TA_BASEFUNS_NOCOPY(V1RetinaProc);
};

#endif // RetinaProc_h

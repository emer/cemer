// File Automatically Generated by MakeTA
// DO NOT EDIT


#include "ta_type.h"
#include "ta_type_constr.h"
#include "css_basic_types.h"
#include "css_c_ptr_types.h"
#include "ta_css.h"
#include "ta_TA_type.h"
#include "tamisc_TA_type.h"
#include "pdp_TA_type.h"
#include "leabra.h"
#include "leabra_extra.h"
#include "leabra_td.h"
#include "leabra_pvlv.h"
#include "leabra_pbwm.h"
#include "leabra_v3_compat.h"
#include "leabra_TA_type.h"
#include "leabra_TA_inst.h"


// Types

TypeDef TA_LeabraCon("LeabraCon", " Leabra connection", 
	"NO_UPDATE_AFTER CAT_Network ", "NO_UPDATE_AFTER CAT_Network ", "", sizeof(LeabraCon), (void**)&TAI_LeabraCon, 0, 0, 0,1);
TypeDef TA_LeabraConSpec("LeabraConSpec", " Leabra connection specs", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(LeabraConSpec), (void**)&TAI_LeabraConSpec, 1, 0, 0,1);
TypeDef TA_LeabraBiasSpec("LeabraBiasSpec", " Leabra bias-weight connection specs (bias wts are a little bit special)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(LeabraBiasSpec), (void**)&TAI_LeabraBiasSpec, 1, 0, 0,1);
TypeDef TA_LeabraCon_Group("LeabraCon_Group", " Leabra connection group", 
	"MEMB_HIDDEN_EDIT HIDDEN_INLINE NO_UPDATE_AFTER CAT_Network ", "MEMB_HIDDEN_EDIT HIDDEN_INLINE NO_UPDATE_AFTER CAT_Network ", "", sizeof(LeabraCon_Group), (void**)&TAI_LeabraCon_Group, 0, 0, 0,1);
TypeDef TA_LeabraUnitSpec("LeabraUnitSpec", " Leabra unit specifications, point-neuron approximation", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(LeabraUnitSpec), (void**)&TAI_LeabraUnitSpec, 1, 0, 0,1);
TypeDef TA_LeabraUnit("LeabraUnit", " Leabra unit, point-neuron approximation", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 CAT_Network DMEM_SHARE_SETS_5 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 CAT_Network DMEM_SHARE_SETS_5 ", "", sizeof(LeabraUnit), (void**)&TAI_LeabraUnit, 0, 0, 0,1);
TypeDef TA_LeabraInhib("LeabraInhib", " holds threshold-computation values, used as a parent class for layers, etc", 
	"", "", "", sizeof(LeabraInhib), (void**)0, 1, 0, 0,1);
TypeDef TA_LeabraLayerSpec("LeabraLayerSpec", " Leabra layer specs, computes inhibitory input for all units in layer", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(LeabraLayerSpec), (void**)&TAI_LeabraLayerSpec, 1, 0, 0,1);
TypeDef TA_LeabraUnit_Group("LeabraUnit_Group", " for independent subgroups of competing units within a single layer", 
	"MEMB_HIDDEN_EDIT HIDDEN_INLINE CAT_Network ", "MEMB_HIDDEN_EDIT HIDDEN_INLINE CAT_Network MULT_INHERIT ", "", sizeof(LeabraUnit_Group), (void**)&TAI_LeabraUnit_Group, 0, 0, 0,1);
TypeDef TA_LeabraLayer("LeabraLayer", " Leabra Layer: implicit inhibition for soft kWTA behavior", 
	"EXT_lay COMPRESS CAT_Network ", "EXT_lay COMPRESS CAT_Network MULT_INHERIT ", "", sizeof(LeabraLayer), (void**)&TAI_LeabraLayer, 1, 0, 0,1);
TypeDef TA_LeabraNetwork("LeabraNetwork", " Leabra network: has specific functions to operate on Leabra Networks", 
	"FILETYPE_Network EXT_net COMPRESS CAT_Network ", "FILETYPE_Network EXT_net COMPRESS CAT_Network ", "", sizeof(LeabraNetwork), (void**)&TAI_LeabraNetwork, 1, 0, 0,1);
TypeDef TA_LeabraProject("LeabraProject", " _ project for Leabra models", 
	"FILETYPE_Project EXT_proj COMPRESS ", "FILETYPE_Project EXT_proj COMPRESS ", "", sizeof(LeabraProject), (void**)&TAI_LeabraProject, 1, 0, 0,1);
TypeDef TA_const_LeabraCon("const_LeabraCon", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraCon_ref("const_LeabraCon_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_WtScaleSpec("WtScaleSpec", " weight scaling specification", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(WtScaleSpec), (void**)&TAI_WtScaleSpec, 0, 0, 0,1);
TypeDef TA_const_WtScaleSpec("const_WtScaleSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_WtSigSpec("WtSigSpec", " sigmoidal weight function specification", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(WtSigSpec), (void**)&TAI_WtSigSpec, 0, 0, 0,1);
TypeDef TA_const_WtScaleSpec_ref("const_WtScaleSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_WtSigSpec("const_WtSigSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_WtSigSpec_ref("const_WtSigSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LearnMixSpec("LearnMixSpec", " mixture of learning factors (hebbian vs. error-driven) specification", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(LearnMixSpec), (void**)&TAI_LearnMixSpec, 0, 0, 0,1);
TypeDef TA_const_LearnMixSpec("const_LearnMixSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LearnMixSpec_ref("const_LearnMixSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SAvgCorSpec("SAvgCorSpec", " sending average activation correction specifications: affects hebbian learning and netinput computation", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(SAvgCorSpec), (void**)&TAI_SAvgCorSpec, 0, 0, 0,1);
TypeDef TA_LeabraCon_Group_ptr("LeabraCon_Group_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_SAvgCorSpec("const_SAvgCorSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraCon_ptr("LeabraCon_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_SAvgCorSpec_ref("const_SAvgCorSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraUnit_ptr("LeabraUnit_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_LeabraUnitSpec_ptr("LeabraUnitSpec_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_LeabraNetwork_ptr("LeabraNetwork_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_LeabraConSpec("const_LeabraConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraConSpec_ref("const_LeabraConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraBiasSpec("const_LeabraBiasSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraBiasSpec_ref("const_LeabraBiasSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraCon_Group("const_LeabraCon_Group", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraCon_Group_ref("const_LeabraCon_Group_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ActFunSpec("ActFunSpec", " activation function specifications", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ActFunSpec), (void**)&TAI_ActFunSpec, 0, 0, 0,1);
TypeDef TA_const_ActFunSpec("const_ActFunSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_SpikeFunSpec("SpikeFunSpec", " spiking activation function specs", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(SpikeFunSpec), (void**)&TAI_SpikeFunSpec, 0, 0, 0,1);
TypeDef TA_const_ActFunSpec_ref("const_ActFunSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_SpikeFunSpec("const_SpikeFunSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SpikeFunSpec_ref("const_SpikeFunSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DepressSpec("DepressSpec", " depressing synapses activation function specs", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(DepressSpec), (void**)&TAI_DepressSpec, 0, 0, 0,1);
TypeDef TA_const_DepressSpec("const_DepressSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DepressSpec_ref("const_DepressSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_OptThreshSpec("OptThreshSpec", " optimization thresholds for faster processing", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(OptThreshSpec), (void**)&TAI_OptThreshSpec, 0, 0, 0,1);
TypeDef TA_const_OptThreshSpec("const_OptThreshSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_OptThreshSpec_ref("const_OptThreshSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DtSpec("DtSpec", " time constants", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(DtSpec), (void**)&TAI_DtSpec, 0, 0, 0,1);
TypeDef TA_const_DtSpec("const_DtSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DtSpec_ref("const_DtSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraChannels("LeabraChannels", " channels used in Leabra", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(LeabraChannels), (void**)&TAI_LeabraChannels, 0, 0, 0,1);
TypeDef TA_const_LeabraChannels("const_LeabraChannels", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraChannels_ref("const_LeabraChannels_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_VChanSpec("VChanSpec", " voltage gated channel specs", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(VChanSpec), (void**)&TAI_VChanSpec, 0, 0, 0,1);
TypeDef TA_const_VChanSpec("const_VChanSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_ActRegSpec("ActRegSpec", " activity regulation via weight adjustment", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ActRegSpec), (void**)&TAI_ActRegSpec, 0, 0, 0,1);
TypeDef TA_const_VChanSpec_ref("const_VChanSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_ActRegSpec("const_ActRegSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ActRegSpec_ref("const_ActRegSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MaxDaSpec("MaxDaSpec", " how to compute the maxda value, which serves as a stopping criterion for settling", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(MaxDaSpec), (void**)&TAI_MaxDaSpec, 0, 0, 0,1);
TypeDef TA_LeabraLayer_ptr("LeabraLayer_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_MaxDaSpec("const_MaxDaSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraInhib_ptr("LeabraInhib_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_MaxDaSpec_ref("const_MaxDaSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnitSpec("const_LeabraUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnitSpec_ref("const_LeabraUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_VChanBasis("VChanBasis", " basis variables for vchannels", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(VChanBasis), (void**)&TAI_VChanBasis, 0, 0, 0,1);
TypeDef TA_const_VChanBasis("const_VChanBasis", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraUnitChans("LeabraUnitChans", " channels used in Leabra units", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(LeabraUnitChans), (void**)&TAI_LeabraUnitChans, 0, 0, 0,1);
TypeDef TA_const_VChanBasis_ref("const_VChanBasis_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnit("const_LeabraUnit", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnitChans("const_LeabraUnitChans", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnit_ref("const_LeabraUnit_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnitChans_ref("const_LeabraUnitChans_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_taPtrList_LeabraUnit_("taPtrList_LeabraUnit_", " ", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(taPtrList<LeabraUnit>), (void**)&TAI_taPtrList_LeabraUnit_, 0, 0, 0,1);
TypeDef TA_LeabraSort("LeabraSort", " used for sorting units in kwta computation", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER ", "", sizeof(LeabraSort), (void**)0, 0, 0, 0,1);
TypeDef TA_KWTASpec("KWTASpec", " specifies k-winner-take-all parameters", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(KWTASpec), (void**)&TAI_KWTASpec, 0, 0, 0,1);
TypeDef TA_const_KWTASpec("const_KWTASpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_KwtaTieBreak("KwtaTieBreak", " break ties where all the units have similar netinputs and thus none get activated. this lowers the inhibition so that all get active to some extent", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(KwtaTieBreak), (void**)&TAI_KwtaTieBreak, 0, 0, 0,1);
TypeDef TA_const_KWTASpec_ref("const_KWTASpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_KwtaTieBreak("const_KwtaTieBreak", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_KwtaTieBreak_ref("const_KwtaTieBreak_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_AdaptISpec("AdaptISpec", " specifies adaptive kwta specs (esp for avg-based)", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(AdaptISpec), (void**)&TAI_AdaptISpec, 0, 0, 0,1);
TypeDef TA_const_AdaptISpec("const_AdaptISpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AdaptISpec_ref("const_AdaptISpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ClampSpec("ClampSpec", " specs for clamping ", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ClampSpec), (void**)&TAI_ClampSpec, 0, 0, 0,1);
TypeDef TA_const_ClampSpec("const_ClampSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ClampSpec_ref("const_ClampSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DecaySpec("DecaySpec", " holds decay values", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(DecaySpec), (void**)&TAI_DecaySpec, 0, 0, 0,1);
TypeDef TA_const_DecaySpec("const_DecaySpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DecaySpec_ref("const_DecaySpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LayNetRescaleSpec("LayNetRescaleSpec", " global rescale of layer netinputs to prevent blowup", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(LayNetRescaleSpec), (void**)&TAI_LayNetRescaleSpec, 0, 0, 0,1);
TypeDef TA_const_LayNetRescaleSpec("const_LayNetRescaleSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_KWTASpec_ref("KWTASpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LayNetRescaleSpec_ref("const_LayNetRescaleSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraLayerSpec("const_LeabraLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraLayerSpec_ref("const_LeabraLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SpecPtr_LeabraLayerSpec_("SpecPtr_LeabraLayerSpec_", "", 
	"INLINE INLINE_DUMP NO_UPDATE_AFTER ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(SpecPtr<LeabraLayerSpec>), (void**)&TAI_SpecPtr_LeabraLayerSpec_, 0, 0, 0,1);
TypeDef TA_LeabraLayerSpec_SPtr("LeabraLayerSpec_SPtr", "", 
	"INLINE INLINE_DUMP NO_UPDATE_AFTER ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(LeabraLayerSpec_SPtr), (void**)&TAI_LeabraLayerSpec_SPtr, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_SPtr("const_LeabraLayerSpec_SPtr", 1, 0, 0, 0, 1, 0);
TypeDef TA_AvgMaxVals("AvgMaxVals", " holds average and max statistics", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(AvgMaxVals), (void**)&TAI_AvgMaxVals, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_SPtr_ref("const_LeabraLayerSpec_SPtr_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_AvgMaxVals("const_AvgMaxVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AvgMaxVals_ref("const_AvgMaxVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_KWTAVals("KWTAVals", " holds values for kwta stuff", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(KWTAVals), (void**)&TAI_KWTAVals, 0, 0, 0,1);
TypeDef TA_const_KWTAVals("const_KWTAVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_KWTAVals_ref("const_KWTAVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_AdaptIVals("AdaptIVals", " holds values for adapting kwta stuff", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(AdaptIVals), (void**)&TAI_AdaptIVals, 0, 0, 0,1);
TypeDef TA_const_AdaptIVals("const_AdaptIVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AdaptIVals_ref("const_AdaptIVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_InhibVals("InhibVals", " holds values for inhibition", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(InhibVals), (void**)&TAI_InhibVals, 0, 0, 0,1);
TypeDef TA_LeabraLayerSpec_ptr("LeabraLayerSpec_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_InhibVals("const_InhibVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraInhib("const_LeabraInhib", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_InhibVals_ref("const_InhibVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraInhib_ref("const_LeabraInhib_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraLayer("const_LeabraLayer", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraLayer_ref("const_LeabraLayer_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnit_Group("const_LeabraUnit_Group", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnit_Group_ref("const_LeabraUnit_Group_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraNetwork("const_LeabraNetwork", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraNetwork_ref("const_LeabraNetwork_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraProject("const_LeabraProject", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraProject_ref("const_LeabraProject_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraWizard("LeabraWizard", " Leabra-specific wizard for automating construction of simulation objects", 
	"BUTROWS_2 EDIT_WIDTH_60 ", "BUTROWS_2 EDIT_WIDTH_60 ", "", sizeof(LeabraWizard), (void**)&TAI_LeabraWizard, 1, 0, 0,1);
TypeDef TA_const_LeabraWizard("const_LeabraWizard", 1, 0, 0, 0, 1, 0);
TypeDef TA_MarkerConSpec("MarkerConSpec", " connection spec that marks special projections: doesn't send netin or adapt weights", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(MarkerConSpec), (void**)&TAI_MarkerConSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraWizard_ref("const_LeabraWizard_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_MarkerConSpec("const_MarkerConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MarkerConSpec_ref("const_MarkerConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_CtxtUpdateSpec("CtxtUpdateSpec", " context updating specifications", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(CtxtUpdateSpec), (void**)&TAI_CtxtUpdateSpec, 0, 0, 0,1);
TypeDef TA_const_CtxtUpdateSpec("const_CtxtUpdateSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_CtxtUpdateSpec_ref("const_CtxtUpdateSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraContextLayerSpec("LeabraContextLayerSpec", " context layer that copies from its recv projection (like an input layer)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(LeabraContextLayerSpec), (void**)&TAI_LeabraContextLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraContextLayerSpec("const_LeabraContextLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraContextLayerSpec_ref("const_LeabraContextLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraLinUnitSpec("LeabraLinUnitSpec", " a pure linear unit (suitable for an AC unit spec unit)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(LeabraLinUnitSpec), (void**)&TAI_LeabraLinUnitSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraLinUnitSpec("const_LeabraLinUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraLinUnitSpec_ref("const_LeabraLinUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraNegBiasSpec("LeabraNegBiasSpec", " only learns negative bias changes, not positive ones (decay restores back to zero)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(LeabraNegBiasSpec), (void**)&TAI_LeabraNegBiasSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraNegBiasSpec("const_LeabraNegBiasSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraNegBiasSpec_ref("const_LeabraNegBiasSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TrialSynDepCon("TrialSynDepCon", " synaptic depression connection at the trial level (as opposed to cycle level)", 
	"NO_UPDATE_AFTER CAT_Network ", "NO_UPDATE_AFTER CAT_Network ", "", sizeof(TrialSynDepCon), (void**)&TAI_TrialSynDepCon, 0, 0, 0,1);
TypeDef TA_const_TrialSynDepCon("const_TrialSynDepCon", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TrialSynDepCon_ref("const_TrialSynDepCon_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SynDepSpec("SynDepSpec", " specs for synaptic depression", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(SynDepSpec), (void**)&TAI_SynDepSpec, 0, 0, 0,1);
TypeDef TA_TrialSynDepCon_ptr("TrialSynDepCon_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_SynDepSpec("const_SynDepSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SynDepSpec_ref("const_SynDepSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TrialSynDepConSpec("TrialSynDepConSpec", " synaptic depression connection at the trial level (as opposed to cycle level)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(TrialSynDepConSpec), (void**)&TAI_TrialSynDepConSpec, 1, 0, 0,1);
TypeDef TA_const_TrialSynDepConSpec("const_TrialSynDepConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TrialSynDepConSpec_ref("const_TrialSynDepConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_FastWtCon("FastWtCon", " fast weight connection: standard wt learns fast, but decays toward slow weight value", 
	"NO_UPDATE_AFTER CAT_Network ", "NO_UPDATE_AFTER CAT_Network ", "", sizeof(FastWtCon), (void**)&TAI_FastWtCon, 0, 0, 0,1);
TypeDef TA_const_FastWtCon("const_FastWtCon", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_FastWtCon_ref("const_FastWtCon_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_FastWtSpec("FastWtSpec", " specificiations for fast weights", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(FastWtSpec), (void**)&TAI_FastWtSpec, 0, 0, 0,1);
TypeDef TA_FastWtCon_ptr("FastWtCon_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_FastWtSpec("const_FastWtSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_FastWtSpec_ref("const_FastWtSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_FastWtConSpec("FastWtConSpec", " fast weight connection: standard wt learns fast, but decays toward slow weight value", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(FastWtConSpec), (void**)&TAI_FastWtConSpec, 1, 0, 0,1);
TypeDef TA_const_FastWtConSpec("const_FastWtConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_FastWtConSpec_ref("const_FastWtConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ActAvgHebbMixSpec("ActAvgHebbMixSpec", " mixture of average activation hebbian learning and regular hebbian learning (on current act value)", 
	"INLINE ", "INLINE NO_UPDATE_AFTER ", "", sizeof(ActAvgHebbMixSpec), (void**)&TAI_ActAvgHebbMixSpec, 0, 0, 0,1);
TypeDef TA_const_ActAvgHebbMixSpec("const_ActAvgHebbMixSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ActAvgHebbMixSpec_ref("const_ActAvgHebbMixSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ActAvgHebbConSpec("ActAvgHebbConSpec", " ", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(ActAvgHebbConSpec), (void**)&TAI_ActAvgHebbConSpec, 1, 0, 0,1);
TypeDef TA_const_ActAvgHebbConSpec("const_ActAvgHebbConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ActAvgHebbConSpec_ref("const_ActAvgHebbConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValSpec("ScalarValSpec", " specs for scalar values", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ScalarValSpec), (void**)&TAI_ScalarValSpec, 0, 0, 0,1);
TypeDef TA_const_ScalarValSpec("const_ScalarValSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValSpec_ref("const_ScalarValSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValBias("ScalarValBias", " initial bias for given activation value for scalar value units", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ScalarValBias), (void**)&TAI_ScalarValBias, 0, 0, 0,1);
TypeDef TA_const_ScalarValBias("const_ScalarValBias", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValBias_ref("const_ScalarValBias_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValLayerSpec("ScalarValLayerSpec", " represents a scalar value using a coarse-coded distributed code over units. first unit represents scalar value.", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(ScalarValLayerSpec), (void**)&TAI_ScalarValLayerSpec, 1, 0, 0,1);
TypeDef TA_const_ScalarValLayerSpec("const_ScalarValLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValLayerSpec_ref("const_ScalarValLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValSelfPrjnSpec("ScalarValSelfPrjnSpec", " special projection for making self-connection that establishes neighbor similarity in scalar val", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(ScalarValSelfPrjnSpec), (void**)&TAI_ScalarValSelfPrjnSpec, 1, 0, 0,1);
TypeDef TA_const_ScalarValSelfPrjnSpec("const_ScalarValSelfPrjnSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValSelfPrjnSpec_ref("const_ScalarValSelfPrjnSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TwoDValSpec("TwoDValSpec", " specs for two-dimensional values", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(TwoDValSpec), (void**)&TAI_TwoDValSpec, 0, 0, 0,1);
TypeDef TA_const_TwoDValSpec("const_TwoDValSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TwoDValSpec_ref("const_TwoDValSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TwoDValBias("TwoDValBias", " initial bias for given activation value for scalar value units", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(TwoDValBias), (void**)&TAI_TwoDValBias, 0, 0, 0,1);
TypeDef TA_const_TwoDValBias("const_TwoDValBias", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TwoDValBias_ref("const_TwoDValBias_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TwoDValLayerSpec("TwoDValLayerSpec", " represents one or more two-d value(s) using a coarse-coded distributed code over units. first row represents scalar value(s). one val readout is weighted-average; multiple vals = max bumps over 3x3 local grid", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(TwoDValLayerSpec), (void**)&TAI_TwoDValLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TwoDValLayerSpec("const_TwoDValLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TwoDValLayerSpec_ref("const_TwoDValLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DecodeTwoDValLayerSpec("DecodeTwoDValLayerSpec", " a two-d-value layer spec that copies its activations from one-to-one input prjns, to act as a decoder of another layer", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(DecodeTwoDValLayerSpec), (void**)&TAI_DecodeTwoDValLayerSpec, 1, 0, 0,1);
TypeDef TA_const_DecodeTwoDValLayerSpec("const_DecodeTwoDValLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DecodeTwoDValLayerSpec_ref("const_DecodeTwoDValLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DaModUnit("DaModUnit", " Leabra unit with dopamine-like modulation of minus phase activation for learning", 
	"NO_UPDATE_AFTER DMEM_SHARE_SETS_3 CAT_Network DMEM_SHARE_SETS_5 ", "NO_UPDATE_AFTER DMEM_SHARE_SETS_3 CAT_Network DMEM_SHARE_SETS_5 ", "", sizeof(DaModUnit), (void**)&TAI_DaModUnit, 0, 0, 0,1);
TypeDef TA_const_DaModUnit("const_DaModUnit", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DaModUnit_ref("const_DaModUnit_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DaModSpec("DaModSpec", " specs for effects of da-based modulation: plus-phase = learning effects", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(DaModSpec), (void**)&TAI_DaModSpec, 0, 0, 0,1);
TypeDef TA_const_DaModSpec("const_DaModSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DaModSpec_ref("const_DaModSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DaModUnitSpec("DaModUnitSpec", " Leabra unit with temporal-differences error modulation of minus phase activation for learning", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(DaModUnitSpec), (void**)&TAI_DaModUnitSpec, 1, 0, 0,1);
TypeDef TA_const_DaModUnitSpec("const_DaModUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DaModUnitSpec_ref("const_DaModUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_AvgExtRewSpec("AvgExtRewSpec", " specs for computing average external rewards", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(AvgExtRewSpec), (void**)&TAI_AvgExtRewSpec, 0, 0, 0,1);
TypeDef TA_const_AvgExtRewSpec("const_AvgExtRewSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AvgExtRewSpec_ref("const_AvgExtRewSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_OutErrSpec("OutErrSpec", " specs for computing external rewards based on output performance of network", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(OutErrSpec), (void**)&TAI_OutErrSpec, 0, 0, 0,1);
TypeDef TA_const_OutErrSpec("const_OutErrSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_OutErrSpec_ref("const_OutErrSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ExtRewSpec("ExtRewSpec", " specs for computing external rewards", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ExtRewSpec), (void**)&TAI_ExtRewSpec, 0, 0, 0,1);
TypeDef TA_DaModUnit_ptr("DaModUnit_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_ExtRewSpec("const_ExtRewSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ExtRewSpec_ref("const_ExtRewSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ExtRewLayerSpec("ExtRewLayerSpec", " computes external reward feedback: minus phase is zero, plus phase is reward value derived from network performance or other inputs (computed at start of 1+)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(ExtRewLayerSpec), (void**)&TAI_ExtRewLayerSpec, 1, 0, 0,1);
TypeDef TA_const_ExtRewLayerSpec("const_ExtRewLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ExtRewLayerSpec_ref("const_ExtRewLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewPredConSpec("TDRewPredConSpec", " Reward Prediction connections: for TD RewPred Layer, uses TD algorithm for predicting rewards", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(TDRewPredConSpec), (void**)&TAI_TDRewPredConSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewPredConSpec("const_TDRewPredConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewPredConSpec_ref("const_TDRewPredConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewPredLayerSpec("TDRewPredLayerSpec", " predicts rewards: minus phase = clamped prior expected reward V^(t), plus = settles on expectation of future reward V^(t+1)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(TDRewPredLayerSpec), (void**)&TAI_TDRewPredLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewPredLayerSpec("const_TDRewPredLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewPredLayerSpec_ref("const_TDRewPredLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewIntegSpec("TDRewIntegSpec", " misc specs for TDRewIntegLayerSpec", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(TDRewIntegSpec), (void**)&TAI_TDRewIntegSpec, 0, 0, 0,1);
TypeDef TA_const_TDRewIntegSpec("const_TDRewIntegSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewIntegSpec_ref("const_TDRewIntegSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewIntegLayerSpec("TDRewIntegLayerSpec", " integrates perceived and external rewards: delta over phases = DA td-like signal. minus phase = prev exp rew V^(t), plus phase = extrew (r) + tdrewpred computing V(t+1)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(TDRewIntegLayerSpec), (void**)&TAI_TDRewIntegLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewIntegLayerSpec("const_TDRewIntegLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewIntegLayerSpec_ref("const_TDRewIntegLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TdLayerSpec("TdLayerSpec", " computes activation = temporal derivative (act_eq - act_m) of sending units in plus phases: note, act will go negative!", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(TdLayerSpec), (void**)&TAI_TdLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TdLayerSpec("const_TdLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TdLayerSpec_ref("const_TdLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVConSpec("PVConSpec", " primary value connection spec: learns using delta rule from PVe - PVi values", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(PVConSpec), (void**)&TAI_PVConSpec, 1, 0, 0,1);
TypeDef TA_const_PVConSpec("const_PVConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVConSpec_ref("const_PVConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVDetectSpec("PVDetectSpec", " specs for detecting if a primary value is present or expected", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(PVDetectSpec), (void**)&TAI_PVDetectSpec, 0, 0, 0,1);
TypeDef TA_const_PVDetectSpec("const_PVDetectSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVDetectSpec_ref("const_PVDetectSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PViLayerSpec("PViLayerSpec", " primary value inhibitory (PVi) layer: continously learns to expect primary reward values", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(PViLayerSpec), (void**)&TAI_PViLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PViLayerSpec("const_PViLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PViLayerSpec_ref("const_PViLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LVConSpec("LVConSpec", " learned value connection spec: learns using delta rule from PVe - LV values; also does synaptic depression to do novelty filtering", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(LVConSpec), (void**)&TAI_LVConSpec, 1, 0, 0,1);
TypeDef TA_const_LVConSpec("const_LVConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LVConSpec_ref("const_LVConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LVSpec("LVSpec", " specs for learned value layers", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(LVSpec), (void**)&TAI_LVSpec, 0, 0, 0,1);
TypeDef TA_const_LVSpec("const_LVSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LVSpec_ref("const_LVSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LVeLayerSpec("LVeLayerSpec", " learns value based on inputs that are associated with rewards, only learns at time of primary rewards (filtered by PV system). This is excitatory version", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(LVeLayerSpec), (void**)&TAI_LVeLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LVeLayerSpec("const_LVeLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LVeLayerSpec_ref("const_LVeLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LViLayerSpec("LViLayerSpec", " inhibitory/slow version of LV layer spec: (just a marker for layer; same functionality as LVeLayerSpec)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(LViLayerSpec), (void**)&TAI_LViLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LViLayerSpec("const_LViLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LViLayerSpec_ref("const_LViLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVLVDaSpec("PVLVDaSpec", " specs for PVLV da parameters", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(PVLVDaSpec), (void**)&TAI_PVLVDaSpec, 0, 0, 0,1);
TypeDef TA_const_PVLVDaSpec("const_PVLVDaSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVLVDaSpec_ref("const_PVLVDaSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVLVDaLayerSpec("PVLVDaLayerSpec", " computes PVLV 'Da' signal: typically if(ER), da = ER-PV, else LVe - LVs", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(PVLVDaLayerSpec), (void**)&TAI_PVLVDaLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PVLVDaLayerSpec("const_PVLVDaLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVLVDaLayerSpec_ref("const_PVLVDaLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PatchLayerSpec("PatchLayerSpec", " simulates Patch as a LV layer: currently no doing anything different than regular LV", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(PatchLayerSpec), (void**)&TAI_PatchLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PatchLayerSpec("const_PatchLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PatchLayerSpec_ref("const_PatchLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNcMiscSpec("SNcMiscSpec", " misc parameters for SNc layer", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(SNcMiscSpec), (void**)&TAI_SNcMiscSpec, 0, 0, 0,1);
TypeDef TA_const_SNcMiscSpec("const_SNcMiscSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNcMiscSpec_ref("const_SNcMiscSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNcLayerSpec("SNcLayerSpec", " computes PVLV 'Da' signal, uses inputs from the patch to provide stripe-specific modulation (NOTE: not currently supported); Does not do SNrThal modulation, which is computed directly in Matrix units", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(SNcLayerSpec), (void**)&TAI_SNcLayerSpec, 1, 0, 0,1);
TypeDef TA_const_SNcLayerSpec("const_SNcLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNcLayerSpec_ref("const_SNcLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixConSpec("MatrixConSpec", " Learning of matrix input connections based on dopamine modulation of activation", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(MatrixConSpec), (void**)&TAI_MatrixConSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixConSpec("const_MatrixConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixConSpec_ref("const_MatrixConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixBiasSpec("MatrixBiasSpec", " Matrix bias spec: special learning paramters for matrix units", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(MatrixBiasSpec), (void**)&TAI_MatrixBiasSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixBiasSpec("const_MatrixBiasSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixBiasSpec_ref("const_MatrixBiasSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixUnitSpec("MatrixUnitSpec", " basal ganglia matrix units: fire actions or WM updates. modulated by da signals", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network CAT_Spec ", "", sizeof(MatrixUnitSpec), (void**)&TAI_MatrixUnitSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixUnitSpec("const_MatrixUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixUnitSpec_ref("const_MatrixUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixMiscSpec("MatrixMiscSpec", " misc specs for the matrix layer", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(MatrixMiscSpec), (void**)&TAI_MatrixMiscSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixMiscSpec("const_MatrixMiscSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixMiscSpec_ref("const_MatrixMiscSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ContrastSpec("ContrastSpec", " contrast enhancement of the GO units", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(ContrastSpec), (void**)&TAI_ContrastSpec, 0, 0, 0,1);
TypeDef TA_const_ContrastSpec("const_ContrastSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ContrastSpec_ref("const_ContrastSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixRndGoSpec("MatrixRndGoSpec", " misc random go specifications (unconditional, nogo)", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(MatrixRndGoSpec), (void**)&TAI_MatrixRndGoSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoSpec("const_MatrixRndGoSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixRndGoSpec_ref("const_MatrixRndGoSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixErrRndGoSpec("MatrixErrRndGoSpec", " matrix random Go firing to encourage exploration when (a series of) errors occur: a stripe is chosen from a softmax over the snrthal netinputs (closer to firing chosen with higher probability)", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(MatrixErrRndGoSpec), (void**)&TAI_MatrixErrRndGoSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixErrRndGoSpec("const_MatrixErrRndGoSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixErrRndGoSpec_ref("const_MatrixErrRndGoSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixAvgDaRndGoSpec("MatrixAvgDaRndGoSpec", " matrix random Go firing to encourage exploration for non-productive stripes based on softmax of avg_go_da for that stripe (matrix_u->misc_1)", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(MatrixAvgDaRndGoSpec), (void**)&TAI_MatrixAvgDaRndGoSpec, 0, 0, 0,1);
TypeDef TA_LeabraUnit_Group_ptr("LeabraUnit_Group_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_MatrixAvgDaRndGoSpec("const_MatrixAvgDaRndGoSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixAvgDaRndGoSpec_ref("const_MatrixAvgDaRndGoSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixLayerSpec("MatrixLayerSpec", " basal ganglia matrix layer: fire actions/WM updates, or nogo; MAINT = gate in 1+ and 2+, OUTPUT = gate in -", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(MatrixLayerSpec), (void**)&TAI_MatrixLayerSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixLayerSpec("const_MatrixLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixLayerSpec_ref("const_MatrixLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNrThalMiscSpec("SNrThalMiscSpec", " misc specs for the snrthal layer", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(SNrThalMiscSpec), (void**)&TAI_SNrThalMiscSpec, 0, 0, 0,1);
TypeDef TA_const_SNrThalMiscSpec("const_SNrThalMiscSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNrThalMiscSpec_ref("const_SNrThalMiscSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNrThalLayerSpec("SNrThalLayerSpec", " computes activation = GO - NOGO from MatrixLayerSpec", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(SNrThalLayerSpec), (void**)&TAI_SNrThalLayerSpec, 1, 0, 0,1);
TypeDef TA_const_SNrThalLayerSpec("const_SNrThalLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNrThalLayerSpec_ref("const_SNrThalLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PFCGateSpec("PFCGateSpec", " gating specifications for basal ganglia gating of PFC maintenance layer", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(PFCGateSpec), (void**)&TAI_PFCGateSpec, 0, 0, 0,1);
TypeDef TA_const_PFCGateSpec("const_PFCGateSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PFCGateSpec_ref("const_PFCGateSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PFCLayerSpec("PFCLayerSpec", " Prefrontal cortex layer: gets gating signal from SNrThal, gate updates before plus and 2nd plus (update) phase (toggle off, toggle on)", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(PFCLayerSpec), (void**)&TAI_PFCLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PFCLayerSpec("const_PFCLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PFCLayerSpec_ref("const_PFCLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PFCOutGateSpec("PFCOutGateSpec", " specifications for pfc output gating", 
	"INLINE INLINE_DUMP ", "INLINE INLINE_DUMP NO_UPDATE_AFTER ", "", sizeof(PFCOutGateSpec), (void**)&TAI_PFCOutGateSpec, 0, 0, 0,1);
TypeDef TA_const_PFCOutGateSpec("const_PFCOutGateSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PFCOutGateSpec_ref("const_PFCOutGateSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PFCOutLayerSpec("PFCOutLayerSpec", " Prefrontal cortex output gated layer: gets gating signal from SNrThal and activations from PFC_mnt layer: gating modulates strength of activation", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network ", "", sizeof(PFCOutLayerSpec), (void**)&TAI_PFCOutLayerSpec, 1, 0, 0,1);
TypeDef TA_LeabraCycle("LeabraCycle", " one Leabra cycle of activation updating", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(LeabraCycle), (void**)&TAI_LeabraCycle, 1, 0, 0,1);
TypeDef TA_const_PFCOutLayerSpec("const_PFCOutLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraSettle("LeabraSettle", " Leabra settling phase of activation updating", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(LeabraSettle), (void**)&TAI_LeabraSettle, 1, 0, 0,1);
TypeDef TA_const_PFCOutLayerSpec_ref("const_PFCOutLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraTrial("LeabraTrial", " Leabra trial process, iterates over phases", 
	"EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "EXT_proc MEMB_IN_GPMENU AGGOP_SUM ", "", sizeof(LeabraTrial), (void**)&TAI_LeabraTrial, 1, 0, 0,1);
TypeDef TA_LeabraMaxDa("LeabraMaxDa", " //////////////////////// stat that computes maximum change in activation, used for determining equilibrium to stop settling; also looks for maximum activation on target layers to provide that as an additional stopping criterion", 
	"EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "EXT_proc COMPUTE_IN_SettleProcess LOOP_STAT ", "", sizeof(LeabraMaxDa), (void**)&TAI_LeabraMaxDa, 1, 0, 0,1);
TypeDef TA_LeabraSettle_ptr("LeabraSettle_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_LeabraCycle("const_LeabraCycle", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraCycle_ref("const_LeabraCycle_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraTrial_ptr("LeabraTrial_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_LeabraSettle("const_LeabraSettle", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraSettle_ref("const_LeabraSettle_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraTrial("const_LeabraTrial", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraTrial_ref("const_LeabraTrial_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraMaxDa("const_LeabraMaxDa", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraMaxDa_ref("const_LeabraMaxDa_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraSE_Stat("LeabraSE_Stat", " squared error for leabra, controls when to compute SE ", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraSE_Stat), (void**)&TAI_LeabraSE_Stat, 1, 0, 0,1);
TypeDef TA_const_LeabraSE_Stat("const_LeabraSE_Stat", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraGoodStat("LeabraGoodStat", " constraint satisfaction goodness statistic", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraGoodStat), (void**)&TAI_LeabraGoodStat, 1, 0, 0,1);
TypeDef TA_const_LeabraSE_Stat_ref("const_LeabraSE_Stat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraGoodStat("const_LeabraGoodStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraGoodStat_ref("const_LeabraGoodStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraSharpStat("LeabraSharpStat", " layer sharpness statistic: just max / avg", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraSharpStat), (void**)&TAI_LeabraSharpStat, 1, 0, 0,1);
TypeDef TA_const_LeabraSharpStat("const_LeabraSharpStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraSharpStat_ref("const_LeabraSharpStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_WrongOnStat("WrongOnStat", " Reports an error if a unit is on when it shouldn't have been (for multiple output cases)", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(WrongOnStat), (void**)&TAI_WrongOnStat, 1, 0, 0,1);
TypeDef TA_const_WrongOnStat("const_WrongOnStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_WrongOnStat_ref("const_WrongOnStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraPrjnRelNetinStat("LeabraPrjnRelNetinStat", " computes overall relative netinput contributions for the different projections into a layer. Useful for setting wt_scale parameters to achieve desired relative contributions of different inputs. you MUST set the layer parameter to the layer in question", 
	"EXT_proc COMPUTE_IN_TrialProcess ", "EXT_proc COMPUTE_IN_TrialProcess ", "", sizeof(LeabraPrjnRelNetinStat), (void**)&TAI_LeabraPrjnRelNetinStat, 1, 0, 0,1);
TypeDef TA_const_LeabraPrjnRelNetinStat("const_LeabraPrjnRelNetinStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraPrjnRelNetinStat_ref("const_LeabraPrjnRelNetinStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ExtRew_Stat("ExtRew_Stat", " external reward statistic", 
	"EXT_proc COMPUTE_IN_TrialProcess FINAL_STAT ", "EXT_proc COMPUTE_IN_TrialProcess FINAL_STAT ", "", sizeof(ExtRew_Stat), (void**)&TAI_ExtRew_Stat, 1, 0, 0,1);
TypeDef TA_const_ExtRew_Stat("const_ExtRew_Stat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ExtRew_Stat_ref("const_ExtRew_Stat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PhaseOrderEventSpec("PhaseOrderEventSpec", " event specification including order of phases", 
	"EXT_spec MEMB_IN_GPMENU SCOPE_Network SCOPE_Environment IMMEDIATE_UPDATE ", "EXT_spec MEMB_IN_GPMENU SCOPE_Network SCOPE_Environment IMMEDIATE_UPDATE ", "", sizeof(PhaseOrderEventSpec), (void**)&TAI_PhaseOrderEventSpec, 1, 0, 0,1);
TypeDef TA_const_PhaseOrderEventSpec("const_PhaseOrderEventSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PhaseOrderEventSpec_ref("const_PhaseOrderEventSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_V3LeabraProject("V3LeabraProject", "", 
	"FILETYPE_Project EXT_proj COMPRESS ", "FILETYPE_Project EXT_proj COMPRESS ", "", sizeof(V3LeabraProject), (void**)&TAI_V3LeabraProject, 1, 0, 0,1);
TypeDef TA_const_V3LeabraProject("const_V3LeabraProject", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_V3LeabraProject_ref("const_V3LeabraProject_ref", 1, 0, 1, 0, 1, 0);

// Instances

LeabraCon*		 TAI_LeabraCon=NULL;
LeabraConSpec*		 TAI_LeabraConSpec=NULL;
  static cssEl* cssElCFun_LeabraConSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtState((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Net((LeabraCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_WtFmLin((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_WtFmLin((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_LinFmWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_LinFmWt((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_LinFmWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_LinFmWt((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtState_Post((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_SAvgCor_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_SAvgCor((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->B_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_ActReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_ActReg((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_UpdateWeightsActReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_UpdateWeightsActReg((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_B_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->B_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnitSpec*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->SetCurLrate((int)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_CreateWtSigFun_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->CreateWtSigFun();
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Defaults();
    return rval;}
LeabraBiasSpec*		 TAI_LeabraBiasSpec=NULL;
  static cssEl* cssElCFun_LeabraBiasSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraBiasSpec*)ths)->B_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraBiasSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraBiasSpec*)ths)->Defaults();
    return rval;}
LeabraCon_Group*		 TAI_LeabraCon_Group=NULL;
  static cssEl* cssElCFun_LeabraCon_Group_Compute_LinFmWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Compute_LinFmWt();
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Compute_WtFmLin_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Compute_WtFmLin();
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->C_InitWtState_Post((Connection*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->SetCurLrate((int)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Send_ClampNet((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Send_NetDelta((LeabraUnit*)(void*)*arg[1]);
    return rval;}
LeabraUnitSpec*		 TAI_LeabraUnitSpec=NULL;
  static cssEl* cssElCFun_LeabraUnitSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssBool(((LeabraUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (Network*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssBool(((LeabraUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (Network*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitWtState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_Net((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Act((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SSE_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_SSE((Unit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitActAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitActAvg((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->SetCurLrate((LeabraUnit*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitDelta((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetScale((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetRescale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetRescale((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Init_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Init_ClampNet((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_ClampNet((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_NetDelta((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_InhibAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_HardClamp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_HardClampNoClip_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_HardClampNoClip((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnitSpec*)ths)->Compute_SoftClamp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThresh_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThresh((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshAll_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshAll((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoA_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoA((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoH((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoAH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoAH((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_MaxDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_MaxDa((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Conduct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Conduct((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Vm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Vm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_ActFmVm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_ActFmVm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SelfReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_SelfReg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->PhaseInit((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->DecayPhase((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->DecayEvent((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->ExtToComp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->TargExtToComp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4], (bool)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_dWt_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_dWt_impl((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_WtFmLin((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->EncodeState((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_CreateNXX1Fun_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->CreateNXX1Fun();
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Defaults();
    return rval;}
LeabraUnit*		 TAI_LeabraUnit=NULL;
  static cssEl* cssElCFun_LeabraUnit_InitDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->InitDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_Net((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_InitActAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->InitActAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->SetCurLrate((LeabraNetwork*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetRescale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetRescale((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Init_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Init_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_NetDelta((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_HardClampNoClip_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_HardClampNoClip((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit*)ths)->Compute_SoftClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_IThresh_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnit*)ths)->Compute_IThresh((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_IThreshNoAH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnit*)ths)->Compute_IThreshNoAH((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_MaxDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_MaxDa((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->PhaseInit((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->DecayEvent((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->DecayPhase((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->ExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->TargExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      ((LeabraUnit*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);}
    if(na == 4) {
      ((LeabraUnit*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3], (bool)*arg[4]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_WtFmLin((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->EncodeState((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_GetInSubGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->GetInSubGp();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
LeabraLayerSpec*		 TAI_LeabraLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((LeabraLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((LeabraLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitWtState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitActAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitActAvg((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->SetCurLrate((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Active_K_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Active_K((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Active_K_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    KWTASpec& refarg_3=*(KWTASpec*)arg[4]->GetVoidPtrOfType(&TA_KWTASpec);
    ((LeabraLayerSpec*)ths)->Compute_Active_K_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], refarg_3);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Pat_K_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayerSpec*)ths)->Compute_Pat_K((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_HardClampPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_HardClampPhase2((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Init_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Init_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_Net((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_NetDelta((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Clamp_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetAvg((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_SoftClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitInhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitInhib((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA_Avg((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_AvgMaxPt((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA_Gps((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_BreakTie_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_BreakTie((LeabraInhib*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_LayInhibToGps_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_LayInhibToGps((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_InhibAvg_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_InhibAvg_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActMAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActMAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActMAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActMAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActPAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActPAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActPAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActPAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetRescale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetRescale((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->PhaseInit((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayEvent((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayPhase((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayPhase2((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->ExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->TargExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);}
    if(na == 3) {
      ((LeabraLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_AdaptGBarI_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->AdaptGBarI((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_AdaptKWTAPt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->AdaptKWTAPt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_WtFmLin((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpec((LeabraLayer*)(void*)*arg[1], refarg_1, (TypeDef*)*arg[3]), 1, &TA_LeabraLayer);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpecExact_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpecExact((LeabraLayer*)(void*)*arg[1], refarg_1, (TypeDef*)*arg[3]), 1, &TA_LeabraLayer);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpecNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpecNet((Network*)(void*)*arg[1], (TypeDef*)*arg[2]), 1, &TA_LeabraLayer);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Defaults();
    return rval;}
LeabraUnit_Group*		 TAI_LeabraUnit_Group=NULL;
  static cssEl* cssElCFun_LeabraUnit_Group_setDirty_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->setDirty((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetIndex_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetIndex());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetFileName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->SetFileName(arg[1]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetFileName_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraUnit_Group*)ths)->GetFileName());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetOwner_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->GetOwner((TypeDef*)*arg[1]), 1, &TA_taBase);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath());}
    if(na == 1) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindFromPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(arg[1]->GetStr()), 1, &TA_taBase);}
    if(na == 2) {
      MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(arg[1]->GetStr(), refarg_1), 1, &TA_taBase);    *arg[2]=(void*)refarg_1;
}
    if(na == 3) {
      MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(arg[1]->GetStr(), refarg_1, (int)*arg[3]), 1, &TA_taBase);    *arg[2]=(void*)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_New_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New(), 1, &TA_taBase);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New((int)*arg[1]), 1, &TA_taBase);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taBase);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAllViews_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAllViews();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_StructUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->StructUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DataUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DataUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->CheckConfig());}
    if(na == 1) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->CheckConfig((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddDataView((taDataView*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveDataView((taDataView*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InheritsFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->InheritsFrom((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetEnumString_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraUnit_Group*)ths)->GetEnumString(arg[1]->GetStr(), (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetEnumVal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetEnumVal(arg[1]->GetStr()));}
    if(na == 2) {
      taString refarg_1=arg[2]->GetStr();
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetEnumVal(arg[1]->GetStr(), refarg_1));    *arg[2]=(String)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Load_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0));}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2], (void**)(void**)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Save_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SaveAs_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Save_File_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save_File());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SaveAs_File_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs_File());}
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs_File(arg[1]->GetStr()));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Edit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Edit());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReShowEdit_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->ReShowEdit());}
    if(na == 1) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->ReShowEdit((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CloseLater_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->CloseLater();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CopyFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->CopyFrom((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->CopyTo((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DuplicateMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->DuplicateMe());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChangeMyType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ChangeMyType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SelectForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->SelectForEdit((MemberDef*)*arg[1], (SelectEdit*)(void*)*arg[2], arg[3]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SelectFunForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->SelectFunForEdit((MethodDef*)*arg[1], (SelectEdit*)(void*)*arg[2], arg[3]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Help_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Help();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CallFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->CallFun(arg[1]->GetStr());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetAdapter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->SetAdapter((taBaseAdapter*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Alloc_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Alloc((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Reset_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Reset();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_IsEmpty_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->IsEmpty());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BuildHashTable_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BuildHashTable((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Find_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Find(arg[1]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Remove_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Remove((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveName(arg[1]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLast_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveLast());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveAll_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->RemoveAll();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Move_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Move((int)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Swap_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Swap((int)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PopAll_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->PopAll();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Permute_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Permute();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Sort_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->Sort();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->Sort((bool)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Sort__stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->Sort_();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->Sort_((bool)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FirstEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NextEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Duplicate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Duplicate(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DupeUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DupeUniqNameNew(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DupeUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DupeUniqNameOld(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Stealth_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Stealth_Borrow(*(taPtrList_impl*)arg[1]->GetVoidPtrOfType(&TA_taPtrList_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Borrow(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUnique(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUniqNameNew(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUniqNameOld(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Common_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Common(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Duplicate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Duplicate(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Borrow(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_List_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->List();}
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->List(refarg_0);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddEl((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Add_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Add((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->AddUnique((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->AddUniqNameNew((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Insert_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Insert((taBase*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Replace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Replace((int)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ReplaceEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ReplaceName(arg[1]->GetStr(), (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DuplicateEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->DuplicateEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Link_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Link((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->LinkUnique((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->LinkUniqNameNew((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InsertLink_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->InsertLink((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->InsertLink((taBase*)(void*)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ReplaceLink((int)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLinkEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ReplaceLinkEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLinkName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ReplaceLinkName(arg[1]->GetStr(), (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Push_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Push((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->MoveEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Transfer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Transfer((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->MoveBefore((Unit*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->MoveAfter((Unit*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Dump_Save_PathR_impl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultElName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultElName(arg[1]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultElType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultElType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceSize_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceSize((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceType_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceType();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceSameStru_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceSameStru(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChangeType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->ChangeType((taBase*)(void*)*arg[1], (TypeDef*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceType((TypeDef*)*arg[1], (TypeDef*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetBaseType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->SetBaseType((TypeDef*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReturnFindMd_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraUnit_Group*)ths)->ReturnFindMd(), 1, &TA_MemberDef);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_IsRoot_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->IsRoot());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InitLeafGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->InitLeafGp();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveLeaf((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeafName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveLeafName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeafEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveLeafEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->RemoveGp((taGroup_impl*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EditSubGps_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->EditSubGps(), 1, &TA_TALOG);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceLeaves_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceLeaves((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindLeaf((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindLeafEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeEl((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastEl((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->DefaultEl(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Edit_El((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastLeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastLeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeLeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeLeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Leaf((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RootGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->RootGp(), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->LastEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PrevEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->PrevEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl(), 1, &TA_Unit);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl((int)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_Unit);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindName((const char*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Pop(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Peek(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->AddUniqNameOld((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->LinkUniqNameOld((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Weights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Weights((const Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_WriteWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->WriteWeights(refarg_0);}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->WriteWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReadWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraUnit_Group*)ths)->ReadWeights(refarg_0);}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraUnit_Group*)ths)->ReadWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Build_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->Build());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CheckBuild_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->CheckBuild());}
    if(na == 1) {
      rval=new cssBool(((LeabraUnit_Group*)ths)->CheckBuild((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LayoutUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->LayoutUnits();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->LayoutUnits((Unit*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RecomputeGeometry_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->RecomputeGeometry();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->SetUnitSpec((UnitSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraUnit_Group*)ths)->SetConSpec((ConSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_TransformWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->TransformWeights(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddNoiseToWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddNoiseToWeights(*(Random*)arg[1]->GetVoidPtrOfType(&TA_Random));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PruneCons_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->PruneCons(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec), (CountParam::Relation)(int)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LesionCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionCons((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LesionUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionUnits((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionUnits((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnitValuesToArray_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float_RArray& refarg_0=*(float_RArray*)arg[1]->GetVoidPtrOfType(&TA_float_RArray);
    ((LeabraUnit_Group*)ths)->UnitValuesToArray(refarg_0, (const char*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnitValuesFromArray_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float_RArray& refarg_0=*(float_RArray*)arg[1]->GetVoidPtrOfType(&TA_float_RArray);
    ((LeabraUnit_Group*)ths)->UnitValuesFromArray(refarg_0, (const char*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindUnitFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindUnitFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
LeabraLayer*		 TAI_LeabraLayer=NULL;
  static cssEl* cssElCFun_LeabraLayer_setDirty_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->setDirty((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetIndex_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->GetIndex());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetFileName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->SetFileName(arg[1]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetFileName_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraLayer*)ths)->GetFileName());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetOwner_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->GetOwner((TypeDef*)*arg[1]), 1, &TA_taBase);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath());}
    if(na == 1) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindFromPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(arg[1]->GetStr()), 1, &TA_taBase);}
    if(na == 2) {
      MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(arg[1]->GetStr(), refarg_1), 1, &TA_taBase);    *arg[2]=(void*)refarg_1;
}
    if(na == 3) {
      MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(arg[1]->GetStr(), refarg_1, (int)*arg[3]), 1, &TA_taBase);    *arg[2]=(void*)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_New_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New(), 1, &TA_taBase);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New((int)*arg[1]), 1, &TA_taBase);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taBase);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateAllViews_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateAllViews();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_StructUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->StructUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DataUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DataUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssBool(((LeabraLayer*)ths)->CheckConfig((Network*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssBool(((LeabraLayer*)ths)->CheckConfig((Network*)(void*)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_AddDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->AddDataView((taDataView*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->RemoveDataView((taDataView*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InheritsFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->InheritsFrom((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetEnumString_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraLayer*)ths)->GetEnumString(arg[1]->GetStr(), (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetEnumVal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->GetEnumVal(arg[1]->GetStr()));}
    if(na == 2) {
      taString refarg_1=arg[2]->GetStr();
    rval=new cssInt((int)((LeabraLayer*)ths)->GetEnumVal(arg[1]->GetStr(), refarg_1));    *arg[2]=(String)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Load_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0));}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2], (void**)(void**)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Save_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SaveAs_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Save_File_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->Save_File());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SaveAs_File_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs_File());}
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs_File(arg[1]->GetStr()));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Edit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->Edit());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReShowEdit_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssBool(((LeabraLayer*)ths)->ReShowEdit());}
    if(na == 1) {
      rval=new cssBool(((LeabraLayer*)ths)->ReShowEdit((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CloseLater_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->CloseLater();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CopyFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->CopyFrom((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->CopyTo((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DuplicateMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->DuplicateMe());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ChangeMyType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->ChangeMyType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SelectForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->SelectForEdit((MemberDef*)*arg[1], (SelectEdit*)(void*)*arg[2], arg[3]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SelectFunForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->SelectFunForEdit((MethodDef*)*arg[1], (SelectEdit*)(void*)*arg[2], arg[3]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Help_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Help();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CallFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->CallFun(arg[1]->GetStr());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetAdapter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetAdapter((taBaseAdapter*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_numUnits_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->numUnits());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_isSparse_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->isSparse());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_uses_groups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->uses_groups());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_project_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->project(), 1, &TA_ProjectBase);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Copy_Weights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Copy_Weights((const Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_WriteWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraLayer*)ths)->WriteWeights(refarg_0);}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraLayer*)ths)->WriteWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReadWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraLayer*)ths)->ReadWeights(refarg_0);}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraLayer*)ths)->ReadWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Build_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Build();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RecomputeGeometry_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RecomputeGeometry();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LayoutUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraLayer*)ths)->LayoutUnits();}
    if(na == 1) {
      ((LeabraLayer*)ths)->LayoutUnits((Unit*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LayoutUnitGroups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->LayoutUnitGroups();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ConnectFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ConnectFrom((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Connect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Connect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckBuild_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssBool(((LeabraLayer*)ths)->CheckBuild());}
    if(na == 1) {
      rval=new cssBool(((LeabraLayer*)ths)->CheckBuild((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckConnect_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssBool(((LeabraLayer*)ths)->CheckConnect());}
    if(na == 1) {
      rval=new cssBool(((LeabraLayer*)ths)->CheckConnect((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveCons_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveCons();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveUnits_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveUnits();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveUnitGroups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveUnitGroups();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PreConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->PreConnect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SyncSendPrjns_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SyncSendPrjns();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DisConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DisConnect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CountRecvCons_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CountRecvCons());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitExterns_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitExterns();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ModifyState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ModifyState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitWtDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitWtDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitWtState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitWtState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetToLay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetToLay((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetToMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetToMe();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Act((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateWeights();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_SSE_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraLayer*)ths)->Compute_SSE());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_TransformWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->TransformWeights(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_AddNoiseToWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->AddNoiseToWeights(*(Random*)arg[1]->GetVoidPtrOfType(&TA_Random));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PruneCons_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->PruneCons(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec), (CountParam::Relation)(int)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ProbAddCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ProbAddCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ProbAddCons((float)*arg[1], (float)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LesionCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionCons((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LesionUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionUnits((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionUnits((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetLayerSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->SetLayerSpec((LayerSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetLayerSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->GetLayerSpec(), 1, &TA_LayerSpec);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->SetUnitSpec((UnitSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetUnitType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetUnitType((TypeDef*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->SetConSpec((ConSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckTypes_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((LeabraLayer*)ths)->CheckTypes());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FixPrjnIndexes_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->FixPrjnIndexes();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceUnitSpec((UnitSpec*)(void*)*arg[1], (UnitSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceConSpec((ConSpec*)(void*)*arg[1], (ConSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplacePrjnSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplacePrjnSpec((ProjectionSpec*)(void*)*arg[1], (ProjectionSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceLayerSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceLayerSpec((LayerSpec*)(void*)*arg[1], (LayerSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_WeightsToTable_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->WeightsToTable((DataTable*)(void*)*arg[1], (Layer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetExtFlag_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetExtFlag((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UnSetExtFlag_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnSetExtFlag((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ApplyExternal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraLayer*)ths)->ApplyExternal((taMatrix*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraLayer*)ths)->ApplyExternal((taMatrix*)(void*)*arg[1], (Unit::ExtType)(int)*arg[2]);}
    if(na == 3) {
      ((LeabraLayer*)ths)->ApplyExternal((taMatrix*)(void*)*arg[1], (Unit::ExtType)(int)*arg[2], (Random*)(void*)*arg[3]);}
    if(na == 4) {
      ((LeabraLayer*)ths)->ApplyExternal((taMatrix*)(void*)*arg[1], (Unit::ExtType)(int)*arg[2], (Random*)(void*)*arg[3], (const PosTwoDCoord*)(void*)*arg[4]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitFmGpCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitFmGpCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord), *(TwoDCoord*)arg[2]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitGpFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitGpFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit_Group);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetActGeomNoSpc_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    PosTDCoord& refarg_0=*(PosTDCoord*)arg[1]->GetVoidPtrOfType(&TA_PosTDCoord);
    ((LeabraLayer*)ths)->GetActGeomNoSpc(refarg_0);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitActAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitActAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitInhib_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitInhib();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetCurLrate((LeabraNetwork*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Active_K_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Active_K();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_HardClamp((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_NetScale((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Init_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Init_ClampNet((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_ClampNet((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Clamp_NetAvg((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Inhib((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_LayInhibToGps_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_LayInhibToGps((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_InhibAvg((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->PhaseInit((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayEvent((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayPhase((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayPhase2((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ExtToComp((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->TargExtToComp((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraLayer*)ths)->PostSettle((LeabraNetwork*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraLayer*)ths)->PostSettle((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_WtFmLin((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ResetSortBuf();
    return rval;}
LeabraNetwork*		 TAI_LeabraNetwork=NULL;
  static cssEl* cssElCFun_LeabraNetwork_InitCounters_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->InitCounters();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_InitStats_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->InitStats();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_Act_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_Act();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_SSE_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_SSE();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_EpochSSE_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_EpochSSE();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_Clamp_NetAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_Inhib_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_Inhib();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_InhibAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_InhibAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Cycle_Run_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Cycle_Run();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_Active_K_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_Active_K();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_DecayPhase_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->DecayPhase();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_DecayPhase2_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->DecayPhase2();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_PhaseInit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->PhaseInit();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_ExtToComp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->ExtToComp();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_TargExtToComp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->TargExtToComp();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_HardClamp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_HardClamp();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_NetScale_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_NetScale();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Send_ClampNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Send_ClampNet();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Settle_Init_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Settle_Init();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_PostSettle_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->PostSettle();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_PostSettle_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->PostSettle_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Settle_Final_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Settle_Final();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_SetCurLrate_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->SetCurLrate();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_DecayEvent_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->DecayEvent();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_DecayState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->DecayState();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Trial_Init_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Trial_Init();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Trial_UpdatePhase_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Trial_UpdatePhase();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_EncodeState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->EncodeState();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_dWt_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_dWt_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_ExtRew_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_ExtRew();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Trial_Final_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Trial_Final();
    return rval;}
  static cssEl* cssElCFun_LeabraNetwork_Compute_AvgExtRew_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNetwork*)ths)->Compute_AvgExtRew();
    return rval;}
LeabraProject*		 TAI_LeabraProject=NULL;
WtScaleSpec*		 TAI_WtScaleSpec=NULL;
  static cssEl* cssElCFun_WtScaleSpec_NetScale_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtScaleSpec*)ths)->NetScale());
    return rval;}
WtSigSpec*		 TAI_WtSigSpec=NULL;
  static cssEl* cssElCFun_WtSigSpec_SigFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtSigSpec*)ths)->SigFun((float)*arg[1], (float)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_WtSigSpec_SigFunInv_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtSigSpec*)ths)->SigFunInv((float)*arg[1], (float)*arg[2], (float)*arg[3]));
    return rval;}
LearnMixSpec*		 TAI_LearnMixSpec=NULL;
  static cssEl* cssElCFun_LearnMixSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LearnMixSpec*)ths)->UpdateAfterEdit();
    return rval;}
SAvgCorSpec*		 TAI_SAvgCorSpec=NULL;
ActFunSpec*		 TAI_ActFunSpec=NULL;
SpikeFunSpec*		 TAI_SpikeFunSpec=NULL;
DepressSpec*		 TAI_DepressSpec=NULL;
  static cssEl* cssElCFun_DepressSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((DepressSpec*)ths)->UpdateAfterEdit();
    return rval;}
OptThreshSpec*		 TAI_OptThreshSpec=NULL;
DtSpec*		 TAI_DtSpec=NULL;
LeabraChannels*		 TAI_LeabraChannels=NULL;
VChanSpec*		 TAI_VChanSpec=NULL;
  static cssEl* cssElCFun_VChanSpec_UpdateBasis_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float refarg_0=(float)*arg[1];    bool refarg_1=(bool)*arg[2];    float refarg_2=(float)*arg[3];
    ((VChanSpec*)ths)->UpdateBasis(refarg_0, refarg_1, refarg_2, (float)*arg[4]);
    *arg[1]=(Real)refarg_0;    *arg[2]=(bool)refarg_1;    *arg[3]=(Real)refarg_2;
    return rval;}
ActRegSpec*		 TAI_ActRegSpec=NULL;
MaxDaSpec*		 TAI_MaxDaSpec=NULL;
VChanBasis*		 TAI_VChanBasis=NULL;
LeabraUnitChans*		 TAI_LeabraUnitChans=NULL;
taPtrList<LeabraUnit>*		 TAI_taPtrList_LeabraUnit_=NULL;
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Find_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Find(arg[1]->GetStr()));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Remove_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->Remove((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->SafeEl((int)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FastEl((int)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Edit_El((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FindName(arg[1]->GetStr()), 1, &TA_LeabraUnit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FindName(arg[1]->GetStr(), refarg_1), 1, &TA_LeabraUnit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Pop(), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Peek(), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->AddUniqNameOld((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->LinkUniqNameOld((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FindEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->FindEl((const LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->AddEl((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Add_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Add((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->AddUnique((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->AddUniqNameNew((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Insert_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->Insert((LeabraUnit*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Replace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->Replace((int)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->ReplaceEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->ReplaceName(arg[1]->GetStr(), (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__RemoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->RemoveEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__DuplicateEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->DuplicateEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Link_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Link((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->LinkUnique((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->LinkUniqNameNew((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__InsertLink_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->InsertLink((LeabraUnit*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->InsertLink((LeabraUnit*)(void*)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->ReplaceLink((int)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLinkEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->ReplaceLinkEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLinkName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->ReplaceLinkName(arg[1]->GetStr(), (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Push_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Push((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->MoveEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Transfer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->Transfer((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->MoveBefore((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((taPtrList<LeabraUnit>*)ths)->MoveAfter((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraSort_FindNewNetPos_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraSort*)ths)->FindNewNetPos((float)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraSort_FastInsertLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSort*)ths)->FastInsertLink((void*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
KWTASpec*		 TAI_KWTASpec=NULL;
KwtaTieBreak*		 TAI_KwtaTieBreak=NULL;
AdaptISpec*		 TAI_AdaptISpec=NULL;
ClampSpec*		 TAI_ClampSpec=NULL;
DecaySpec*		 TAI_DecaySpec=NULL;
LayNetRescaleSpec*		 TAI_LayNetRescaleSpec=NULL;
SpecPtr<LeabraLayerSpec>*		 TAI_SpecPtr_LeabraLayerSpec_=NULL;
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__GetSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((SpecPtr<LeabraLayerSpec>*)ths)->GetSpec(), 1, &TA_BaseSpec);
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__SetSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SpecPtr<LeabraLayerSpec>*)ths)->SetSpec((BaseSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__SetDefaultSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SpecPtr<LeabraLayerSpec>*)ths)->SetDefaultSpec((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__CheckSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((SpecPtr<LeabraLayerSpec>*)ths)->CheckSpec());
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__NewChild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((SpecPtr<LeabraLayerSpec>*)ths)->NewChild(), 1, &TA_LeabraLayerSpec);
    return rval;}
LeabraLayerSpec_SPtr*		 TAI_LeabraLayerSpec_SPtr=NULL;
AvgMaxVals*		 TAI_AvgMaxVals=NULL;
KWTAVals*		 TAI_KWTAVals=NULL;
  static cssEl* cssElCFun_KWTAVals_Compute_Pct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((KWTAVals*)ths)->Compute_Pct((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_KWTAVals_Compute_IThrR_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((KWTAVals*)ths)->Compute_IThrR();
    return rval;}
AdaptIVals*		 TAI_AdaptIVals=NULL;
InhibVals*		 TAI_InhibVals=NULL;
LeabraWizard*		 TAI_LeabraWizard=NULL;
  static cssEl* cssElCFun_LeabraWizard_StdNetwork_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraWizard*)ths)->StdNetwork();}
    if(na == 1) {
      ((LeabraWizard*)ths)->StdNetwork((Network*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_StdProgs_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWizard*)ths)->StdProgs();
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_StdLayerSpecs_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWizard*)ths)->StdLayerSpecs((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_SRNContext_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWizard*)ths)->SRNContext((LeabraNetwork*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_UnitInhib_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWizard*)ths)->UnitInhib((LeabraNetwork*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWizard*)ths)->UnitInhib((LeabraNetwork*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_TD_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWizard*)ths)->TD((LeabraNetwork*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWizard*)ths)->TD((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWizard*)ths)->TD((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_PVLV_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWizard*)ths)->PVLV((LeabraNetwork*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWizard*)ths)->PVLV((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWizard*)ths)->PVLV((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraWizard*)ths)->PVLV((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4]);}
    if(na == 5) {
      ((LeabraWizard*)ths)->PVLV((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5]);}
    if(na == 6) {
      ((LeabraWizard*)ths)->PVLV((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_BgPFC_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4]);}
    if(na == 5) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5]);}
    if(na == 6) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6]);}
    if(na == 7) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (int)*arg[7]);}
    if(na == 8) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (int)*arg[7], (bool)*arg[8]);}
    if(na == 9) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (int)*arg[7], (bool)*arg[8], (bool)*arg[9]);}
    if(na == 10) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (int)*arg[7], (bool)*arg[8], (bool)*arg[9], (bool)*arg[10]);}
    if(na == 11) {
      ((LeabraWizard*)ths)->BgPFC((LeabraNetwork*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6], (int)*arg[7], (bool)*arg[8], (bool)*arg[9], (bool)*arg[10], (bool)*arg[11]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWizard_SetPFCStripes_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraWizard*)ths)->SetPFCStripes((LeabraNetwork*)(void*)*arg[1], (int)*arg[2]);}
    if(na == 3) {
      ((LeabraWizard*)ths)->SetPFCStripes((LeabraNetwork*)(void*)*arg[1], (int)*arg[2], (int)*arg[3]);}
    return rval;}
MarkerConSpec*		 TAI_MarkerConSpec=NULL;
  static cssEl* cssElCFun_MarkerConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MarkerConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_DMem_AlwaysLocal_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((MarkerConSpec*)ths)->DMem_AlwaysLocal());
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
CtxtUpdateSpec*		 TAI_CtxtUpdateSpec=NULL;
LeabraContextLayerSpec*		 TAI_LeabraContextLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraContextLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((LeabraContextLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((LeabraContextLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraContextLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraContextLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraContextLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraContextLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_LeabraContextLayerSpec_Compute_Context_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraContextLayerSpec*)ths)->Compute_Context((LeabraLayer*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
LeabraLinUnitSpec*		 TAI_LeabraLinUnitSpec=NULL;
  static cssEl* cssElCFun_LeabraLinUnitSpec_Compute_ActFmVm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLinUnitSpec*)ths)->Compute_ActFmVm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLinUnitSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLinUnitSpec*)ths)->Defaults();
    return rval;}
LeabraNegBiasSpec*		 TAI_LeabraNegBiasSpec=NULL;
  static cssEl* cssElCFun_LeabraNegBiasSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNegBiasSpec*)ths)->B_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraNegBiasSpec_B_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraNegBiasSpec*)ths)->B_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnitSpec*)(void*)*arg[3]);
    return rval;}
TrialSynDepCon*		 TAI_TrialSynDepCon=NULL;
SynDepSpec*		 TAI_SynDepSpec=NULL;
TrialSynDepConSpec*		 TAI_TrialSynDepConSpec=NULL;
  static cssEl* cssElCFun_TrialSynDepConSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TrialSynDepConSpec*)ths)->C_Compute_Net((TrialSynDepCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TrialSynDepConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_InitWtState_Post((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Depress_Wt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Depress_Wt((TrialSynDepCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Depress_Wt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Depress_Wt((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Reset_EffWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Reset_EffWt((TrialSynDepCon*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Reset_EffWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Reset_EffWt((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
FastWtCon*		 TAI_FastWtCon=NULL;
FastWtSpec*		 TAI_FastWtSpec=NULL;
FastWtConSpec*		 TAI_FastWtConSpec=NULL;
  static cssEl* cssElCFun_FastWtConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_UpdateWeights((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_InitWtState_Post((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_UpdateWeightsActReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_UpdateWeightsActReg((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->SetCurLrate((int)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowHebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FastWtConSpec*)ths)->C_Compute_SlowHebb((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowErr_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FastWtConSpec*)ths)->C_Compute_SlowErr((FastWtCon*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowdWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_SlowdWt((FastWtCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_FastDecay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_FastDecay((FastWtCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]);
    return rval;}
ActAvgHebbMixSpec*		 TAI_ActAvgHebbMixSpec=NULL;
  static cssEl* cssElCFun_ActAvgHebbMixSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ActAvgHebbMixSpec*)ths)->UpdateAfterEdit();
    return rval;}
ActAvgHebbConSpec*		 TAI_ActAvgHebbConSpec=NULL;
  static cssEl* cssElCFun_ActAvgHebbConSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ActAvgHebbConSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_ActAvgHebbConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ActAvgHebbConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ActAvgHebbConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ActAvgHebbConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
ScalarValSpec*		 TAI_ScalarValSpec=NULL;
  static cssEl* cssElCFun_ScalarValSpec_InitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSpec*)ths)->InitVal((float)*arg[1], (int)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSpec_GetUnitAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValSpec*)ths)->GetUnitAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_ScalarValSpec_GetUnitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValSpec*)ths)->GetUnitVal((int)*arg[1]));
    return rval;}
ScalarValBias*		 TAI_ScalarValBias=NULL;
ScalarValLayerSpec*		 TAI_ScalarValLayerSpec=NULL;
  static cssEl* cssElCFun_ScalarValLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((ScalarValLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((ScalarValLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->InitWtState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_Inhib_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_Inhib_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_ActAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_ActAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_ActMAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_ActMAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_ActPAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_ActPAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ClampValue_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((ScalarValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);}
    if(na == 3) {
      ((ScalarValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (float)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ClampAvgAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValLayerSpec*)ths)->ClampAvgAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ReadValue_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValLayerSpec*)ths)->ReadValue((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ResetAfterClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->ResetAfterClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_HardClampExt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->HardClampExt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnits_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnits_impl((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnits_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnits((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnitsNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnitsNet((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_WtBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_WtBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_NegSlp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_NegSlp((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_PosSlp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_PosSlp((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_BiasVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_BiasVal((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_dWtUgp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_dWtUgp((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ReConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((ScalarValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((ScalarValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
ScalarValSelfPrjnSpec*		 TAI_ScalarValSelfPrjnSpec=NULL;
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_Connect_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->Connect_impl((Projection*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->C_InitWtState((Projection*)(void*)*arg[1], (Con_Group*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_Connect_UnitGroup_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->Connect_UnitGroup((Unit_Group*)(void*)*arg[1], (Projection*)(void*)*arg[2]);
    return rval;}
TwoDValSpec*		 TAI_TwoDValSpec=NULL;
  static cssEl* cssElCFun_TwoDValSpec_InitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValSpec*)ths)->InitVal((float)*arg[1], (float)*arg[2], (int)*arg[3], (int)*arg[4], (float)*arg[5], (float)*arg[6], (float)*arg[7], (float)*arg[8]);
    return rval;}
  static cssEl* cssElCFun_TwoDValSpec_GetUnitAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TwoDValSpec*)ths)->GetUnitAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_TwoDValSpec_GetUnitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float refarg_1=(float)*arg[2];    float refarg_2=(float)*arg[3];
    ((TwoDValSpec*)ths)->GetUnitVal((int)*arg[1], refarg_1, refarg_2);
    *arg[2]=(Real)refarg_1;    *arg[3]=(Real)refarg_2;
    return rval;}
TwoDValBias*		 TAI_TwoDValBias=NULL;
TwoDValLayerSpec*		 TAI_TwoDValLayerSpec=NULL;
  static cssEl* cssElCFun_TwoDValLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((TwoDValLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((TwoDValLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->InitWtState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_ActAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_ActAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_ActMAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_ActMAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_ActPAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_ActPAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ClampValue_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((TwoDValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);}
    if(na == 3) {
      ((TwoDValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (float)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ReadValue_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->ReadValue((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ResetAfterClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->ResetAfterClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_HardClampExt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->HardClampExt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_LabelUnits_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->LabelUnits_impl((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_LabelUnits_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->LabelUnits((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_LabelUnitsNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->LabelUnitsNet((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_WtBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_WtBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_UnBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_UnBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_BiasVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_BiasVal((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_dWtUgp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_dWtUgp((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ReConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((TwoDValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((TwoDValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
DecodeTwoDValLayerSpec*		 TAI_DecodeTwoDValLayerSpec=NULL;
  static cssEl* cssElCFun_DecodeTwoDValLayerSpec_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DecodeTwoDValLayerSpec*)ths)->Compute_Inhib((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_DecodeTwoDValLayerSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DecodeTwoDValLayerSpec*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_DecodeTwoDValLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DecodeTwoDValLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_DecodeTwoDValLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DecodeTwoDValLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
DaModUnit*		 TAI_DaModUnit=NULL;
DaModSpec*		 TAI_DaModSpec=NULL;
DaModUnitSpec*		 TAI_DaModUnitSpec=NULL;
  static cssEl* cssElCFun_DaModUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssBool(((DaModUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (Network*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssBool(((DaModUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (Network*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_Compute_Conduct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->Compute_Conduct((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->DecayEvent((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 4) {
      ((DaModUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);}
    if(na == 5) {
      ((DaModUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4], (bool)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->EncodeState((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->Defaults();
    return rval;}
AvgExtRewSpec*		 TAI_AvgExtRewSpec=NULL;
OutErrSpec*		 TAI_OutErrSpec=NULL;
ExtRewSpec*		 TAI_ExtRewSpec=NULL;
ExtRewLayerSpec*		 TAI_ExtRewLayerSpec=NULL;
  static cssEl* cssElCFun_ExtRewLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((ExtRewLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((ExtRewLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_OutErrRewAvail_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((ExtRewLayerSpec*)ths)->OutErrRewAvail((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_GetOutErrRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ExtRewLayerSpec*)ths)->GetOutErrRew((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_OutErrRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_OutErrRew((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_ExtRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_ExtRew((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_DaRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_DaRew((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_UnitDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_UnitDa((float)*arg[1], (DaModUnit*)(void*)*arg[2], (Unit_Group*)(void*)*arg[3], (LeabraLayer*)(void*)*arg[4], (LeabraNetwork*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_NoRewAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_NoRewAct((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
TDRewPredConSpec*		 TAI_TDRewPredConSpec=NULL;
  static cssEl* cssElCFun_TDRewPredConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TDRewPredConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (DaModUnit*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3]));
    return rval;}
TDRewPredLayerSpec*		 TAI_TDRewPredLayerSpec=NULL;
  static cssEl* cssElCFun_TDRewPredLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((TDRewPredLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((TDRewPredLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((TDRewPredLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);}
    if(na == 3) {
      ((TDRewPredLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_SavePred_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_SavePred((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ClampPred_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ClampPred((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ClampPrev_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ClampPrev((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_TdPlusPhase_impl((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_TdPlusPhase((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
TDRewIntegSpec*		 TAI_TDRewIntegSpec=NULL;
TDRewIntegLayerSpec*		 TAI_TDRewIntegLayerSpec=NULL;
  static cssEl* cssElCFun_TDRewIntegLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_TDRewIntegLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((TDRewIntegLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((TDRewIntegLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_TDRewIntegLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewIntegLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewIntegLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TDRewIntegLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->Defaults();
    return rval;}
TdLayerSpec*		 TAI_TdLayerSpec=NULL;
  static cssEl* cssElCFun_TdLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((TdLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((TdLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_Td_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_Td((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Send_Td_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Send_Td((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
PVConSpec*		 TAI_PVConSpec=NULL;
  static cssEl* cssElCFun_PVConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((PVConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]));
    return rval;}
PVDetectSpec*		 TAI_PVDetectSpec=NULL;
PViLayerSpec*		 TAI_PViLayerSpec=NULL;
  static cssEl* cssElCFun_PViLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((PViLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((PViLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_PVe_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    bool refarg_2=(bool)*arg[3];    bool refarg_3=(bool)*arg[4];
    rval=new cssReal((double)((PViLayerSpec*)ths)->Compute_PVe((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], refarg_2, refarg_3));
    *arg[3]=(bool)refarg_2;    *arg[4]=(bool)refarg_3;
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_PVPlusPhaseDwt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->Compute_PVPlusPhaseDwt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
LVConSpec*		 TAI_LVConSpec=NULL;
  static cssEl* cssElCFun_LVConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LVConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]));
    return rval;}
LVSpec*		 TAI_LVSpec=NULL;
LVeLayerSpec*		 TAI_LVeLayerSpec=NULL;
  static cssEl* cssElCFun_LVeLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((LVeLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((LVeLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_DepressWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_DepressWt((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_LVPlusPhaseDwt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_LVPlusPhaseDwt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
LViLayerSpec*		 TAI_LViLayerSpec=NULL;
PVLVDaSpec*		 TAI_PVLVDaSpec=NULL;
PVLVDaLayerSpec*		 TAI_PVLVDaLayerSpec=NULL;
  static cssEl* cssElCFun_PVLVDaLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((PVLVDaLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((PVLVDaLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_Da((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Send_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Send_Da((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
PatchLayerSpec*		 TAI_PatchLayerSpec=NULL;
SNcMiscSpec*		 TAI_SNcMiscSpec=NULL;
SNcLayerSpec*		 TAI_SNcLayerSpec=NULL;
  static cssEl* cssElCFun_SNcLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((SNcLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((SNcLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_SNcLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNcLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_SNcLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNcLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_SNcLayerSpec_Compute_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SNcLayerSpec*)ths)->Compute_Da((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
MatrixConSpec*		 TAI_MatrixConSpec=NULL;
  static cssEl* cssElCFun_MatrixConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MatrixConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3], (DaModUnit*)(void*)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_MatrixConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MatrixConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (DaModUnit*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3]));
    return rval;}
MatrixBiasSpec*		 TAI_MatrixBiasSpec=NULL;
  static cssEl* cssElCFun_MatrixBiasSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixBiasSpec*)ths)->B_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
MatrixUnitSpec*		 TAI_MatrixUnitSpec=NULL;
  static cssEl* cssElCFun_MatrixUnitSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixUnitSpec*)ths)->Compute_NetAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixUnitSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 4) {
      ((MatrixUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);}
    if(na == 5) {
      ((MatrixUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4], (bool)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_MatrixUnitSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixUnitSpec*)ths)->Defaults();
    return rval;}
MatrixMiscSpec*		 TAI_MatrixMiscSpec=NULL;
ContrastSpec*		 TAI_ContrastSpec=NULL;
MatrixRndGoSpec*		 TAI_MatrixRndGoSpec=NULL;
MatrixErrRndGoSpec*		 TAI_MatrixErrRndGoSpec=NULL;
MatrixAvgDaRndGoSpec*		 TAI_MatrixAvgDaRndGoSpec=NULL;
MatrixLayerSpec*		 TAI_MatrixLayerSpec=NULL;
  static cssEl* cssElCFun_MatrixLayerSpec_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((MatrixLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((MatrixLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->InitWtState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((MatrixLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);}
    if(na == 3) {
      ((MatrixLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Check_RndGoAvgRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((MatrixLayerSpec*)ths)->Check_RndGoAvgRew((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_UCondNoGoRndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_UCondNoGoRndGo((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_ErrRndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_ErrRndGo((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_AvgDaRndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_AvgDaRndGo((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_ClearRndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_ClearRndGo((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaModUnit_NoContrast_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaModUnit_NoContrast((DaModUnit*)(void*)*arg[1], (float)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaModUnit_Contrast_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaModUnit_Contrast((DaModUnit*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (int)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaTonicMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaTonicMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaPerfMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaPerfMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaLearnMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaLearnMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_AvgGoDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_AvgGoDa((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_MotorGate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_MotorGate((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
SNrThalMiscSpec*		 TAI_SNrThalMiscSpec=NULL;
SNrThalLayerSpec*		 TAI_SNrThalLayerSpec=NULL;
  static cssEl* cssElCFun_SNrThalLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((SNrThalLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((SNrThalLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->Compute_Clamp_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_Compute_GoNogoNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->Compute_GoNogoNet((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
PFCGateSpec*		 TAI_PFCGateSpec=NULL;
PFCLayerSpec*		 TAI_PFCLayerSpec=NULL;
  static cssEl* cssElCFun_PFCLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((PFCLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((PFCLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((PFCLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);}
    if(na == 3) {
      ((PFCLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_ResetSynDep_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->ResetSynDep((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraNetwork*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_MaintUpdt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_MaintUpdt((LeabraUnit_Group*)(void*)*arg[1], (PFCLayerSpec::MaintUpdtAct)(int)*arg[2], (LeabraLayer*)(void*)*arg[3], (LeabraNetwork*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_SendGateStates_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->SendGateStates((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_TmpClear_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_TmpClear((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_GatingGOGO_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_GatingGOGO((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
PFCOutGateSpec*		 TAI_PFCOutGateSpec=NULL;
PFCOutLayerSpec*		 TAI_PFCOutLayerSpec=NULL;
  static cssEl* cssElCFun_PFCOutLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssBool(((PFCOutLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssBool(((PFCOutLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->Compute_Inhib((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraNetwork*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PFCOutLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PFCOutLayerSpec*)ths)->Defaults();
    return rval;}
LeabraCycle*		 TAI_LeabraCycle=NULL;
LeabraSettle*		 TAI_LeabraSettle=NULL;
LeabraTrial*		 TAI_LeabraTrial=NULL;
LeabraMaxDa*		 TAI_LeabraMaxDa=NULL;
LeabraSE_Stat*		 TAI_LeabraSE_Stat=NULL;
LeabraGoodStat*		 TAI_LeabraGoodStat=NULL;
LeabraSharpStat*		 TAI_LeabraSharpStat=NULL;
WrongOnStat*		 TAI_WrongOnStat=NULL;
LeabraPrjnRelNetinStat*		 TAI_LeabraPrjnRelNetinStat=NULL;
ExtRew_Stat*		 TAI_ExtRew_Stat=NULL;
PhaseOrderEventSpec*		 TAI_PhaseOrderEventSpec=NULL;
V3LeabraProject*		 TAI_V3LeabraProject=NULL;
  static cssEl* cssElCFun_V3LeabraProject_ConvertToV4_impl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssBool(((V3LeabraProject*)ths)->ConvertToV4_impl());
    return rval;}

// Type Data

static int LeabraCon::* TA_LeabraCon_MbrOff;
static MemberDef_data TA_LeabraCon_MemberDef[]={
  {&TA_float,NULL,"dwt"," resulting net weight change","NO_VIEW NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_MbrOff=(int LeabraCon::*)(&LeabraCon::dwt))),0,NULL,0},
  {&TA_float,NULL,"pdw"," previous delta-weight change","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_MbrOff=(int LeabraCon::*)(&LeabraCon::pdw))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraConSpec_LRSValue[]={
  {"NO_LRS"," don't use a learning rate schedule","",0},
  {"EPOCH"," current epoch counter","",1},
  {"EXT_REW_STAT"," avg_ext_rew value on network (computed over an 'epoch' of training): value is * 100 (0..100) ","",2},
  {"EXT_REW_AVG"," uses average reward computed by ExtRew layer (if present): value is units[0].act_avg (avg_rew) * 100 (0..100) ","",3},
  NULL};
static int LeabraConSpec::* TA_LeabraConSpec_MbrOff;
static MemberDef_data TA_LeabraConSpec_MemberDef[]={
  {&TA_bool,NULL,"inhib"," makes the connection inhibitory (to g_i instead of net)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::inhib))),0,NULL,0},
  {&TA_WtScaleSpec,NULL,"wt_scale"," scale weight values, both relative and absolute factors","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_scale))),0,NULL,0},
  {&TA_WtSigSpec,NULL,"wt_sig"," sigmoidal weight function for contrast enhancement: high gain makes weights more binary & discriminative","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig))),0,NULL,0},
  {&TA_float,NULL,"lrate"," learning rate -- how fast do the weights change per experience","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrate))),0,NULL,0},
  {&TA_float,NULL,"cur_lrate"," current actual learning rate = lrate * lrate_sched current value (* 1 if no lrate_sched)","READ_ONLY NO_INHERIT SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::cur_lrate))),0,NULL,0},
  {NULL,"::LRSValue","lrs_value"," what value to drive the learning rate schedule with (Important: affects values entered in start_ctr fields of schedule!)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrs_value))),0,NULL,0},
  {&TA_Schedule,NULL,"lrate_sched"," schedule of learning rate over training epochs (multiplies lrate!)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrate_sched))),0,NULL,0},
  {&TA_LearnMixSpec,NULL,"lmix"," mixture of hebbian & err-driven learning","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lmix))),0,NULL,0},
  {&TA_SAvgCorSpec,NULL,"savg_cor"," for Hebbian and netinput computation: correction for sending average act levels (i.e., renormalization); also norm_con_n for normalizing netinput computation","AKA_fix_savg ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::savg_cor))),0,NULL,0},
  {&TA_FunLookup,NULL,"wt_sig_fun"," computes wt sigmoidal fun","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun))),0,NULL,0},
  {&TA_FunLookup,NULL,"wt_sig_fun_inv"," computes inverse of wt sigmoidal fun","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_inv))),0,NULL,0},
  {&TA_WtSigSpec,NULL,"wt_sig_fun_lst"," last values of wt sig parameters for which the wt_sig_fun's were computed; prevents excessive updating","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_lst))),0,NULL,0},
  {&TA_float,NULL,"wt_sig_fun_res"," last values of resolution parameters for which the wt_sig_fun's were computed","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_res))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtState_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Net_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"gp",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_LinFmWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_LinFmWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"gp",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtState_Post_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Connection_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_delta_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_delta_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_SAvgCor_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"na",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"su_act_m",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_B_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_ActReg_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_UpdateWeightsActReg_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_B_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_LeabraConSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraConSpec_UpdateAfterEdit_stub,NULL},
  {&TA_void,NULL,"C_InitWtState","","","",
    1,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_InitWtState_stub,TA_LeabraConSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_InitWtDelta_stub,TA_LeabraConSpec_C_InitWtDelta_MethArgs},
  {&TA_float,NULL,"C_Compute_Net","","","",
    1,3,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Net_stub,TA_LeabraConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net"," receiver-based net input ","","",
    1,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Compute_Net_stub,TA_LeabraConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    1,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Send_Net_stub,TA_LeabraConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input computation","","",
    1,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Send_Net_stub,TA_LeabraConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    1,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_dWt_stub,TA_LeabraConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Compute_dWt_stub,TA_LeabraConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights"," update weights, if activation regulation is NOT in effect","","",
    1,5,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_UpdateWeights_stub,TA_LeabraConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights","","","",
    1,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_UpdateWeights_stub,TA_LeabraConSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"C_Compute_WtFmLin"," weight is negative if it is in its linear form, only perform if negative","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_WtFmLin_stub,TA_LeabraConSpec_C_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," compute actual weight value from linear weight value","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraConSpec_Compute_WtFmLin_stub,TA_LeabraConSpec_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"C_Compute_LinFmWt"," weight is negative if it is in its linear form, only perform if positive","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_LinFmWt_stub,TA_LeabraConSpec_C_Compute_LinFmWt_MethArgs},
  {&TA_void,NULL,"Compute_LinFmWt"," compute linear weight value from actual weight value","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraConSpec_Compute_LinFmWt_stub,TA_LeabraConSpec_Compute_LinFmWt_MethArgs},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtState_Post_stub,TA_LeabraConSpec_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"C_Send_Inhib","","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Send_Inhib_stub,TA_LeabraConSpec_C_Send_Inhib_MethArgs},
  {&TA_void,NULL,"Send_Inhib"," sender-based inhibitiory net input computation","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Send_Inhib_stub,TA_LeabraConSpec_Send_Inhib_MethArgs},
  {&TA_void,NULL,"C_Send_NetDelta","","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Send_NetDelta_stub,TA_LeabraConSpec_C_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," sender-based delta net input computation (send_delta mode only)","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Send_NetDelta_stub,TA_LeabraConSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"C_Send_InhibDelta","","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Send_InhibDelta_stub,TA_LeabraConSpec_C_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"Send_InhibDelta"," sender-based delta inhibitiory net input computation (send_delta mode only)","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Send_InhibDelta_stub,TA_LeabraConSpec_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"C_Send_ClampNet","","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Send_ClampNet_stub,TA_LeabraConSpec_C_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," sender-based net input computation for clamp net","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Send_ClampNet_stub,TA_LeabraConSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Compute_SAvgCor"," compute hebb correction scaling term for sending average act (cg->savg_cor) based on layer target activity percent","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_Compute_SAvgCor_stub,TA_LeabraConSpec_Compute_SAvgCor_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," compute Hebbian associative learning","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Hebb_stub,TA_LeabraConSpec_C_Compute_Hebb_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    0,5,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Err_stub,TA_LeabraConSpec_C_Compute_Err_MethArgs},
  {&TA_void,NULL,"B_Compute_dWt"," compute bias weight change for netin model of bias weight","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraConSpec_B_Compute_dWt_stub,TA_LeabraConSpec_B_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_Compute_ActReg"," compute dwt for activation regulation","","",
    0,5,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_Compute_ActReg_stub,TA_LeabraConSpec_C_Compute_ActReg_MethArgs},
  {&TA_void,NULL,"C_UpdateWeightsActReg"," update weights, if activation regulation is in effect","","",
    0,5,-1,0,0,NULL,cssElCFun_LeabraConSpec_C_UpdateWeightsActReg_stub,TA_LeabraConSpec_C_UpdateWeightsActReg_MethArgs},
  {&TA_void,NULL,"B_UpdateWeights","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraConSpec_B_UpdateWeights_stub,TA_LeabraConSpec_B_UpdateWeights_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on schedule given epoch (or error value)","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraConSpec_SetCurLrate_stub,TA_LeabraConSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"CreateWtSigFun"," create the wt_sig_fun and wt_sig_fun_inv","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraConSpec_CreateWtSigFun_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraConSpec_Defaults_stub,NULL},
  NULL};
static int LeabraBiasSpec::* TA_LeabraBiasSpec_MbrOff;
static MemberDef_data TA_LeabraBiasSpec_MemberDef[]={
  {&TA_float,NULL,"dwt_thresh"," don't change if dwt < thresh, prevents buildup of small changes","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_LeabraBiasSpec_MbrOff=(int LeabraBiasSpec::*)(&LeabraBiasSpec::dwt_thresh))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraBiasSpec_B_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodDef_data TA_LeabraBiasSpec_MethodDef[]={
  {&TA_void,NULL,"B_Compute_dWt","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraBiasSpec_B_Compute_dWt_stub,TA_LeabraBiasSpec_B_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraBiasSpec_Defaults_stub,NULL},
  NULL};
static int LeabraCon_Group::* TA_LeabraCon_Group_MbrOff;
static MemberDef_data TA_LeabraCon_Group_MemberDef[]={
  {&TA_float,NULL,"scale_eff"," effective scale parameter for netin","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::scale_eff))),0,NULL,0},
  {&TA_float,NULL,"savg_cor"," savg correction factor for hebbian learning","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::savg_cor))),0,NULL,0},
  {&TA_float,NULL,"net"," netinput to this con_group: not normally computed!","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::net))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_C_InitWtState_Post_MethArgs[]={
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_Send_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_Send_NetDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LeabraCon_Group_MethodDef[]={
  {&TA_void,NULL,"Compute_LinFmWt","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraCon_Group_Compute_LinFmWt_stub,NULL},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraCon_Group_Compute_WtFmLin_stub,NULL},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraCon_Group_C_InitWtState_Post_stub,TA_LeabraCon_Group_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraCon_Group_SetCurLrate_stub,TA_LeabraCon_Group_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraCon_Group_Send_ClampNet_stub,TA_LeabraCon_Group_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraCon_Group_Send_NetDelta_stub,TA_LeabraCon_Group_Send_NetDelta_MethArgs},
  NULL};
static EnumDef_data TA_LeabraUnitSpec_ActFun[]={
  {"NOISY_XX1"," x over x plus 1 convolved with Gaussian noise (noise is nvar)","",0},
  {"XX1"," x over x plus 1, hard threshold, no noise convolution","",1},
  {"NOISY_LINEAR"," simple linear output function (still thesholded) convolved with Gaussian noise (noise is nvar)","",2},
  {"LINEAR"," simple linear output function (still thesholded)","",3},
  {"DEPRESS"," depressing synapses activation function (rate coded)","",4},
  {"SPIKE"," discrete spiking activations (spike when > thr)","",5},
  NULL};
static EnumDef_data TA_LeabraUnitSpec_NoiseType[]={
  {"NO_NOISE"," no noise added to processing","",0},
  {"VM_NOISE"," noise in the value of v_m (membrane potential)","",1},
  {"NETIN_NOISE"," noise in the net input (g_e)","",2},
  {"ACT_NOISE"," noise in the activations","",3},
  NULL};
static int LeabraUnitSpec::* TA_LeabraUnitSpec_MbrOff;
static MemberDef_data TA_LeabraUnitSpec_MemberDef[]={
  {NULL,"::ActFun","act_fun"," activation function to use","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act_fun))),0,NULL,0},
  {&TA_ActFunSpec,NULL,"act"," activation function specs","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act))),0,NULL,0},
  {&TA_SpikeFunSpec,NULL,"spike"," spiking function specs (only for act_fun = SPIKE)","CONDEDIT_ON_act_fun:SPIKE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::spike))),0,NULL,0},
  {&TA_DepressSpec,NULL,"depress"," depressing synapses activation function specs, note that act_range deterimines range of spk_amp spiking amplitude, max should be > 1","CONDEDIT_ON_act_fun:DEPRESS ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::depress))),0,NULL,0},
  {&TA_OptThreshSpec,NULL,"opt_thresh"," optimization thresholds for speeding up processing when units are basically inactive","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::opt_thresh))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"clamp_range"," range of clamped activation values (min, max, 0, .95 std), don't clamp to 1 because acts can't reach, so .95 instead","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::clamp_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"vm_range"," membrane potential range (min, max, 0-1 for normalized, -90-50 for bio-based)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::vm_range))),0,NULL,0},
  {&TA_Random,NULL,"v_m_init"," what to initialize the membrane potential to (mean = .15, var = 0 std)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::v_m_init))),0,NULL,0},
  {&TA_DtSpec,NULL,"dt"," time constants (rate of updating): membrane potential (vm) and net input (net)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::dt))),0,NULL,0},
  {&TA_LeabraChannels,NULL,"g_bar"," [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::g_bar))),0,NULL,0},
  {&TA_LeabraChannels,NULL,"e_rev"," [Defaults: 1, .15, .15, 1, 0] reversal potentials for each channel","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::e_rev))),0,NULL,0},
  {&TA_VChanSpec,NULL,"hyst"," [Defaults: .05, .8, .7, .1] hysteresis (excitatory) v-gated chan (Ca2+, NMDA)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::hyst))),0,NULL,0},
  {&TA_VChanSpec,NULL,"acc"," [Defaults: .01, .5, .1, .1] accomodation (inhibitory) v-gated chan (K+)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::acc))),0,NULL,0},
  {&TA_ActRegSpec,NULL,"act_reg"," activity regulation via global scaling of weight values","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act_reg))),0,NULL,0},
  {&TA_MaxDaSpec,NULL,"maxda"," maximum change in activation (da) computation -- regulates settling","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::maxda))),0,NULL,0},
  {NULL,"::NoiseType","noise_type"," where to add random noise in the processing (if at all)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_type))),0,NULL,0},
  {&TA_Random,NULL,"noise"," distribution parameters for random added noise","CONDEDIT_OFF_noise_type:NO_NOISE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise))),0,NULL,0},
  {&TA_Schedule,NULL,"noise_sched"," schedule of noise variance over settling cycles","CONDEDIT_OFF_noise_type:NO_NOISE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_sched))),0,NULL,0},
  {&TA_FunLookup,NULL,"nxx1_fun"," convolved gaussian and x/x+1 function as lookup table","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::nxx1_fun))),0,NULL,0},
  {&TA_FunLookup,NULL,"noise_conv"," gaussian for convolution","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_conv))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitWtState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_Net_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SSE_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitActAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_SetCurLrate_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetRescale_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"new_scale",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Init_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_HardClampNoClip_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThresh_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshAll_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoA_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoH_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoAH_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_MaxDa_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Conduct_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Vm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_ActFmVm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SelfReg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_PhaseInit_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_DecayPhase_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_ExtToComp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_TargExtToComp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_PostSettle_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_dWt_impl_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_EncodeState_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_LeabraUnitSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script) to set _impl sig","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig","","","",
    2,4,3,0,0,NULL,cssElCFun_LeabraUnitSpec_CheckConfig_stub,TA_LeabraUnitSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitState","","","",
    2,1,-1,0,0,NULL,cssElCFun_LeabraUnitSpec_InitState_stub,TA_LeabraUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"InitWtState","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnitSpec_InitWtState_stub,TA_LeabraUnitSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Send_Net"," add ext input, sender-based","","",
    2,2,-1,0,0,NULL,cssElCFun_LeabraUnitSpec_Send_Net_stub,TA_LeabraUnitSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act"," compute the final activation: calls following function steps","","",
    2,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Act_stub,TA_LeabraUnitSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    2,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_dWt_stub,TA_LeabraUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights","","","",
    1,1,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_UpdateWeights_stub,TA_LeabraUnitSpec_UpdateWeights_MethArgs},
  {&TA_float,NULL,"Compute_SSE"," compute sum squared error for this unit","","",
    1,1,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SSE_stub,TA_LeabraUnitSpec_Compute_SSE_MethArgs},
  {&TA_void,NULL,"InitActAvg","","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_InitActAvg_stub,TA_LeabraUnitSpec_InitActAvg_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on epoch","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_SetCurLrate_stub,TA_LeabraUnitSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"InitDelta","","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_InitDelta_stub,TA_LeabraUnitSpec_InitDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," compute net input scaling values and input from hard-clamped inputs","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetScale_stub,TA_LeabraUnitSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Compute_NetRescale"," rescale netinput scales by given amount","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetRescale_stub,TA_LeabraUnitSpec_Compute_NetRescale_MethArgs},
  {&TA_void,NULL,"Init_ClampNet"," init clam net value prior to sending","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Init_ClampNet_stub,TA_LeabraUnitSpec_Init_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," compute net input from hard-clamped inputs (sender based)","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Send_ClampNet_stub,TA_LeabraUnitSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," //////////////////////////////////////////////////////////////","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Send_NetDelta_stub,TA_LeabraUnitSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg"," compute netin average","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetAvg_stub,TA_LeabraUnitSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," compute inhib netin average","","",
    0,4,-1,0,0,NULL,cssElCFun_LeabraUnitSpec_Compute_InhibAvg_stub,TA_LeabraUnitSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," force units to external values provided by environment: also optimizes settling by only computing netinput once","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_HardClamp_stub,TA_LeabraUnitSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_HardClampNoClip"," hard-clamp units without clipping values to clamp_range (use for second plus phase clamping to settled values)","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_HardClampNoClip_stub,TA_LeabraUnitSpec_Compute_HardClampNoClip_MethArgs},
  {&TA_bool,NULL,"Compute_SoftClamp"," soft-clamps unit, returns true if unit is not above .5","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SoftClamp_stub,TA_LeabraUnitSpec_Compute_SoftClamp_MethArgs},
  {&TA_float,NULL,"Compute_IThresh"," compute inhibitory value that would place unit directly at threshold","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThresh_stub,TA_LeabraUnitSpec_Compute_IThresh_MethArgs},
  {&TA_float,NULL,"Compute_IThreshAll"," compute inhibitory value that would place unit directly at threshold, using all currents","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshAll_stub,TA_LeabraUnitSpec_Compute_IThreshAll_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoA"," compute inhibitory value that would place unit directly at threshold, excluding gc.a current","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoA_stub,TA_LeabraUnitSpec_Compute_IThreshNoA_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoH"," compute inhibitory value that would place unit directly at threshold, excluding gc.a current","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoH_stub,TA_LeabraUnitSpec_Compute_IThreshNoH_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoAH"," compute inhibitory value that would place unit directly at threshold, excluding any gc.a, gc.h currents","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoAH_stub,TA_LeabraUnitSpec_Compute_IThreshNoAH_MethArgs},
  {&TA_void,NULL,"Compute_MaxDa","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_MaxDa_stub,TA_LeabraUnitSpec_Compute_MaxDa_MethArgs},
  {&TA_void,NULL,"Compute_Conduct"," compute input conductance values in the gc variables","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Conduct_stub,TA_LeabraUnitSpec_Compute_Conduct_MethArgs},
  {&TA_void,NULL,"Compute_Vm"," compute the membrante potential from input conductances","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Vm_stub,TA_LeabraUnitSpec_Compute_Vm_MethArgs},
  {&TA_void,NULL,"Compute_ActFmVm"," compute the activation from membrane potential","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_ActFmVm_stub,TA_LeabraUnitSpec_Compute_ActFmVm_MethArgs},
  {&TA_void,NULL,"Compute_SelfReg"," compute self-regulatory currents (hysteresis, accommodation)","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SelfReg_stub,TA_LeabraUnitSpec_Compute_SelfReg_MethArgs},
  {&TA_void,NULL,"PhaseInit"," initialize external input flags based on phase","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_PhaseInit_stub,TA_LeabraUnitSpec_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayPhase"," decay activation states towards initial values: at phase-level boundary","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_DecayPhase_stub,TA_LeabraUnitSpec_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay activation states towards initial values: at event-level boundary","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_DecayEvent_stub,TA_LeabraUnitSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"ExtToComp"," change external inputs to comparisons (remove input)","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_ExtToComp_stub,TA_LeabraUnitSpec_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp"," change target & external inputs to comparisons (remove targ & input)","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_TargExtToComp_stub,TA_LeabraUnitSpec_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle"," set stuff after settling is over (set_both = both _m and _p for current)","","",
    0,5,4,1,0,NULL,cssElCFun_LeabraUnitSpec_PostSettle_stub,TA_LeabraUnitSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_dWt_impl"," actually do wt change","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_dWt_impl_stub,TA_LeabraUnitSpec_Compute_dWt_impl_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," if weights need to be updated from linear values without doing updatewts","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_WtFmLin_stub,TA_LeabraUnitSpec_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"EncodeState"," encode current state information (hook for time-based learning)","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_EncodeState_stub,TA_LeabraUnitSpec_EncodeState_MethArgs},
  {&TA_void,NULL,"CreateNXX1Fun"," create convolved gaussian and x/x+1 ","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_CreateNXX1Fun_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnitSpec_Defaults_stub,NULL},
  NULL};
static int LeabraUnit::* TA_LeabraUnit_MbrOff;
static MemberDef_data TA_LeabraUnit_MemberDef[]={
  {&TA_float,NULL,"act_eq"," rate-code equivalent activity value (time-averaged spikes or just act)","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_eq))),0,NULL,0},
  {&TA_float,NULL,"act_avg"," average activation over long time intervals (dt = act.avg_dt)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_avg))),0,NULL,0},
  {&TA_float,NULL,"act_m"," minus_phase activation, set after settling, used for learning","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_m))),0,NULL,0},
  {&TA_float,NULL,"act_p"," plus_phase activation, set after settling, used for learning","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_p))),0,NULL,0},
  {&TA_float,NULL,"act_dif"," difference between plus and minus phase acts, gives unit err contribution","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_dif))),0,NULL,0},
  {&TA_float,NULL,"da"," delta activation: change in act from one cycle to next, used to stop settling","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::da))),0,NULL,0},
  {&TA_VChanBasis,NULL,"vcb"," voltage-gated channel basis variables","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::vcb))),0,NULL,0},
  {&TA_LeabraUnitChans,NULL,"gc"," current unit channel conductances","DMEM_SHARE_SET_1 NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::gc))),0,NULL,0},
  {&TA_float,NULL,"I_net"," net current produced by all channels","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::I_net))),0,NULL,0},
  {&TA_float,NULL,"v_m"," membrane potential","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::v_m))),0,NULL,0},
  {&TA_bool,NULL,"in_subgp"," determine if unit is in a subgroup","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::in_subgp))),0,NULL,0},
  {&TA_float,NULL,"clmp_net"," hard-clamp net input (no need to recompute)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_4 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::clmp_net))),0,NULL,0},
  {&TA_float,NULL,"net_scale"," total netinput scaling basis","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_scale))),0,NULL,0},
  {&TA_float,NULL,"bias_scale"," bias weight scaling factor","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::bias_scale))),0,NULL,0},
  {&TA_float,NULL,"prv_net"," previous net input (for time averaging)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::prv_net))),0,NULL,0},
  {&TA_float,NULL,"prv_g_i"," previous inhibitory conductance value (for time averaging)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::prv_g_i))),0,NULL,0},
  {&TA_float,NULL,"act_sent"," last activation value sent (only send when diff is over threshold)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_sent))),0,NULL,0},
  {&TA_float,NULL,"act_delta"," change in activation to send to other units","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_delta))),0,NULL,0},
  {&TA_float,NULL,"net_raw"," raw net input received from sending units (increments the deltas in send_delta)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_raw))),0,NULL,0},
  {&TA_float,NULL,"net_delta"," change in netinput received from other units (send_delta mode only)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_3 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_delta))),0,NULL,0},
  {&TA_float,NULL,"g_i_raw"," raw inhib net input received from sending units (increments the deltas in send_delta)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::g_i_raw))),0,NULL,0},
  {&TA_float,NULL,"g_i_delta"," change in inhibitory netinput received from other units (send_delta mode only)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_3 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::g_i_delta))),0,NULL,0},
  {&TA_float,NULL,"i_thr"," inhibitory threshold value for computing kWTA","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::i_thr))),0,NULL,0},
  {&TA_float,NULL,"spk_amp"," amplitude of spiking output (for depressing synapse activation function)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::spk_amp))),0,NULL,0},
  {&TA_float,NULL,"misc_1"," miscellaneous variable for other algorithms that need it (e.g., TdLayerSpec)","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::misc_1))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnit_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_Net_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_SetCurLrate_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetRescale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"new_scale",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Init_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_NetDelta_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_HardClampNoClip_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_IThresh_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_IThreshNoAH_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_MaxDa_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_PhaseInit_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_DecayEvent_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_DecayPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_ExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_TargExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_EncodeState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_LeabraUnit_MethodDef[]={
  {&TA_void,NULL,"InitDelta"," these are convenience functions for those defined in the spec","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_InitDelta_stub,NULL},
  {&TA_void,NULL,"InitState","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_InitState_stub,TA_LeabraUnit_InitState_MethArgs},
  {&TA_void,NULL,"Send_Net","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Send_Net_stub,TA_LeabraUnit_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act","","","",
    1,3,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_Act_stub,TA_LeabraUnit_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_dWt_stub,TA_LeabraUnit_Compute_dWt_MethArgs},
  {&TA_void,NULL,"InitActAvg","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_InitActAvg_stub,NULL},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_SetCurLrate_stub,TA_LeabraUnit_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_NetScale_stub,TA_LeabraUnit_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Compute_NetRescale","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_NetRescale_stub,TA_LeabraUnit_Compute_NetRescale_MethArgs},
  {&TA_void,NULL,"Init_ClampNet","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Init_ClampNet_stub,TA_LeabraUnit_Init_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Send_ClampNet_stub,TA_LeabraUnit_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Send_NetDelta_stub,TA_LeabraUnit_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_NetAvg_stub,TA_LeabraUnit_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_InhibAvg_stub,TA_LeabraUnit_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_HardClamp_stub,TA_LeabraUnit_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_HardClampNoClip","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_HardClampNoClip_stub,TA_LeabraUnit_Compute_HardClampNoClip_MethArgs},
  {&TA_bool,NULL,"Compute_SoftClamp","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_SoftClamp_stub,TA_LeabraUnit_Compute_SoftClamp_MethArgs},
  {&TA_float,NULL,"Compute_IThresh","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_IThresh_stub,TA_LeabraUnit_Compute_IThresh_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoAH","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_IThreshNoAH_stub,TA_LeabraUnit_Compute_IThreshNoAH_MethArgs},
  {&TA_void,NULL,"Compute_MaxDa","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_MaxDa_stub,TA_LeabraUnit_Compute_MaxDa_MethArgs},
  {&TA_void,NULL,"PhaseInit","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_PhaseInit_stub,TA_LeabraUnit_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraUnit_DecayEvent_stub,TA_LeabraUnit_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraUnit_DecayPhase_stub,TA_LeabraUnit_DecayPhase_MethArgs},
  {&TA_void,NULL,"ExtToComp","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_ExtToComp_stub,TA_LeabraUnit_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_TargExtToComp_stub,TA_LeabraUnit_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle","","","",
    0,4,3,0,0,NULL,cssElCFun_LeabraUnit_PostSettle_stub,TA_LeabraUnit_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_Compute_WtFmLin_stub,TA_LeabraUnit_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"EncodeState","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraUnit_EncodeState_stub,TA_LeabraUnit_EncodeState_MethArgs},
  {&TA_void,NULL,"GetInSubGp","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_GetInSubGp_stub,NULL},
  NULL};
static int LeabraInhib::* TA_LeabraInhib_MbrOff;
static MemberDef_data TA_LeabraInhib_MemberDef[]={
  {&TA_LeabraSort,NULL,"active_buf"," list of active units","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::active_buf))),0,NULL,0},
  {&TA_LeabraSort,NULL,"inact_buf"," list of inactive units","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::inact_buf))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"netin"," net input values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::netin))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"i_thrs"," inhibitory threshold values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::i_thrs))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts"," activation values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts_p"," plus-phase activation stats for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts_p))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts_m"," minus-phase activation stats for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts_m))),0,NULL,0},
  {&TA_float,NULL,"phase_dif_ratio"," phase-difference ratio (acts_m.avg / acts_p.avg)","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::phase_dif_ratio))),0,NULL,0},
  {&TA_KWTAVals,NULL,"kwta"," values for kwta -- activity levels, etc NOTE THIS IS A COMPUTED VALUE: k IS SET IN LayerSpec!","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::kwta))),0,NULL,0},
  {&TA_InhibVals,NULL,"i_val"," inhibitory values computed by kwta","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::i_val))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"un_g_i"," average and stdev (not max) values for unit inhib-to-thresh","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::un_g_i))),0,NULL,0},
  {&TA_AdaptIVals,NULL,"adapt_i"," adapting inhibition values","READ_ONLY AKA_adapt_pt ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::adapt_i))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodDef_data TA_LeabraInhib_MethodDef[]={
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraInhib_Inhib_SetVals_stub,TA_LeabraInhib_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraInhib_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraInhib_Inhib_InitState_stub,TA_LeabraInhib_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraInhib_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraInhib_Inhib_Copy__stub,TA_LeabraInhib_Inhib_Copy__MethArgs},
  NULL};
static EnumDef_data TA_LeabraLayerSpec_Compute_I[]={
  {"KWTA_INHIB"," between thresholds of k and k+1th most activated units (sets precise k value, should use i_kwta_pt = .25 std)","",0},
  {"KWTA_AVG_INHIB"," average of top k vs avg of rest (provides more flexibility in actual k value, should use i_kwta_pt = .6 std)","",1},
  {"AVG_MAX_PT_INHIB"," put inhib value at i_kwta_pt between avg and max values for layer!","",2},
  {"UNIT_INHIB"," unit-based inhibition (g_i from netinput -- requires connections with inhib flag set to provide inhibition)","",3},
  NULL};
static EnumDef_data TA_LeabraLayerSpec_InhibGroup[]={
  {"ENTIRE_LAYER"," treat entire layer as one inhibitory group (even if subgroups exist)","",0},
  {"UNIT_GROUPS"," treat sub unit groups as separate inhibitory groups (but also uses gp_i and gp_g if set, to have some sharing of inhib across groups","",1},
  {"LAY_AND_GPS"," compute inhib over both groups and whole layer, inhibi is max of layer and group inhib","",2},
  NULL};
static int LeabraLayerSpec::* TA_LeabraLayerSpec_MbrOff;
static MemberDef_data TA_LeabraLayerSpec_MemberDef[]={
  {&TA_KWTASpec,NULL,"kwta"," desired activity level over entire layer (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)","CONDEDIT_OFF_inhib_group:UNIT_GROUPS ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::kwta))),0,NULL,0},
  {&TA_KWTASpec,NULL,"gp_kwta"," desired activity level for units within unit groups (not for ENTIRE_LAYER) (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)","CONDEDIT_OFF_inhib_group:ENTIRE_LAYER ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::gp_kwta))),0,NULL,0},
  {NULL,"::InhibGroup","inhib_group"," what to consider the inhibitory group (layer or unit subgroups, or both)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::inhib_group))),0,NULL,0},
  {NULL,"::Compute_I","compute_i"," how to compute inhibition (g_i): two forms of kwta or unit-level inhibition","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::compute_i))),0,NULL,0},
  {&TA_float,NULL,"i_kwta_pt"," [Default: .25 for KWTA_INHIB, .6 for KWTA_AVG, .2 for AVG_MAX_PT_INHIB] point to place inhibition between k and k+1 (or avg and max for AVG_MAX_PT_INHIB)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::i_kwta_pt))),0,NULL,0},
  {&TA_float,NULL,"gp_i_pt"," [Default: .2] for unit groups: point to place inhibition between avg and max for AVG_MAX_PT_INHIB","CONDEDIT_ON_compute_i:AVG_MAX_PT_INHIB ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::gp_i_pt))),0,NULL,0},
  {&TA_KwtaTieBreak,NULL,"tie_brk"," break ties when all the units in the layer have similar netinputs, which puts the inhbition value too close to everyone's threshold and produces no activation at all. this will lower the inhibition and allow all the units to have some activation","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::tie_brk))),0,NULL,0},
  {&TA_AdaptISpec,NULL,"adapt_i"," adapt the inhibition: either i_kwta_pt point based on diffs between actual and target k level (for avg-based), or g_bar.i for unit-inhib","AKA_adapt_pt ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::adapt_i))),0,NULL,0},
  {&TA_ClampSpec,NULL,"clamp"," how to clamp external inputs to units (hard vs. soft)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::clamp))),0,NULL,0},
  {&TA_DecaySpec,NULL,"decay"," decay of activity state vars between events, -/+ phase, and 2nd set of phases (if appl)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::decay))),0,NULL,0},
  {&TA_LayNetRescaleSpec,NULL,"net_rescale"," rescale layer-wide netinputs to prevent blowup, when max net exceeds specified net value","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::net_rescale))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitWtState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitActAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_SetCurLrate_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Active_K_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Active_K_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_KWTASpec_ref,NULL,"kwtspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Pat_K_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_HardClampPhase2_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Init_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_Net_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitInhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_BreakTie_MethArgs[]={
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_LayInhibToGps_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_InhibAvg_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActMAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActMAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActPAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActPAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetRescale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_PhaseInit_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayPhase2_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_ExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_TargExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_AdaptGBarI_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_AdaptKWTAPt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpec_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int_ref,NULL,"prjn_idx",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpecExact_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int_ref,NULL,"prjn_idx",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpecNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodDef_data TA_LeabraLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_LeabraLayerSpec_CheckConfig_stub,TA_LeabraLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitWtState"," initialize weight values and other permanent state","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_InitWtState_stub,TA_LeabraLayerSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"InitActAvg"," initialize act_avg values","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_InitActAvg_stub,TA_LeabraLayerSpec_InitActAvg_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on epoch","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_SetCurLrate_stub,TA_LeabraLayerSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_Active_K"," prior to settling: compute actual activity levels based on spec, inputs, etc","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Active_K_stub,TA_LeabraLayerSpec_Compute_Active_K_MethArgs},
  {&TA_void,NULL,"Compute_Active_K_impl","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Active_K_impl_stub,TA_LeabraLayerSpec_Compute_Active_K_impl_MethArgs},
  {&TA_int,NULL,"Compute_Pat_K"," above are implementation helpers","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Pat_K_stub,TA_LeabraLayerSpec_Compute_Pat_K_MethArgs},
  {&TA_void,NULL,"InitState"," prior to settling: initialize dynamic state variables","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_InitState_stub,TA_LeabraLayerSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_HardClampPhase2"," prior to settling: hard-clamp inputs (special code for hard clamping in phase 2 based on prior acts)","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_HardClampPhase2_stub,TA_LeabraLayerSpec_Compute_HardClampPhase2_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_HardClamp_stub,TA_LeabraLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," prior to settling: compute netinput scaling values","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetScale_stub,TA_LeabraLayerSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Init_ClampNet"," prior to settling: init clamp net variable prior to sending","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Init_ClampNet_stub,TA_LeabraLayerSpec_Init_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," prior to settling: compute input from hard-clamped","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Send_ClampNet_stub,TA_LeabraLayerSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_Net"," compute net inputs","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Send_Net_stub,TA_LeabraLayerSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," compute net inputs as changes in activation","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Send_NetDelta_stub,TA_LeabraLayerSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_Clamp_NetAvg"," clamp and compute averages of net inputs that were already computed","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Clamp_NetAvg_stub,TA_LeabraLayerSpec_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetAvg_stub,TA_LeabraLayerSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_SoftClamp"," soft-clamp inputs by adding to net input","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_SoftClamp_stub,TA_LeabraLayerSpec_Compute_SoftClamp_MethArgs},
  {&TA_void,NULL,"InitInhib"," initialize the inhibitory state values","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_InitInhib_stub,TA_LeabraLayerSpec_InitInhib_MethArgs},
  {&TA_void,NULL,"Compute_Inhib"," stage two: compute the inhibition for layer","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_stub,TA_LeabraLayerSpec_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_impl"," implementation of inhibition computation for either layer or unit group","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_impl_stub,TA_LeabraLayerSpec_Compute_Inhib_impl_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA"," implementation of basic kwta inhibition computation","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA_Avg"," implementation of kwta avg-based inhibition computation","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_AvgMaxPt"," implementation of avg-max-pt inhibition computation","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_stub,TA_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA_Gps"," implementation of GPS_THEN_UNITS kwta on groups","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_BreakTie"," break any ties in the kwta function","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_BreakTie_stub,TA_LeabraLayerSpec_Compute_Inhib_BreakTie_MethArgs},
  {&TA_void,NULL,"Compute_LayInhibToGps"," Stage 3.25: for layer groups, need to propagate inhib out to unit groups","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_LayInhibToGps_stub,TA_LeabraLayerSpec_Compute_LayInhibToGps_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_InhibAvg_stub,TA_LeabraLayerSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg_impl"," //////////////////////////////////////","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_InhibAvg_impl_stub,TA_LeabraLayerSpec_Compute_InhibAvg_impl_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg"," helper function to compute acts.avg from act_eq","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActAvg_stub,TA_LeabraLayerSpec_Compute_ActAvg_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActMAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActMAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg"," helper function to compute acts_m.avg from act_m","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActMAvg_stub,TA_LeabraLayerSpec_Compute_ActMAvg_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActPAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActPAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg"," helper function to compute acts_p.avg from act_p","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActPAvg_stub,TA_LeabraLayerSpec_Compute_ActPAvg_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Act_stub,TA_LeabraLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl","","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Act_impl_stub,TA_LeabraLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"Compute_NetRescale"," do net rescaling to prevent blowup based on netin.max","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetRescale_stub,TA_LeabraLayerSpec_Compute_NetRescale_MethArgs},
  {&TA_void,NULL,"PhaseInit"," initialize start of a setting phase, set input flags appropriately, etc","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_PhaseInit_stub,TA_LeabraLayerSpec_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent","","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_DecayEvent_stub,TA_LeabraLayerSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase","","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_DecayPhase_stub,TA_LeabraLayerSpec_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayPhase2","","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_DecayPhase2_stub,TA_LeabraLayerSpec_DecayPhase2_MethArgs},
  {&TA_void,NULL,"ExtToComp"," change external inputs to comparisons (remove input)","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_ExtToComp_stub,TA_LeabraLayerSpec_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp"," change target & external inputs to comparisons (remove targ & input)","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_TargExtToComp_stub,TA_LeabraLayerSpec_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle"," after settling, keep track of phase variables, etc.","","",
    0,3,2,1,0,NULL,cssElCFun_LeabraLayerSpec_PostSettle_stub,TA_LeabraLayerSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"AdaptGBarI"," adapt inhibitory conductances based on target activation values relative to current values","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_AdaptGBarI_stub,TA_LeabraLayerSpec_AdaptGBarI_MethArgs},
  {&TA_void,NULL,"AdaptKWTAPt"," adapt the kwta point based on average activity","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_AdaptKWTAPt_stub,TA_LeabraLayerSpec_AdaptKWTAPt_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_dWt_stub,TA_LeabraLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," use this if weights will be used again for activations prior to being updated","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_WtFmLin_stub,TA_LeabraLayerSpec_Compute_WtFmLin_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpec"," find a layer that given layer receives from based on the type of layer spec","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_FindLayerFmSpec_stub,TA_LeabraLayerSpec_FindLayerFmSpec_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpecExact"," find a layer that given layer receives from based on the type of layer spec: uses exact type match, not inherits!","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_FindLayerFmSpecExact_stub,TA_LeabraLayerSpec_FindLayerFmSpecExact_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpecNet"," find a layer in network based on the type of layer spec","","",
    0,2,-1,0,1,(ta_void_fun)(LeabraLayerSpec::FindLayerFmSpecNet),cssElCFun_LeabraLayerSpec_FindLayerFmSpecNet_stub,TA_LeabraLayerSpec_FindLayerFmSpecNet_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayerSpec_Defaults_stub,NULL},
  NULL};
static int LeabraUnit_Group::* TA_LeabraUnit_Group_MbrOff;
static MemberDef_data TA_LeabraUnit_Group_MemberDef[]={
  {&TA_int,NULL,"misc_state"," miscellaneous state variable","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state))),0,NULL,0},
  {&TA_int,NULL,"misc_state1"," second miscellaneous state variable ","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state1))),0,NULL,0},
  {&TA_int,NULL,"misc_state2"," third miscellaneous state variable ","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state2))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_setDirty_MethArgs[]={
  {&TA_bool,NULL,"value",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetFileName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetOwner_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"tp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetPath_MethArgs[]={
  {&TA_TAPtr,NULL,"ta","__null"},
  {&TA_TAPtr,NULL,"par_stop"," __null"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindFromPath_MethArgs[]={
  {&TA_const_taString_ref,NULL,"path",""},
  {&TA_MemberDef_ptr_ref,NULL,"ret_md","no_mdef"},
  {&TA_int,NULL,"start","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_New_MethArgs[]={
  {&TA_int,NULL,"no","0"},
  {&TA_TypeDef_ptr,NULL,"typ"," __null"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_StructUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DataUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CheckConfig_MethArgs[]={
  {&TA_bool,NULL,"quiet"," false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_InheritsFrom_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetEnumString_MethArgs[]={
  {&TA_const_taString_ref,NULL,"enum_tp_nm",""},
  {&TA_int,NULL,"enum_val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetEnumVal_MethArgs[]={
  {&TA_const_taString_ref,NULL,"enum_nm",""},
  {&TA_taString_ref,NULL,"enum_tp_nm"," no_name"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Load_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_void_ptr_ptr,NULL,"el"," __null"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Save_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SaveAs_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SaveAs_File_MethArgs[]={
  {&TA_const_taString_ref,NULL,"fname"," "},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReShowEdit_MethArgs[]={
  {&TA_bool,NULL,"force"," false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CopyFrom_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_from",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChangeMyType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SelectForEdit_MethArgs[]={
  {&TA_MemberDef_ptr,NULL,"member",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_taString_ref,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SelectFunForEdit_MethArgs[]={
  {&TA_MethodDef_ptr,NULL,"function",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_taString_ref,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CallFun_MethArgs[]={
  {&TA_const_taString_ref,NULL,"fun_name",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetAdapter_MethArgs[]={
  {&TA_taBaseAdapter_ptr,NULL,"adapter_",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Alloc_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BuildHashTable_MethArgs[]={
  {&TA_int,NULL,"n_buckets",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Find_MethArgs[]={
  {&TA_const_taString_ref,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Remove_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Move_MethArgs[]={
  {&TA_int,NULL,"from",""},
  {&TA_int,NULL,"to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Swap_MethArgs[]={
  {&TA_int,NULL,"pos1",""},
  {&TA_int,NULL,"pos2",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Sort_MethArgs[]={
  {&TA_bool,NULL,"descending","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Sort__MethArgs[]={
  {&TA_bool,NULL,"descending","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Duplicate_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DupeUniqNameNew_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DupeUniqNameOld_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Stealth_Borrow_MethArgs[]={
  {&TA_const_taPtrList_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Borrow_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUnique_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUniqNameNew_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUniqNameOld_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Common_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Duplicate_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Borrow_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_List_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm","cout"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Add_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUnique_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUniqNameNew_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Insert_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  {&TA_int,NULL,"where",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Replace_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","old_it",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"old_nm",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DuplicateEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Link_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUnique_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUniqNameNew_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_InsertLink_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  {&TA_int,NULL,"idx"," -1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLink_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLinkEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","old_it",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLinkName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"old_nm",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Push_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","from",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Transfer_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveBefore_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","trg",""},
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveAfter_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","trg",""},
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Dump_Save_PathR_impl_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultEl_MethArgs[]={
  {&TA_TAPtr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultElName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultElType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceSize_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceSameStru_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChangeType_MethArgs[]={
  {&TA_TAPtr,NULL,"itm",""},
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"old_type",""},
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetBaseType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeafEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveGp_MethArgs[]={
  {&TA_TAGPtr,NULL,"group",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceLeaves_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeaf_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Edit_El_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastLeafGp_MethArgs[]={
  {&TA_int,NULL,"gp_idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeLeafGp_MethArgs[]={
  {&TA_int,NULL,"gp_idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LastEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_PrevEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","__null"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","__null"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUniqNameOld_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUniqNameOld_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Weights_MethArgs[]={
  {&TA_const_Unit_Group_ptr,NULL,"src",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_WriteWeights_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReadWeights_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CheckBuild_MethArgs[]={
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LayoutUnits_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u"," __null"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"unitspec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"conspec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_TransformWeights_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"trans",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddNoiseToWeights_MethArgs[]={
  {&TA_const_Random_ref,NULL,"noise_spec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_PruneCons_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"pre_proc",""},
  {NULL,"CountParam::Relation","rel",""},
  {&TA_float,NULL,"cmp_val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LesionCons_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LesionUnits_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnitValuesToArray_MethArgs[]={
  {&TA_float_RArray_ref,NULL,"ary",""},
  {&TA_const_char_ptr,NULL,"variable",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnitValuesFromArray_MethArgs[]={
  {&TA_float_RArray_ref,NULL,"ary",""},
  {&TA_const_char_ptr,NULL,"variable",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindUnitFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodDef_data TA_LeabraUnit_Group_MethodDef[]={
  {&TA_void,NULL,"setDirty"," 'true' gets forwarded up; 'false' does nothing","CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_setDirty_stub,TA_LeabraUnit_Group_setDirty_MethArgs},
  {&TA_int,NULL,"GetIndex"," typically its index in an own List","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_GetIndex_stub,NULL},
  {&TA_bool,NULL,"SetFileName"," set file name for object","CAT_File ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SetFileName_stub,TA_LeabraUnit_Group_SetFileName_MethArgs},
  {&TA_taString,NULL,"GetFileName"," get file name object was last saved with","CAT_File ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_GetFileName_stub,NULL},
  {&TA_TAPtr,NULL,"GetOwner","","","",
    3,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_GetOwner_stub,TA_LeabraUnit_Group_GetOwner_MethArgs},
  {&TA_taString,NULL,"GetPath"," get path without name informtation, stop at par_stop if non-null","CAT_ObjectMgmt ","",
    0,2,0,1,0,NULL,cssElCFun_LeabraUnit_Group_GetPath_stub,TA_LeabraUnit_Group_GetPath_MethArgs},
  {&TA_TAPtr,NULL,"FindFromPath"," find object from path (starting from this, and position start of the path)","CAT_ObjectMgmt ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindFromPath_stub,TA_LeabraUnit_Group_FindFromPath_MethArgs},
  {&TA_TAPtr,NULL,"New"," Create n_objs objects of given type (type is optional) create n_objs new objects of given type","CAT_ObjectMgmt MENU MENU_ON_Object ARGC_0 UPDATE_MENUS NO_SCRIPT MENU_CONTEXT CAT_Modify ","",
    0,2,0,1,0,NULL,cssElCFun_LeabraUnit_Group_New_stub,TA_LeabraUnit_Group_New_MethArgs},
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script) we skip the taOBase version, and inherit only taBase","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAfterEdit_stub,NULL},
  {&TA_void,NULL,"UpdateAllViews"," called after data changes, to update views","CAT_Display ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAllViews_stub,NULL},
  {&TA_void,NULL,"StructUpdate"," bracket structural changes with (nestable) true/false calls;","CAT_ObjectMgmt ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_StructUpdate_stub,TA_LeabraUnit_Group_StructUpdate_MethArgs},
  {&TA_void,NULL,"DataUpdate"," bracket data value changes with (nestable) true/false calls;","CAT_ObjectMgmt ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_DataUpdate_stub,TA_LeabraUnit_Group_DataUpdate_MethArgs},
  {&TA_bool,NULL,"CheckConfig"," check the configuration of this object (false if not configed properly). typically called before running any major processing, enabling processing to assume things are configured correctly. quiet flag suppresses error messages","CAT_ObjectMgmt ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_CheckConfig_stub,TA_LeabraUnit_Group_CheckConfig_MethArgs},
  {&TA_void,NULL,"AddDataView"," add a dataview ","CAT_Display ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_AddDataView_stub,TA_LeabraUnit_Group_AddDataView_MethArgs},
  {&TA_bool,NULL,"RemoveDataView"," removes a dataview (not usually overridden)","CAT_Display ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveDataView_stub,TA_LeabraUnit_Group_RemoveDataView_MethArgs},
  {&TA_bool,NULL,"InheritsFrom"," does this inherit from given type?","CAT_ObjectMgmt ","",
    2,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_InheritsFrom_stub,TA_LeabraUnit_Group_InheritsFrom_MethArgs},
  {&TA_taString,NULL,"GetEnumString"," get the name corresponding to given enum value in enum type enum_tp_nm","CAT_ObjectMgmt ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_GetEnumString_stub,TA_LeabraUnit_Group_GetEnumString_MethArgs},
  {&TA_int,NULL,"GetEnumVal"," get the enum value corresponding to the given enum name (-1 if not found), and sets enum_tp_nm to name of type this enum belongs in (empty if not found)","CAT_ObjectMgmt ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_GetEnumVal_stub,TA_LeabraUnit_Group_GetEnumVal_MethArgs},
  {&TA_int,NULL,"Load"," Load object data from a file","MENU MENU_ON_Object ARGC_1 UPDATE_MENUS MENU_CONTEXT CAT_File ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraUnit_Group_Load_stub,TA_LeabraUnit_Group_Load_MethArgs},
  {&TA_int,NULL,"Save"," Save object data to a file","CAT_File ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraUnit_Group_Save_stub,TA_LeabraUnit_Group_Save_MethArgs},
  {&TA_int,NULL,"SaveAs"," Save object data to a new file","ARGC_1 CAT_File ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraUnit_Group_SaveAs_stub,TA_LeabraUnit_Group_SaveAs_MethArgs},
  {&TA_int,NULL,"Save_File"," saves the object to a file","MENU MENU_ON_Object LABEL_Save CAT_File ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Save_File_stub,NULL},
  {&TA_int,NULL,"SaveAs_File"," Saves object data to a new file","MENU ARGC_0 LABEL_Save_As CAT_File ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_SaveAs_File_stub,TA_LeabraUnit_Group_SaveAs_File_MethArgs},
  {&TA_int,NULL,"Edit"," Edit this object using the gui","MENU ARGC_0 MENU_ON_Object MENU_CONTEXT NO_SCRIPT CAT_Display ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Edit_stub,NULL},
  {&TA_bool,NULL,"ReShowEdit"," reshows any open edit dialogs for this object","CAT_Display ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_ReShowEdit_stub,TA_LeabraUnit_Group_ReShowEdit_MethArgs},
  {&TA_void,NULL,"CloseLater"," PERMANENTLY Destroy this object! This is not Iconify.","MENU CONFIRM NO_REVERT_AFTER LABEL_Close_(Destroy) NO_MENU_CONTEXT CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_CloseLater_stub,NULL},
  {&TA_bool,NULL,"CopyFrom"," Copy from given object into this object","MENU MENU_ON_Object MENU_SEP_BEFORE TYPE_ON_this NO_SCOPE UPDATE_MENUS CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_CopyFrom_stub,TA_LeabraUnit_Group_CopyFrom_MethArgs},
  {&TA_bool,NULL,"CopyTo"," Copy to given object from this object","MENU TYPE_ON_this NO_SCOPE UPDATE_MENUS CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_CopyTo_stub,TA_LeabraUnit_Group_CopyTo_MethArgs},
  {&TA_bool,NULL,"DuplicateMe"," Make another copy of myself (done through owner)","MENU CONFIRM UPDATE_MENUS CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_DuplicateMe_stub,NULL},
  {&TA_bool,NULL,"ChangeMyType"," Change me into a different type of object, copying current info (done through owner)","MENU TYPE_this UPDATE_MENUS CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ChangeMyType_stub,TA_LeabraUnit_Group_ChangeMyType_MethArgs},
  {&TA_bool,NULL,"SelectForEdit"," select a given member for editing --\n if already on dialog, removes it & returns false (else true)","MENU CAT_Display ","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SelectForEdit_stub,TA_LeabraUnit_Group_SelectForEdit_MethArgs},
  {&TA_bool,NULL,"SelectFunForEdit"," select a given function (method) for calling in a select edit dialog --\nif already on dialog, removes it & returns false (else true)","MENU CAT_Display ","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SelectFunForEdit_stub,TA_LeabraUnit_Group_SelectFunForEdit_MethArgs},
  {&TA_void,NULL,"Help"," get help on using this object","MENU CAT_Display ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Help_stub,NULL},
  {&TA_void,NULL,"CallFun"," call function of given name on this object, prompting for args using gui interface","CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_CallFun_stub,TA_LeabraUnit_Group_CallFun_MethArgs},
  {&TA_void,NULL,"SetAdapter","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_SetAdapter_stub,TA_LeabraUnit_Group_SetAdapter_MethArgs},
  {&TA_void,NULL,"Alloc"," allocate a list big enough for given number of elements (or current size)","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Alloc_stub,TA_LeabraUnit_Group_Alloc_MethArgs},
  {&TA_void,NULL,"Reset"," reset the list (remove all elements)","CAT_Modify ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Reset_stub,NULL},
  {&TA_bool,NULL,"IsEmpty"," is the list empty of elements (i.e., size == 0)","CAT_Access ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_IsEmpty_stub,NULL},
  {&TA_void,NULL,"BuildHashTable"," build a hash table with given number of buckets (not dynamic, so make it big)","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_BuildHashTable_stub,TA_LeabraUnit_Group_BuildHashTable_MethArgs},
  {&TA_int,NULL,"Find","","","",
    4,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Find_stub,TA_LeabraUnit_Group_Find_MethArgs},
  {&TA_bool,NULL,"Remove"," Remove object at given index on list","","",
    7,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Remove_stub,TA_LeabraUnit_Group_Remove_MethArgs},
  {&TA_bool,NULL,"RemoveName"," remove given named element from list (if on list)","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveName_stub,TA_LeabraUnit_Group_RemoveName_MethArgs},
  {&TA_bool,NULL,"RemoveLast"," remove the last element on the list","CAT_Modify ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLast_stub,NULL},
  {&TA_void,NULL,"RemoveAll"," Remove all elements on the list Remove all elements of the group","MENU MENU_ON_Edit CONFIRM UPDATE_MENUS CAT_Modify ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveAll_stub,NULL},
  {&TA_bool,NULL,"Move"," Move element from (from) to position (to) in list","CAT_Modify ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Move_stub,TA_LeabraUnit_Group_Move_MethArgs},
  {&TA_bool,NULL,"Swap"," Swap the elements in the two given positions on the list","CAT_Modify ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Swap_stub,TA_LeabraUnit_Group_Swap_MethArgs},
  {&TA_void,NULL,"PopAll"," pop all elements off the stack","CAT_Modify ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_PopAll_stub,NULL},
  {&TA_void,NULL,"Permute"," permute the items in the list into a random order","MENU CONFIRM UPDATE_MENUS CAT_Order ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Permute_stub,NULL},
  {&TA_void,NULL,"Sort"," sort the items in the list in alpha order according to name (or El_Compare_)","MENU CONFIRM UPDATE_MENUS CAT_Order ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_Sort_stub,TA_LeabraUnit_Group_Sort_MethArgs},
  {&TA_void,NULL,"Sort_"," implementation of sorting function","","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_Sort__stub,TA_LeabraUnit_Group_Sort__MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FirstEl"," returns first leaf element and inits indexes","CAT_Access ","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_FirstEl_stub,TA_LeabraUnit_Group_FirstEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","NextEl"," returns next leaf element and incs indexes","CAT_Access ","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_NextEl_stub,TA_LeabraUnit_Group_NextEl_MethArgs},
  {&TA_void,NULL,"Duplicate","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Duplicate_stub,TA_LeabraUnit_Group_Duplicate_MethArgs},
  {&TA_void,NULL,"DupeUniqNameNew","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_DupeUniqNameNew_stub,TA_LeabraUnit_Group_DupeUniqNameNew_MethArgs},
  {&TA_void,NULL,"DupeUniqNameOld","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_DupeUniqNameOld_stub,TA_LeabraUnit_Group_DupeUniqNameOld_MethArgs},
  {&TA_void,NULL,"Stealth_Borrow"," borrow without referencing the borrowed elements (i.e. use AddEl_())","CAT_Copy ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Stealth_Borrow_stub,TA_LeabraUnit_Group_Stealth_Borrow_MethArgs},
  {&TA_void,NULL,"Borrow","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Borrow_stub,TA_LeabraUnit_Group_Borrow_MethArgs},
  {&TA_void,NULL,"BorrowUnique","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUnique_stub,TA_LeabraUnit_Group_BorrowUnique_MethArgs},
  {&TA_void,NULL,"BorrowUniqNameNew","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUniqNameNew_stub,TA_LeabraUnit_Group_BorrowUniqNameNew_MethArgs},
  {&TA_void,NULL,"BorrowUniqNameOld","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUniqNameOld_stub,TA_LeabraUnit_Group_BorrowUniqNameOld_MethArgs},
  {&TA_void,NULL,"Copy_Common","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Common_stub,TA_LeabraUnit_Group_Copy_Common_MethArgs},
  {&TA_void,NULL,"Copy_Duplicate","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Duplicate_stub,TA_LeabraUnit_Group_Copy_Duplicate_MethArgs},
  {&TA_void,NULL,"Copy_Borrow","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Borrow_stub,TA_LeabraUnit_Group_Copy_Borrow_MethArgs},
  {&TA_void,NULL,"List"," List the group items Display list of elements in the group","CAT_Display ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_List_stub,TA_LeabraUnit_Group_List_MethArgs},
  {&TA_int,NULL,"FindEl"," find given element in list (-1 if not there)","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindEl_stub,TA_LeabraUnit_Group_FindEl_MethArgs},
  {&TA_void,NULL,"AddEl"," append a new pointer to end of list","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_AddEl_stub,TA_LeabraUnit_Group_AddEl_MethArgs},
  {&TA_void,NULL,"Add"," add element to the list and 'own' item","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Add_stub,TA_LeabraUnit_Group_Add_MethArgs},
  {&TA_bool,NULL,"AddUnique"," add so that object is unique, true if unique","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_AddUnique_stub,TA_LeabraUnit_Group_AddUnique_MethArgs},
  {&TA_bool,NULL,"AddUniqNameNew"," add so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_AddUniqNameNew_stub,TA_LeabraUnit_Group_AddUniqNameNew_MethArgs},
  {&TA_bool,NULL,"Insert"," insert element at index (-1 for end)","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Insert_stub,TA_LeabraUnit_Group_Insert_MethArgs},
  {&TA_bool,NULL,"Replace"," replace element at index with the new one","","",
    2,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Replace_stub,TA_LeabraUnit_Group_Replace_MethArgs},
  {&TA_bool,NULL,"ReplaceEl"," replace given element with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceEl_stub,TA_LeabraUnit_Group_ReplaceEl_MethArgs},
  {&TA_bool,NULL,"ReplaceName"," replace named element with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceName_stub,TA_LeabraUnit_Group_ReplaceName_MethArgs},
  {&TA_bool,NULL,"RemoveEl"," Remove given item from the list","","",
    1,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveEl_stub,TA_LeabraUnit_Group_RemoveEl_MethArgs},
  {&TA_bool,NULL,"DuplicateEl"," Duplicate given list item and Add to list","MENU ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_DuplicateEl_stub,TA_LeabraUnit_Group_DuplicateEl_MethArgs},
  {&TA_void,NULL,"Link"," Link an item to list without owning it","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Link_stub,TA_LeabraUnit_Group_Link_MethArgs},
  {&TA_bool,NULL,"LinkUnique"," link so that object is unique, true if unique","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUnique_stub,TA_LeabraUnit_Group_LinkUnique_MethArgs},
  {&TA_bool,NULL,"LinkUniqNameNew"," link so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUniqNameNew_stub,TA_LeabraUnit_Group_LinkUniqNameNew_MethArgs},
  {&TA_bool,NULL,"InsertLink"," Insert a link at index (-1 for end)","MENU LABEL_Link UPDATE_MENUS ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_InsertLink_stub,TA_LeabraUnit_Group_InsertLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLink"," replace element with a link to the new one","","",
    2,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLink_stub,TA_LeabraUnit_Group_ReplaceLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkEl"," replace given element (if on list) with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLinkEl_stub,TA_LeabraUnit_Group_ReplaceLinkEl_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkName"," replace given named element (if on list) with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLinkName_stub,TA_LeabraUnit_Group_ReplaceLinkName_MethArgs},
  {&TA_void,NULL,"Push"," push item on stack (for temporary use, not 'owned')","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Push_stub,TA_LeabraUnit_Group_Push_MethArgs},
  {&TA_bool,NULL,"MoveEl"," Move item (from) to position of (to)","MENU LABEL_Move ARG_ON_OBJ UPDATE_MENUS ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_MoveEl_stub,TA_LeabraUnit_Group_MoveEl_MethArgs},
  {&TA_bool,NULL,"Transfer"," Transfer element to this list","MENU MENU_ON_Edit NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Transfer_stub,TA_LeabraUnit_Group_Transfer_MethArgs},
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list","CAT_Modify ","",
    1,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_MoveBefore_stub,TA_LeabraUnit_Group_MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list","CAT_Modify ","",
    1,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_MoveAfter_stub,TA_LeabraUnit_Group_MoveAfter_MethArgs},
  {&TA_int,NULL,"Dump_Save_PathR_impl","","","",
    0,3,1,1,0,NULL,cssElCFun_LeabraUnit_Group_Dump_Save_PathR_impl_stub,TA_LeabraUnit_Group_Dump_Save_PathR_impl_MethArgs},
  {&TA_int,NULL,"SetDefaultEl"," set the default element to be given item","","",
    2,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultEl_stub,TA_LeabraUnit_Group_SetDefaultEl_MethArgs},
  {&TA_int,NULL,"SetDefaultElName"," set the default element to be item with given name","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultElName_stub,TA_LeabraUnit_Group_SetDefaultElName_MethArgs},
  {&TA_int,NULL,"SetDefaultElType"," set the default element to be item with given type","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultElType_stub,TA_LeabraUnit_Group_SetDefaultElType_MethArgs},
  {&TA_void,NULL,"EnforceSize"," add or remove elements to force list to be of given size","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceSize_stub,TA_LeabraUnit_Group_EnforceSize_MethArgs},
  {&TA_void,NULL,"EnforceType"," enforce current type (all elements have to be of this type)","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceType_stub,NULL},
  {&TA_void,NULL,"EnforceSameStru"," enforce this group to have same structure as cp","CAT_Modify ","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_EnforceSameStru_stub,TA_LeabraUnit_Group_EnforceSameStru_MethArgs},
  {&TA_bool,NULL,"ChangeType"," change type of item to new type, copying current info","MENU MENU_ON_Object UPDATE_MENUS ARG_ON_OBJ TYPE_ON_el_base ","",
    1,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ChangeType_stub,TA_LeabraUnit_Group_ChangeType_MethArgs},
  {&TA_int,NULL,"ReplaceType"," replace all items of old type with new type (returns number changed)","MENU MENU_ON_Object USE_RVAL UPDATE_MENUS TYPE_ON_el_base ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceType_stub,TA_LeabraUnit_Group_ReplaceType_MethArgs},
  {&TA_void,NULL,"SetBaseType"," set base (and default) type to given td","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_SetBaseType_stub,TA_LeabraUnit_Group_SetBaseType_MethArgs},
  {&TA_MemberDef_ptr,NULL,"ReturnFindMd"," return the find_md variable, initialized if necessary","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_ReturnFindMd_stub,NULL},
  {&TA_bool,NULL,"IsRoot"," 'true' if this is the root","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_IsRoot_stub,NULL},
  {&TA_void,NULL,"InitLeafGp"," Initialize the leaf group iter list, always ok to call","CAT_Access ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_InitLeafGp_stub,NULL},
  {&TA_bool,NULL,"RemoveLeaf"," Remove leaf element at leaf index","CAT_Modify ","",
    2,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeaf_stub,TA_LeabraUnit_Group_RemoveLeaf_MethArgs},
  {&TA_bool,NULL,"RemoveLeafName"," remove given named leaf element","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeafName_stub,TA_LeabraUnit_Group_RemoveLeafName_MethArgs},
  {&TA_bool,NULL,"RemoveLeafEl"," Remove given leaf element","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeafEl_stub,TA_LeabraUnit_Group_RemoveLeafEl_MethArgs},
  {&TA_bool,NULL,"RemoveGp"," remove given group","MENU FROM_GROUP_gp MENU_ON_Edit UPDATE_MENUS CAT_Modify ","",
    1,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveGp_stub,TA_LeabraUnit_Group_RemoveGp_MethArgs},
  {&TA_TALOG_ptr,NULL,"EditSubGps"," edit the list of sub-groups (e.g., so you can move around subgroups)","MENU USE_RVAL CAT_Access ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_EditSubGps_stub,NULL},
  {&TA_void,NULL,"EnforceLeaves"," ensure that sz leaves exits by adding new ones to top group and removing old ones from end","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceLeaves_stub,TA_LeabraUnit_Group_EnforceLeaves_MethArgs},
  {&TA_int,NULL,"FindLeaf"," find named leaf element","CAT_Access ","",
    2,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeaf_stub,TA_LeabraUnit_Group_FindLeaf_MethArgs},
  {&TA_int,NULL,"FindLeafEl"," find given leaf element -1 = not here.","CAT_Access ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafEl_stub,TA_LeabraUnit_Group_FindLeafEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","SafeEl"," get element at index","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_SafeEl_stub,TA_LeabraUnit_Group_SafeEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FastEl"," fast element (no checking)","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_FastEl_stub,TA_LeabraUnit_Group_FastEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","DefaultEl"," returns the element specified as the default for this group","CAT_Access ","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_DefaultEl_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Edit_El_stub,TA_LeabraUnit_Group_Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_SafeGp_stub,TA_LeabraUnit_Group_SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_FastGp_stub,TA_LeabraUnit_Group_FastGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastLeafGp"," the leaf sub group at index, note: 0 is always 'this'","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_FastLeafGp_stub,TA_LeabraUnit_Group_FastLeafGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeLeafGp"," the leaf sub group at index, note: 0 is always 'this'","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_SafeLeafGp_stub,TA_LeabraUnit_Group_SafeLeafGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","Leaf"," get leaf element at index","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Leaf_stub,TA_LeabraUnit_Group_Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"RootGp"," the root group ('this' for the root group)","CAT_Access ","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_RootGp_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","LastEl"," returns first leaf element and inits indexes","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_LastEl_stub,TA_LeabraUnit_Group_LastEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","PrevEl"," returns next leaf element and incs indexes","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_PrevEl_stub,TA_LeabraUnit_Group_PrevEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_FirstGp_stub,TA_LeabraUnit_Group_FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","CAT_Access ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_NextGp_stub,TA_LeabraUnit_Group_NextGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","NewEl"," Create and add (n_els) new element(s) of given type","CAT_Modify ","",
    0,2,0,1,0,NULL,cssElCFun_LeabraUnit_Group_NewEl_stub,TA_LeabraUnit_Group_NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","CAT_Modify ","",
    0,2,0,1,0,NULL,cssElCFun_LeabraUnit_Group_NewGp_stub,TA_LeabraUnit_Group_NewGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","CAT_Access ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindName_stub,TA_LeabraUnit_Group_FindName_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindType"," find given type element (NULL = not here), sets idx","CAT_Access ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindType_stub,TA_LeabraUnit_Group_FindType_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","Pop"," pop the last element off the stack","CAT_Modify ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Pop_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","Peek"," peek at the last element on the stack","CAT_Access ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Peek_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_AddUniqNameOld_stub,TA_LeabraUnit_Group_AddUniqNameOld_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","CAT_Modify ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUniqNameOld_stub,TA_LeabraUnit_Group_LinkUniqNameOld_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindLeafName"," Find element with given name (el_nm)","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find CAT_Access ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafName_stub,TA_LeabraUnit_Group_FindLeafName_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","CAT_Access ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafType_stub,TA_LeabraUnit_Group_FindLeafType_MethArgs},
  {&TA_void,NULL,"Copy_Weights"," copies weights from other unit group (incl wts assoc with unit bias member)","MENU MENU_ON_Object ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Weights_stub,TA_LeabraUnit_Group_Copy_Weights_MethArgs},
  {&TA_void,NULL,"WriteWeights"," write weight values out in a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_WriteWeights_stub,TA_LeabraUnit_Group_WriteWeights_MethArgs},
  {&TA_void,NULL,"ReadWeights"," read weight values in from a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_ReadWeights_stub,TA_LeabraUnit_Group_ReadWeights_MethArgs},
  {&TA_bool,NULL,"Build"," for subgroups: build units to specs (true if changed)","MENU MENU_ON_Actions ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_Build_stub,NULL},
  {&TA_bool,NULL,"CheckBuild"," check if network is built ","","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_CheckBuild_stub,TA_LeabraUnit_Group_CheckBuild_MethArgs},
  {&TA_void,NULL,"LayoutUnits"," for subgroups: redistribute units within the given geometry of the group","","",
    0,1,0,1,0,NULL,cssElCFun_LeabraUnit_Group_LayoutUnits_stub,TA_LeabraUnit_Group_LayoutUnits_MethArgs},
  {&TA_void,NULL,"RecomputeGeometry"," re compute geometry based on parent layer","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_RecomputeGeometry_stub,NULL},
  {&TA_bool,NULL,"SetUnitSpec"," set for all units in group","MENU MENU_SEP_BEFORE ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SetUnitSpec_stub,TA_LeabraUnit_Group_SetUnitSpec_MethArgs},
  {&TA_bool,NULL,"SetConSpec"," set for all unit's connections in group","MENU ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_SetConSpec_stub,TA_LeabraUnit_Group_SetConSpec_MethArgs},
  {&TA_void,NULL,"TransformWeights"," apply given transformation to weights","MENU MENU_SEP_BEFORE ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_TransformWeights_stub,TA_LeabraUnit_Group_TransformWeights_MethArgs},
  {&TA_void,NULL,"AddNoiseToWeights"," add noise to weights using given noise specification","MENU ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_AddNoiseToWeights_stub,TA_LeabraUnit_Group_AddNoiseToWeights_MethArgs},
  {&TA_int,NULL,"PruneCons"," remove weights that (after pre-proc) meet relation to compare val","MENU USE_RVAL ","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_PruneCons_stub,TA_LeabraUnit_Group_PruneCons_MethArgs},
  {&TA_int,NULL,"LesionCons"," remove connections with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_LesionCons_stub,TA_LeabraUnit_Group_LesionCons_MethArgs},
  {&TA_int,NULL,"LesionUnits"," remove units with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraUnit_Group_LesionUnits_stub,TA_LeabraUnit_Group_LesionUnits_MethArgs},
  {&TA_void,NULL,"UnitValuesToArray"," adds values of variable from the units into the given array","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_UnitValuesToArray_stub,TA_LeabraUnit_Group_UnitValuesToArray_MethArgs},
  {&TA_void,NULL,"UnitValuesFromArray"," sets unit values from values in the given array","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraUnit_Group_UnitValuesFromArray_stub,TA_LeabraUnit_Group_UnitValuesFromArray_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmCoord"," returns unit at given coordinates within layer","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_FindUnitFmCoord_stub,TA_LeabraUnit_Group_FindUnitFmCoord_MethArgs},
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_SetVals_stub,TA_LeabraUnit_Group_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_InitState_stub,TA_LeabraUnit_Group_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_Copy__stub,TA_LeabraUnit_Group_Inhib_Copy__MethArgs},
  NULL};
static int LeabraLayer::* TA_LeabraLayer_MbrOff;
static MemberDef_data TA_LeabraLayer_MemberDef[]={
  {&TA_LeabraLayerSpec_SPtr,NULL,"spec"," the spec for this layer: controls all functions of layer","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::spec))),0,NULL,0},
  {&TA_float,NULL,"stm_gain"," actual stim gain for soft clamping, can be incremented to ensure clamped units active","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::stm_gain))),0,NULL,0},
  {&TA_bool,NULL,"hard_clamped"," this layer is actually hard clamped","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::hard_clamped))),0,NULL,0},
  {&TA_int,NULL,"prv_phase"," previous phase value (needed for 2nd plus phases and the like)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::prv_phase))),0,NULL,0},
  {&TA_float,NULL,"dav"," dopamine-like modulatory value (where applicable)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::dav))),0,NULL,0},
  {&TA_float,NULL,"net_rescale"," computed netinput rescaling factor (updated by net_rescale)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::net_rescale))),0,NULL,0},
  {&TA_int,NULL,"da_updt"," true if da triggered an update (either + to store or - reset)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::da_updt))),0,NULL,0},
  {&TA_int_Array,NULL,"misc_iar"," misc int array of data","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::misc_iar))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraLayer_setDirty_MethArgs[]={
  {&TA_bool,NULL,"value",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetFileName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetOwner_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"tp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetPath_MethArgs[]={
  {&TA_TAPtr,NULL,"ta","__null"},
  {&TA_TAPtr,NULL,"par_stop","__null"},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindFromPath_MethArgs[]={
  {&TA_const_taString_ref,NULL,"path",""},
  {&TA_MemberDef_ptr_ref,NULL,"ret_md","no_mdef"},
  {&TA_int,NULL,"start","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_New_MethArgs[]={
  {&TA_int,NULL,"n_objs","0"},
  {&TA_TypeDef_ptr,NULL,"type","__null"},
  NULL};
static MethodArgs_data TA_LeabraLayer_StructUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DataUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CheckConfig_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_AddDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_RemoveDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_InheritsFrom_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetEnumString_MethArgs[]={
  {&TA_const_taString_ref,NULL,"enum_tp_nm",""},
  {&TA_int,NULL,"enum_val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetEnumVal_MethArgs[]={
  {&TA_const_taString_ref,NULL,"enum_nm",""},
  {&TA_taString_ref,NULL,"enum_tp_nm"," no_name"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Load_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_void_ptr_ptr,NULL,"el"," __null"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Save_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SaveAs_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","__null"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SaveAs_File_MethArgs[]={
  {&TA_const_taString_ref,NULL,"fname"," "},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReShowEdit_MethArgs[]={
  {&TA_bool,NULL,"force"," false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_CopyFrom_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_from",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_to",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ChangeMyType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SelectForEdit_MethArgs[]={
  {&TA_MemberDef_ptr,NULL,"member",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_taString_ref,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SelectFunForEdit_MethArgs[]={
  {&TA_MethodDef_ptr,NULL,"function",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_taString_ref,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CallFun_MethArgs[]={
  {&TA_const_taString_ref,NULL,"fun_name",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetAdapter_MethArgs[]={
  {&TA_taBaseAdapter_ptr,NULL,"adapter_",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Copy_Weights_MethArgs[]={
  {&TA_const_Layer_ptr,NULL,"src",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_WriteWeights_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReadWeights_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LayoutUnits_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u","__null"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ConnectFrom_MethArgs[]={
  {&TA_Layer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CheckBuild_MethArgs[]={
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_CheckConnect_MethArgs[]={
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Send_NetToLay_MethArgs[]={
  {&TA_Layer_ptr,NULL,"tolay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Act_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_TransformWeights_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"trans",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_AddNoiseToWeights_MethArgs[]={
  {&TA_const_Random_ref,NULL,"noise_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PruneCons_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"pre_proc",""},
  {NULL,"CountParam::Relation","rel",""},
  {&TA_float,NULL,"cmp_val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ProbAddCons_MethArgs[]={
  {&TA_float,NULL,"p_add_con",""},
  {&TA_float,NULL,"init_wt"," 0.0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LesionCons_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LesionUnits_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetLayerSpec_MethArgs[]={
  {&TA_LayerSpec_ptr,NULL,"sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"unitspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetUnitType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"td",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"conspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"old_sp",""},
  {&TA_UnitSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"old_sp",""},
  {&TA_ConSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplacePrjnSpec_MethArgs[]={
  {&TA_ProjectionSpec_ptr,NULL,"old_sp",""},
  {&TA_ProjectionSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceLayerSpec_MethArgs[]={
  {&TA_LayerSpec_ptr,NULL,"old_sp",""},
  {&TA_LayerSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_WeightsToTable_MethArgs[]={
  {&TA_DataTable_ptr,NULL,"dt",""},
  {&TA_Layer_ptr,NULL,"send_lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetExtFlag_MethArgs[]={
  {&TA_int,NULL,"flg",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_UnSetExtFlag_MethArgs[]={
  {&TA_int,NULL,"flg",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ApplyExternal_MethArgs[]={
  {&TA_taMatrix_ptr,NULL,"data",""},
  {NULL,"Unit::ExtType","ext_flags"," Unit::NO_EXTERNAL"},
  {&TA_Random_ptr,NULL,"ran"," __null"},
  {&TA_const_PosTwoDCoord_ptr,NULL,"offset"," __null"},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitFmGpCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"gp_coord",""},
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitGpFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetActGeomNoSpc_MethArgs[]={
  {&TA_PosTDCoord_ref,NULL,"nospc_geom",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetCurLrate_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_NetScale_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Init_ClampNet_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Send_ClampNet_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Inhib_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_LayInhibToGps_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PhaseInit_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayEvent_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayPhase_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayPhase2_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ExtToComp_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_TargExtToComp_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PostSettle_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_LeabraLayer_MethodDef[]={
  {&TA_void,NULL,"setDirty"," 'true' gets forwarded up; 'false' does nothing","CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_setDirty_stub,TA_LeabraLayer_setDirty_MethArgs},
  {&TA_int,NULL,"GetIndex"," typically its index in an own List","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_GetIndex_stub,NULL},
  {&TA_bool,NULL,"SetFileName"," set file name for object","CAT_File ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_SetFileName_stub,TA_LeabraLayer_SetFileName_MethArgs},
  {&TA_taString,NULL,"GetFileName"," get file name object was last saved with","CAT_File ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_GetFileName_stub,NULL},
  {&TA_TAPtr,NULL,"GetOwner","","","",
    3,1,-1,0,0,NULL,cssElCFun_LeabraLayer_GetOwner_stub,TA_LeabraLayer_GetOwner_MethArgs},
  {&TA_taString,NULL,"GetPath"," get path without name informtation, stop at par_stop if non-null","CAT_ObjectMgmt ","",
    0,2,0,1,0,NULL,cssElCFun_LeabraLayer_GetPath_stub,TA_LeabraLayer_GetPath_MethArgs},
  {&TA_TAPtr,NULL,"FindFromPath"," find object from path (starting from this, and position start of the path)","CAT_ObjectMgmt ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraLayer_FindFromPath_stub,TA_LeabraLayer_FindFromPath_MethArgs},
  {&TA_TAPtr,NULL,"New"," Create n_objs objects of given type (type is optional)","CAT_ObjectMgmt ","",
    0,2,0,1,0,NULL,cssElCFun_LeabraLayer_New_stub,TA_LeabraLayer_New_MethArgs},
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script) reset sort_buf after any edits..","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_UpdateAfterEdit_stub,NULL},
  {&TA_void,NULL,"UpdateAllViews"," called after data changes, to update views","CAT_Display ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_UpdateAllViews_stub,NULL},
  {&TA_void,NULL,"StructUpdate"," bracket structural changes with (nestable) true/false calls;","CAT_ObjectMgmt ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_StructUpdate_stub,TA_LeabraLayer_StructUpdate_MethArgs},
  {&TA_void,NULL,"DataUpdate"," bracket data value changes with (nestable) true/false calls;","CAT_ObjectMgmt ","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_DataUpdate_stub,TA_LeabraLayer_DataUpdate_MethArgs},
  {&TA_bool,NULL,"CheckConfig","","","",
    2,2,1,0,0,NULL,cssElCFun_LeabraLayer_CheckConfig_stub,TA_LeabraLayer_CheckConfig_MethArgs},
  {&TA_void,NULL,"AddDataView"," add a dataview ","CAT_Display ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_AddDataView_stub,TA_LeabraLayer_AddDataView_MethArgs},
  {&TA_bool,NULL,"RemoveDataView"," removes a dataview (not usually overridden)","CAT_Display ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_RemoveDataView_stub,TA_LeabraLayer_RemoveDataView_MethArgs},
  {&TA_bool,NULL,"InheritsFrom"," does this inherit from given type?","CAT_ObjectMgmt ","",
    2,1,-1,0,0,NULL,cssElCFun_LeabraLayer_InheritsFrom_stub,TA_LeabraLayer_InheritsFrom_MethArgs},
  {&TA_taString,NULL,"GetEnumString"," get the name corresponding to given enum value in enum type enum_tp_nm","CAT_ObjectMgmt ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayer_GetEnumString_stub,TA_LeabraLayer_GetEnumString_MethArgs},
  {&TA_int,NULL,"GetEnumVal"," get the enum value corresponding to the given enum name (-1 if not found), and sets enum_tp_nm to name of type this enum belongs in (empty if not found)","CAT_ObjectMgmt ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraLayer_GetEnumVal_stub,TA_LeabraLayer_GetEnumVal_MethArgs},
  {&TA_int,NULL,"Load"," Load object data from a file","MENU MENU_ON_Object ARGC_1 UPDATE_MENUS MENU_CONTEXT CAT_File ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraLayer_Load_stub,TA_LeabraLayer_Load_MethArgs},
  {&TA_int,NULL,"Save"," Save object data to a file","CAT_File ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraLayer_Save_stub,TA_LeabraLayer_Save_MethArgs},
  {&TA_int,NULL,"SaveAs"," Save object data to a new file","ARGC_1 CAT_File ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraLayer_SaveAs_stub,TA_LeabraLayer_SaveAs_MethArgs},
  {&TA_int,NULL,"Save_File"," saves the object to a file","MENU MENU_ON_Object LABEL_Save CAT_File ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Save_File_stub,NULL},
  {&TA_int,NULL,"SaveAs_File"," Saves object data to a new file","MENU ARGC_0 LABEL_Save_As CAT_File ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraLayer_SaveAs_File_stub,TA_LeabraLayer_SaveAs_File_MethArgs},
  {&TA_int,NULL,"Edit"," Edit this object using the gui","MENU ARGC_0 MENU_ON_Object MENU_CONTEXT NO_SCRIPT CAT_Display ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Edit_stub,NULL},
  {&TA_bool,NULL,"ReShowEdit"," reshows any open edit dialogs for this object","CAT_Display ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraLayer_ReShowEdit_stub,TA_LeabraLayer_ReShowEdit_MethArgs},
  {&TA_void,NULL,"CloseLater"," PERMANENTLY Destroy this object! This is not Iconify.","MENU CONFIRM NO_REVERT_AFTER LABEL_Close_(Destroy) NO_MENU_CONTEXT CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_CloseLater_stub,NULL},
  {&TA_bool,NULL,"CopyFrom"," Copy from given object into this object","MENU MENU_ON_Object MENU_SEP_BEFORE TYPE_ON_this NO_SCOPE UPDATE_MENUS CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_CopyFrom_stub,TA_LeabraLayer_CopyFrom_MethArgs},
  {&TA_bool,NULL,"CopyTo"," Copy to given object from this object","MENU TYPE_ON_this NO_SCOPE UPDATE_MENUS CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_CopyTo_stub,TA_LeabraLayer_CopyTo_MethArgs},
  {&TA_bool,NULL,"DuplicateMe"," Make another copy of myself (done through owner)","MENU CONFIRM UPDATE_MENUS CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_DuplicateMe_stub,NULL},
  {&TA_bool,NULL,"ChangeMyType"," Change me into a different type of object, copying current info (done through owner)","MENU TYPE_this UPDATE_MENUS CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_ChangeMyType_stub,TA_LeabraLayer_ChangeMyType_MethArgs},
  {&TA_bool,NULL,"SelectForEdit"," select a given member for editing --\n if already on dialog, removes it & returns false (else true)","MENU CAT_Display ","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayer_SelectForEdit_stub,TA_LeabraLayer_SelectForEdit_MethArgs},
  {&TA_bool,NULL,"SelectFunForEdit"," select a given function (method) for calling in a select edit dialog --\nif already on dialog, removes it & returns false (else true)","MENU CAT_Display ","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayer_SelectFunForEdit_stub,TA_LeabraLayer_SelectFunForEdit_MethArgs},
  {&TA_void,NULL,"Help"," get help on using this object","MENU CAT_Display ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Help_stub,NULL},
  {&TA_void,NULL,"CallFun"," call function of given name on this object, prompting for args using gui interface","CAT_ObjectMgmt ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_CallFun_stub,TA_LeabraLayer_CallFun_MethArgs},
  {&TA_void,NULL,"SetAdapter","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_SetAdapter_stub,TA_LeabraLayer_SetAdapter_MethArgs},
  {&TA_int,NULL,"numUnits"," count of N units, regardless of geom","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_numUnits_stub,NULL},
  {&TA_bool,NULL,"isSparse"," true if N units doesn't fit evenly into geom or 4-d geom","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_isSparse_stub,NULL},
  {&TA_bool,NULL,"uses_groups","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_uses_groups_stub,NULL},
  {&TA_ProjectBase_ptr,NULL,"project"," this layer's project","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_project_stub,NULL},
  {&TA_void,NULL,"Copy_Weights"," copies weights from other layer (incl wts assoc with unit bias member)","MENU MENU_ON_Object MENU_SEP_BEFORE ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_Copy_Weights_stub,TA_LeabraLayer_Copy_Weights_MethArgs},
  {&TA_void,NULL,"WriteWeights"," write weight values out in a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraLayer_WriteWeights_stub,TA_LeabraLayer_WriteWeights_MethArgs},
  {&TA_void,NULL,"ReadWeights"," read weight values in from a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraLayer_ReadWeights_stub,TA_LeabraLayer_ReadWeights_MethArgs},
  {&TA_void,NULL,"Build"," build the units based on n_units, geom","MENU MENU_ON_Actions CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Build_stub,NULL},
  {&TA_void,NULL,"RecomputeGeometry"," recompute the layer's geometry specifcations","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_RecomputeGeometry_stub,NULL},
  {&TA_void,NULL,"LayoutUnits"," layout the units according to layer geometry","ARGC_0 ","",
    0,1,0,1,0,NULL,cssElCFun_LeabraLayer_LayoutUnits_stub,TA_LeabraLayer_LayoutUnits_MethArgs},
  {&TA_void,NULL,"LayoutUnitGroups"," layout the unit groups according to layer group geometry and spacing","MENU CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_LayoutUnitGroups_stub,NULL},
  {&TA_void,NULL,"ConnectFrom"," connect one or more other layers to this layer","DYN12N ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_ConnectFrom_stub,TA_LeabraLayer_ConnectFrom_MethArgs},
  {&TA_void,NULL,"Connect"," connect the layer","MENU CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Connect_stub,NULL},
  {&TA_bool,NULL,"CheckBuild"," check if network is built ","","",
    0,1,0,1,0,NULL,cssElCFun_LeabraLayer_CheckBuild_stub,TA_LeabraLayer_CheckBuild_MethArgs},
  {&TA_bool,NULL,"CheckConnect"," check if network is connected","","",
    0,1,0,1,0,NULL,cssElCFun_LeabraLayer_CheckConnect_stub,TA_LeabraLayer_CheckConnect_MethArgs},
  {&TA_void,NULL,"RemoveCons"," remove all connections in this layer","MENU CONFIRM MENU_SEP_BEFORE ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_RemoveCons_stub,NULL},
  {&TA_void,NULL,"RemoveUnits"," remove all units in this layer (preserving groups)","MENU DYN1 ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_RemoveUnits_stub,NULL},
  {&TA_void,NULL,"RemoveUnitGroups"," remove all unit groups in this layer","MENU DYN1 ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_RemoveUnitGroups_stub,NULL},
  {&TA_void,NULL,"PreConnect"," prepare to connect the layer (create con_groups)","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_PreConnect_stub,NULL},
  {&TA_void,NULL,"SyncSendPrjns"," synchronize sending projections with the recv projections so everyone's happy","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_SyncSendPrjns_stub,NULL},
  {&TA_void,NULL,"DisConnect"," disconnect layer from all others","MENU CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_DisConnect_stub,NULL},
  {&TA_int,NULL,"CountRecvCons"," count recv connections for all units in layer","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_CountRecvCons_stub,NULL},
  {&TA_void,NULL,"InitExterns"," Initializes external and target inputs","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_InitExterns_stub,NULL},
  {&TA_void,NULL,"InitDelta"," Initialize the unit deltas","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_InitDelta_stub,NULL},
  {&TA_void,NULL,"InitState"," Initialize the unit state variables","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_InitState_stub,NULL},
  {&TA_void,NULL,"ModifyState"," Alters state in an algorithm-specific way (e.g., decay) this is what modify means..","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_ModifyState_stub,NULL},
  {&TA_void,NULL,"InitWtDelta"," Initialize the deltas","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_InitWtDelta_stub,NULL},
  {&TA_void,NULL,"InitWtState"," Initialize the weights","MENU LABEL_Init_Weights CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_InitWtState_stub,NULL},
  {&TA_void,NULL,"Compute_Net"," Compute NetInput","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Send_Net"," sender-based compute net-input sending to all layers","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Send_Net_stub,NULL},
  {&TA_void,NULL,"Send_NetToLay"," sender-based compute net-input sending only to tolay layer","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_Send_NetToLay_stub,TA_LeabraLayer_Send_NetToLay_MethArgs},
  {&TA_void,NULL,"Send_NetToMe"," tell all layers that I receive from to send their net input to me","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Send_NetToMe_stub,NULL},
  {&TA_void,NULL,"Compute_Act","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_Act_stub,TA_LeabraLayer_Compute_Act_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights for whole layer","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_UpdateWeights_stub,NULL},
  {&TA_void,NULL,"Compute_dWt","","","",
    2,0,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_dWt_stub,NULL},
  {&TA_float,NULL,"Compute_SSE"," compute sum squared error over the entire network","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_Compute_SSE_stub,NULL},
  {&TA_void,NULL,"TransformWeights"," apply given transformation to weights","MENU MENU_SEP_BEFORE ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_TransformWeights_stub,TA_LeabraLayer_TransformWeights_MethArgs},
  {&TA_void,NULL,"AddNoiseToWeights"," add noise to weights using given noise specification","MENU ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_AddNoiseToWeights_stub,TA_LeabraLayer_AddNoiseToWeights_MethArgs},
  {&TA_int,NULL,"PruneCons"," remove weights that (after pre-proc) meet relation to compare val","MENU USE_RVAL ","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraLayer_PruneCons_stub,TA_LeabraLayer_PruneCons_MethArgs},
  {&TA_int,NULL,"ProbAddCons"," probabilistically add new connections (assuming prior pruning), init_wt = initial weight value of new connection","MENU USE_RVAL ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraLayer_ProbAddCons_stub,TA_LeabraLayer_ProbAddCons_MethArgs},
  {&TA_int,NULL,"LesionCons"," remove connectiosn with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraLayer_LesionCons_stub,TA_LeabraLayer_LesionCons_MethArgs},
  {&TA_int,NULL,"LesionUnits"," remove units with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraLayer_LesionUnits_stub,TA_LeabraLayer_LesionUnits_MethArgs},
  {&TA_bool,NULL,"SetLayerSpec","","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraLayer_SetLayerSpec_stub,TA_LeabraLayer_SetLayerSpec_MethArgs},
  {&TA_LayerSpec_ptr,NULL,"GetLayerSpec","","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_GetLayerSpec_stub,NULL},
  {&TA_bool,NULL,"SetUnitSpec"," set for all units in layer","MENU ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_SetUnitSpec_stub,TA_LeabraLayer_SetUnitSpec_MethArgs},
  {&TA_void,NULL,"SetUnitType"," set unit type for all units in layer (created by Build)","MENU TYPE_Unit ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_SetUnitType_stub,TA_LeabraLayer_SetUnitType_MethArgs},
  {&TA_bool,NULL,"SetConSpec"," set for all unit's connections in layer","MENU ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_SetConSpec_stub,TA_LeabraLayer_SetConSpec_MethArgs},
  {&TA_bool,NULL,"CheckTypes","","","",
    1,0,-1,0,0,NULL,cssElCFun_LeabraLayer_CheckTypes_stub,NULL},
  {&TA_void,NULL,"FixPrjnIndexes"," fix the projection indicies of the connection groups (other_idx)","MENU ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_FixPrjnIndexes_stub,NULL},
  {&TA_int,NULL,"ReplaceUnitSpec"," switch any units/layers using old_sp to using new_sp","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayer_ReplaceUnitSpec_stub,TA_LeabraLayer_ReplaceUnitSpec_MethArgs},
  {&TA_int,NULL,"ReplaceConSpec"," switch any connections/projections using old_sp to using new_sp","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayer_ReplaceConSpec_stub,TA_LeabraLayer_ReplaceConSpec_MethArgs},
  {&TA_int,NULL,"ReplacePrjnSpec"," switch any projections using old_sp to using new_sp","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayer_ReplacePrjnSpec_stub,TA_LeabraLayer_ReplacePrjnSpec_MethArgs},
  {&TA_int,NULL,"ReplaceLayerSpec"," switch any layers using old_sp to using new_sp","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayer_ReplaceLayerSpec_stub,TA_LeabraLayer_ReplaceLayerSpec_MethArgs},
  {&TA_void,NULL,"WeightsToTable"," TODO:define send entire set of weights from sending layer to given table (e.g., for analysis), with one row per receiving unit, and the pattern in the event reflects the weights into that unit","MENU NULL_OK ","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraLayer_WeightsToTable_stub,TA_LeabraLayer_WeightsToTable_MethArgs},
  {&TA_void,NULL,"SetExtFlag","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_SetExtFlag_stub,TA_LeabraLayer_SetExtFlag_MethArgs},
  {&TA_void,NULL,"UnSetExtFlag","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_UnSetExtFlag_stub,TA_LeabraLayer_UnSetExtFlag_MethArgs},
  {&TA_void,NULL,"ApplyExternal"," apply the 2d or 4d external input pattern to the network, optional random additional values, and offsetting;\nuses a flat 2-d model where grouped layer or 4-d data are flattened to 2d;\nframe<0 means from end","","",
    0,4,1,1,0,NULL,cssElCFun_LeabraLayer_ApplyExternal_stub,TA_LeabraLayer_ApplyExternal_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmCoord"," get unit from coordinates, taking into account group geometry if present (subtracts any gp_spc -- as if it is not present).","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraLayer_FindUnitFmCoord_stub,TA_LeabraLayer_FindUnitFmCoord_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmGpCoord"," get unit from coordinates","","",
    1,2,-1,0,0,NULL,cssElCFun_LeabraLayer_FindUnitFmGpCoord_stub,TA_LeabraLayer_FindUnitFmGpCoord_MethArgs},
  {&TA_Unit_Group_ptr,NULL,"FindUnitGpFmCoord"," get unit group from group coordinates (i.e., within gp_geom, not unit coordinates)","","",
    1,1,-1,0,0,NULL,cssElCFun_LeabraLayer_FindUnitGpFmCoord_stub,TA_LeabraLayer_FindUnitGpFmCoord_MethArgs},
  {&TA_void,NULL,"GetActGeomNoSpc"," get the actual geometry of the layer, subtracting any gp_spc that might be present (as if there were no spaces between unit groups)","","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraLayer_GetActGeomNoSpc_stub,TA_LeabraLayer_GetActGeomNoSpc_MethArgs},
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Inhib_SetVals_stub,TA_LeabraLayer_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Inhib_InitState_stub,TA_LeabraLayer_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Inhib_Copy__stub,TA_LeabraLayer_Inhib_Copy__MethArgs},
  {&TA_void,NULL,"InitActAvg","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_InitActAvg_stub,NULL},
  {&TA_void,NULL,"InitInhib"," initialize inhibitory state","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_InitInhib_stub,NULL},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraLayer_SetCurLrate_stub,TA_LeabraLayer_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_Active_K","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_Active_K_stub,NULL},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_HardClamp_stub,TA_LeabraLayer_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_NetScale_stub,TA_LeabraLayer_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Init_ClampNet","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Init_ClampNet_stub,TA_LeabraLayer_Init_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Send_ClampNet_stub,TA_LeabraLayer_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,0,-1,0,0,NULL,cssElCFun_LeabraLayer_Send_NetDelta_stub,NULL},
  {&TA_void,NULL,"Compute_Clamp_NetAvg","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_Clamp_NetAvg_stub,TA_LeabraLayer_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_Inhib","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_Inhib_stub,TA_LeabraLayer_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_LayInhibToGps","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_LayInhibToGps_stub,TA_LeabraLayer_Compute_LayInhibToGps_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_InhibAvg_stub,TA_LeabraLayer_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"PhaseInit","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_PhaseInit_stub,TA_LeabraLayer_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay between events","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_DecayEvent_stub,TA_LeabraLayer_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase"," decay between phases","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_DecayPhase_stub,TA_LeabraLayer_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayPhase2"," decay between 2nd set of phases","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_DecayPhase2_stub,TA_LeabraLayer_DecayPhase2_MethArgs},
  {&TA_void,NULL,"ExtToComp","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_ExtToComp_stub,TA_LeabraLayer_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_TargExtToComp_stub,TA_LeabraLayer_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle","","","",
    0,2,1,0,0,NULL,cssElCFun_LeabraLayer_PostSettle_stub,TA_LeabraLayer_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraLayer_Compute_WtFmLin_stub,TA_LeabraLayer_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"ResetSortBuf","","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLayer_ResetSortBuf_stub,NULL},
  NULL};
static EnumDef_data TA_LeabraNetwork_StateInit[]={
  {"DO_NOTHING"," do nothing","",0},
  {"INIT_STATE"," initialize state","",1},
  {"DECAY_STATE"," decay the state","",2},
  NULL};
static EnumDef_data TA_LeabraNetwork_Phase[]={
  {"MINUS_PHASE"," minus phase","",0},
  {"PLUS_PHASE"," plus phase","",1},
  {"MINUS_2"," second minus phase","",2},
  {"PLUS_2"," second plus phase","",3},
  NULL};
static EnumDef_data TA_LeabraNetwork_PhaseOrder[]={
  {"MINUS_PLUS"," standard minus-plus (err and assoc)","",0},
  {"PLUS_ONLY"," only present the plus phase (hebbian-only)","",1},
  {"MINUS_PLUS_NOTHING"," auto-encoder version with final 'nothing' minus phase","",2},
  {"PLUS_NOTHING"," just the auto-encoder (no initial minus phase)","",3},
  {"MINUS_PLUS_PLUS"," two plus phases for gated context layer updating","",4},
  {"MINUS_PLUS_2"," two minus-plus phases (for pfc/bg system)","",5},
  NULL};
static EnumDef_data TA_LeabraNetwork_FirstPlusdWt[]={
  {"NO_FIRST_DWT"," for three phase cases: don't change weights after first plus","",0},
  {"ONLY_FIRST_DWT"," for three phase cases: only change weights after first plus","",1},
  {"ALL_DWT"," for three phase cases: change weights after *both* post-minus phases","",2},
  NULL};
static int LeabraNetwork::* TA_LeabraNetwork_MbrOff;
static MemberDef_data TA_LeabraNetwork_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," [Default: MINUS_PLUS] number and order of phases to present","CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::phase_order))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_test"," don't run the plus phase when testing","DEF_true CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::no_plus_test))),0,NULL,0},
  {NULL,"::StateInit","trial_init"," how to initialize network state at start of trial","DEF_DECAY_STATE CAT_Activation ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::trial_init))),0,NULL,0},
  {NULL,"::StateInit","sequence_init"," how to initialize network state at start of a sequence of trials","DEF_DO_NOTHING CAT_Activation ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::sequence_init))),0,NULL,0},
  {NULL,"::FirstPlusdWt","first_plus_dwt"," how to change weights on first plus phase if 2 plus phases (applies only to standard leabralayer specs -- others must decide on their own!)","CONDEDIT_ON_phase_order:MINUS_PLUS_PLUS CAT_Learning ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::first_plus_dwt))),0,NULL,0},
  {NULL,"::Phase","phase"," type of settling phase","GUI_READ_ONLY SHOW CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::phase))),0,NULL,0},
  {&TA_int,NULL,"phase_no"," phase as an ordinal number (regular phase is Phase enum)","GUI_READ_ONLY SHOW CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::phase_no))),0,NULL,0},
  {&TA_int,NULL,"phase_max"," maximum number of phases to run (note: this is set by Trial_Init depending on phase_order)","CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::phase_max))),0,NULL,0},
  {&TA_int,NULL,"cycle_max"," maximum number of cycles to settle for","DEF_60 CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::cycle_max))),0,NULL,0},
  {&TA_int,NULL,"min_cycles"," minimum number of cycles to settle for","DEF_15 CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::min_cycles))),0,NULL,0},
  {&TA_int,NULL,"min_cycles_phase2"," minimum number of cycles to settle for in second phase","DEF_15 CAT_Counter ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::min_cycles_phase2))),0,NULL,0},
  {&TA_int,NULL,"netin_mod"," net input computation modulus: how often to compute netinput vs. activation update (2 = faster)","DEF_1 CAT_Optimization ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::netin_mod))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send netin deltas instead of raw netin: more efficient (automatically sets corresponding unitspec flag)","DEF_false CAT_Optimization ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::send_delta))),0,NULL,0},
  {&TA_float,NULL,"maxda_stopcrit"," stopping criterion for max da","DEF_0.005 CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::maxda_stopcrit))),0,NULL,0},
  {&TA_float,NULL,"maxda"," maximum change in activation (delta-activation) over network; used in stopping settling","GUI_READ_ONLY SHOW CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::maxda))),0,NULL,0},
  {&TA_float,NULL,"trg_max_act_stopcrit"," stopping criterion for target-layer maximum activation (can be used for stopping settling)","CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::trg_max_act_stopcrit))),0,NULL,0},
  {&TA_float,NULL,"trg_max_act"," target-layer maximum activation (can be used for stopping settling)","GUI_READ_ONLY SHOW CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::trg_max_act))),0,NULL,0},
  {&TA_float,NULL,"ext_rew"," external reward value (on this trial)","GUI_READ_ONLY SHOW CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::ext_rew))),0,NULL,0},
  {&TA_float,NULL,"avg_ext_rew"," average external reward value (computed over previous epoch)","GUI_READ_ONLY SHOW CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::avg_ext_rew))),0,NULL,0},
  {&TA_float,NULL,"avg_ext_rew_sum"," sum for computing current average external reward value in this epoch","READ_ONLY CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::avg_ext_rew_sum))),0,NULL,0},
  {&TA_int,NULL,"avg_ext_rew_n"," N for average external reward value computation for this epoch","READ_ONLY CAT_Statistic ","",
    *((ta_memb_ptr*)&(TA_LeabraNetwork_MbrOff=(int LeabraNetwork::*)(&LeabraNetwork::avg_ext_rew_n))),0,NULL,0},
  NULL};
static MethodDef_data TA_LeabraNetwork_MethodDef[]={
  {&TA_void,NULL,"InitCounters"," initialize counter variables on network","CAT_Counter ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_InitCounters_stub,NULL},
  {&TA_void,NULL,"InitStats"," initialize statistic variables on network single cycle-level functions","CAT_Statistic ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_InitStats_stub,NULL},
  {&TA_void,NULL,"Compute_Net"," Compute NetInput compute netinputs (sender based, if send_delta, then only when sender activations change)","CAT_Cycle ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Compute_Act"," Compute Activation; subtypes may replace with their own algorithm compute activations, and max delta activation","CAT_Cycle ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_Act_stub,NULL},
  {&TA_void,NULL,"Compute_dWt"," update weights for whole net compute weight change on all layers","CAT_TrialFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"Compute_SSE"," compute sum squared error over the entire network compute sum squared error AND also call Compute_ExtRew","CAT_Statistic ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_SSE_stub,NULL},
  {&TA_void,NULL,"Compute_EpochSSE"," compute epoch-level sum squared error and related statistics compute epoch-level sum squared error and related statistics, INCLUDING AvgExtRew","CAT_Statistic ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_EpochSSE_stub,NULL},
  {&TA_void,NULL,"Compute_Clamp_NetAvg"," add in clamped netinput values (computed once at start of settle) and average netinput values","CAT_Cycle ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_Clamp_NetAvg_stub,NULL},
  {&TA_void,NULL,"Compute_Inhib"," compute inhibitory conductances (kwta)","CAT_Cycle ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_Inhib_stub,NULL},
  {&TA_void,NULL,"Compute_InhibAvg"," compute average inhibitory conductances","CAT_Cycle ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_InhibAvg_stub,NULL},
  {&TA_void,NULL,"Cycle_Run"," compute one cycle of updating: netinput, inhibition, activations","CAT_Cycle ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Cycle_Run_stub,NULL},
  {&TA_void,NULL,"Compute_Active_K"," determine the active k values for each layer based on pcts, etc (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_Active_K_stub,NULL},
  {&TA_void,NULL,"DecayPhase"," decay activations and other state between minus-plus phases (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_DecayPhase_stub,NULL},
  {&TA_void,NULL,"DecayPhase2"," decay activations and other state between second and third phase (if applicable) (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_DecayPhase2_stub,NULL},
  {&TA_void,NULL,"PhaseInit"," initialize at start of settling phase (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_PhaseInit_stub,NULL},
  {&TA_void,NULL,"ExtToComp"," move external input values to comparison values (not currently used)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_ExtToComp_stub,NULL},
  {&TA_void,NULL,"TargExtToComp"," move target and external input values to comparison (for PLUS_NOTHING, called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_TargExtToComp_stub,NULL},
  {&TA_void,NULL,"Compute_HardClamp"," compute hard clamping from external inputs (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_HardClamp_stub,NULL},
  {&TA_void,NULL,"Compute_NetScale"," compute netinput scaling values by projection (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_NetScale_stub,NULL},
  {&TA_void,NULL,"Send_ClampNet"," send clamped activation netinputs to other layers -- only needs to be computed once (called by Settle_Init)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Send_ClampNet_stub,NULL},
  {&TA_void,NULL,"Settle_Init"," initialize network for settle-level processing (decay, active k, hard clamp, netscale, clampnet)","CAT_SettleInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Settle_Init_stub,NULL},
  {&TA_void,NULL,"PostSettle"," perform computations in layers at end of settling (called by Settle_Final)","CAT_SettleFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_PostSettle_stub,NULL},
  {&TA_void,NULL,"PostSettle_NStdLay"," perform post-settle computations in layers for non-standard layers (called by Settle_Init)","CAT_SettleFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_PostSettle_NStdLay_stub,NULL},
  {&TA_void,NULL,"Settle_Final"," do final processing after settling (postsettle, Compute_dWt if needed","CAT_SettleFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Settle_Final_stub,NULL},
  {&TA_void,NULL,"SetCurLrate"," set the current learning rate according to the LeabraConSpec parameters","CAT_TrialInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_SetCurLrate_stub,NULL},
  {&TA_void,NULL,"DecayEvent"," decay activations and other state between events (trial-level)","CAT_TrialInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_DecayEvent_stub,NULL},
  {&TA_void,NULL,"DecayState"," decay the state in between trials (params in LayerSpec)","CAT_TrialInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_DecayState_stub,NULL},
  {&TA_void,NULL,"Trial_Init"," initialize at start of trial (SetCurLrate, set phase_max, Decay state)","CAT_TrialInit ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Trial_Init_stub,NULL},
  {&TA_void,NULL,"Trial_UpdatePhase"," update phase based on phase_no -- return false if no more phases need to be run","","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Trial_UpdatePhase_stub,NULL},
  {&TA_void,NULL,"EncodeState"," encode final state information for subsequent use","CAT_TrialFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_EncodeState_stub,NULL},
  {&TA_void,NULL,"Compute_dWt_NStdLay"," compute weight change on non-nstandard layers (depends on which phase is being run)","CAT_TrialFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_dWt_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_ExtRew"," compute external reward information","CAT_Statistic ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_ExtRew_stub,NULL},
  {&TA_void,NULL,"Trial_Final"," do final processing after trial (Compute_dWt, EncodeState)","CAT_TrialFinal ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Trial_Final_stub,NULL},
  {&TA_void,NULL,"Compute_AvgExtRew"," compute average external reward information (at an epoch-level timescale)","CAT_Statistic ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraNetwork_Compute_AvgExtRew_stub,NULL},
  NULL};
static int WtScaleSpec::* TA_WtScaleSpec_MbrOff;
static MemberDef_data TA_WtScaleSpec_MemberDef[]={
  {&TA_float,NULL,"abs"," absolute scaling (not subject to normalization: directly multiplies weight values)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_WtScaleSpec_MbrOff=(int WtScaleSpec::*)(&WtScaleSpec::abs))),0,NULL,0},
  {&TA_float,NULL,"rel"," [Default: 1] relative scaling (subject to normalization across all other projections into unit)","","",
    *((ta_memb_ptr*)&(TA_WtScaleSpec_MbrOff=(int WtScaleSpec::*)(&WtScaleSpec::rel))),0,NULL,0},
  NULL};
static MethodDef_data TA_WtScaleSpec_MethodDef[]={
  {&TA_float,NULL,"NetScale","","","",
    0,0,-1,0,0,NULL,cssElCFun_WtScaleSpec_NetScale_stub,NULL},
  NULL};
static int WtSigSpec::* TA_WtSigSpec_MbrOff;
static MemberDef_data TA_WtSigSpec_MemberDef[]={
  {&TA_float,NULL,"gain"," gain (contrast, sharpness) of the weight contrast function (1 = linear)","DEF_6 ","",
    *((ta_memb_ptr*)&(TA_WtSigSpec_MbrOff=(int WtSigSpec::*)(&WtSigSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"off"," offset of the function (1=centered at .5, >1=higher, <1=lower)","DEF_1.25 ","",
    *((ta_memb_ptr*)&(TA_WtSigSpec_MbrOff=(int WtSigSpec::*)(&WtSigSpec::off))),0,NULL,0},
  NULL};
static MethodArgs_data TA_WtSigSpec_SigFun_MethArgs[]={
  {&TA_float,NULL,"w",""},
  {&TA_float,NULL,"gain",""},
  {&TA_float,NULL,"off",""},
  NULL};
static MethodArgs_data TA_WtSigSpec_SigFunInv_MethArgs[]={
  {&TA_float,NULL,"w",""},
  {&TA_float,NULL,"gain",""},
  {&TA_float,NULL,"off",""},
  NULL};
static MethodDef_data TA_WtSigSpec_MethodDef[]={
  {&TA_float,NULL,"SigFun"," function for implementing inverse of weight sigmoid","","",
    0,3,-1,0,1,(ta_void_fun)(WtSigSpec::SigFun),cssElCFun_WtSigSpec_SigFun_stub,TA_WtSigSpec_SigFun_MethArgs},
  {&TA_float,NULL,"SigFunInv","","","",
    0,3,-1,0,1,(ta_void_fun)(WtSigSpec::SigFunInv),cssElCFun_WtSigSpec_SigFunInv_stub,TA_WtSigSpec_SigFunInv_MethArgs},
  NULL};
static int LearnMixSpec::* TA_LearnMixSpec_MbrOff;
static MemberDef_data TA_LearnMixSpec_MemberDef[]={
  {&TA_float,NULL,"hebb"," [Default: .01] amount of hebbian learning (should be relatively small, can be effective at .0001)","","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::hebb))),0,NULL,0},
  {&TA_float,NULL,"err"," [Default: .99] amount of error driven learning, automatically computed to be 1-hebb","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::err))),0,NULL,0},
  {&TA_bool,NULL,"err_sb"," apply exponential soft-bounding to the error learning component","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::err_sb))),0,NULL,0},
  NULL};
static MethodDef_data TA_LearnMixSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LearnMixSpec_UpdateAfterEdit_stub,NULL},
  NULL};
static int SAvgCorSpec::* TA_SAvgCorSpec_MbrOff;
static MemberDef_data TA_SAvgCorSpec_MemberDef[]={
  {&TA_float,NULL,"cor"," proportion of correction to apply (0=none, 1=all, .5=half, etc)","DEF_0.4 ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::cor))),0,NULL,0},
  {&TA_float,NULL,"thresh"," threshold of sending average activation below which learning does not occur (prevents learning when there is no input)","DEF_0.001 ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::thresh))),0,NULL,0},
  {&TA_bool,NULL,"norm_con_n"," in normalizing netinput, divide by the actual number of connections (recv group n), not the overall number of units in the sending layer; this is good when units only receive from a small fraction of sending layer units","DEF_false AKA_div_gp_n ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::norm_con_n))),0,NULL,0},
  NULL};
static EnumDef_data TA_ActFunSpec_IThrFun[]={
  {"STD"," include all currents (except bias weights) in inhibitory threshold computation","",0},
  {"NO_A"," exclude gc.a current: allows accommodation to knock out units from kwta active list, without other units coming in to take their place","",1},
  {"NO_H"," exclude gc.h current: prevent hysteresis current from affecting inhibitory threshold computation","",2},
  {"NO_AH"," exclude gc.a and gc.h currents: prevent both accommodation and hysteresis currents from affecting inhibitory threshold computation","",3},
  NULL};
static int ActFunSpec::* TA_ActFunSpec_MbrOff;
static MemberDef_data TA_ActFunSpec_MemberDef[]={
  {&TA_float,NULL,"thr"," threshold value Theta (Q) for firing output activation ","DEF_0.25 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::thr))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain (gamma) of the sigmoidal rate-coded activation function ","DEF_600 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"nvar"," variance of the Gaussian noise kernel for convolving with XX1 in NOISY_XX1","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::nvar))),0,NULL,0},
  {&TA_float,NULL,"avg_dt"," time constant for integrating activation average (computed across trials)","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::avg_dt))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send only changes in activation when it changes beyond opt_thresh.delta: COPIED FROM LeabraSettle!","DEF_false READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::send_delta))),0,NULL,0},
  {NULL,"::IThrFun","i_thr"," how to compute the inhibitory threshold for kWTA functions (what currents to include or exclude in determining what amount of inhibition would keep the unit just at threshold firing)","DEF_STD ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::i_thr))),0,NULL,0},
  NULL};
static int SpikeFunSpec::* TA_SpikeFunSpec_MbrOff;
static MemberDef_data TA_SpikeFunSpec_MemberDef[]={
  {&TA_float,NULL,"decay"," exponential decay of activation produced by a spike (act(t+1) = act(t) * (1-decay))","DEF_0.05 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::decay))),0,NULL,0},
  {&TA_float,NULL,"v_m_r"," post-spiking membrane potential to reset to, produces refractory effect","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::v_m_r))),0,NULL,0},
  {&TA_float,NULL,"eq_gain"," gain for computing act_eq relative to actual average: act_eq = eq_gain * (spikes/cycles)","DEF_10 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::eq_gain))),0,NULL,0},
  {&TA_float,NULL,"eq_dt"," if non-zero, eq is computed as a running average with this time constant","DEF_0.02 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::eq_dt))),0,NULL,0},
  {&TA_float,NULL,"hard_gain"," gain for hard-clamped external inputs, mutliplies ext. constant external inputs otherwise have too much influence compared to spiking ones: Note: soft clamping is strongly recommended","DEF_0.4 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::hard_gain))),0,NULL,0},
  NULL};
static EnumDef_data TA_DepressSpec_PSpike[]={
  {"P_NXX1"," probability of spiking is based on NOISY_XX1 f(Vm - Q)","",0},
  {"P_LINEAR"," probability of spiking is based on LINEAR f(Vm - Q)","",1},
  NULL};
static int DepressSpec::* TA_DepressSpec_MbrOff;
static MemberDef_data TA_DepressSpec_MemberDef[]={
  {NULL,"::PSpike","p_spike"," how to compute the probability of spiking, which is then mult by amp of spiking","","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::p_spike))),0,NULL,0},
  {&TA_float,NULL,"rec"," rate of recovery of spike amplitude (determines overall time constant of depression function)","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::rec))),0,NULL,0},
  {&TA_float,NULL,"asymp_act"," asymptotic activation value (as proportion of 1) for a fully active unit (determines depl value)","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::asymp_act))),0,NULL,0},
  {&TA_float,NULL,"depl"," rate of depletion of spike amplitude as a function of activation output (computed from rec, asymp_act)","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::depl))),0,NULL,0},
  {&TA_float,NULL,"max_amp"," maximum amplitude required to maintain asymptotic firing at normal clamp levels (copied to act_range.max) ","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::max_amp))),0,NULL,0},
  NULL};
static MethodDef_data TA_DepressSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_DepressSpec_UpdateAfterEdit_stub,NULL},
  NULL};
static int OptThreshSpec::* TA_OptThreshSpec_MbrOff;
static MemberDef_data TA_OptThreshSpec_MemberDef[]={
  {&TA_float,NULL,"send"," don't send activation when act <= send -- greatly speeds processing","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::send))),0,NULL,0},
  {&TA_float,NULL,"delta"," don't send activation changes until they exceed this threshold: only for when LeabraSettle::send_delta is on!","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::delta))),0,NULL,0},
  {&TA_float,NULL,"learn"," don't learn on recv unit weights when both phase acts <= learn","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::learn))),0,NULL,0},
  {&TA_bool,NULL,"updt_wts"," whether to apply learn threshold to updating weights (otherwise always update)","DEF_true ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::updt_wts))),0,NULL,0},
  {&TA_float,NULL,"phase_dif"," don't learn when +/- phase difference ratio (- / +) < phase_dif (.8 when used, but off by default)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::phase_dif))),0,NULL,0},
  NULL};
static int DtSpec::* TA_DtSpec_MbrOff;
static MemberDef_data TA_DtSpec_MemberDef[]={
  {&TA_float,NULL,"vm"," membrane potential time constant -- if units oscillate too much, then this is too high (but see d_vm_max for another solution)","DEF_0.3 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::vm))),0,NULL,0},
  {&TA_float,NULL,"net"," net input time constant -- how fast to update net input (damps oscillations)","DEF_0.7 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::net))),0,NULL,0},
  {&TA_float,NULL,"d_vm_max"," maximum change in vm at any timestep (limits blowup)","DEF_0.025 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::d_vm_max))),0,NULL,0},
  {&TA_int,NULL,"vm_eq_cyc"," number of cycles to compute the vm as equilibirium potential given current inputs: set to 1 to quickly activate input layers; set to 100 to always use this computation","AKA_cyc0_vm_eq DEF_0 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::vm_eq_cyc))),0,NULL,0},
  {&TA_float,NULL,"vm_eq_dt"," time constant for integrating the vm_eq values: how quickly to move toward the current eq value from previous vm value","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::vm_eq_dt))),0,NULL,0},
  NULL};
static int LeabraChannels::* TA_LeabraChannels_MbrOff;
static MemberDef_data TA_LeabraChannels_MemberDef[]={
  {&TA_float,NULL,"e"," Excitatory (glutamatergic synaptic sodium (Na) channel)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::e))),0,NULL,0},
  {&TA_float,NULL,"l"," Constant leak (potassium, K+) channel ","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::l))),0,NULL,0},
  {&TA_float,NULL,"i"," inhibitory","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::i))),0,NULL,0},
  {&TA_float,NULL,"h"," hysteresis (Ca)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::h))),0,NULL,0},
  {&TA_float,NULL,"a"," accomodation (k)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::a))),0,NULL,0},
  NULL};
static int VChanSpec::* TA_VChanSpec_MbrOff;
static MemberDef_data TA_VChanSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," true if channel is on","DEF_false ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::on))),0,NULL,0},
  {&TA_float,NULL,"b_dt"," time constant for integrating basis variable (basis ~ intracellular calcium which builds up slowly as function of activation)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::b_dt))),0,NULL,0},
  {&TA_float,NULL,"a_thr"," activation threshold of the channel: when basis > a_thr, conductance starts to build up (channels open)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::a_thr))),0,NULL,0},
  {&TA_float,NULL,"d_thr"," deactivation threshold of the channel: when basis < d_thr, conductance diminshes (channels close)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::d_thr))),0,NULL,0},
  {&TA_float,NULL,"g_dt"," time constant for changing conductance (activating or deactivating)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::g_dt))),0,NULL,0},
  {&TA_bool,NULL,"init"," initialize variables when state is intialized between trials (else with weights)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::init))),0,NULL,0},
  NULL};
static MethodArgs_data TA_VChanSpec_UpdateBasis_MethArgs[]={
  {&TA_float_ref,NULL,"basis",""},
  {&TA_bool_ref,NULL,"on_off",""},
  {&TA_float_ref,NULL,"gc",""},
  {&TA_float,NULL,"act",""},
  NULL};
static MethodDef_data TA_VChanSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateBasis","","","",
    0,4,-1,0,0,NULL,cssElCFun_VChanSpec_UpdateBasis_stub,TA_VChanSpec_UpdateBasis_MethArgs},
  NULL};
static int ActRegSpec::* TA_ActRegSpec_MbrOff;
static MemberDef_data TA_ActRegSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to activity regulation is on (active) or not","","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::on))),0,NULL,0},
  {&TA_float,NULL,"min"," increase weights for units below this level of average activation","CONDEDIT_ON_on:true DEF_0 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::min))),0,NULL,0},
  {&TA_float,NULL,"max"," decrease weights for units above this level of average activation ","CONDEDIT_ON_on:true DEF_0.35 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::max))),0,NULL,0},
  {&TA_float,NULL,"wt_dt"," pre-lrate rate constant for making weight changes to rectify over-activation (dwt = cur_lrate * wt_dt * wt)","CONDEDIT_ON_on:true DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::wt_dt))),0,NULL,0},
  NULL};
static EnumDef_data TA_MaxDaSpec_dAValue[]={
  {"DA_ONLY"," just use da","",0},
  {"INET_ONLY"," just use inet","",1},
  {"INET_DA"," use inet if no activity, then use da","",2},
  NULL};
static int MaxDaSpec::* TA_MaxDaSpec_MbrOff;
static MemberDef_data TA_MaxDaSpec_MemberDef[]={
  {NULL,"::dAValue","val"," value to use for computing delta-activation (change in activation over cycles of settling).","DEF_INET_DA ","",
    *((ta_memb_ptr*)&(TA_MaxDaSpec_MbrOff=(int MaxDaSpec::*)(&MaxDaSpec::val))),0,NULL,0},
  {&TA_float,NULL,"inet_scale"," how to scale the inet measure to be like da","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_MaxDaSpec_MbrOff=(int MaxDaSpec::*)(&MaxDaSpec::inet_scale))),0,NULL,0},
  {&TA_float,NULL,"lay_avg_thr"," threshold for layer average activation to switch to da fm Inet","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_MaxDaSpec_MbrOff=(int MaxDaSpec::*)(&MaxDaSpec::lay_avg_thr))),0,NULL,0},
  NULL};
static int VChanBasis::* TA_VChanBasis_MbrOff;
static MemberDef_data TA_VChanBasis_MemberDef[]={
  {&TA_float,NULL,"hyst"," hysteresis","","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::hyst))),0,NULL,0},
  {&TA_float,NULL,"acc"," fast accomodation","","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::acc))),0,NULL,0},
  {&TA_bool,NULL,"hyst_on"," binary thresholded mode state variable, hyst","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::hyst_on))),0,NULL,0},
  {&TA_bool,NULL,"acc_on"," binary thresholded mode state variable, acc","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::acc_on))),0,NULL,0},
  {&TA_float,NULL,"g_h"," hysteresis conductance","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::g_h))),0,NULL,0},
  {&TA_float,NULL,"g_a"," accomodation conductance","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::g_a))),0,NULL,0},
  NULL};
static int LeabraUnitChans::* TA_LeabraUnitChans_MbrOff;
static MemberDef_data TA_LeabraUnitChans_MemberDef[]={
  {&TA_float,NULL,"l"," leak","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::l))),0,NULL,0},
  {&TA_float,NULL,"i"," inhibitory","DMEM_SHARE_SET_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::i))),0,NULL,0},
  {&TA_float,NULL,"h"," hysteresis (Ca)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::h))),0,NULL,0},
  {&TA_float,NULL,"a"," accomodation (K)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::a))),0,NULL,0},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Find_MethArgs[]={
  {&TA_const_taString_ref,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Remove_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__SafeEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Edit_El_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FindName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUniqNameOld_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUniqNameOld_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FindEl_MethArgs[]={
  {NULL,"::const_LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Add_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUnique_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUniqNameNew_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Insert_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Replace_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","old_it",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"old_nm",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__RemoveEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__DuplicateEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Link_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUnique_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUniqNameNew_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__InsertLink_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  {&TA_int,NULL,"idx"," -1"},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLink_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLinkEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","old_it",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLinkName_MethArgs[]={
  {&TA_const_taString_ref,NULL,"old_nm",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Push_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","from",""},
  {NULL,"::LeabraUnit_ptr","to",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Transfer_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveBefore_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","trg",""},
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveAfter_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","trg",""},
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodDef_data TA_taPtrList_LeabraUnit__MethodDef[]={
  {&TA_int,NULL,"Find","","","",
    2,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Find_stub,TA_taPtrList_LeabraUnit__Find_MethArgs},
  {&TA_bool,NULL,"Remove"," Remove element at given index","","",
    4,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Remove_stub,TA_taPtrList_LeabraUnit__Remove_MethArgs},
  {NULL,"::LeabraUnit_ptr","SafeEl"," element at index","","",
    0,1,-1,0,0,NULL,cssElCFun_taPtrList_LeabraUnit__SafeEl_stub,TA_taPtrList_LeabraUnit__SafeEl_MethArgs},
  {NULL,"::LeabraUnit_ptr","FastEl"," fast element (no range checking)","","",
    0,1,-1,0,0,NULL,cssElCFun_taPtrList_LeabraUnit__FastEl_stub,TA_taPtrList_LeabraUnit__FastEl_MethArgs},
  {NULL,"::LeabraUnit_ptr","Edit_El"," Edit given list item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,0,NULL,cssElCFun_taPtrList_LeabraUnit__Edit_El_stub,TA_taPtrList_LeabraUnit__Edit_El_MethArgs},
  {NULL,"::LeabraUnit_ptr","FindName"," find given named element (NULL = not here), sets idx","","",
    0,2,1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FindName_stub,TA_taPtrList_LeabraUnit__FindName_MethArgs},
  {NULL,"::LeabraUnit_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Pop_stub,NULL},
  {NULL,"::LeabraUnit_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Peek_stub,NULL},
  {NULL,"::LeabraUnit_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUniqNameOld_stub,TA_taPtrList_LeabraUnit__AddUniqNameOld_MethArgs},
  {NULL,"::LeabraUnit_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUniqNameOld_stub,TA_taPtrList_LeabraUnit__LinkUniqNameOld_MethArgs},
  {&TA_int,NULL,"FindEl"," find given element in list (-1 if not there)","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FindEl_stub,TA_taPtrList_LeabraUnit__FindEl_MethArgs},
  {&TA_void,NULL,"AddEl"," append a new pointer to end of list","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddEl_stub,TA_taPtrList_LeabraUnit__AddEl_MethArgs},
  {&TA_void,NULL,"Add"," add element to the list and 'own' item","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Add_stub,TA_taPtrList_LeabraUnit__Add_MethArgs},
  {&TA_bool,NULL,"AddUnique"," add so that object is unique, true if unique","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUnique_stub,TA_taPtrList_LeabraUnit__AddUnique_MethArgs},
  {&TA_bool,NULL,"AddUniqNameNew"," add so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUniqNameNew_stub,TA_taPtrList_LeabraUnit__AddUniqNameNew_MethArgs},
  {&TA_bool,NULL,"Insert"," Add or insert element at idx (-1 for end)","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Insert_stub,TA_taPtrList_LeabraUnit__Insert_MethArgs},
  {&TA_bool,NULL,"Replace"," replace element at index with the new one","","",
    2,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Replace_stub,TA_taPtrList_LeabraUnit__Replace_MethArgs},
  {&TA_bool,NULL,"ReplaceEl"," replace given element with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceEl_stub,TA_taPtrList_LeabraUnit__ReplaceEl_MethArgs},
  {&TA_bool,NULL,"ReplaceName"," replace named element with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceName_stub,TA_taPtrList_LeabraUnit__ReplaceName_MethArgs},
  {&TA_bool,NULL,"RemoveEl"," Remove given item from list","MENU LABEL_Remove ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__RemoveEl_stub,TA_taPtrList_LeabraUnit__RemoveEl_MethArgs},
  {&TA_bool,NULL,"DuplicateEl"," Duplicate given list item and Add to list","MENU ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__DuplicateEl_stub,TA_taPtrList_LeabraUnit__DuplicateEl_MethArgs},
  {&TA_void,NULL,"Link"," Link an item to list without owning it","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Link_stub,TA_taPtrList_LeabraUnit__Link_MethArgs},
  {&TA_bool,NULL,"LinkUnique"," link so that object is unique, true if unique","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUnique_stub,TA_taPtrList_LeabraUnit__LinkUnique_MethArgs},
  {&TA_bool,NULL,"LinkUniqNameNew"," link so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUniqNameNew_stub,TA_taPtrList_LeabraUnit__LinkUniqNameNew_MethArgs},
  {&TA_bool,NULL,"InsertLink"," Insert a link at index (-1 for end)","MENU LABEL_Link UPDATE_MENUS ","",
    0,2,1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__InsertLink_stub,TA_taPtrList_LeabraUnit__InsertLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLink"," replace element with a link to the new one","","",
    2,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLink_stub,TA_taPtrList_LeabraUnit__ReplaceLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkEl"," replace given element (if on list) with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLinkEl_stub,TA_taPtrList_LeabraUnit__ReplaceLinkEl_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkName"," replace given named element (if on list) with the new one","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLinkName_stub,TA_taPtrList_LeabraUnit__ReplaceLinkName_MethArgs},
  {&TA_void,NULL,"Push"," push item on stack (for temporary use, not 'owned')","","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Push_stub,TA_taPtrList_LeabraUnit__Push_MethArgs},
  {&TA_bool,NULL,"MoveEl"," Move item (from) to position of (to)","MENU LABEL_Move ARG_ON_OBJ UPDATE_MENUS ","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveEl_stub,TA_taPtrList_LeabraUnit__MoveEl_MethArgs},
  {&TA_bool,NULL,"Transfer"," Transfer item to this list","MENU MENU_ON_Edit NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Transfer_stub,TA_taPtrList_LeabraUnit__Transfer_MethArgs},
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveBefore_stub,TA_taPtrList_LeabraUnit__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list","","",
    0,2,-1,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveAfter_stub,TA_taPtrList_LeabraUnit__MoveAfter_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraSort_FindNewNetPos_MethArgs[]={
  {&TA_float,NULL,"nw_net",""},
  NULL};
static MethodArgs_data TA_LeabraSort_FastInsertLink_MethArgs[]={
  {&TA_void_ptr,NULL,"it",""},
  {&TA_int,NULL,"where",""},
  NULL};
static MethodDef_data TA_LeabraSort_MethodDef[]={
  {&TA_int,NULL,"FindNewNetPos"," find position in list for a new net value","","",
    0,1,-1,0,0,NULL,cssElCFun_LeabraSort_FindNewNetPos_stub,TA_LeabraSort_FindNewNetPos_MethArgs},
  {&TA_void,NULL,"FastInsertLink"," faster version of insert link fun","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraSort_FastInsertLink_stub,TA_LeabraSort_FastInsertLink_MethArgs},
  NULL};
static EnumDef_data TA_KWTASpec_K_From[]={
  {"USE_K"," use the k specified directly","",0},
  {"USE_PCT"," use the percentage pct to compute the k as a function of layer size","",1},
  {"USE_PAT_K"," use the activity level of the current event pattern (k = of units > pat_q)"," ",2},
  NULL};
static int KWTASpec::* TA_KWTASpec_MbrOff;
static MemberDef_data TA_KWTASpec_MemberDef[]={
  {NULL,"::K_From","k_from"," how is the active_k determined: directly by k, by pct, or by no. of units where ext > pat_q","","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::k_from))),0,NULL,0},
  {&TA_int,NULL,"k"," desired number of active units in the layer","CONDEDIT_ON_k_from:USE_K ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::k))),0,NULL,0},
  {&TA_float,NULL,"pct"," desired proportion of activity (used to compute a k value based on layer size, .25 std)","CONDEDIT_ON_k_from:USE_PCT ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::pct))),0,NULL,0},
  {&TA_float,NULL,"pat_q"," threshold for pat_k based activity level: add to k if ext > pat_q","HIDDEN DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::pat_q))),0,NULL,0},
  {&TA_bool,NULL,"diff_act_pct"," if true, use different actual percent activity for overall layer activation","DEF_false ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::diff_act_pct))),0,NULL,0},
  {&TA_float,NULL,"act_pct"," actual percent activity to put in kwta.pct field of layer","CONDEDIT_ON_diff_act_pct:true ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::act_pct))),0,NULL,0},
  {&TA_bool,NULL,"gp_i"," compute inhibition including all of the layers in the same group, or unit groups within the layer: each items computed inhib vals are multipled by gp_g scaling, then MAX'd, and each item's inhib is the MAX of this pooled MAX value and its original own value","","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::gp_i))),0,NULL,0},
  {&TA_float,NULL,"gp_g"," how much this item (layer or unit group) contributes to the pooled layer group values","CONDEDIT_ON_gp_i:true ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::gp_g))),0,NULL,0},
  NULL};
static int KwtaTieBreak::* TA_KwtaTieBreak_MbrOff;
static MemberDef_data TA_KwtaTieBreak_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to perform the tie breaking function at all","","",
    *((ta_memb_ptr*)&(TA_KwtaTieBreak_MbrOff=(int KwtaTieBreak::*)(&KwtaTieBreak::on))),0,NULL,0},
  {&TA_float,NULL,"k_thr"," threshold on inhibitory threshold (i_thr) for top kwta units before tie break is engaged: don't break ties for weakly activated layers","CONDEDIT_ON_on:true DEF_1 ","",
    *((ta_memb_ptr*)&(TA_KwtaTieBreak_MbrOff=(int KwtaTieBreak::*)(&KwtaTieBreak::k_thr))),0,NULL,0},
  {&TA_float,NULL,"diff_thr"," threshold on difference ratio between top k and rest (k_ithr - k1_ithr) / k_ithr for a tie to be indicated. This is also how much k1_ithr is reduced relative to k_ithr to fix the tie: sets a lower limit on this value. larger values mean higher overall activations during ties, but you dont' want to activate the tie mechanism unnecessarily either.","CONDEDIT_ON_on:true DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_KwtaTieBreak_MbrOff=(int KwtaTieBreak::*)(&KwtaTieBreak::diff_thr))),0,NULL,0},
  NULL};
static EnumDef_data TA_AdaptISpec_AdaptType[]={
  {"NONE"," don't adapt anything","",0},
  {"KWTA_PT"," adapt kwta point (i_kwta_pt) based on running-average layer activation as compared to target value","",1},
  {"G_BAR_I"," adapt g_bar.i for unit inhibition values based on layer activation at any point in time","",2},
  {"G_BAR_IL"," adapt g_bar.i and g_bar.l for unit inhibition & leak values based on layer activation at any point in time","",3},
  NULL};
static int AdaptISpec::* TA_AdaptISpec_MbrOff;
static MemberDef_data TA_AdaptISpec_MemberDef[]={
  {NULL,"::AdaptType","type"," what to adapt, or none for nothing","","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::type))),0,NULL,0},
  {&TA_float,NULL,"tol"," tolerance around target avg act before changing parameter","CONDEDIT_OFF_type:NONE DEF_0.02 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::tol))),0,NULL,0},
  {&TA_float,NULL,"p_dt"," time constant for changing the parameter (i_kwta_pt or g_bar.i)","CONDEDIT_OFF_type:NONE DEF_0.1 AKA_pt_dt ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::p_dt))),0,NULL,0},
  {&TA_float,NULL,"mx_d"," maximum deviation (proportion) from initial parameter setting allowed","CONDEDIT_OFF_type:NONE DEF_0.9 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::mx_d))),0,NULL,0},
  {&TA_float,NULL,"l"," proportion of difference from target activation to allocate to the leak in G_BAR_IL mode","CONDEDIT_ON_type:G_BAR_IL ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::l))),0,NULL,0},
  {&TA_float,NULL,"a_dt"," time constant for integrating average average activation, which is basis for adapting i_kwta_pt","CONDEDIT_ON_type:KWTA_PT DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::a_dt))),0,NULL,0},
  NULL};
static int ClampSpec::* TA_ClampSpec_MbrOff;
static MemberDef_data TA_ClampSpec_MemberDef[]={
  {&TA_bool,NULL,"hard"," whether to hard clamp inputs to this layer or not","DEF_true ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::hard))),0,NULL,0},
  {&TA_float,NULL,"gain"," starting soft clamp gain factor (net = gain * ext)","CONDEDIT_OFF_hard:true DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"d_gain"," [Default: 0] for soft clamp, delta to increase gain when target units not > .5 (0 = off, .1 std when used)","CONDEDIT_OFF_hard:true ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::d_gain))),0,NULL,0},
  NULL};
static int DecaySpec::* TA_DecaySpec_MbrOff;
static MemberDef_data TA_DecaySpec_MemberDef[]={
  {&TA_float,NULL,"event"," proportion decay of state vars between events","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::event))),0,NULL,0},
  {&TA_float,NULL,"phase"," proportion decay of state vars between minus and plus phases ","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::phase))),0,NULL,0},
  {&TA_float,NULL,"phase2"," proportion decay of state vars between 2nd set of phases (if appl, 0 std)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::phase2))),0,NULL,0},
  {&TA_bool,NULL,"clamp_phase2"," if true, hard-clamp second plus phase activations to prev plus phase (only special layers will then update -- optimizes speed)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::clamp_phase2))),0,NULL,0},
  NULL};
static int LayNetRescaleSpec::* TA_LayNetRescaleSpec_MbrOff;
static MemberDef_data TA_LayNetRescaleSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to apply layer netinput rescaling","","",
    *((ta_memb_ptr*)&(TA_LayNetRescaleSpec_MbrOff=(int LayNetRescaleSpec::*)(&LayNetRescaleSpec::on))),0,NULL,0},
  {&TA_float,NULL,"max_net"," target maximum netinput value","CONDEDIT_ON_on:true DEF_0.6 ","",
    *((ta_memb_ptr*)&(TA_LayNetRescaleSpec_MbrOff=(int LayNetRescaleSpec::*)(&LayNetRescaleSpec::max_net))),0,NULL,0},
  {&TA_float,NULL,"net_extra"," extra netin value to add to actual to anticipate further increases, preventing too many updates","CONDEDIT_ON_on:true DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_LayNetRescaleSpec_MbrOff=(int LayNetRescaleSpec::*)(&LayNetRescaleSpec::net_extra))),0,NULL,0},
  NULL};
static EnumDef_data TA_SpecPtr_LeabraLayerSpec__Orientation[]={
  {"Horizontal","","",1},
  {"Vertical","","",2},
  NULL};
static EnumDef_data TA_SpecPtr_LeabraLayerSpec__ValType[]={
  {"VT_STRING"," an ANSI string of any length","",0},
  {"VT_DOUBLE"," a 8-byte floating point value (aprox 15 sig decimal digits)","",1},
  {"VT_FLOAT"," a 4-byte floating point value (aprox 7 sig decimal digits)","",2},
  {"VT_INT"," a 32-bit signed integer","",3},
  {"VT_BYTE"," an unsigned 8-bit integer; used mostly for image components (rgb)","",4},
  {"VT_VARIANT"," a Variant, which can hold scalars, matrices, and objects","",5},
  NULL};
static int SpecPtr<LeabraLayerSpec>::* TA_SpecPtr_LeabraLayerSpec__MbrOff;
static MemberDef_data TA_SpecPtr_LeabraLayerSpec__MemberDef[]={
  {NULL,"::LeabraLayerSpec_ptr","spec"," the actual spec itself","","",
    *((ta_memb_ptr*)&(TA_SpecPtr_LeabraLayerSpec__MbrOff=(int SpecPtr<LeabraLayerSpec>::*)(&SpecPtr<LeabraLayerSpec>::spec))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SpecPtr_LeabraLayerSpec__SetSpec_MethArgs[]={
  {&TA_BaseSpec_ptr,NULL,"es",""},
  NULL};
static MethodArgs_data TA_SpecPtr_LeabraLayerSpec__SetDefaultSpec_MethArgs[]={
  {&TA_TAPtr,NULL,"ownr",""},
  NULL};
static MethodDef_data TA_SpecPtr_LeabraLayerSpec__MethodDef[]={
  {&TA_BaseSpec_ptr,NULL,"GetSpec"," get the spec pointer","","",
    0,0,-1,1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__GetSpec_stub,NULL},
  {&TA_void,NULL,"SetSpec"," set the spec pointer","","",
    0,1,-1,1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__SetSpec_stub,TA_SpecPtr_LeabraLayerSpec__SetSpec_MethArgs},
  {&TA_void,NULL,"SetDefaultSpec","","","",
    1,1,-1,0,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__SetDefaultSpec_stub,TA_SpecPtr_LeabraLayerSpec__SetDefaultSpec_MethArgs},
  {&TA_bool,NULL,"CheckSpec","","","",
    1,0,-1,0,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__CheckSpec_stub,NULL},
  {NULL,"::LeabraLayerSpec_ptr","NewChild","","","",
    0,0,-1,1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__NewChild_stub,NULL},
  NULL};
static int AvgMaxVals::* TA_AvgMaxVals_MbrOff;
static MemberDef_data TA_AvgMaxVals_MemberDef[]={
  {&TA_float,NULL,"avg"," average value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::avg))),0,NULL,0},
  {&TA_float,NULL,"max"," maximum value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::max))),0,NULL,0},
  {&TA_int,NULL,"max_i"," index of unit with maximum value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::max_i))),0,NULL,0},
  NULL};
static int KWTAVals::* TA_KWTAVals_MbrOff;
static MemberDef_data TA_KWTAVals_MemberDef[]={
  {&TA_int,NULL,"k"," target number of active units for this collection","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k))),0,NULL,0},
  {&TA_float,NULL,"pct"," actual percent activity in group","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::pct))),0,NULL,0},
  {&TA_float,NULL,"pct_c"," complement of (1.0 - ) actual percent activity in group","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::pct_c))),0,NULL,0},
  {&TA_int,NULL,"adth_k"," adapting threshold k value -- how many units can adapt per time","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::adth_k))),0,NULL,0},
  {&TA_float,NULL,"k_ithr"," inhib threshold for k unit (top k for kwta_avg)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k_ithr))),0,NULL,0},
  {&TA_float,NULL,"k1_ithr"," inhib threshold for k+1 unit (other units for kwta_avg)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k1_ithr))),0,NULL,0},
  {&TA_float,NULL,"ithr_r"," log of ratio of ithr values (indicates signal differentiation)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::ithr_r))),0,NULL,0},
  {&TA_float,NULL,"ithr_diff"," normalized difference ratio for k vs k+1 ithr values: (k_ithr - k1_ithr) / k_ithr","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::ithr_diff))),0,NULL,0},
  {&TA_int,NULL,"tie_brk"," was a tie break operation applied to this layer based on ithr_diff value?","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::tie_brk))),0,NULL,0},
  NULL};
static MethodArgs_data TA_KWTAVals_Compute_Pct_MethArgs[]={
  {&TA_int,NULL,"n_units",""},
  NULL};
static MethodDef_data TA_KWTAVals_MethodDef[]={
  {&TA_void,NULL,"Compute_Pct","","","",
    0,1,-1,0,0,NULL,cssElCFun_KWTAVals_Compute_Pct_stub,TA_KWTAVals_Compute_Pct_MethArgs},
  {&TA_void,NULL,"Compute_IThrR"," compute ithr_r ratio value","","",
    0,0,-1,0,0,NULL,cssElCFun_KWTAVals_Compute_IThrR_stub,NULL},
  NULL};
static int AdaptIVals::* TA_AdaptIVals_MbrOff;
static MemberDef_data TA_AdaptIVals_MemberDef[]={
  {&TA_float,NULL,"avg_avg"," average of the average activation in a layer","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::avg_avg))),0,NULL,0},
  {&TA_float,NULL,"i_kwta_pt"," adapting point to place inhibition between k and k+1 for kwta","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::i_kwta_pt))),0,NULL,0},
  {&TA_float,NULL,"g_bar_i"," adapting g_bar.i value ","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::g_bar_i))),0,NULL,0},
  {&TA_float,NULL,"g_bar_l"," adapting g_bar.l value ","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::g_bar_l))),0,NULL,0},
  NULL};
static int InhibVals::* TA_InhibVals_MbrOff;
static MemberDef_data TA_InhibVals_MemberDef[]={
  {&TA_float,NULL,"kwta"," inhibition due to kwta function","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::kwta))),0,NULL,0},
  {&TA_float,NULL,"g_i"," overall value of the inhibition","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::g_i))),0,NULL,0},
  {&TA_float,NULL,"gp_g_i"," g_i from the layer or unit group, if applicable","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::gp_g_i))),0,NULL,0},
  {&TA_float,NULL,"g_i_orig"," original value of the inhibition (before any layer group effects set in)","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::g_i_orig))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraWizard_StdNetwork_MethArgs[]={
  {&TA_Network_ptr,NULL,"net"," __null"},
  NULL};
static MethodArgs_data TA_LeabraWizard_StdLayerSpecs_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraWizard_SRNContext_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraWizard_UnitInhib_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_inhib_units","10"},
  NULL};
static MethodArgs_data TA_LeabraWizard_TD_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," false"},
  {&TA_bool,NULL,"td_mod_all"," false"},
  NULL};
static MethodArgs_data TA_LeabraWizard_PVLV_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," false"},
  {&TA_bool,NULL,"localist_val"," true"},
  {&TA_bool,NULL,"fm_hid_cons","true"},
  {&TA_bool,NULL,"fm_out_cons","false"},
  {&TA_bool,NULL,"da_mod_all"," false"},
  NULL};
static MethodArgs_data TA_LeabraWizard_BgPFC_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," false"},
  {&TA_bool,NULL,"localist_val"," true"},
  {&TA_bool,NULL,"fm_hid_cons","true"},
  {&TA_bool,NULL,"fm_out_cons","false"},
  {&TA_bool,NULL,"da_mod_all"," false"},
  {&TA_int,NULL,"n_stripes","4"},
  {&TA_bool,NULL,"mat_fm_pfc_full"," false"},
  {&TA_bool,NULL,"out_gate","false"},
  {&TA_bool,NULL,"nolrn_pfc","false"},
  {&TA_bool,NULL,"lr_sched"," true"},
  NULL};
static MethodArgs_data TA_LeabraWizard_SetPFCStripes_MethArgs[]={
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_stripes",""},
  {&TA_int,NULL,"n_units","-1"},
  NULL};
static MethodDef_data TA_LeabraWizard_MethodDef[]={
  {&TA_void,NULL,"StdNetwork"," make a standard network according to the current settings (if net == NULL, new network is created)","MENU_BUTTON MENU_ON_Network NULL_OK ","",
    1,1,0,1,0,NULL,cssElCFun_LeabraWizard_StdNetwork_stub,TA_LeabraWizard_StdNetwork_MethArgs},
  {&TA_void,NULL,"StdProgs"," create a standard set of programs for running the algorithm specified by this project","MENU_BUTTON MENU_ON_Programs CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraWizard_StdProgs_stub,NULL},
  {&TA_void,NULL,"StdLayerSpecs"," make standard layer specs for a basic Leabra network (KWTA_AVG 25% for hiddens, KWTA PAT_K for input/output)","MENU_BUTTON MENU_ON_Network MENU_SEP_BEFORE ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraWizard_StdLayerSpecs_stub,TA_LeabraWizard_StdLayerSpecs_MethArgs},
  {&TA_void,NULL,"SRNContext"," configure a simple-recurrent-network context layer in the network","MENU_BUTTON ","",
    0,1,-1,1,0,NULL,cssElCFun_LeabraWizard_SRNContext_stub,TA_LeabraWizard_SRNContext_MethArgs},
  {&TA_void,NULL,"UnitInhib"," configures unit-based inhibition for all layers in the network","MENU_BUTTON ","",
    0,2,1,1,0,NULL,cssElCFun_LeabraWizard_UnitInhib_stub,TA_LeabraWizard_UnitInhib_MethArgs},
  {&TA_void,NULL,"TD"," configure standard TD reinforcement learning layers; bio_labels = use biologically-based labels for layers, else functional; td_mod_all = have td value modulate all the regular units in the network","MENU_BUTTON MENU_SEP_BEFORE ","",
    0,3,1,1,0,NULL,cssElCFun_LeabraWizard_TD_stub,TA_LeabraWizard_TD_MethArgs},
  {&TA_void,NULL,"PVLV"," configure PVLV (pavlovian perceived value and local value) learning layers in a network; bio_labels = use biologically-based labels for layers, else functional; localist_val = use localist value representations for lvpv layers; da_mod_all = have da value modulate all the regular units in the network","MENU_BUTTON ","",
    0,6,1,1,0,NULL,cssElCFun_LeabraWizard_PVLV_stub,TA_LeabraWizard_PVLV_MethArgs},
  {&TA_void,NULL,"BgPFC"," configure all the layers and specs for doing basal-ganglia based gating of the pfc layer; bio_labels = label layers with biological, else functional, names; localist_val = use localist value representations for lvpv layers; fm_hid_cons = make cons to pfc/bg fm hidden layers; fm_out_cons = from output layers; mat_fm_pfc_full = make pfc -> matrix prjn full (else stripe-specific); out_gate = each PFC layer has separate output gated layer and corresponding matrix output gates; patch per-stripe learning system optional; nolrn_pfc = pfc does not learn -- just copies input acts directly; da_mod_all = have da value modulate all the regular units in the network; lr_sched = make a learning rate schedule on BG learn cons","MENU_BUTTON MENU_SEP_BEFORE ","",
    0,11,1,1,0,NULL,cssElCFun_LeabraWizard_BgPFC_stub,TA_LeabraWizard_BgPFC_MethArgs},
  {&TA_void,NULL,"SetPFCStripes"," set number of 'stripes' (unit groups) throughout the entire set of pfc/bg layers (n_units = -1 = use current of units)","MENU_BUTTON  ","",
    0,3,2,1,0,NULL,cssElCFun_LeabraWizard_SetPFCStripes_stub,TA_LeabraWizard_SetPFCStripes_MethArgs},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_MarkerConSpec_MethodDef[]={
  {&TA_float,NULL,"Compute_Net","","","",
    1,2,-1,0,0,NULL,cssElCFun_MarkerConSpec_Compute_Net_stub,TA_MarkerConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"Send_Net","","","",
    1,2,-1,0,0,NULL,cssElCFun_MarkerConSpec_Send_Net_stub,TA_MarkerConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_MarkerConSpec_Compute_dWt_stub,TA_MarkerConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights","","","",
    1,2,-1,0,0,NULL,cssElCFun_MarkerConSpec_UpdateWeights_stub,TA_MarkerConSpec_UpdateWeights_MethArgs},
  {&TA_bool,NULL,"DMem_AlwaysLocal"," overload this function to prevent this projection from being pruned for non-local units under dmem processing (for 'special' connection types) these connections always need to be there on all nodes..","CAT_DMem ","",
    0,0,-1,1,0,NULL,cssElCFun_MarkerConSpec_DMem_AlwaysLocal_stub,NULL},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,2,-1,0,0,NULL,cssElCFun_MarkerConSpec_Send_NetDelta_stub,TA_MarkerConSpec_Send_NetDelta_MethArgs},
  NULL};
static int CtxtUpdateSpec::* TA_CtxtUpdateSpec_MbrOff;
static MemberDef_data TA_CtxtUpdateSpec_MemberDef[]={
  {&TA_float,NULL,"fm_hid"," from hidden (inputs to context layer)","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::fm_hid))),0,NULL,0},
  {&TA_float,NULL,"fm_prv"," from previous context layer values (maintenance)","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::fm_prv))),0,NULL,0},
  {&TA_float,NULL,"to_out"," outputs from context layer","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::to_out))),0,NULL,0},
  NULL};
static int LeabraContextLayerSpec::* TA_LeabraContextLayerSpec_MbrOff;
static MemberDef_data TA_LeabraContextLayerSpec_MemberDef[]={
  {&TA_CtxtUpdateSpec,NULL,"updt"," ctxt updating constants: from hidden, from previous values (hysteresis), outputs from context (n/a on simple gate layer)","","",
    *((ta_memb_ptr*)&(TA_LeabraContextLayerSpec_MbrOff=(int LeabraContextLayerSpec::*)(&LeabraContextLayerSpec::updt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraContextLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraContextLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraContextLayerSpec_Compute_Context_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_LeabraContextLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_LeabraContextLayerSpec_CheckConfig_stub,TA_LeabraContextLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs clamp from act_p values of sending layer","","",
    0,2,-1,1,0,NULL,cssElCFun_LeabraContextLayerSpec_Compute_HardClamp_stub,TA_LeabraContextLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraContextLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_Context"," get context source value for given context unit","","",
    0,3,-1,1,0,NULL,cssElCFun_LeabraContextLayerSpec_Compute_Context_stub,TA_LeabraContextLayerSpec_Compute_Context_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraLinUnitSpec_Compute_ActFmVm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_LeabraLinUnitSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_ActFmVm"," compute the activation from membrane potential","","",
    0,4,-1,1,0,NULL,cssElCFun_LeabraLinUnitSpec_Compute_ActFmVm_stub,TA_LeabraLinUnitSpec_Compute_ActFmVm_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LeabraLinUnitSpec_Defaults_stub,NULL},
  NULL};
static int LeabraNegBiasSpec::* TA_LeabraNegBiasSpec_MbrOff;
static MemberDef_data TA_LeabraNegBiasSpec_MemberDef[]={
  {&TA_float,NULL,"decay"," rate of weight decay towards zero ","","",
    *((ta_memb_ptr*)&(TA_LeabraNegBiasSpec_MbrOff=(int LeabraNegBiasSpec::*)(&LeabraNegBiasSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"updt_immed"," update weights immediately when weights are changed","","",
    *((ta_memb_ptr*)&(TA_LeabraNegBiasSpec_MbrOff=(int LeabraNegBiasSpec::*)(&LeabraNegBiasSpec::updt_immed))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraNegBiasSpec_B_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraNegBiasSpec_B_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodDef_data TA_LeabraNegBiasSpec_MethodDef[]={
  {&TA_void,NULL,"B_Compute_dWt","","","",
    0,2,-1,0,0,NULL,cssElCFun_LeabraNegBiasSpec_B_Compute_dWt_stub,TA_LeabraNegBiasSpec_B_Compute_dWt_MethArgs},
  {&TA_void,NULL,"B_UpdateWeights","","","",
    0,3,-1,0,0,NULL,cssElCFun_LeabraNegBiasSpec_B_UpdateWeights_stub,TA_LeabraNegBiasSpec_B_UpdateWeights_MethArgs},
  NULL};
static int TrialSynDepCon::* TA_TrialSynDepCon_MbrOff;
static MemberDef_data TA_TrialSynDepCon_MemberDef[]={
  {&TA_float,NULL,"effwt"," effective weight value (can be depressed) -- used for sending ativation","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_TrialSynDepCon_MbrOff=(int TrialSynDepCon::*)(&TrialSynDepCon::effwt))),0,NULL,0},
  NULL};
static int SynDepSpec::* TA_SynDepSpec_MbrOff;
static MemberDef_data TA_SynDepSpec_MemberDef[]={
  {&TA_float,NULL,"rec"," rate of recovery from depression","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_SynDepSpec_MbrOff=(int SynDepSpec::*)(&SynDepSpec::rec))),0,NULL,0},
  {&TA_float,NULL,"depl"," rate of depletion of synaptic efficacy as a function of sender-receiver activations","DEF_1.1 ","",
    *((ta_memb_ptr*)&(TA_SynDepSpec_MbrOff=(int SynDepSpec::*)(&SynDepSpec::depl))),0,NULL,0},
  NULL};
static int TrialSynDepConSpec::* TA_TrialSynDepConSpec_MbrOff;
static MemberDef_data TA_TrialSynDepConSpec_MemberDef[]={
  {&TA_SynDepSpec,NULL,"syn_dep"," synaptic depression specifications","","",
    *((ta_memb_ptr*)&(TA_TrialSynDepConSpec_MbrOff=(int TrialSynDepConSpec::*)(&TrialSynDepConSpec::syn_dep))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Compute_Net_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_InitWtState_Post_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Depress_Wt_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Depress_Wt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Reset_EffWt_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Reset_EffWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  NULL};
static MethodDef_data TA_TrialSynDepConSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_TrialSynDepConSpec_UpdateAfterEdit_stub,NULL},
  {&TA_float,NULL,"C_Compute_Net","","","",
    2,3,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Compute_Net_stub,TA_TrialSynDepConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net","","","",
    1,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Compute_Net_stub,TA_TrialSynDepConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    2,4,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_Net_stub,TA_TrialSynDepConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net","","","",
    1,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Send_Net_stub,TA_TrialSynDepConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Compute_dWt_stub,TA_TrialSynDepConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,4,-1,1,0,NULL,cssElCFun_TrialSynDepConSpec_C_InitWtState_Post_stub,TA_TrialSynDepConSpec_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"C_Send_Inhib","","","",
    1,4,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_Inhib_stub,TA_TrialSynDepConSpec_C_Send_Inhib_MethArgs},
  {&TA_void,NULL,"Send_Inhib","","","",
    0,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Send_Inhib_stub,TA_TrialSynDepConSpec_Send_Inhib_MethArgs},
  {&TA_void,NULL,"C_Send_NetDelta","","","",
    1,4,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_NetDelta_stub,TA_TrialSynDepConSpec_C_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Send_NetDelta_stub,TA_TrialSynDepConSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"C_Send_InhibDelta","","","",
    1,4,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_InhibDelta_stub,TA_TrialSynDepConSpec_C_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"Send_InhibDelta","","","",
    0,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Send_InhibDelta_stub,TA_TrialSynDepConSpec_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"C_Send_ClampNet","","","",
    1,4,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_ClampNet_stub,TA_TrialSynDepConSpec_C_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,2,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_Send_ClampNet_stub,TA_TrialSynDepConSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"C_Depress_Wt","","","",
    0,3,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Depress_Wt_stub,TA_TrialSynDepConSpec_C_Depress_Wt_MethArgs},
  {&TA_void,NULL,"Depress_Wt","","","",
    0,2,-1,1,0,NULL,cssElCFun_TrialSynDepConSpec_Depress_Wt_stub,TA_TrialSynDepConSpec_Depress_Wt_MethArgs},
  {&TA_void,NULL,"C_Reset_EffWt","","","",
    0,1,-1,0,0,NULL,cssElCFun_TrialSynDepConSpec_C_Reset_EffWt_stub,TA_TrialSynDepConSpec_C_Reset_EffWt_MethArgs},
  {&TA_void,NULL,"Reset_EffWt","","","",
    0,1,-1,1,0,NULL,cssElCFun_TrialSynDepConSpec_Reset_EffWt_stub,TA_TrialSynDepConSpec_Reset_EffWt_MethArgs},
  NULL};
static int FastWtCon::* TA_FastWtCon_MbrOff;
static MemberDef_data TA_FastWtCon_MemberDef[]={
  {&TA_float,NULL,"swt"," slow weight value","","",
    *((ta_memb_ptr*)&(TA_FastWtCon_MbrOff=(int FastWtCon::*)(&FastWtCon::swt))),0,NULL,0},
  {&TA_float,NULL,"sdwt"," slow weight delta-weight change","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_FastWtCon_MbrOff=(int FastWtCon::*)(&FastWtCon::sdwt))),0,NULL,0},
  NULL};
static EnumDef_data TA_FastWtSpec_DecayMode[]={
  {"ALWAYS"," always decay all weights toward slow weight (swt)","",0},
  {"SU_PROP"," decay in proportion to the sending unit activation: decay only happens after sending activity dissipates","",1},
  {"SU_THR"," decay only weights with sending unit activations below sending threshold (nom .1): decay only happens after sending activity dissipates","",2},
  NULL};
static int FastWtSpec::* TA_FastWtSpec_MbrOff;
static MemberDef_data TA_FastWtSpec_MemberDef[]={
  {&TA_float,NULL,"lrate"," learning rate","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::lrate))),0,NULL,0},
  {&TA_bool,NULL,"use_lrs"," use learning rate schedule to modify cur_lrate learning rate?","DEF_false ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::use_lrs))),0,NULL,0},
  {&TA_float,NULL,"cur_lrate"," current learning rate with lrate schedule factored in","READ_ONLY NO_INHERIT SHOW ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::cur_lrate))),0,NULL,0},
  {&TA_float,NULL,"decay"," rate of decay toward the slow weight values","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"slw_sat"," does fast weight contribute to saturation of slow weights?","DEF_true ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::slw_sat))),0,NULL,0},
  {NULL,"::DecayMode","dk_mode"," how to apply the decay of fast weights back to the slow weight (swt) value","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::dk_mode))),0,NULL,0},
  NULL};
static int FastWtConSpec::* TA_FastWtConSpec_MbrOff;
static MemberDef_data TA_FastWtConSpec_MemberDef[]={
  {&TA_FastWtSpec,NULL,"fast_wt"," fast weight specs: fast weights are added in separately to overall weight value as an increment (","","",
    *((ta_memb_ptr*)&(TA_FastWtConSpec_MbrOff=(int FastWtConSpec::*)(&FastWtConSpec::fast_wt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_InitWtState_Post_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_UpdateWeightsActReg_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowHebb_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowErr_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"su_act_m",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowdWt_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_FastDecay_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_FastWtConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_InitWtDelta_stub,TA_FastWtConSpec_C_InitWtDelta_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt","","","",
    1,4,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_Compute_dWt_stub,TA_FastWtConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_FastWtConSpec_Compute_dWt_stub,TA_FastWtConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights","","","",
    2,5,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_UpdateWeights_stub,TA_FastWtConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights","","","",
    1,2,-1,0,0,NULL,cssElCFun_FastWtConSpec_UpdateWeights_stub,TA_FastWtConSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,4,-1,1,0,NULL,cssElCFun_FastWtConSpec_C_InitWtState_Post_stub,TA_FastWtConSpec_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"C_UpdateWeightsActReg","","","",
    1,5,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_UpdateWeightsActReg_stub,TA_FastWtConSpec_C_UpdateWeightsActReg_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on schedule given epoch (or error value)","","",
    0,2,-1,1,0,NULL,cssElCFun_FastWtConSpec_SetCurLrate_stub,TA_FastWtConSpec_SetCurLrate_MethArgs},
  {&TA_float,NULL,"C_Compute_SlowHebb"," todo: somewhat inefficient to do this computation twice..","","",
    0,4,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowHebb_stub,TA_FastWtConSpec_C_Compute_SlowHebb_MethArgs},
  {&TA_float,NULL,"C_Compute_SlowErr","","","",
    0,5,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowErr_stub,TA_FastWtConSpec_C_Compute_SlowErr_MethArgs},
  {&TA_void,NULL,"C_Compute_SlowdWt"," combine hebbian and error-driven","","",
    0,4,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowdWt_stub,TA_FastWtConSpec_C_Compute_SlowdWt_MethArgs},
  {&TA_void,NULL,"C_Compute_FastDecay","","","",
    0,3,-1,0,0,NULL,cssElCFun_FastWtConSpec_C_Compute_FastDecay_stub,TA_FastWtConSpec_C_Compute_FastDecay_MethArgs},
  NULL};
static int ActAvgHebbMixSpec::* TA_ActAvgHebbMixSpec_MbrOff;
static MemberDef_data TA_ActAvgHebbMixSpec_MemberDef[]={
  {&TA_float,NULL,"act_avg"," what proportion of average activation to include in hebbian receiving unit activation learning term","","",
    *((ta_memb_ptr*)&(TA_ActAvgHebbMixSpec_MbrOff=(int ActAvgHebbMixSpec::*)(&ActAvgHebbMixSpec::act_avg))),0,NULL,0},
  {&TA_float,NULL,"cur_act"," 1.0 - act_avg -- proportion of current activation for hebbian learning","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_ActAvgHebbMixSpec_MbrOff=(int ActAvgHebbMixSpec::*)(&ActAvgHebbMixSpec::cur_act))),0,NULL,0},
  NULL};
static MethodDef_data TA_ActAvgHebbMixSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_ActAvgHebbMixSpec_UpdateAfterEdit_stub,NULL},
  NULL};
static int ActAvgHebbConSpec::* TA_ActAvgHebbConSpec_MbrOff;
static MemberDef_data TA_ActAvgHebbConSpec_MemberDef[]={
  {&TA_ActAvgHebbMixSpec,NULL,"act_avg_hebb"," hebbian learning that includes a proportion of average activation over time, in addition to standard current unit activation; produces a trace-based learning effect for learning over trajectories","","",
    *((ta_memb_ptr*)&(TA_ActAvgHebbConSpec_MbrOff=(int ActAvgHebbConSpec::*)(&ActAvgHebbConSpec::act_avg_hebb))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ActAvgHebbConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_ActAvgHebbConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  {&TA_float,NULL,"ru_avg_act",""},
  NULL};
static MethodDef_data TA_ActAvgHebbConSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_ActAvgHebbConSpec_UpdateAfterEdit_stub,NULL},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_ActAvgHebbConSpec_Compute_dWt_stub,TA_ActAvgHebbConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," this computes weight changes based on sender at time t-1","","",
    1,5,-1,0,0,NULL,cssElCFun_ActAvgHebbConSpec_C_Compute_Hebb_stub,TA_ActAvgHebbConSpec_C_Compute_Hebb_MethArgs},
  NULL};
static EnumDef_data TA_ScalarValSpec_RepType[]={
  {"GAUSSIAN"," gaussian bump, with value = weighted average of tuned unit values","",0},
  {"LOCALIST"," each unit represents a distinct value; intermediate values represented by graded activity of neighbors; overall activity is weighted-average across all units","",1},
  {"SUM_BAR"," bar of increasing activation threshold across units, with value = sum of overall activation. This has more natural activation dynamics than GAUSSIAN","",2},
  NULL};
static int ScalarValSpec::* TA_ScalarValSpec_MbrOff;
static MemberDef_data TA_ScalarValSpec_MemberDef[]={
  {NULL,"::RepType","rep"," type of representation of scalar value to use","","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::rep))),0,NULL,0},
  {&TA_float,NULL,"un_width"," sigma parameter of a gaussian specifying the tuning width of the coarse-coded units (in min-max units)","CONDEDIT_ON_rep:GAUSSIAN ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::un_width))),0,NULL,0},
  {&TA_float,NULL,"min_net"," minimum netinput value for purposes of computing gc.i in sum_bar","CONDEDIT_ON_rep:SUM_BAR DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min_net))),0,NULL,0},
  {&TA_bool,NULL,"clamp_pat"," if true, environment provides full set of values to clamp over entire layer (instead of providing single scalar value to clamp on 1st unit, which then generates a corresponding distributed pattern)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::clamp_pat))),0,NULL,0},
  {&TA_float,NULL,"min_sum_act"," minimum total activity of all the units representing a value: when computing weighted average value, this is used as a minimum for the sum that you divide by","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min_sum_act))),0,NULL,0},
  {&TA_bool,NULL,"val_mult_lrn"," for learning, effectively multiply the learning rate by the minus-plus phase difference in overall represented value (i.e., if overall value is the same, no learning takes place)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::val_mult_lrn))),0,NULL,0},
  {&TA_float,NULL,"min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min))),0,NULL,0},
  {&TA_float,NULL,"range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::range))),0,NULL,0},
  {&TA_float,NULL,"val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::val))),0,NULL,0},
  {&TA_float,NULL,"incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::incr))),0,NULL,0},
  {&TA_int,NULL,"sb_lt"," sum_bar lower threshold index (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::sb_lt))),0,NULL,0},
  {&TA_float,NULL,"sb_ev"," sum_bar 'edge' unit value (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::sb_ev))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValSpec_InitVal_MethArgs[]={
  {&TA_float,NULL,"sval",""},
  {&TA_int,NULL,"ugp_size",""},
  {&TA_float,NULL,"umin",""},
  {&TA_float,NULL,"urng",""},
  NULL};
static MethodArgs_data TA_ScalarValSpec_GetUnitAct_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodArgs_data TA_ScalarValSpec_GetUnitVal_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodDef_data TA_ScalarValSpec_MethodDef[]={
  {&TA_void,NULL,"InitVal"," initialize implementational values for subsequently computing GetUnitAct to represent scalar val sval over unit group of ugp_size","","",
    0,4,-1,1,0,NULL,cssElCFun_ScalarValSpec_InitVal_stub,TA_ScalarValSpec_InitVal_MethArgs},
  {&TA_float,NULL,"GetUnitAct"," get activation under current representation for unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValSpec_GetUnitAct_stub,TA_ScalarValSpec_GetUnitAct_MethArgs},
  {&TA_float,NULL,"GetUnitVal"," get target value associated with unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValSpec_GetUnitVal_stub,TA_ScalarValSpec_GetUnitVal_MethArgs},
  NULL};
static EnumDef_data TA_ScalarValBias_UnitBias[]={
  {"NO_UN"," no unit bias","",0},
  {"GC"," bias value enters as a conductance in gc.h or gc.a","",1},
  {"BWT"," bias value enters as a bias.wt","",2},
  NULL};
static EnumDef_data TA_ScalarValBias_BiasShape[]={
  {"VAL"," bias as a particular value representation","",0},
  {"NEG_SLP"," bias as an increasingly negative slope (gc.a or -bwt) as unit values increase","",1},
  {"POS_SLP"," bias as an increasingly positive slope (gc.h or +bwt) as unit values increase","",2},
  NULL};
static EnumDef_data TA_ScalarValBias_WeightBias[]={
  {"NO_WT"," no weight bias","",0},
  {"WT"," input weights","",1},
  NULL};
static int ScalarValBias::* TA_ScalarValBias_MbrOff;
static MemberDef_data TA_ScalarValBias_MemberDef[]={
  {NULL,"::UnitBias","un"," bias on individual units","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un))),0,NULL,0},
  {NULL,"::BiasShape","un_shp"," shape of unit bias","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un_shp))),0,NULL,0},
  {&TA_float,NULL,"un_gain"," gain multiplier (strength) of bias to apply for units. WT = .03 as basic weight multiplier","CONDEDIT_OFF_un:NO_UN DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un_gain))),0,NULL,0},
  {NULL,"::WeightBias","wt"," bias on weights: always uses a val-shaped bias","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::wt))),0,NULL,0},
  {&TA_float,NULL,"wt_gain"," gain multiplier (strength) of bias to apply for weights (gain 1 = .03 wt value)","CONDEDIT_OFF_wt:NO_WT DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::wt_gain))),0,NULL,0},
  {&TA_float,NULL,"val"," value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::val))),0,NULL,0},
  NULL};
static int ScalarValLayerSpec::* TA_ScalarValLayerSpec_MbrOff;
static MemberDef_data TA_ScalarValLayerSpec_MemberDef[]={
  {&TA_ScalarValSpec,NULL,"scalar"," specifies how values are represented in terms of distributed patterns of activation across the layer","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::scalar))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"unit_range"," range of values represented across the units; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::unit_range))),0,NULL,0},
  {&TA_ScalarValBias,NULL,"bias_val"," specifies bias for given value (as gaussian bump) ","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::bias_val))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::val_range))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_InitWtState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_Inhib_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_ActAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_ActMAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_ActPAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ClampValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"rescale","1.0f"},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ClampAvgAct_MethArgs[]={
  {&TA_int,NULL,"ugp_size",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ReadValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ResetAfterClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_HardClampExt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnits_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnits_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnitsNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_WtBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_NegSlp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_PosSlp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_BiasVal_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_dWtUgp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ReConfig_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_units"," -1"},
  NULL};
static MethodDef_data TA_ScalarValLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_ScalarValLayerSpec_CheckConfig_stub,TA_ScalarValLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitWtState"," initialize weight values and other permanent state","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_InitWtState_stub,TA_ScalarValLayerSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_HardClamp_stub,TA_ScalarValLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," prior to settling: compute netinput scaling values","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_NetScale_stub,TA_ScalarValLayerSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_impl"," implementation of inhibition computation for either layer or unit group","","",
    0,4,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_Inhib_impl_stub,TA_ScalarValLayerSpec_Compute_Inhib_impl_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_ActAvg_ugp_stub,TA_ScalarValLayerSpec_Compute_ActAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_ActMAvg_ugp_stub,TA_ScalarValLayerSpec_Compute_ActMAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_ActPAvg_ugp_stub,TA_ScalarValLayerSpec_Compute_ActPAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl"," don't include first unit in any of these computations!","","",
    0,4,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_Act_impl_stub,TA_ScalarValLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_dWt_stub,TA_ScalarValLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ClampValue"," clamp value in the first unit's ext field to the units in the group","","",
    0,3,2,1,0,NULL,cssElCFun_ScalarValLayerSpec_ClampValue_stub,TA_ScalarValLayerSpec_ClampValue_MethArgs},
  {&TA_float,NULL,"ClampAvgAct"," computes the average activation for a clamped unit pattern (for computing rescaling)","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_ClampAvgAct_stub,TA_ScalarValLayerSpec_ClampAvgAct_MethArgs},
  {&TA_float,NULL,"ReadValue"," read out current value represented by activations in layer","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_ReadValue_stub,TA_ScalarValLayerSpec_ReadValue_MethArgs},
  {&TA_void,NULL,"ResetAfterClamp"," reset activation of first unit(s) after hard clamping","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_ResetAfterClamp_stub,TA_ScalarValLayerSpec_ResetAfterClamp_MethArgs},
  {&TA_void,NULL,"HardClampExt"," hard clamp current ext values (on all units, after ClampValue called) to all the units","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_HardClampExt_stub,TA_ScalarValLayerSpec_HardClampExt_MethArgs},
  {&TA_void,NULL,"LabelUnits_impl"," label units with their underlying values","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnits_impl_stub,TA_ScalarValLayerSpec_LabelUnits_impl_MethArgs},
  {&TA_void,NULL,"LabelUnits"," label units in given layer with their underlying values","BUTTON ","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnits_stub,TA_ScalarValLayerSpec_LabelUnits_MethArgs},
  {&TA_void,NULL,"LabelUnitsNet"," label all layers in given network using this spec","BUTTON ","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnitsNet_stub,TA_ScalarValLayerSpec_LabelUnitsNet_MethArgs},
  {&TA_void,NULL,"Compute_WtBias_Val","","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_WtBias_Val_stub,TA_ScalarValLayerSpec_Compute_WtBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_Val","","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_Val_stub,TA_ScalarValLayerSpec_Compute_UnBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_NegSlp","","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_NegSlp_stub,TA_ScalarValLayerSpec_Compute_UnBias_NegSlp_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_PosSlp","","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_PosSlp_stub,TA_ScalarValLayerSpec_Compute_UnBias_PosSlp_MethArgs},
  {&TA_void,NULL,"Compute_BiasVal"," initialize the bias value ","","",
    0,1,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_BiasVal_stub,TA_ScalarValLayerSpec_Compute_BiasVal_MethArgs},
  {&TA_void,NULL,"Compute_dWtUgp"," compute weight changes just for one unit group","","",
    0,3,-1,1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_dWtUgp_stub,TA_ScalarValLayerSpec_Compute_dWtUgp_MethArgs},
  {&TA_void,NULL,"ReConfig"," reconfigure layer and associated specs for current scalar.rep type; if n_units > 0, changes number of units in layer to specified value","BUTTON ","",
    0,2,1,1,0,NULL,cssElCFun_ScalarValLayerSpec_ReConfig_stub,TA_ScalarValLayerSpec_ReConfig_MethArgs},
  NULL};
static int ScalarValSelfPrjnSpec::* TA_ScalarValSelfPrjnSpec_MbrOff;
static MemberDef_data TA_ScalarValSelfPrjnSpec_MemberDef[]={
  {&TA_int,NULL,"width"," width of neighborhood, in units (i.e., connect width units to the left, and width units to the right)","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::width))),0,NULL,0},
  {&TA_float,NULL,"wt_width"," width of the sigmoid for providing initial weight values","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::wt_width))),0,NULL,0},
  {&TA_float,NULL,"wt_max"," maximum weight value (of 1st neighbor -- not of self unit!)","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::wt_max))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_Connect_impl_MethArgs[]={
  {&TA_Projection_ptr,NULL,"prjn",""},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_C_InitWtState_MethArgs[]={
  {&TA_Projection_ptr,NULL,"prjn",""},
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_Connect_UnitGroup_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"gp",""},
  {&TA_Projection_ptr,NULL,"prjn",""},
  NULL};
static MethodDef_data TA_ScalarValSelfPrjnSpec_MethodDef[]={
  {&TA_void,NULL,"Connect_impl","","","",
    1,1,-1,0,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_Connect_impl_stub,TA_ScalarValSelfPrjnSpec_Connect_impl_MethArgs},
  {&TA_void,NULL,"C_InitWtState"," uses weight values as specified in the tesselel's","","",
    1,3,-1,0,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_C_InitWtState_stub,TA_ScalarValSelfPrjnSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"Connect_UnitGroup","","","",
    0,2,-1,1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_Connect_UnitGroup_stub,TA_ScalarValSelfPrjnSpec_Connect_UnitGroup_MethArgs},
  NULL};
static EnumDef_data TA_TwoDValSpec_RepType[]={
  {"GAUSSIAN"," gaussian bump, with value = weighted average of tuned unit values","",0},
  {"LOCALIST"," each unit represents a distinct value; intermediate values represented by graded activity of neighbors; overall activity is weighted-average across all units","",1},
  NULL};
static int TwoDValSpec::* TA_TwoDValSpec_MbrOff;
static MemberDef_data TA_TwoDValSpec_MemberDef[]={
  {NULL,"::RepType","rep"," type of representation of scalar value to use","","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::rep))),0,NULL,0},
  {&TA_int,NULL,"n_vals"," number of values to represent in layer: layer geom.x must be >= 2 * n_vals because vals are represented in first row of layer!","","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::n_vals))),0,NULL,0},
  {&TA_float,NULL,"un_width"," sigma parameter of a gaussian specifying the tuning width of the coarse-coded units (in min-max units)","CONDEDIT_ON_rep:GAUSSIAN ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::un_width))),0,NULL,0},
  {&TA_bool,NULL,"clamp_pat"," if true, environment provides full set of values to clamp over entire layer (instead of providing single scalar value to clamp on 1st unit, which then generates a corresponding distributed pattern)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::clamp_pat))),0,NULL,0},
  {&TA_float,NULL,"min_sum_act"," minimum total activity of all the units representing a value: when computing weighted average value, this is used as a minimum for the sum that you divide by","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::min_sum_act))),0,NULL,0},
  {&TA_float,NULL,"mn_dst"," minimum distance factor for reading out multiple bumps: must be at least this times un_width far away from other bumps","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::mn_dst))),0,NULL,0},
  {&TA_float,NULL,"x_min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_min))),0,NULL,0},
  {&TA_float,NULL,"x_range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_range))),0,NULL,0},
  {&TA_float,NULL,"y_min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_min))),0,NULL,0},
  {&TA_float,NULL,"y_range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_range))),0,NULL,0},
  {&TA_float,NULL,"x_val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_val))),0,NULL,0},
  {&TA_float,NULL,"y_val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_val))),0,NULL,0},
  {&TA_float,NULL,"x_incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_incr))),0,NULL,0},
  {&TA_float,NULL,"y_incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_incr))),0,NULL,0},
  {&TA_int,NULL,"x_size"," size of axis","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_size))),0,NULL,0},
  {&TA_int,NULL,"y_size"," size of axis","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_size))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TwoDValSpec_InitVal_MethArgs[]={
  {&TA_float,NULL,"xval",""},
  {&TA_float,NULL,"yval",""},
  {&TA_int,NULL,"xsize",""},
  {&TA_int,NULL,"ysize",""},
  {&TA_float,NULL,"xmin",""},
  {&TA_float,NULL,"xrng",""},
  {&TA_float,NULL,"ymin",""},
  {&TA_float,NULL,"yrng",""},
  NULL};
static MethodArgs_data TA_TwoDValSpec_GetUnitAct_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodArgs_data TA_TwoDValSpec_GetUnitVal_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  {&TA_float_ref,NULL,"x_cur",""},
  {&TA_float_ref,NULL,"y_cur",""},
  NULL};
static MethodDef_data TA_TwoDValSpec_MethodDef[]={
  {&TA_void,NULL,"InitVal"," initialize implementational values for subsequently computing GetUnitAct to represent scalar val sval over unit group of ugp_size","","",
    0,8,-1,1,0,NULL,cssElCFun_TwoDValSpec_InitVal_stub,TA_TwoDValSpec_InitVal_MethArgs},
  {&TA_float,NULL,"GetUnitAct"," get activation under current representation for unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,1,0,NULL,cssElCFun_TwoDValSpec_GetUnitAct_stub,TA_TwoDValSpec_GetUnitAct_MethArgs},
  {&TA_void,NULL,"GetUnitVal"," get target values associated with unit at given index: MUST CALL InitVal first!","","",
    0,3,-1,1,0,NULL,cssElCFun_TwoDValSpec_GetUnitVal_stub,TA_TwoDValSpec_GetUnitVal_MethArgs},
  NULL};
static EnumDef_data TA_TwoDValBias_UnitBias[]={
  {"NO_UN"," no unit bias","",0},
  {"GC"," bias value enters as a conductance in gc.h or gc.a","",1},
  {"BWT"," bias value enters as a bias.wt","",2},
  NULL};
static EnumDef_data TA_TwoDValBias_WeightBias[]={
  {"NO_WT"," no weight bias","",0},
  {"WT"," input weights","",1},
  NULL};
static int TwoDValBias::* TA_TwoDValBias_MbrOff;
static MemberDef_data TA_TwoDValBias_MemberDef[]={
  {NULL,"::UnitBias","un"," bias on individual units","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::un))),0,NULL,0},
  {&TA_float,NULL,"un_gain"," gain multiplier (strength) of bias to apply for units. WT = .03 as basic weight multiplier","CONDEDIT_OFF_un:NO_UN DEF_1 ","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::un_gain))),0,NULL,0},
  {NULL,"::WeightBias","wt"," bias on weights: always uses a val-shaped bias","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::wt))),0,NULL,0},
  {&TA_float,NULL,"wt_gain"," gain multiplier (strength) of bias to apply for weights (gain 1 = .03 wt value)","CONDEDIT_OFF_wt:NO_WT DEF_1 ","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::wt_gain))),0,NULL,0},
  {&TA_float,NULL,"x_val"," X axis value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::x_val))),0,NULL,0},
  {&TA_float,NULL,"y_val"," Y axis value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::y_val))),0,NULL,0},
  NULL};
static int TwoDValLayerSpec::* TA_TwoDValLayerSpec_MbrOff;
static MemberDef_data TA_TwoDValLayerSpec_MemberDef[]={
  {&TA_TwoDValSpec,NULL,"twod"," specifies how values are represented in terms of distributed patterns of activation across the layer","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::twod))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"x_range"," range of values represented across the X (horizontal) axis; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::x_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"y_range"," range of values represented across the Y (vertical) axis; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::y_range))),0,NULL,0},
  {&TA_TwoDValBias,NULL,"bias_val"," specifies bias values","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::bias_val))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"x_val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::x_val_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"y_val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::y_val_range))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_InitWtState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_ActAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_ActMAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_ActPAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ClampValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"rescale","1.0f"},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ReadValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ResetAfterClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_HardClampExt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_LabelUnits_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_LabelUnits_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_LabelUnitsNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_WtBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"x_val",""},
  {&TA_float,NULL,"y_val",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_UnBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"x_val",""},
  {&TA_float,NULL,"y_val",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_BiasVal_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_dWtUgp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ReConfig_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_units"," -1"},
  NULL};
static MethodDef_data TA_TwoDValLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_TwoDValLayerSpec_CheckConfig_stub,TA_TwoDValLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitWtState"," initialize weight values and other permanent state","","",
    0,1,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_InitWtState_stub,TA_TwoDValLayerSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_HardClamp_stub,TA_TwoDValLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," prior to settling: compute netinput scaling values","","",
    0,2,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_NetScale_stub,TA_TwoDValLayerSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_ActAvg_ugp_stub,TA_TwoDValLayerSpec_Compute_ActAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_ActMAvg_ugp_stub,TA_TwoDValLayerSpec_Compute_ActMAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg_ugp","","","",
    0,4,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_ActPAvg_ugp_stub,TA_TwoDValLayerSpec_Compute_ActPAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl"," don't include first unit in any of these computations!","","",
    0,4,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_Act_impl_stub,TA_TwoDValLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_dWt_stub,TA_TwoDValLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ClampValue"," clamp value in the first unit's ext field to the units in the group","","",
    0,3,2,1,0,NULL,cssElCFun_TwoDValLayerSpec_ClampValue_stub,TA_TwoDValLayerSpec_ClampValue_MethArgs},
  {&TA_void,NULL,"ReadValue"," read out current value represented by activations in layer","","",
    0,2,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_ReadValue_stub,TA_TwoDValLayerSpec_ReadValue_MethArgs},
  {&TA_void,NULL,"ResetAfterClamp"," reset activation of first unit(s) after hard clamping","","",
    0,2,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_ResetAfterClamp_stub,TA_TwoDValLayerSpec_ResetAfterClamp_MethArgs},
  {&TA_void,NULL,"HardClampExt"," hard clamp current ext values (on all units, after ClampValue called) to all the units","","",
    0,2,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_HardClampExt_stub,TA_TwoDValLayerSpec_HardClampExt_MethArgs},
  {&TA_void,NULL,"LabelUnits_impl"," label units with their underlying values","","",
    0,1,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_LabelUnits_impl_stub,TA_TwoDValLayerSpec_LabelUnits_impl_MethArgs},
  {&TA_void,NULL,"LabelUnits"," label units in given layer with their underlying values","BUTTON ","",
    0,1,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_LabelUnits_stub,TA_TwoDValLayerSpec_LabelUnits_MethArgs},
  {&TA_void,NULL,"LabelUnitsNet"," label all layers in given network using this spec","BUTTON ","",
    0,1,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_LabelUnitsNet_stub,TA_TwoDValLayerSpec_LabelUnitsNet_MethArgs},
  {&TA_void,NULL,"Compute_WtBias_Val","","","",
    0,3,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_WtBias_Val_stub,TA_TwoDValLayerSpec_Compute_WtBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_Val","","","",
    0,3,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_UnBias_Val_stub,TA_TwoDValLayerSpec_Compute_UnBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_BiasVal"," initialize the bias value ","","",
    0,1,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_BiasVal_stub,TA_TwoDValLayerSpec_Compute_BiasVal_MethArgs},
  {&TA_void,NULL,"Compute_dWtUgp"," compute weight changes just for one unit group","","",
    0,3,-1,1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_dWtUgp_stub,TA_TwoDValLayerSpec_Compute_dWtUgp_MethArgs},
  {&TA_void,NULL,"ReConfig"," reconfigure layer and associated specs for current scalar.rep type; if n_units > 0, changes number of units in layer to specified value","BUTTON ","",
    0,2,1,1,0,NULL,cssElCFun_TwoDValLayerSpec_ReConfig_stub,TA_TwoDValLayerSpec_ReConfig_MethArgs},
  NULL};
static MethodArgs_data TA_DecodeTwoDValLayerSpec_Compute_Inhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_DecodeTwoDValLayerSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_DecodeTwoDValLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_DecodeTwoDValLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_DecodeTwoDValLayerSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_Inhib"," stage two: compute the inhibition for layer","","",
    0,2,-1,1,0,NULL,cssElCFun_DecodeTwoDValLayerSpec_Compute_Inhib_stub,TA_DecodeTwoDValLayerSpec_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_DecodeTwoDValLayerSpec_Compute_InhibAvg_stub,TA_DecodeTwoDValLayerSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl"," don't include first unit in any of these computations!","","",
    0,4,-1,1,0,NULL,cssElCFun_DecodeTwoDValLayerSpec_Compute_Act_impl_stub,TA_DecodeTwoDValLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_DecodeTwoDValLayerSpec_Compute_dWt_stub,TA_DecodeTwoDValLayerSpec_Compute_dWt_MethArgs},
  NULL};
static int DaModUnit::* TA_DaModUnit_MbrOff;
static MemberDef_data TA_DaModUnit_MemberDef[]={
  {&TA_float,NULL,"act_m2"," second minus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::act_m2))),0,NULL,0},
  {&TA_float,NULL,"act_p2"," second plus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::act_p2))),0,NULL,0},
  {&TA_float,NULL,"p_act_m"," previous minus phase activation ","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::p_act_m))),0,NULL,0},
  {&TA_float,NULL,"p_act_p"," previous plus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::p_act_p))),0,NULL,0},
  {&TA_float,NULL,"dav"," modulatory dopamine value ","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::dav))),0,NULL,0},
  NULL};
static EnumDef_data TA_DaModSpec_ModType[]={
  {"PLUS_CONT"," da modulates plus-phase activations (only) in a continuous manner","",0},
  {"PLUS_POST"," da modulates plus-phase activations (only), at the end of the plus phase","",1},
  {"NEG_DIP"," da dips provide a (decaying) negative (accomodation) current on a trial-wise basis","",2},
  NULL};
static int DaModSpec::* TA_DaModSpec_MbrOff;
static MemberDef_data TA_DaModSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to actually modulate activations by da values","","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::on))),0,NULL,0},
  {NULL,"::ModType","mod"," how to apply DA modulation","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::mod))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain multiplier of da values","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"neg_rec"," recovery time constant for NEG_DIP case (how much to decay negative current per trial)","CONDEDIT_ON_mod:NEG_DIP ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::neg_rec))),0,NULL,0},
  {&TA_bool,NULL,"p_dwt"," whether units learn based on prior activation states, as in TD and other algorithms (not really to do with DA modulation; just stuck here.. affects Compute_dWt and UpdateWeights calls)","","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::p_dwt))),0,NULL,0},
  NULL};
static int DaModUnitSpec::* TA_DaModUnitSpec_MbrOff;
static MemberDef_data TA_DaModUnitSpec_MemberDef[]={
  {&TA_DaModSpec,NULL,"da_mod"," da modulation of activations (for da-based learning, and other effects)","","",
    *((ta_memb_ptr*)&(TA_DaModUnitSpec_MbrOff=(int DaModUnitSpec::*)(&DaModUnitSpec::da_mod))),0,NULL,0},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_Compute_Conduct_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_PostSettle_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_EncodeState_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_DaModUnitSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig","","","",
    2,4,3,0,0,NULL,cssElCFun_DaModUnitSpec_CheckConfig_stub,TA_DaModUnitSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitState","","","",
    4,1,-1,0,0,NULL,cssElCFun_DaModUnitSpec_InitState_stub,TA_DaModUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    4,3,-1,0,0,NULL,cssElCFun_DaModUnitSpec_Compute_dWt_stub,TA_DaModUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights","","","",
    1,1,-1,1,0,NULL,cssElCFun_DaModUnitSpec_UpdateWeights_stub,TA_DaModUnitSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"Compute_Conduct"," compute input conductance values in the gc variables","","",
    0,4,-1,1,0,NULL,cssElCFun_DaModUnitSpec_Compute_Conduct_stub,TA_DaModUnitSpec_Compute_Conduct_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay activation states towards initial values: at event-level boundary","","",
    0,4,-1,1,0,NULL,cssElCFun_DaModUnitSpec_DecayEvent_stub,TA_DaModUnitSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"PostSettle"," set stuff after settling is over (set_both = both _m and _p for current)","","",
    0,5,4,1,0,NULL,cssElCFun_DaModUnitSpec_PostSettle_stub,TA_DaModUnitSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"EncodeState"," encode current state information (hook for time-based learning)","","",
    0,3,-1,1,0,NULL,cssElCFun_DaModUnitSpec_EncodeState_stub,TA_DaModUnitSpec_EncodeState_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_DaModUnitSpec_Defaults_stub,NULL},
  NULL};
static int AvgExtRewSpec::* TA_AvgExtRewSpec_MbrOff;
static MemberDef_data TA_AvgExtRewSpec_MemberDef[]={
  {&TA_bool,NULL,"sub_avg"," subtract average reward value in computing rewards","DEF_false ","",
    *((ta_memb_ptr*)&(TA_AvgExtRewSpec_MbrOff=(int AvgExtRewSpec::*)(&AvgExtRewSpec::sub_avg))),0,NULL,0},
  {&TA_float,NULL,"avg_dt"," time constant for integrating average reward value","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_AvgExtRewSpec_MbrOff=(int AvgExtRewSpec::*)(&AvgExtRewSpec::avg_dt))),0,NULL,0},
  NULL};
static int OutErrSpec::* TA_OutErrSpec_MbrOff;
static MemberDef_data TA_OutErrSpec_MemberDef[]={
  {&TA_float,NULL,"err_tol"," error tolerance for counting an activation wrong","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::err_tol))),0,NULL,0},
  {&TA_bool,NULL,"graded"," compute a graded reward signal as a function of number of correct output values","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::graded))),0,NULL,0},
  {&TA_bool,NULL,"no_off_err"," do not count a unit wrong if it is off but target says on -- only count wrong units that are on but should be off","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::no_off_err))),0,NULL,0},
  {&TA_bool,NULL,"seq_all_cor"," require that all RewTarg events in a sequence be correct before giving reward (on the last event in sequence); if graded is checked, this reward is a graded function of % correct","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::seq_all_cor))),0,NULL,0},
  NULL};
static int ExtRewSpec::* TA_ExtRewSpec_MbrOff;
static MemberDef_data TA_ExtRewSpec_MemberDef[]={
  {&TA_float,NULL,"err_val"," reward value for errors (when network does not respond correctly)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::err_val))),0,NULL,0},
  {&TA_float,NULL,"norew_val"," reward value when no feedback information is present","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::norew_val))),0,NULL,0},
  {&TA_float,NULL,"rew_val"," reward value for correct responses (positive rewards)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::rew_val))),0,NULL,0},
  NULL};
static EnumDef_data TA_ExtRewLayerSpec_RewardType[]={
  {"OUT_ERR_REW"," get rewards as a function of errors on the output layer ONLY WHEN RewTarg layer act > .5 -- get from markerconspec from output layer(s)","",0},
  {"EXT_REW"," get rewards as external inputs marked as ext_flag = TARG to the first unit in the layer","",1},
  {"DA_REW"," get rewards from da values on first unit in layer","",2},
  NULL};
static int ExtRewLayerSpec::* TA_ExtRewLayerSpec_MbrOff;
static MemberDef_data TA_ExtRewLayerSpec_MemberDef[]={
  {NULL,"::RewardType","rew_type"," how do we get the reward values?","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::rew_type))),0,NULL,0},
  {&TA_AvgExtRewSpec,NULL,"avg_rew"," average reward computation specifications","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::avg_rew))),0,NULL,0},
  {&TA_OutErrSpec,NULL,"out_err"," how to compute external rewards based on output performance","CONDEDIT_ON_rew_type:OUT_ERR_REW ","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::out_err))),0,NULL,0},
  {&TA_ExtRewSpec,NULL,"rew"," misc reward computation specifications","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::rew))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_OutErrRewAvail_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_GetOutErrRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_OutErrRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_ExtRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_DaRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_UnitDa_MethArgs[]={
  {&TA_float,NULL,"er",""},
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_NoRewAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_ExtRewLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_ExtRewLayerSpec_CheckConfig_stub,TA_ExtRewLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_HardClamp_stub,TA_ExtRewLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_dWt_stub,TA_ExtRewLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Defaults_stub,NULL},
  {&TA_bool,NULL,"OutErrRewAvail"," figure out if reward is available on this trial (look if target signals are present)","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_OutErrRewAvail_stub,TA_ExtRewLayerSpec_OutErrRewAvail_MethArgs},
  {&TA_float,NULL,"GetOutErrRew"," get reward value based on error at layer with MarkerConSpec connection: 1 = rew (correct), 0 = err, -1 = no info","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_GetOutErrRew_stub,TA_ExtRewLayerSpec_GetOutErrRew_MethArgs},
  {&TA_void,NULL,"Compute_OutErrRew"," get reward value based on external error (put in da val, clamp)","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_OutErrRew_stub,TA_ExtRewLayerSpec_Compute_OutErrRew_MethArgs},
  {&TA_void,NULL,"Compute_ExtRew"," get external rewards from inputs (put in da val, clamp)","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_ExtRew_stub,TA_ExtRewLayerSpec_Compute_ExtRew_MethArgs},
  {&TA_void,NULL,"Compute_DaRew"," clamp external rewards as da values (put in da val, clamp)","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_DaRew_stub,TA_ExtRewLayerSpec_Compute_DaRew_MethArgs},
  {&TA_void,NULL,"Compute_UnitDa"," actually compute the unit da value based on external reward value er","","",
    0,5,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_UnitDa_stub,TA_ExtRewLayerSpec_Compute_UnitDa_MethArgs},
  {&TA_void,NULL,"Compute_ZeroAct"," clamp zero activations, for minus phase","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_ZeroAct_stub,TA_ExtRewLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_NoRewAct"," clamp norew_val values for when no reward information is present","","",
    0,2,-1,1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_NoRewAct_stub,TA_ExtRewLayerSpec_Compute_NoRewAct_MethArgs},
  NULL};
static MethodArgs_data TA_TDRewPredConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TDRewPredConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_TDRewPredConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_TDRewPredConSpec_Compute_dWt_stub,TA_TDRewPredConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," this computes weight changes based on sender at time t-1","","",
    1,3,-1,0,0,NULL,cssElCFun_TDRewPredConSpec_C_Compute_Err_stub,TA_TDRewPredConSpec_C_Compute_Err_MethArgs},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_SavePred_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ClampPred_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ClampPrev_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_TdPlusPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_TDRewPredLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_TDRewPredLayerSpec_CheckConfig_stub,TA_TDRewPredLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitState"," prior to settling: initialize dynamic state variables","","",
    0,1,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_InitState_stub,TA_TDRewPredLayerSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_HardClamp_stub,TA_TDRewPredLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"PostSettle"," after settling, keep track of phase variables, etc.","","",
    0,3,2,1,0,NULL,cssElCFun_TDRewPredLayerSpec_PostSettle_stub,TA_TDRewPredLayerSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_dWt_stub,TA_TDRewPredLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_SavePred"," save current prediction to misc_1 for later clamping","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_SavePred_stub,TA_TDRewPredLayerSpec_Compute_SavePred_MethArgs},
  {&TA_void,NULL,"Compute_ClampPred"," clamp misc_1 to ext ","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ClampPred_stub,TA_TDRewPredLayerSpec_Compute_ClampPred_MethArgs},
  {&TA_void,NULL,"Compute_ClampPrev"," clamp minus phase to previous act value","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ClampPrev_stub,TA_TDRewPredLayerSpec_Compute_ClampPrev_MethArgs},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ExtToPlus_stub,TA_TDRewPredLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_TdPlusPhase_impl","","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_stub,TA_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_MethArgs},
  {&TA_void,NULL,"Compute_TdPlusPhase"," compute plus phase activations for learning including the td values","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_stub,TA_TDRewPredLayerSpec_Compute_TdPlusPhase_MethArgs},
  NULL};
static int TDRewIntegSpec::* TA_TDRewIntegSpec_MbrOff;
static MemberDef_data TA_TDRewIntegSpec_MemberDef[]={
  {&TA_float,NULL,"discount"," discount factor for V(t+1) from TDRewPredLayer","","",
    *((ta_memb_ptr*)&(TA_TDRewIntegSpec_MbrOff=(int TDRewIntegSpec::*)(&TDRewIntegSpec::discount))),0,NULL,0},
  NULL};
static int TDRewIntegLayerSpec::* TA_TDRewIntegLayerSpec_MbrOff;
static MemberDef_data TA_TDRewIntegLayerSpec_MemberDef[]={
  {&TA_TDRewIntegSpec,NULL,"rew_integ"," misc specs for TDRewIntegLayerSpec","","",
    *((ta_memb_ptr*)&(TA_TDRewIntegLayerSpec_MbrOff=(int TDRewIntegLayerSpec::*)(&TDRewIntegLayerSpec::rew_integ))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TDRewIntegLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_TDRewIntegLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TDRewIntegLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_TDRewIntegLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_TDRewIntegLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_TDRewIntegLayerSpec_CheckConfig_stub,TA_TDRewIntegLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewIntegLayerSpec_Compute_Act_stub,TA_TDRewIntegLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_TDRewIntegLayerSpec_Compute_dWt_stub,TA_TDRewIntegLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_TDRewIntegLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_TDRewIntegLayerSpec_Defaults_stub,NULL},
  NULL};
static MethodArgs_data TA_TdLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_Td_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Send_Td_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_TdLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_TdLayerSpec_CheckConfig_stub,TA_TdLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_TdLayerSpec_Compute_HardClamp_stub,TA_TdLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_TdLayerSpec_Compute_Act_stub,TA_TdLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," nop","","",
    0,2,-1,1,0,NULL,cssElCFun_TdLayerSpec_Compute_dWt_stub,TA_TdLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_TdLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_TdLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_ZeroAct"," compute a zero td value: in minus phase","","",
    0,2,-1,1,0,NULL,cssElCFun_TdLayerSpec_Compute_ZeroAct_stub,TA_TdLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_Td"," compute the td value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,1,0,NULL,cssElCFun_TdLayerSpec_Compute_Td_stub,TA_TdLayerSpec_Compute_Td_MethArgs},
  {&TA_void,NULL,"Send_Td"," send the td value to sending projections: every cycle","","",
    0,2,-1,1,0,NULL,cssElCFun_TdLayerSpec_Send_Td_stub,TA_TdLayerSpec_Send_Td_MethArgs},
  NULL};
static MethodArgs_data TA_PVConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_PVConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_PVConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_PVConSpec_Compute_dWt_stub,TA_PVConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," this computes weight changes based on sender at time t-1","","",
    1,3,-1,0,0,NULL,cssElCFun_PVConSpec_C_Compute_Err_stub,TA_PVConSpec_C_Compute_Err_MethArgs},
  NULL};
static int PVDetectSpec::* TA_PVDetectSpec_MbrOff;
static MemberDef_data TA_PVDetectSpec_MemberDef[]={
  {&TA_float,NULL,"thr_min"," minimum threshold on PVe (ExtRew) or PVi, below which PV is considered present (i.e., punishment) (set to 0 if PVe.rew.norew_val = 0)","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_PVDetectSpec_MbrOff=(int PVDetectSpec::*)(&PVDetectSpec::thr_min))),0,NULL,0},
  {&TA_float,NULL,"thr_max"," maximum threshold on PVe (ExtRew) or PVi, above which PV is considered present (i.e., reward) (set to .4 if PVe.rew.norew_val = 0)","DEF_0.8 ","",
    *((ta_memb_ptr*)&(TA_PVDetectSpec_MbrOff=(int PVDetectSpec::*)(&PVDetectSpec::thr_max))),0,NULL,0},
  NULL};
static int PViLayerSpec::* TA_PViLayerSpec_MbrOff;
static MemberDef_data TA_PViLayerSpec_MemberDef[]={
  {&TA_PVDetectSpec,NULL,"pv_detect"," primary reward value detection spec: detect if a primary reward is present or expected","","",
    *((ta_memb_ptr*)&(TA_PViLayerSpec_MbrOff=(int PViLayerSpec::*)(&PViLayerSpec::pv_detect))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PViLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_PVe_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool_ref,NULL,"actual_er_avail",""},
  {&TA_bool_ref,NULL,"pv_detected",""},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_PVPlusPhaseDwt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_PViLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_PViLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_PViLayerSpec_CheckConfig_stub,TA_PViLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_PViLayerSpec_Compute_dWt_stub,TA_PViLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_PViLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_PViLayerSpec_Defaults_stub,NULL},
  {&TA_float,NULL,"Compute_PVe"," get excitatory primary reward value from PVe/ExtRew layer if it is available: actual_er_avail = internal flag from ExtRew layer (cheating), pv_detected = PVi layer's detection of primary reward presence or expectation based on PVi, PVe values (not cheating)","","",
    0,4,-1,1,0,NULL,cssElCFun_PViLayerSpec_Compute_PVe_stub,TA_PViLayerSpec_Compute_PVe_MethArgs},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,1,0,NULL,cssElCFun_PViLayerSpec_Compute_ExtToPlus_stub,TA_PViLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_PVPlusPhaseDwt"," compute plus phase activations as external rewards and change weights","","",
    0,2,-1,1,0,NULL,cssElCFun_PViLayerSpec_Compute_PVPlusPhaseDwt_stub,TA_PViLayerSpec_Compute_PVPlusPhaseDwt_MethArgs},
  NULL};
static MethodArgs_data TA_LVConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LVConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LVConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_LVConSpec_Compute_dWt_stub,TA_LVConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err","","","",
    1,3,-1,0,0,NULL,cssElCFun_LVConSpec_C_Compute_Err_stub,TA_LVConSpec_C_Compute_Err_MethArgs},
  NULL};
static int LVSpec::* TA_LVSpec_MbrOff;
static MemberDef_data TA_LVSpec_MemberDef[]={
  {&TA_float,NULL,"discount"," multiplicative discount factor for PVe/ExtRew/US training signal: plus phase clamp = (1-discount)*PVe","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::discount))),0,NULL,0},
  {&TA_bool,NULL,"use_actual_er"," use actual external reward presence to determine when to learn (cheating), otherwise use PVi's estimate of when primary value is avail (more realistic)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::use_actual_er))),0,NULL,0},
  NULL};
static int LVeLayerSpec::* TA_LVeLayerSpec_MbrOff;
static MemberDef_data TA_LVeLayerSpec_MemberDef[]={
  {&TA_LVSpec,NULL,"lv"," learned value specs","","",
    *((ta_memb_ptr*)&(TA_LVeLayerSpec_MbrOff=(int LVeLayerSpec::*)(&LVeLayerSpec::lv))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_DepressWt_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_LVPlusPhaseDwt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_LVeLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_LVeLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_LVeLayerSpec_CheckConfig_stub,TA_LVeLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_LVeLayerSpec_Compute_dWt_stub,TA_LVeLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_LVeLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_LVeLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,1,0,NULL,cssElCFun_LVeLayerSpec_Compute_ExtToPlus_stub,TA_LVeLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_DepressWt"," depress weights for units in unit group (only if not doing dwts!)","","",
    0,3,-1,1,0,NULL,cssElCFun_LVeLayerSpec_Compute_DepressWt_stub,TA_LVeLayerSpec_Compute_DepressWt_MethArgs},
  {&TA_void,NULL,"Compute_LVPlusPhaseDwt"," if primary value detected (present/expected), compute plus phase activations for learning, and actually change weights; otherwise just depress weights","","",
    0,2,-1,1,0,NULL,cssElCFun_LVeLayerSpec_Compute_LVPlusPhaseDwt_stub,TA_LVeLayerSpec_Compute_LVPlusPhaseDwt_MethArgs},
  NULL};
static EnumDef_data TA_PVLVDaSpec_DaMode[]={
  {"LV_PLUS_IF_PV"," da = (LVe - LVi) + [if (PV detected (present/expected), PVe - PVi]","",0},
  {"IF_PV_ELSE_LV"," if (PV detected (present/expected), da = PVe - PVi; else da = LVe - LVi","",1},
  {"PV_PLUS_LV"," da = (PVe - PVi) + (LVe - LVi)","",2},
  NULL};
static int PVLVDaSpec::* TA_PVLVDaSpec_MbrOff;
static MemberDef_data TA_PVLVDaSpec_MemberDef[]={
  {NULL,"::DaMode","mode"," how to compute DA as a function of PV and LV systems","DEF_LV_PLUS_IF_PV ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::mode))),0,NULL,0},
  {&TA_float,NULL,"tonic_da"," set a tonic 'dopamine' (DA) level (offset to add to da values)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::tonic_da))),0,NULL,0},
  {&TA_float,NULL,"min_lvi"," minimum LVi value, so that a low LVe value (~0) makes for negative DA: DA_lv = LVe - MAX(LVi, min_lvi)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::min_lvi))),0,NULL,0},
  {&TA_bool,NULL,"use_actual_er"," use actual external reward presence to determine when PV is detected (cheating), otherwise use PVi's estimate of when primary value is avail (more realistic)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::use_actual_er))),0,NULL,0},
  NULL};
static int PVLVDaLayerSpec::* TA_PVLVDaLayerSpec_MbrOff;
static MemberDef_data TA_PVLVDaLayerSpec_MemberDef[]={
  {&TA_PVLVDaSpec,NULL,"da"," parameters for the lvpv da computation","","",
    *((ta_memb_ptr*)&(TA_PVLVDaLayerSpec_MbrOff=(int PVLVDaLayerSpec::*)(&PVLVDaLayerSpec::da))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Send_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_PVLVDaLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_PVLVDaLayerSpec_CheckConfig_stub,TA_PVLVDaLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_HardClamp_stub,TA_PVLVDaLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_Act_stub,TA_PVLVDaLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_dWt_stub,TA_PVLVDaLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_ZeroAct"," compute a zero da value: in minus phase","","",
    0,2,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_ZeroAct_stub,TA_PVLVDaLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_Da"," compute the da value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_Da_stub,TA_PVLVDaLayerSpec_Compute_Da_MethArgs},
  {&TA_void,NULL,"Send_Da"," send the da value to sending projections: every cycle","","",
    0,2,-1,1,0,NULL,cssElCFun_PVLVDaLayerSpec_Send_Da_stub,TA_PVLVDaLayerSpec_Send_Da_MethArgs},
  NULL};
static EnumDef_data TA_SNcMiscSpec_PatchMode[]={
  {"NO_PATCH"," no patch at all","",0},
  {"PATCH"," use patch: Note currently not supported.","",1},
  NULL};
static int SNcMiscSpec::* TA_SNcMiscSpec_MbrOff;
static MemberDef_data TA_SNcMiscSpec_MemberDef[]={
  {NULL,"::PatchMode","patch_mode"," how to run the patch computation","DEF_NO_PATCH ","",
    *((ta_memb_ptr*)&(TA_SNcMiscSpec_MbrOff=(int SNcMiscSpec::*)(&SNcMiscSpec::patch_mode))),0,NULL,0},
  {&TA_float,NULL,"patch_gain"," proportion of patch (stripe-specific) da relative to global abl da","CONDEDIT_ON_patch_mode:PATCH DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_SNcMiscSpec_MbrOff=(int SNcMiscSpec::*)(&SNcMiscSpec::patch_gain))),0,NULL,0},
  NULL};
static int SNcLayerSpec::* TA_SNcLayerSpec_MbrOff;
static MemberDef_data TA_SNcLayerSpec_MemberDef[]={
  {&TA_SNcMiscSpec,NULL,"snc"," misc SNc specific parameters controlling influence of patch modulation","","",
    *((ta_memb_ptr*)&(TA_SNcLayerSpec_MbrOff=(int SNcLayerSpec::*)(&SNcLayerSpec::snc))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SNcLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_SNcLayerSpec_Compute_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_SNcLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_SNcLayerSpec_CheckConfig_stub,TA_SNcLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_SNcLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_SNcLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_Da"," compute the da value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,1,0,NULL,cssElCFun_SNcLayerSpec_Compute_Da_stub,TA_SNcLayerSpec_Compute_Da_MethArgs},
  NULL};
static EnumDef_data TA_MatrixConSpec_LearnRule[]={
  {"OUTPUT_DELTA"," delta rule for BG_motor: (bg+ - bg-) * s-","AKA_MOTOR_DELTA ",0},
  {"OUTPUT_CHL"," CHL rule for BG_motor: (bg+ * s+) - (bg- * s-)","AKA_MOTOR_CHL ",1},
  {"MAINT"," MAINT learning rule: (bg_p2 - bg_p) * s_p","AKA_PFC ",2},
  NULL};
static int MatrixConSpec::* TA_MatrixConSpec_MbrOff;
static MemberDef_data TA_MatrixConSpec_MemberDef[]={
  {NULL,"::LearnRule","learn_rule"," learning rule to use","","",
    *((ta_memb_ptr*)&(TA_MatrixConSpec_MbrOff=(int MatrixConSpec::*)(&MatrixConSpec::learn_rule))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_MatrixConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_MatrixConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_MatrixConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,0,NULL,cssElCFun_MatrixConSpec_Compute_dWt_stub,TA_MatrixConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb","","","",
    1,4,-1,0,0,NULL,cssElCFun_MatrixConSpec_C_Compute_Hebb_stub,TA_MatrixConSpec_C_Compute_Hebb_MethArgs},
  {&TA_float,NULL,"C_Compute_Err","","","",
    1,3,-1,0,0,NULL,cssElCFun_MatrixConSpec_C_Compute_Err_stub,TA_MatrixConSpec_C_Compute_Err_MethArgs},
  NULL};
static EnumDef_data TA_MatrixBiasSpec_LearnRule[]={
  {"OUTPUT_DELTA"," delta rule for BG_motor: (bg+ - bg-) * s-","",0},
  {"OUTPUT_CHL"," CHL rule for BG_motor: (bg+ * s+) - (bg- * s-)","",1},
  {"MAINT"," MAINT: learn on 2p - p","",2},
  NULL};
static int MatrixBiasSpec::* TA_MatrixBiasSpec_MbrOff;
static MemberDef_data TA_MatrixBiasSpec_MemberDef[]={
  {NULL,"::LearnRule","learn_rule"," learning rule to use","","",
    *((ta_memb_ptr*)&(TA_MatrixBiasSpec_MbrOff=(int MatrixBiasSpec::*)(&MatrixBiasSpec::learn_rule))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixBiasSpec_B_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodDef_data TA_MatrixBiasSpec_MethodDef[]={
  {&TA_void,NULL,"B_Compute_dWt","","","",
    0,2,-1,0,0,NULL,cssElCFun_MatrixBiasSpec_B_Compute_dWt_stub,TA_MatrixBiasSpec_B_Compute_dWt_MethArgs},
  NULL};
static int MatrixUnitSpec::* TA_MatrixUnitSpec_MbrOff;
static MemberDef_data TA_MatrixUnitSpec_MemberDef[]={
  {&TA_bool,NULL,"freeze_net"," freeze netinput (MAINT in 2+ phase, OUTPUT in 1+ phase) during learning modulation so that learning only reflects DA modulation and not other changes in netin","DEF_true ","",
    *((ta_memb_ptr*)&(TA_MatrixUnitSpec_MbrOff=(int MatrixUnitSpec::*)(&MatrixUnitSpec::freeze_net))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixUnitSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixUnitSpec_PostSettle_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodDef_data TA_MatrixUnitSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,4,-1,0,0,NULL,cssElCFun_MatrixUnitSpec_Compute_NetAvg_stub,TA_MatrixUnitSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"PostSettle"," set stuff after settling is over (set_both = both _m and _p for current)","","",
    0,5,4,1,0,NULL,cssElCFun_MatrixUnitSpec_PostSettle_stub,TA_MatrixUnitSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_MatrixUnitSpec_Defaults_stub,NULL},
  NULL};
static int MatrixMiscSpec::* TA_MatrixMiscSpec_MbrOff;
static MemberDef_data TA_MatrixMiscSpec_MemberDef[]={
  {&TA_float,NULL,"neg_da_bl"," negative da baseline in learning condition: this amount subtracted from all da values in learning phase (essentially reinforces nogo)","DEF_0.0002 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::neg_da_bl))),0,NULL,0},
  {&TA_float,NULL,"neg_gain"," gain for negative DA signals relative to positive ones: neg DA may need to be stronger!","DEF_1.5 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::neg_gain))),0,NULL,0},
  {&TA_float,NULL,"perf_gain"," performance effect da gain (in 2- phase for trans, 1+ for gogo)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::perf_gain))),0,NULL,0},
  {&TA_bool,NULL,"no_snr_mod"," disable the Da learning modulation by SNrThal ativation (this is only to demonstrate how important it is)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::no_snr_mod))),0,NULL,0},
  NULL};
static int ContrastSpec::* TA_ContrastSpec_MbrOff;
static MemberDef_data TA_ContrastSpec_MemberDef[]={
  {&TA_float,NULL,"gain"," overall gain for da modulation","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"go_p"," proportion of da * gate_act for DA+ on GO units: contrast enhancement","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::go_p))),0,NULL,0},
  {&TA_float,NULL,"go_n"," proportion of da * gate_act for DA- on GO units: contrast reduction","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::go_n))),0,NULL,0},
  {&TA_float,NULL,"nogo_p"," proportion of da * gate_act for DA+ on NOGO units: contrast enhancement","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::nogo_p))),0,NULL,0},
  {&TA_float,NULL,"nogo_n"," proportion of da * gate_act for DA- on NOGO units: contrast reduction","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::nogo_n))),0,NULL,0},
  NULL};
static int MatrixRndGoSpec::* TA_MatrixRndGoSpec_MbrOff;
static MemberDef_data TA_MatrixRndGoSpec_MemberDef[]={
  {&TA_float,NULL,"avgrew"," threshold on global avg reward value (0..1) below which random GO can fire (uses ExtRew_Stat if avail, else avg value from ExtRewLayer) -- once network is doing well overall, shutdown the exploration. This is true for all cases EXCEPT err rnd go","DEF_0.9 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::avgrew))),0,NULL,0},
  {&TA_float,NULL,"ucond_p"," unconditional random go probability (on every trial, each stripe has this probability of firing a Go randomly, without conditions)","DEF_1e-04 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::ucond_p))),0,NULL,0},
  {&TA_float,NULL,"ucond_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) for the unconditional random go","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::ucond_da))),0,NULL,0},
  {&TA_int,NULL,"nogo_thr"," threshold of number of nogo firing in a row that will trigger NoGo random go firing","DEF_50 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::nogo_thr))),0,NULL,0},
  {&TA_float,NULL,"nogo_p"," probability of actually firing a nogo random Go once the threshold is exceeded","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::nogo_p))),0,NULL,0},
  {&TA_float,NULL,"nogo_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) for a nogo-driven random go firing","DEF_10 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::nogo_da))),0,NULL,0},
  NULL};
static int MatrixErrRndGoSpec::* TA_MatrixErrRndGoSpec_MbrOff;
static MemberDef_data TA_MatrixErrRndGoSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to use error-driven random go","DEF_true ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::on))),0,NULL,0},
  {&TA_int,NULL,"min_cor"," [Default is 5 for MAINT, 1 for OUTPUT] minimum number of sequential correct to start counting errors and doing random go: need some amount of correct before errors count!","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::min_cor))),0,NULL,0},
  {&TA_int,NULL,"min_errs"," minimum number of sequential errors to start this random go exploration","CONDEDIT_ON_on:true DEF_1 ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::min_errs))),0,NULL,0},
  {&TA_float,NULL,"err_p"," baseline probability of firing Go, once above min_cor and min_errs","CONDEDIT_ON_on:true DEF_1 ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::err_p))),0,NULL,0},
  {&TA_float,NULL,"gain"," [Default is .2 for MAINT, .5 for OUTPUT] gain on softmax over netinputs on snrthal units for choosing the stripe to activate Go for: softmax = normalized exp(gain * snrthal->net)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"if_go_p"," probability of firing a random Go if some stripes are actually currently firing a Go (i.e., the not-all-nogo case); by default, only fire Go if all stripes are firing nogo","CONDEDIT_ON_on:true DEF_0 ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::if_go_p))),0,NULL,0},
  {&TA_float,NULL,"err_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) when error Go is fired (for learning effect) -- this multiplies the actual DA value coming from the SNc, and is also weighted by the netinput of the snrthal stripe; da = -dav * err_da * (snrthal->net + 1)","CONDEDIT_ON_on:true DEF_10 ","",
    *((ta_memb_ptr*)&(TA_MatrixErrRndGoSpec_MbrOff=(int MatrixErrRndGoSpec::*)(&MatrixErrRndGoSpec::err_da))),0,NULL,0},
  NULL};
static int MatrixAvgDaRndGoSpec::* TA_MatrixAvgDaRndGoSpec_MbrOff;
static MemberDef_data TA_MatrixAvgDaRndGoSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," [Default true for MAINT, false for OUTPUT] whether to use random go based on average dopamine values","","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::on))),0,NULL,0},
  {&TA_float,NULL,"avgda_p"," baseline probability of firing random Go for any stripe (first pass before doing softmax)","CONDEDIT_ON_on:true DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::avgda_p))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain on softmax over avgda values on snrthal units for choosing the stripe to activate Go for (softmax = normalized exp(gain * (avgda_thr - avg_go_da))","CONDEDIT_ON_on:true DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"avgda_thr"," threshold on per stripe avg_go_da value (-1..1) below which the random Go starts happening (and is subtracted from avgda as the reference point for the softmax computation)","CONDEDIT_ON_on:true DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::avgda_thr))),0,NULL,0},
  {&TA_int,NULL,"nogo_thr"," minimum number of sequential nogos in a row for a stripe before a avg-da random Go will fire (not to be confused with nogo_thr, which is regardless of avgda -- this is specifically for avg-da random go)","CONDEDIT_ON_on:true DEF_10 ","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::nogo_thr))),0,NULL,0},
  {&TA_float,NULL,"avgda_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) when go is fired (for learning effect)","CONDEDIT_ON_on:true DEF_10 ","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::avgda_da))),0,NULL,0},
  {&TA_float,NULL,"avgda_dt"," time constant for integrating the average DA value associated with Go firing for each stripe (stored in matrix_u->misc_1)","CONDEDIT_ON_on:true DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_MatrixAvgDaRndGoSpec_MbrOff=(int MatrixAvgDaRndGoSpec::*)(&MatrixAvgDaRndGoSpec::avgda_dt))),0,NULL,0},
  NULL};
static EnumDef_data TA_MatrixLayerSpec_BGType[]={
  {"OUTPUT"," matrix that does output gating: controls access of frontal activations to other areas (e.g., motor output, or output of maintained PFC information)","AKA_MOTOR ",0},
  {"MAINT"," matrix that does maintenance gating: controls toggling of maintenance of activity patterns (e.g., PFC) over time","AKA_PFC ",1},
  NULL};
static int MatrixLayerSpec::* TA_MatrixLayerSpec_MbrOff;
static MemberDef_data TA_MatrixLayerSpec_MemberDef[]={
  {NULL,"::BGType","bg_type"," type of basal ganglia/frontal system: output gating (e.g., motor) or maintenance gating (e.g., pfc)","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::bg_type))),0,NULL,0},
  {&TA_MatrixMiscSpec,NULL,"matrix"," misc parameters for the matrix layer","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::matrix))),0,NULL,0},
  {&TA_ContrastSpec,NULL,"contrast"," contrast enhancement effects of da/dopamine neuromodulation","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::contrast))),0,NULL,0},
  {&TA_MatrixRndGoSpec,NULL,"rnd_go"," matrix random Go firing for unconditional and nogo firing stripes cases","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::rnd_go))),0,NULL,0},
  {&TA_MatrixErrRndGoSpec,NULL,"err_rnd_go"," matrix random Go firing to encourage exploration when (a series of) errors are made: chooses stripe to Go at random using probabilities from a softmax over snrthal netinput values: stripes that are closer to firing fire more often","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::err_rnd_go))),0,NULL,0},
  {&TA_MatrixAvgDaRndGoSpec,NULL,"avgda_rnd_go"," matrix random Go firing based on average da to encourage exploration for non-productive stripes based on a softmax over the avg_go_da for that stripe (matrix_u->misc_1) ","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::avgda_rnd_go))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_InitWtState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Check_RndGoAvgRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_UCondNoGoRndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_ErrRndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_AvgDaRndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_ClearRndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaModUnit_NoContrast_MethArgs[]={
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"dav",""},
  {&TA_int,NULL,"go_no",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaModUnit_Contrast_MethArgs[]={
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"dav",""},
  {&TA_float,NULL,"gating_act",""},
  {&TA_int,NULL,"go_no",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaTonicMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaPerfMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaLearnMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_AvgGoDa_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_MotorGate_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_MatrixLayerSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","CAT_ObjectMgmt ","",
    0,0,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_UpdateAfterEdit_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_MatrixLayerSpec_CheckConfig_stub,TA_MatrixLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"InitWtState"," initialize weight values and other permanent state","","",
    0,1,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_InitWtState_stub,TA_MatrixLayerSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_HardClamp_stub,TA_MatrixLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl","","","",
    0,4,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_Act_impl_stub,TA_MatrixLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"PostSettle"," after settling, keep track of phase variables, etc.","","",
    0,3,2,1,0,NULL,cssElCFun_MatrixLayerSpec_PostSettle_stub,TA_MatrixLayerSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_dWt_stub,TA_MatrixLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Defaults_stub,NULL},
  {&TA_bool,NULL,"Check_RndGoAvgRew"," check avg_rew levels to see whether we should compute random go (don't do when avg_rew is good!); false = don't do rnd go, true = do it","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Check_RndGoAvgRew_stub,TA_MatrixLayerSpec_Check_RndGoAvgRew_MethArgs},
  {&TA_void,NULL,"Compute_UCondNoGoRndGo"," compute random Go for unconditional and nogo cases","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_UCondNoGoRndGo_stub,TA_MatrixLayerSpec_Compute_UCondNoGoRndGo_MethArgs},
  {&TA_void,NULL,"Compute_ErrRndGo"," compute random Go signal when errors have been made recently","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_ErrRndGo_stub,TA_MatrixLayerSpec_Compute_ErrRndGo_MethArgs},
  {&TA_void,NULL,"Compute_AvgDaRndGo"," compute random Go signal based on average da values for stripes ","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_AvgDaRndGo_stub,TA_MatrixLayerSpec_Compute_AvgDaRndGo_MethArgs},
  {&TA_void,NULL,"Compute_ClearRndGo"," clear the rnd go signal","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_ClearRndGo_stub,TA_MatrixLayerSpec_Compute_ClearRndGo_MethArgs},
  {&TA_void,NULL,"Compute_DaModUnit_NoContrast"," apply given dopamine modulation value to the unit, based on whether it is a go (0) or nogo (1); no contrast enancement based on activation","","",
    0,3,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaModUnit_NoContrast_stub,TA_MatrixLayerSpec_Compute_DaModUnit_NoContrast_MethArgs},
  {&TA_void,NULL,"Compute_DaModUnit_Contrast"," apply given dopamine modulation value to the unit, based on whether it is a go (0) or nogo (1); contrast enhancement based on activation (gating_act)","","",
    0,4,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaModUnit_Contrast_stub,TA_MatrixLayerSpec_Compute_DaModUnit_Contrast_MethArgs},
  {&TA_void,NULL,"Compute_DaTonicMod"," compute tonic da modulation (for pfc gating units in first two phases)","","",
    0,4,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaTonicMod_stub,TA_MatrixLayerSpec_Compute_DaTonicMod_MethArgs},
  {&TA_void,NULL,"Compute_DaPerfMod"," compute dynamic da modulation; performance modulation, not learning (second minus phase)","","",
    0,4,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaPerfMod_stub,TA_MatrixLayerSpec_Compute_DaPerfMod_MethArgs},
  {&TA_void,NULL,"Compute_DaLearnMod"," compute dynamic da modulation: evaluation modulation, which is sensitive to GO/NOGO firing and activation in action phase","","",
    0,4,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaLearnMod_stub,TA_MatrixLayerSpec_Compute_DaLearnMod_MethArgs},
  {&TA_void,NULL,"Compute_AvgGoDa"," compute average da present when stripes fire a Go (stored in u->misc_1); used to modulate rnd_go firing","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_AvgGoDa_stub,TA_MatrixLayerSpec_Compute_AvgGoDa_MethArgs},
  {&TA_void,NULL,"Compute_MotorGate"," compute gating signal for OUTPUT Matrix_out","","",
    0,2,-1,1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_MotorGate_stub,TA_MatrixLayerSpec_Compute_MotorGate_MethArgs},
  NULL};
static int SNrThalMiscSpec::* TA_SNrThalMiscSpec_MbrOff;
static MemberDef_data TA_SNrThalMiscSpec_MemberDef[]={
  {&TA_float,NULL,"avg_net_dt"," time-averaged netinput computation integration rate","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_SNrThalMiscSpec_MbrOff=(int SNrThalMiscSpec::*)(&SNrThalMiscSpec::avg_net_dt))),0,NULL,0},
  {&TA_float,NULL,"go_thr"," threshold in snrthal activation required to trigger a Go gating event","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_SNrThalMiscSpec_MbrOff=(int SNrThalMiscSpec::*)(&SNrThalMiscSpec::go_thr))),0,NULL,0},
  {&TA_float,NULL,"rnd_go_inc"," how much to add to the net input for a random-go signal triggered in corresponding matrix layer?","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_SNrThalMiscSpec_MbrOff=(int SNrThalMiscSpec::*)(&SNrThalMiscSpec::rnd_go_inc))),0,NULL,0},
  NULL};
static int SNrThalLayerSpec::* TA_SNrThalLayerSpec_MbrOff;
static MemberDef_data TA_SNrThalLayerSpec_MemberDef[]={
  {&TA_SNrThalMiscSpec,NULL,"snrthal"," misc specs for snrthal layer","","",
    *((ta_memb_ptr*)&(TA_SNrThalLayerSpec_MbrOff=(int SNrThalLayerSpec::*)(&SNrThalLayerSpec::snrthal))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SNrThalLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_SNrThalLayerSpec_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_SNrThalLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_LeabraNetwork_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_SNrThalLayerSpec_Compute_GoNogoNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_SNrThalLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_SNrThalLayerSpec_CheckConfig_stub,TA_SNrThalLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_Clamp_NetAvg"," clamp and compute averages of net inputs that were already computed","","",
    0,2,-1,1,0,NULL,cssElCFun_SNrThalLayerSpec_Compute_Clamp_NetAvg_stub,TA_SNrThalLayerSpec_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_SNrThalLayerSpec_Compute_dWt_stub,TA_SNrThalLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_SNrThalLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_SNrThalLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"Compute_GoNogoNet"," compute netinput as GO - NOGO on matrix layer","","",
    0,2,-1,1,0,NULL,cssElCFun_SNrThalLayerSpec_Compute_GoNogoNet_stub,TA_SNrThalLayerSpec_Compute_GoNogoNet_MethArgs},
  NULL};
static EnumDef_data TA_PFCGateSpec_GateSignal[]={
  {"GATE_GO"," gate GO unit fired ","",0},
  {"GATE_NOGO"," gate NOGO unit fired","",1},
  NULL};
static EnumDef_data TA_PFCGateSpec_GateState[]={
  {"EMPTY_GO"," stripe was empty, got a GO","",0},
  {"EMPTY_NOGO"," stripe was empty, got a NOGO","",1},
  {"LATCH_GO"," stripe was already latched, got a GO","",2},
  {"LATCH_NOGO"," stripe was already latched, got a NOGO","",3},
  {"LATCH_GOGO"," stripe was already latched, got a GO then another GO","",4},
  {"NO_GATE"," no gating took place","",5},
  {"UCOND_RND_GO"," unconditional random go: just fire random go with a given probability, ","",6},
  {"NOGO_RND_GO"," random go for stripes constantly firing nogo","",7},
  {"ERR_RND_GO"," random go when an error has just been made: explore on error (ACC/LC?)","",8},
  {"AVGDA_RND_GO"," random go for stripes with consistently low average dopamine levels (under performers)","",9},
  NULL};
static int PFCGateSpec::* TA_PFCGateSpec_MbrOff;
static MemberDef_data TA_PFCGateSpec_MemberDef[]={
  {&TA_float,NULL,"off_accom"," how much of the maintenance current to apply to accommodation after turning a unit off","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::off_accom))),0,NULL,0},
  {&TA_bool,NULL,"updt_reset_sd"," reset synaptic depression when units are updated","DEF_true ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::updt_reset_sd))),0,NULL,0},
  {&TA_bool,NULL,"allow_clamp"," allow external hard clamp of layer (e.g., for testing)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::allow_clamp))),0,NULL,0},
  NULL};
static EnumDef_data TA_PFCLayerSpec_MaintUpdtAct[]={
  {"NO_UPDT"," no update action","",0},
  {"STORE"," store current activity state in maintenance currents","",1},
  {"CLEAR"," clear current activity state from maintenance currents","",2},
  {"RESTORE"," restore prior maintenance currents (after transient input activation)","",3},
  {"TMP_STORE"," temporary store of current activity state (for default maintenance of last state)","",4},
  {"TMP_CLEAR"," temporary clear of current maintenance state (for transient representation in second plus)","",5},
  NULL};
static int PFCLayerSpec::* TA_PFCLayerSpec_MbrOff;
static MemberDef_data TA_PFCLayerSpec_MemberDef[]={
  {&TA_PFCGateSpec,NULL,"gate"," parameters controlling the gating of pfc units","","",
    *((ta_memb_ptr*)&(TA_PFCLayerSpec_MbrOff=(int PFCLayerSpec::*)(&PFCLayerSpec::gate))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_ResetSynDep_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_MaintUpdt_MethArgs[]={
  {&TA_LeabraUnit_Group_ptr,NULL,"ugp",""},
  {NULL,"::MaintUpdtAct","updt_act",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_SendGateStates_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_TmpClear_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_GatingGOGO_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_PFCLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_PFCLayerSpec_CheckConfig_stub,TA_PFCLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCLayerSpec_Compute_HardClamp_stub,TA_PFCLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"PostSettle"," after settling, keep track of phase variables, etc.","","",
    0,3,2,1,0,NULL,cssElCFun_PFCLayerSpec_PostSettle_stub,TA_PFCLayerSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCLayerSpec_Compute_dWt_stub,TA_PFCLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_PFCLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_PFCLayerSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"ResetSynDep"," reset synaptic depression for sending cons from unit that was just toggled off in plus phase 1","","",
    0,3,-1,1,0,NULL,cssElCFun_PFCLayerSpec_ResetSynDep_stub,TA_PFCLayerSpec_ResetSynDep_MethArgs},
  {&TA_void,NULL,"Compute_MaintUpdt"," update maintenance state variables (gc.h, misc_1) based on given action","","",
    0,4,-1,1,0,NULL,cssElCFun_PFCLayerSpec_Compute_MaintUpdt_stub,TA_PFCLayerSpec_Compute_MaintUpdt_MethArgs},
  {&TA_void,NULL,"SendGateStates"," send misc_state gating state variables to the snrthal and matrix layers","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCLayerSpec_SendGateStates_stub,TA_PFCLayerSpec_SendGateStates_MethArgs},
  {&TA_void,NULL,"Compute_TmpClear"," temporarily clear the maintenance of pfc units to prepare way for transient acts","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCLayerSpec_Compute_TmpClear_stub,TA_PFCLayerSpec_Compute_TmpClear_MethArgs},
  {&TA_void,NULL,"Compute_GatingGOGO"," compute the gating signal based on SNrThal layer: GOGO model","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCLayerSpec_Compute_GatingGOGO_stub,TA_PFCLayerSpec_Compute_GatingGOGO_MethArgs},
  NULL};
static int PFCOutGateSpec::* TA_PFCOutGateSpec_MbrOff;
static MemberDef_data TA_PFCOutGateSpec_MemberDef[]={
  {&TA_float,NULL,"base_gain"," how much activation gets through even without a Go gating signal","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_PFCOutGateSpec_MbrOff=(int PFCOutGateSpec::*)(&PFCOutGateSpec::base_gain))),0,NULL,0},
  {&TA_float,NULL,"go_gain"," how much extra to add for a Go signal","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_PFCOutGateSpec_MbrOff=(int PFCOutGateSpec::*)(&PFCOutGateSpec::go_gain))),0,NULL,0},
  {&TA_bool,NULL,"graded_go"," use a graded Go signal as a function of strength of corresponding SNrThal unit?","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PFCOutGateSpec_MbrOff=(int PFCOutGateSpec::*)(&PFCOutGateSpec::graded_go))),0,NULL,0},
  NULL};
static int PFCOutLayerSpec::* TA_PFCOutLayerSpec_MbrOff;
static MemberDef_data TA_PFCOutLayerSpec_MemberDef[]={
  {&TA_PFCOutGateSpec,NULL,"out_gate"," parameters controlling the output gating of pfc units","","",
    *((ta_memb_ptr*)&(TA_PFCOutLayerSpec_MbrOff=(int PFCOutLayerSpec::*)(&PFCOutLayerSpec::out_gate))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PFCOutLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_PFCOutLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCOutLayerSpec_Compute_Inhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCOutLayerSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCOutLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_PFCOutLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraNetwork_ptr,NULL,"net",""},
  NULL};
static MethodDef_data TA_PFCOutLayerSpec_MethodDef[]={
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,3,2,1,0,NULL,cssElCFun_PFCOutLayerSpec_CheckConfig_stub,TA_PFCOutLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_Compute_HardClamp_stub,TA_PFCOutLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_Inhib"," stage two: compute the inhibition for layer","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_Compute_Inhib_stub,TA_PFCOutLayerSpec_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_Compute_InhibAvg_stub,TA_PFCOutLayerSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_Compute_Act_stub,TA_PFCOutLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_Compute_dWt_stub,TA_PFCOutLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec get help message for configuring this spec","BUTTON ","",
    0,0,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,1,0,NULL,cssElCFun_PFCOutLayerSpec_Defaults_stub,NULL},
  NULL};
static int LeabraCycle::* TA_LeabraCycle_MbrOff;
static MemberDef_data TA_LeabraCycle_MemberDef[]={
  {&TA_LeabraSettle_ptr,NULL,"leabra_settle"," pointer to parent settle proc","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCycle_MbrOff=(int LeabraCycle::*)(&LeabraCycle::leabra_settle))),0,NULL,0},
  NULL};
static int LeabraSettle::* TA_LeabraSettle_MbrOff;
static MemberDef_data TA_LeabraSettle_MemberDef[]={
  {&TA_LeabraTrial_ptr,NULL,"leabra_trial"," pointer to parent phase trial","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::leabra_trial))),0,NULL,0},
  {&TA_int,NULL,"min_cycles"," minimum number of cycles to settle for","DEF_15 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::min_cycles))),0,NULL,0},
  {&TA_int,NULL,"min_cycles_phase2"," minimum number of cycles to settle for in second phase","DEF_15 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::min_cycles_phase2))),0,NULL,0},
  {&TA_int,NULL,"netin_mod"," net input computation modulus: how often to compute netinput vs. activation update (2 = faster)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::netin_mod))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send netin deltas instead of raw netin: more efficient (automatically sets corresponding unitspec flag)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::send_delta))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraTrial_StateInit[]={
  {"DO_NOTHING"," do nothing","",0},
  {"INIT_STATE"," initialize state","",1},
  {"DECAY_STATE"," decay the state","",2},
  NULL};
static EnumDef_data TA_LeabraTrial_Phase[]={
  {"MINUS_PHASE"," minus phase","",0},
  {"PLUS_PHASE"," plus phase","",1},
  {"MINUS_2"," second minus phase","",2},
  {"PLUS_2"," second plus phase","",3},
  NULL};
static EnumDef_data TA_LeabraTrial_PhaseOrder[]={
  {"MINUS_PLUS"," standard minus-plus (err and assoc)","",0},
  {"PLUS_ONLY"," only present the plus phase (hebbian-only)","",1},
  {"MINUS_PLUS_NOTHING"," auto-encoder version with final 'nothing' minus phase","",2},
  {"PLUS_NOTHING"," just the auto-encoder (no initial minus phase)","",3},
  {"MINUS_PLUS_PLUS"," two plus phases for gated context layer updating","",4},
  {"MINUS_PLUS_2"," two minus-plus phases (for pfc/bg system)","",5},
  NULL};
static EnumDef_data TA_LeabraTrial_FirstPlusdWt[]={
  {"NO_FIRST_DWT"," for three phase cases: don't change weights after first plus","",0},
  {"ONLY_FIRST_DWT"," for three phase cases: only change weights after first plus","",1},
  {"ALL_DWT"," for three phase cases: change weights after *both* post-minus phases","",2},
  NULL};
static int LeabraTrial::* TA_LeabraTrial_MbrOff;
static MemberDef_data TA_LeabraTrial_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," [Default: MINUS_PLUS] number and order of phases to present","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase_order))),0,NULL,0},
  {&TA_Counter,NULL,"phase_no"," Current phase number","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase_no))),0,NULL,0},
  {NULL,"::Phase","phase"," Type of current phase: minus or plus","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase))),0,NULL,0},
  {NULL,"::StateInit","trial_init"," how to initialize network state at start of trial","DEF_DECAY_STATE ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::trial_init))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_stats"," don't do stats/logging in the plus phase","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::no_plus_stats))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_test"," don't run the plus phase when testing","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::no_plus_test))),0,NULL,0},
  {NULL,"::FirstPlusdWt","first_plus_dwt"," how to change weights on first plus phase if 2 plus phases (applies only to standard leabralayer specs -- others must decide on their own!)","CONDEDIT_ON_phase_order:MINUS_PLUS_PLUS ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::first_plus_dwt))),0,NULL,0},
  {&TA_int,NULL,"cycle"," current cycle value as copied from settle process ONLY VALID DURING PROCESSING","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::cycle))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraMaxDa_dAType[]={
  {"DA_ONLY"," just use da","",0},
  {"INET_ONLY"," just use inet","",1},
  {"INET_DA"," use inet if no activity, then use da","",2},
  NULL};
static int LeabraMaxDa::* TA_LeabraMaxDa_MbrOff;
static MemberDef_data TA_LeabraMaxDa_MemberDef[]={
  {&TA_LeabraSettle_ptr,NULL,"settle_proc"," the settle process","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::settle_proc))),0,NULL,0},
  {NULL,"::dAType","da_type"," type of activation change measure to use","DEF_INET_DA ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::da_type))),0,NULL,0},
  {&TA_float,NULL,"inet_scale"," how to scale the inet measure to be like da","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::inet_scale))),0,NULL,0},
  {&TA_float,NULL,"lay_avg_thr"," threshold for layer average activation to switch to da fm Inet","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::lay_avg_thr))),0,NULL,0},
  {&TA_StatVal,NULL,"da"," absolute value of activation change -- set the stopping criterion here to stop network settling when change has gone below threshold (typically .005)","","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::da))),0,NULL,0},
  {&TA_StatVal,NULL,"trg_max_act"," target layer(s) maximum activation value -- set the stopping criterion here to stop network settling when activation in target layer exceeds threshold (typically .85)","","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::trg_max_act))),0,NULL,0},
  NULL};
static int LeabraSE_Stat::* TA_LeabraSE_Stat_MbrOff;
static MemberDef_data TA_LeabraSE_Stat_MemberDef[]={
  {&TA_LeabraNetwork_ptr,NULL,"trial_proc"," the trial process to get phase info","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::trial_proc))),0,NULL,0},
  {NULL,"Unit::ExtType","targ_or_comp"," when to compute SE: targ = 1st minus, comp = 2nd minus, both = both","","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::targ_or_comp))),0,NULL,0},
  {&TA_bool,NULL,"no_off_err"," do not count a unit wrong if it is off but target says on -- only count wrong units that are on but should be off","","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::no_off_err))),0,NULL,0},
  NULL};
static int LeabraGoodStat::* TA_LeabraGoodStat_MbrOff;
static MemberDef_data TA_LeabraGoodStat_MemberDef[]={
  {&TA_bool,NULL,"subtr_inhib"," subtract inhibition from harmony?","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::subtr_inhib))),0,NULL,0},
  {&TA_StatVal,NULL,"hrmny"," harmony = act * netin = a_i sum_j a_j w_ij","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::hrmny))),0,NULL,0},
  {&TA_StatVal,NULL,"strss"," stress = act * log(act)","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::strss))),0,NULL,0},
  {&TA_StatVal,NULL,"gdnss"," goodness = harmony + stress","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::gdnss))),0,NULL,0},
  NULL};
static int LeabraSharpStat::* TA_LeabraSharpStat_MbrOff;
static MemberDef_data TA_LeabraSharpStat_MemberDef[]={
  {&TA_StatVal,NULL,"sharp"," sharpness = max / avg ","","",
    *((ta_memb_ptr*)&(TA_LeabraSharpStat_MbrOff=(int LeabraSharpStat::*)(&LeabraSharpStat::sharp))),0,NULL,0},
  NULL};
static int WrongOnStat::* TA_WrongOnStat_MbrOff;
static MemberDef_data TA_WrongOnStat_MemberDef[]={
  {&TA_Layer_ptr,NULL,"trg_lay"," target layer, containing activation pattern for all possible correct responses","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::trg_lay))),0,NULL,0},
  {&TA_StatVal,NULL,"wrng"," wrong on error statistic","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::wrng))),0,NULL,0},
  {&TA_float,NULL,"threshold"," activation value to consider unit being on","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::threshold))),0,NULL,0},
  NULL};
static int LeabraPrjnRelNetinStat::* TA_LeabraPrjnRelNetinStat_MbrOff;
static MemberDef_data TA_LeabraPrjnRelNetinStat_MemberDef[]={
  {&TA_StatVal_List,NULL,"relnet"," relative netinput contributions for the different projections into units in this layer","","",
    *((ta_memb_ptr*)&(TA_LeabraPrjnRelNetinStat_MbrOff=(int LeabraPrjnRelNetinStat::*)(&LeabraPrjnRelNetinStat::relnet))),0,NULL,0},
  {&TA_float,NULL,"recv_act_thr"," only compute netinput for receiving units that are active above this threshold (prevents dilution by varying numbers of inactive units)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_LeabraPrjnRelNetinStat_MbrOff=(int LeabraPrjnRelNetinStat::*)(&LeabraPrjnRelNetinStat::recv_act_thr))),0,NULL,0},
  NULL};
static int ExtRew_Stat::* TA_ExtRew_Stat_MbrOff;
static MemberDef_data TA_ExtRew_Stat_MemberDef[]={
  {&TA_StatVal,NULL,"rew"," external reward value","","",
    *((ta_memb_ptr*)&(TA_ExtRew_Stat_MbrOff=(int ExtRew_Stat::*)(&ExtRew_Stat::rew))),0,NULL,0},
  NULL};
static EnumDef_data TA_PhaseOrderEventSpec_PhaseOrder[]={
  {"MINUS_PLUS"," minus phase, then plus phase","",0},
  {"PLUS_MINUS"," plus phase, then minus phase","",1},
  {"MINUS_ONLY"," only present minus","",2},
  {"PLUS_ONLY"," only present plus","",3},
  NULL};
static int PhaseOrderEventSpec::* TA_PhaseOrderEventSpec_MbrOff;
static MemberDef_data TA_PhaseOrderEventSpec_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," order to present phases of stimuli to network","","",
    *((ta_memb_ptr*)&(TA_PhaseOrderEventSpec_MbrOff=(int PhaseOrderEventSpec::*)(&PhaseOrderEventSpec::phase_order))),0,NULL,0},
  NULL};
static MethodDef_data TA_V3LeabraProject_MethodDef[]={
  {&TA_bool,NULL,"ConvertToV4_impl"," implementation: must be defined by specific type of algorithm","CAT_Convert ","",
    0,0,-1,1,0,NULL,cssElCFun_V3LeabraProject_ConvertToV4_impl_stub,NULL},
  NULL};

// Init Function


static bool ta_Init_leabra_done = false;

void ta_Init_leabra() {
  TypeDef* sbt;

  if(ta_Init_leabra_done) return;
  ta_Init_leabra_done = true;

  ta_Init_ta();
  ta_Init_tamisc();
  ta_Init_pdp();

  taMisc::in_init = true;

  taMisc::types.Add(&TA_LeabraCon);
    TAI_LeabraCon = new LeabraCon;
    TA_LeabraCon.AddParFormal(&TA_class);
    TA_LeabraCon.AddParCache(&TA_taBase);
    TA_LeabraCon.AddClassPar(&TA_Connection,0);
    tac_AddMembers(TA_LeabraCon,TA_LeabraCon_MemberDef);
  taMisc::types.Add(&TA_LeabraConSpec);
    TAI_LeabraConSpec = new LeabraConSpec;
    TA_LeabraConSpec.AddParFormal(&TA_class);
    TA_LeabraConSpec.AddParCache(&TA_taBase);
    TA_LeabraConSpec.AddClassPar(&TA_ConSpec,0);
    tac_AddEnum(TA_LeabraConSpec, "LRSValue", " what value to drive the learning rate schedule with", "", "", "", TA_LeabraConSpec_LRSValue);
    tac_AddMembers(TA_LeabraConSpec,TA_LeabraConSpec_MemberDef);
    tac_AddMethods(TA_LeabraConSpec,TA_LeabraConSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraBiasSpec);
    TAI_LeabraBiasSpec = new LeabraBiasSpec;
    TA_LeabraBiasSpec.AddParFormal(&TA_class);
    TA_LeabraBiasSpec.AddParCache(&TA_taBase);
    TA_LeabraBiasSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_LeabraBiasSpec,TA_LeabraBiasSpec_MemberDef);
    tac_AddMethods(TA_LeabraBiasSpec,TA_LeabraBiasSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraCon_Group);
    TAI_LeabraCon_Group = new LeabraCon_Group;
    TA_LeabraCon_Group.AddParFormal(&TA_class);
    TA_LeabraCon_Group.AddParCache(&TA_taBase);
    TA_LeabraCon_Group.AddClassPar(&TA_Con_Group,0);
    tac_AddMembers(TA_LeabraCon_Group,TA_LeabraCon_Group_MemberDef);
    tac_AddMethods(TA_LeabraCon_Group,TA_LeabraCon_Group_MethodDef);
  taMisc::types.Add(&TA_LeabraUnitSpec);
    TAI_LeabraUnitSpec = new LeabraUnitSpec;
    TA_LeabraUnitSpec.AddParFormal(&TA_class);
    TA_LeabraUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraUnitSpec.AddClassPar(&TA_UnitSpec,0);
    tac_AddEnum(TA_LeabraUnitSpec, "ActFun", "", "", "", "", TA_LeabraUnitSpec_ActFun);
    tac_AddEnum(TA_LeabraUnitSpec, "NoiseType", "", "", "", "", TA_LeabraUnitSpec_NoiseType);
    tac_AddMembers(TA_LeabraUnitSpec,TA_LeabraUnitSpec_MemberDef);
    tac_AddMethods(TA_LeabraUnitSpec,TA_LeabraUnitSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraUnit);
    TAI_LeabraUnit = new LeabraUnit;
    TA_LeabraUnit.AddParFormal(&TA_class);
    TA_LeabraUnit.AddParCache(&TA_taBase);
    TA_LeabraUnit.AddClassPar(&TA_Unit,0);
    tac_AddMembers(TA_LeabraUnit,TA_LeabraUnit_MemberDef);
    tac_AddMethods(TA_LeabraUnit,TA_LeabraUnit_MethodDef);
  taMisc::types.Add(&TA_LeabraInhib);
    TA_LeabraInhib.AddParFormal(&TA_class);
    tac_AddMembers(TA_LeabraInhib,TA_LeabraInhib_MemberDef);
    tac_AddMethods(TA_LeabraInhib,TA_LeabraInhib_MethodDef);
  taMisc::types.Add(&TA_LeabraLayerSpec);
    TAI_LeabraLayerSpec = new LeabraLayerSpec;
    TA_LeabraLayerSpec.AddParFormal(&TA_class);
    TA_LeabraLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraLayerSpec.AddClassPar(&TA_LayerSpec,0);
    tac_AddEnum(TA_LeabraLayerSpec, "Compute_I", " how to compute the inhibition", "", "", "", TA_LeabraLayerSpec_Compute_I);
    tac_AddEnum(TA_LeabraLayerSpec, "InhibGroup", "", "", "", "", TA_LeabraLayerSpec_InhibGroup);
    tac_AddMembers(TA_LeabraLayerSpec,TA_LeabraLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraLayerSpec,TA_LeabraLayerSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraUnit_Group);
    TAI_LeabraUnit_Group = new LeabraUnit_Group;
    TA_LeabraUnit_Group.AddParFormal(&TA_class);
    TA_LeabraUnit_Group.AddParCache(&TA_taBase);
    TA_LeabraUnit_Group.AddClassPar(&TA_Unit_Group,(int)((unsigned long)((Unit_Group*)TAI_LeabraUnit_Group)-(unsigned long)TAI_LeabraUnit_Group), &TA_LeabraInhib,(int)((unsigned long)((LeabraInhib*)TAI_LeabraUnit_Group)-(unsigned long)TAI_LeabraUnit_Group));
    tac_AddMembers(TA_LeabraUnit_Group,TA_LeabraUnit_Group_MemberDef);
    tac_AddMethods(TA_LeabraUnit_Group,TA_LeabraUnit_Group_MethodDef);
  taMisc::types.Add(&TA_LeabraLayer);
    TAI_LeabraLayer = new LeabraLayer;
    TA_LeabraLayer.AddParFormal(&TA_class);
    TA_LeabraLayer.AddParCache(&TA_taBase);
    TA_LeabraLayer.AddClassPar(&TA_Layer,(int)((unsigned long)((Layer*)TAI_LeabraLayer)-(unsigned long)TAI_LeabraLayer), &TA_LeabraInhib,(int)((unsigned long)((LeabraInhib*)TAI_LeabraLayer)-(unsigned long)TAI_LeabraLayer));
    tac_AddMembers(TA_LeabraLayer,TA_LeabraLayer_MemberDef);
    tac_AddMethods(TA_LeabraLayer,TA_LeabraLayer_MethodDef);
  taMisc::types.Add(&TA_LeabraNetwork);
    TAI_LeabraNetwork = new LeabraNetwork;
    TA_LeabraNetwork.AddParFormal(&TA_class);
    TA_LeabraNetwork.AddParCache(&TA_taBase);
    TA_LeabraNetwork.AddClassPar(&TA_Network,0);
    tac_AddEnum(TA_LeabraNetwork, "StateInit", " ways of initializing the state of the network", "", "", "", TA_LeabraNetwork_StateInit);
    tac_AddEnum(TA_LeabraNetwork, "Phase", "", "", "", "", TA_LeabraNetwork_Phase);
    tac_AddEnum(TA_LeabraNetwork, "PhaseOrder", "", "", "", "", TA_LeabraNetwork_PhaseOrder);
    tac_AddEnum(TA_LeabraNetwork, "FirstPlusdWt", "", "", "", "", TA_LeabraNetwork_FirstPlusdWt);
    tac_AddMembers(TA_LeabraNetwork,TA_LeabraNetwork_MemberDef);
    tac_AddMethods(TA_LeabraNetwork,TA_LeabraNetwork_MethodDef);
  taMisc::types.Add(&TA_LeabraProject);
    TAI_LeabraProject = new LeabraProject;
    TA_LeabraProject.AddParFormal(&TA_class);
    TA_LeabraProject.AddParCache(&TA_taBase);
    TA_LeabraProject.AddClassPar(&TA_ProjectBase,0);
  taMisc::types.Add(&TA_const_LeabraCon);
    TA_const_LeabraCon.AddParents(&TA_const, &TA_LeabraCon);
  taMisc::types.Add(&TA_const_LeabraCon_ref);
    TA_const_LeabraCon_ref.AddParents(&TA_const_LeabraCon);
  taMisc::types.Add(&TA_WtScaleSpec);
    TAI_WtScaleSpec = new WtScaleSpec;
    TA_WtScaleSpec.AddParFormal(&TA_class);
    TA_WtScaleSpec.AddParCache(&TA_taBase);
    TA_WtScaleSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_WtScaleSpec,TA_WtScaleSpec_MemberDef);
    tac_AddMethods(TA_WtScaleSpec,TA_WtScaleSpec_MethodDef);
  taMisc::types.Add(&TA_const_WtScaleSpec);
    TA_const_WtScaleSpec.AddParents(&TA_const, &TA_WtScaleSpec);
  taMisc::types.Add(&TA_WtSigSpec);
    TAI_WtSigSpec = new WtSigSpec;
    TA_WtSigSpec.AddParFormal(&TA_class);
    TA_WtSigSpec.AddParCache(&TA_taBase);
    TA_WtSigSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_WtSigSpec,TA_WtSigSpec_MemberDef);
    tac_AddMethods(TA_WtSigSpec,TA_WtSigSpec_MethodDef);
  taMisc::types.Add(&TA_const_WtScaleSpec_ref);
    TA_const_WtScaleSpec_ref.AddParents(&TA_const_WtScaleSpec);
  taMisc::types.Add(&TA_const_WtSigSpec);
    TA_const_WtSigSpec.AddParents(&TA_const, &TA_WtSigSpec);
  taMisc::types.Add(&TA_const_WtSigSpec_ref);
    TA_const_WtSigSpec_ref.AddParents(&TA_const_WtSigSpec);
  taMisc::types.Add(&TA_LearnMixSpec);
    TAI_LearnMixSpec = new LearnMixSpec;
    TA_LearnMixSpec.AddParFormal(&TA_class);
    TA_LearnMixSpec.AddParCache(&TA_taBase);
    TA_LearnMixSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LearnMixSpec,TA_LearnMixSpec_MemberDef);
    tac_AddMethods(TA_LearnMixSpec,TA_LearnMixSpec_MethodDef);
  taMisc::types.Add(&TA_const_LearnMixSpec);
    TA_const_LearnMixSpec.AddParents(&TA_const, &TA_LearnMixSpec);
  taMisc::types.Add(&TA_const_LearnMixSpec_ref);
    TA_const_LearnMixSpec_ref.AddParents(&TA_const_LearnMixSpec);
  taMisc::types.Add(&TA_SAvgCorSpec);
    TAI_SAvgCorSpec = new SAvgCorSpec;
    TA_SAvgCorSpec.AddParFormal(&TA_class);
    TA_SAvgCorSpec.AddParCache(&TA_taBase);
    TA_SAvgCorSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SAvgCorSpec,TA_SAvgCorSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraCon_Group_ptr);
    TA_LeabraCon_Group_ptr.AddParents(&TA_LeabraCon_Group);
  taMisc::types.Add(&TA_const_SAvgCorSpec);
    TA_const_SAvgCorSpec.AddParents(&TA_const, &TA_SAvgCorSpec);
  taMisc::types.Add(&TA_LeabraCon_ptr);
    TA_LeabraCon_ptr.AddParents(&TA_LeabraCon);
  taMisc::types.Add(&TA_const_SAvgCorSpec_ref);
    TA_const_SAvgCorSpec_ref.AddParents(&TA_const_SAvgCorSpec);
  taMisc::types.Add(&TA_LeabraUnit_ptr);
    TA_LeabraUnit_ptr.AddParents(&TA_LeabraUnit);
  taMisc::types.Add(&TA_LeabraUnitSpec_ptr);
    TA_LeabraUnitSpec_ptr.AddParents(&TA_LeabraUnitSpec);
  taMisc::types.Add(&TA_LeabraNetwork_ptr);
    TA_LeabraNetwork_ptr.AddParents(&TA_LeabraNetwork);
  taMisc::types.Add(&TA_const_LeabraConSpec);
    TA_const_LeabraConSpec.AddParents(&TA_const, &TA_LeabraConSpec);
  taMisc::types.Add(&TA_const_LeabraConSpec_ref);
    TA_const_LeabraConSpec_ref.AddParents(&TA_const_LeabraConSpec);
  taMisc::types.Add(&TA_const_LeabraBiasSpec);
    TA_const_LeabraBiasSpec.AddParents(&TA_const, &TA_LeabraBiasSpec);
  taMisc::types.Add(&TA_const_LeabraBiasSpec_ref);
    TA_const_LeabraBiasSpec_ref.AddParents(&TA_const_LeabraBiasSpec);
  taMisc::types.Add(&TA_const_LeabraCon_Group);
    TA_const_LeabraCon_Group.AddParents(&TA_const, &TA_LeabraCon_Group);
  taMisc::types.Add(&TA_const_LeabraCon_Group_ref);
    TA_const_LeabraCon_Group_ref.AddParents(&TA_const_LeabraCon_Group);
  taMisc::types.Add(&TA_ActFunSpec);
    TAI_ActFunSpec = new ActFunSpec;
    TA_ActFunSpec.AddParFormal(&TA_class);
    TA_ActFunSpec.AddParCache(&TA_taBase);
    TA_ActFunSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ActFunSpec, "IThrFun", "", "", "", "", TA_ActFunSpec_IThrFun);
    tac_AddMembers(TA_ActFunSpec,TA_ActFunSpec_MemberDef);
  taMisc::types.Add(&TA_const_ActFunSpec);
    TA_const_ActFunSpec.AddParents(&TA_const, &TA_ActFunSpec);
  taMisc::types.Add(&TA_SpikeFunSpec);
    TAI_SpikeFunSpec = new SpikeFunSpec;
    TA_SpikeFunSpec.AddParFormal(&TA_class);
    TA_SpikeFunSpec.AddParCache(&TA_taBase);
    TA_SpikeFunSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SpikeFunSpec,TA_SpikeFunSpec_MemberDef);
  taMisc::types.Add(&TA_const_ActFunSpec_ref);
    TA_const_ActFunSpec_ref.AddParents(&TA_const_ActFunSpec);
  taMisc::types.Add(&TA_const_SpikeFunSpec);
    TA_const_SpikeFunSpec.AddParents(&TA_const, &TA_SpikeFunSpec);
  taMisc::types.Add(&TA_const_SpikeFunSpec_ref);
    TA_const_SpikeFunSpec_ref.AddParents(&TA_const_SpikeFunSpec);
  taMisc::types.Add(&TA_DepressSpec);
    TAI_DepressSpec = new DepressSpec;
    TA_DepressSpec.AddParFormal(&TA_class);
    TA_DepressSpec.AddParCache(&TA_taBase);
    TA_DepressSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_DepressSpec, "PSpike", "", "", "", "", TA_DepressSpec_PSpike);
    tac_AddMembers(TA_DepressSpec,TA_DepressSpec_MemberDef);
    tac_AddMethods(TA_DepressSpec,TA_DepressSpec_MethodDef);
  taMisc::types.Add(&TA_const_DepressSpec);
    TA_const_DepressSpec.AddParents(&TA_const, &TA_DepressSpec);
  taMisc::types.Add(&TA_const_DepressSpec_ref);
    TA_const_DepressSpec_ref.AddParents(&TA_const_DepressSpec);
  taMisc::types.Add(&TA_OptThreshSpec);
    TAI_OptThreshSpec = new OptThreshSpec;
    TA_OptThreshSpec.AddParFormal(&TA_class);
    TA_OptThreshSpec.AddParCache(&TA_taBase);
    TA_OptThreshSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_OptThreshSpec,TA_OptThreshSpec_MemberDef);
  taMisc::types.Add(&TA_const_OptThreshSpec);
    TA_const_OptThreshSpec.AddParents(&TA_const, &TA_OptThreshSpec);
  taMisc::types.Add(&TA_const_OptThreshSpec_ref);
    TA_const_OptThreshSpec_ref.AddParents(&TA_const_OptThreshSpec);
  taMisc::types.Add(&TA_DtSpec);
    TAI_DtSpec = new DtSpec;
    TA_DtSpec.AddParFormal(&TA_class);
    TA_DtSpec.AddParCache(&TA_taBase);
    TA_DtSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DtSpec,TA_DtSpec_MemberDef);
  taMisc::types.Add(&TA_const_DtSpec);
    TA_const_DtSpec.AddParents(&TA_const, &TA_DtSpec);
  taMisc::types.Add(&TA_const_DtSpec_ref);
    TA_const_DtSpec_ref.AddParents(&TA_const_DtSpec);
  taMisc::types.Add(&TA_LeabraChannels);
    TAI_LeabraChannels = new LeabraChannels;
    TA_LeabraChannels.AddParFormal(&TA_class);
    TA_LeabraChannels.AddParCache(&TA_taBase);
    TA_LeabraChannels.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LeabraChannels,TA_LeabraChannels_MemberDef);
  taMisc::types.Add(&TA_const_LeabraChannels);
    TA_const_LeabraChannels.AddParents(&TA_const, &TA_LeabraChannels);
  taMisc::types.Add(&TA_const_LeabraChannels_ref);
    TA_const_LeabraChannels_ref.AddParents(&TA_const_LeabraChannels);
  taMisc::types.Add(&TA_VChanSpec);
    TAI_VChanSpec = new VChanSpec;
    TA_VChanSpec.AddParFormal(&TA_class);
    TA_VChanSpec.AddParCache(&TA_taBase);
    TA_VChanSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VChanSpec,TA_VChanSpec_MemberDef);
    tac_AddMethods(TA_VChanSpec,TA_VChanSpec_MethodDef);
  taMisc::types.Add(&TA_const_VChanSpec);
    TA_const_VChanSpec.AddParents(&TA_const, &TA_VChanSpec);
  taMisc::types.Add(&TA_ActRegSpec);
    TAI_ActRegSpec = new ActRegSpec;
    TA_ActRegSpec.AddParFormal(&TA_class);
    TA_ActRegSpec.AddParCache(&TA_taBase);
    TA_ActRegSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActRegSpec,TA_ActRegSpec_MemberDef);
  taMisc::types.Add(&TA_const_VChanSpec_ref);
    TA_const_VChanSpec_ref.AddParents(&TA_const_VChanSpec);
  taMisc::types.Add(&TA_const_ActRegSpec);
    TA_const_ActRegSpec.AddParents(&TA_const, &TA_ActRegSpec);
  taMisc::types.Add(&TA_const_ActRegSpec_ref);
    TA_const_ActRegSpec_ref.AddParents(&TA_const_ActRegSpec);
  taMisc::types.Add(&TA_MaxDaSpec);
    TAI_MaxDaSpec = new MaxDaSpec;
    TA_MaxDaSpec.AddParFormal(&TA_class);
    TA_MaxDaSpec.AddParCache(&TA_taBase);
    TA_MaxDaSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_MaxDaSpec, "dAValue", "", "", "", "", TA_MaxDaSpec_dAValue);
    tac_AddMembers(TA_MaxDaSpec,TA_MaxDaSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraLayer_ptr);
    TA_LeabraLayer_ptr.AddParents(&TA_LeabraLayer);
  taMisc::types.Add(&TA_const_MaxDaSpec);
    TA_const_MaxDaSpec.AddParents(&TA_const, &TA_MaxDaSpec);
  taMisc::types.Add(&TA_LeabraInhib_ptr);
    TA_LeabraInhib_ptr.AddParents(&TA_LeabraInhib);
  taMisc::types.Add(&TA_const_MaxDaSpec_ref);
    TA_const_MaxDaSpec_ref.AddParents(&TA_const_MaxDaSpec);
  taMisc::types.Add(&TA_const_LeabraUnitSpec);
    TA_const_LeabraUnitSpec.AddParents(&TA_const, &TA_LeabraUnitSpec);
  taMisc::types.Add(&TA_const_LeabraUnitSpec_ref);
    TA_const_LeabraUnitSpec_ref.AddParents(&TA_const_LeabraUnitSpec);
  taMisc::types.Add(&TA_VChanBasis);
    TAI_VChanBasis = new VChanBasis;
    TA_VChanBasis.AddParFormal(&TA_class);
    TA_VChanBasis.AddParCache(&TA_taBase);
    TA_VChanBasis.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VChanBasis,TA_VChanBasis_MemberDef);
  taMisc::types.Add(&TA_const_VChanBasis);
    TA_const_VChanBasis.AddParents(&TA_const, &TA_VChanBasis);
  taMisc::types.Add(&TA_LeabraUnitChans);
    TAI_LeabraUnitChans = new LeabraUnitChans;
    TA_LeabraUnitChans.AddParFormal(&TA_class);
    TA_LeabraUnitChans.AddParCache(&TA_taBase);
    TA_LeabraUnitChans.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LeabraUnitChans,TA_LeabraUnitChans_MemberDef);
  taMisc::types.Add(&TA_const_VChanBasis_ref);
    TA_const_VChanBasis_ref.AddParents(&TA_const_VChanBasis);
  taMisc::types.Add(&TA_const_LeabraUnit);
    TA_const_LeabraUnit.AddParents(&TA_const, &TA_LeabraUnit);
  taMisc::types.Add(&TA_const_LeabraUnitChans);
    TA_const_LeabraUnitChans.AddParents(&TA_const, &TA_LeabraUnitChans);
  taMisc::types.Add(&TA_const_LeabraUnit_ref);
    TA_const_LeabraUnit_ref.AddParents(&TA_const_LeabraUnit);
  taMisc::types.Add(&TA_const_LeabraUnitChans_ref);
    TA_const_LeabraUnitChans_ref.AddParents(&TA_const_LeabraUnitChans);
  taMisc::types.Add(&TA_taPtrList_LeabraUnit_);
    TAI_taPtrList_LeabraUnit_ = new taPtrList<LeabraUnit>;
    TA_taPtrList_LeabraUnit_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taPtrList_LeabraUnit_.AddClassPar(&TA_taPtrList,0);
    sbt = new TypeDef("LeabraUnit_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LeabraUnit);
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    sbt = new TypeDef("const_LeabraUnit", 1, 0, 0);
    sbt->AddParents(&TA_const, &TA_LeabraUnit);
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    sbt = new TypeDef("const_LeabraUnit_ptr", 1, 1, 0);
    sbt->AddParents(TA_taPtrList_LeabraUnit_.sub_types.FindName("const_LeabraUnit"));
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    tac_AddMethods(TA_taPtrList_LeabraUnit_,TA_taPtrList_LeabraUnit__MethodDef);
  taMisc::types.Add(&TA_LeabraSort);
    TA_LeabraSort.AddParFormal(&TA_class);
    TA_LeabraSort.AddClassPar(&TA_taPtrList_LeabraUnit_,0);
    tac_AddMethods(TA_LeabraSort,TA_LeabraSort_MethodDef);
  taMisc::types.Add(&TA_KWTASpec);
    TAI_KWTASpec = new KWTASpec;
    TA_KWTASpec.AddParFormal(&TA_class);
    TA_KWTASpec.AddParCache(&TA_taBase);
    TA_KWTASpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_KWTASpec, "K_From", "", "", "", "", TA_KWTASpec_K_From);
    tac_AddMembers(TA_KWTASpec,TA_KWTASpec_MemberDef);
  taMisc::types.Add(&TA_const_KWTASpec);
    TA_const_KWTASpec.AddParents(&TA_const, &TA_KWTASpec);
  taMisc::types.Add(&TA_KwtaTieBreak);
    TAI_KwtaTieBreak = new KwtaTieBreak;
    TA_KwtaTieBreak.AddParFormal(&TA_class);
    TA_KwtaTieBreak.AddParCache(&TA_taBase);
    TA_KwtaTieBreak.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_KwtaTieBreak,TA_KwtaTieBreak_MemberDef);
  taMisc::types.Add(&TA_const_KWTASpec_ref);
    TA_const_KWTASpec_ref.AddParents(&TA_const_KWTASpec);
  taMisc::types.Add(&TA_const_KwtaTieBreak);
    TA_const_KwtaTieBreak.AddParents(&TA_const, &TA_KwtaTieBreak);
  taMisc::types.Add(&TA_const_KwtaTieBreak_ref);
    TA_const_KwtaTieBreak_ref.AddParents(&TA_const_KwtaTieBreak);
  taMisc::types.Add(&TA_AdaptISpec);
    TAI_AdaptISpec = new AdaptISpec;
    TA_AdaptISpec.AddParFormal(&TA_class);
    TA_AdaptISpec.AddParCache(&TA_taBase);
    TA_AdaptISpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_AdaptISpec, "AdaptType", "", "", "", "", TA_AdaptISpec_AdaptType);
    tac_AddMembers(TA_AdaptISpec,TA_AdaptISpec_MemberDef);
  taMisc::types.Add(&TA_const_AdaptISpec);
    TA_const_AdaptISpec.AddParents(&TA_const, &TA_AdaptISpec);
  taMisc::types.Add(&TA_const_AdaptISpec_ref);
    TA_const_AdaptISpec_ref.AddParents(&TA_const_AdaptISpec);
  taMisc::types.Add(&TA_ClampSpec);
    TAI_ClampSpec = new ClampSpec;
    TA_ClampSpec.AddParFormal(&TA_class);
    TA_ClampSpec.AddParCache(&TA_taBase);
    TA_ClampSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ClampSpec,TA_ClampSpec_MemberDef);
  taMisc::types.Add(&TA_const_ClampSpec);
    TA_const_ClampSpec.AddParents(&TA_const, &TA_ClampSpec);
  taMisc::types.Add(&TA_const_ClampSpec_ref);
    TA_const_ClampSpec_ref.AddParents(&TA_const_ClampSpec);
  taMisc::types.Add(&TA_DecaySpec);
    TAI_DecaySpec = new DecaySpec;
    TA_DecaySpec.AddParFormal(&TA_class);
    TA_DecaySpec.AddParCache(&TA_taBase);
    TA_DecaySpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DecaySpec,TA_DecaySpec_MemberDef);
  taMisc::types.Add(&TA_const_DecaySpec);
    TA_const_DecaySpec.AddParents(&TA_const, &TA_DecaySpec);
  taMisc::types.Add(&TA_const_DecaySpec_ref);
    TA_const_DecaySpec_ref.AddParents(&TA_const_DecaySpec);
  taMisc::types.Add(&TA_LayNetRescaleSpec);
    TAI_LayNetRescaleSpec = new LayNetRescaleSpec;
    TA_LayNetRescaleSpec.AddParFormal(&TA_class);
    TA_LayNetRescaleSpec.AddParCache(&TA_taBase);
    TA_LayNetRescaleSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LayNetRescaleSpec,TA_LayNetRescaleSpec_MemberDef);
  taMisc::types.Add(&TA_const_LayNetRescaleSpec);
    TA_const_LayNetRescaleSpec.AddParents(&TA_const, &TA_LayNetRescaleSpec);
  taMisc::types.Add(&TA_KWTASpec_ref);
    TA_KWTASpec_ref.AddParents(&TA_KWTASpec);
  taMisc::types.Add(&TA_const_LayNetRescaleSpec_ref);
    TA_const_LayNetRescaleSpec_ref.AddParents(&TA_const_LayNetRescaleSpec);
  taMisc::types.Add(&TA_const_LeabraLayerSpec);
    TA_const_LeabraLayerSpec.AddParents(&TA_const, &TA_LeabraLayerSpec);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_ref);
    TA_const_LeabraLayerSpec_ref.AddParents(&TA_const_LeabraLayerSpec);
  taMisc::types.Add(&TA_SpecPtr_LeabraLayerSpec_);
    TAI_SpecPtr_LeabraLayerSpec_ = new SpecPtr<LeabraLayerSpec>;
    TA_SpecPtr_LeabraLayerSpec_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_SpecPtr_LeabraLayerSpec_.AddParCache(&TA_taBase);
    TA_SpecPtr_LeabraLayerSpec_.AddClassPar(&TA_SpecPtr,0);
    sbt = new TypeDef("LeabraLayerSpec_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LeabraLayerSpec);
    TA_SpecPtr_LeabraLayerSpec_.sub_types.Add(sbt);
    tac_AddEnum(TA_SpecPtr_LeabraLayerSpec_, "Orientation", " must be same values as Qt::Orientation", "", "", "", TA_SpecPtr_LeabraLayerSpec__Orientation);
    tac_AddEnum(TA_SpecPtr_LeabraLayerSpec_, "ValType", " the basic data types widely supported by data-handling api's, esp. matrices", "", "", "", TA_SpecPtr_LeabraLayerSpec__ValType);
    tac_AddMembers(TA_SpecPtr_LeabraLayerSpec_,TA_SpecPtr_LeabraLayerSpec__MemberDef);
    tac_AddMethods(TA_SpecPtr_LeabraLayerSpec_,TA_SpecPtr_LeabraLayerSpec__MethodDef);
  taMisc::types.Add(&TA_LeabraLayerSpec_SPtr);
    TAI_LeabraLayerSpec_SPtr = new LeabraLayerSpec_SPtr;
    TA_LeabraLayerSpec_SPtr.AddParFormal(&TA_class);
    TA_LeabraLayerSpec_SPtr.AddParCache(&TA_taBase);
    TA_LeabraLayerSpec_SPtr.AddClassPar(&TA_SpecPtr_LeabraLayerSpec_,0);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_SPtr);
    TA_const_LeabraLayerSpec_SPtr.AddParents(&TA_const, &TA_LeabraLayerSpec_SPtr);
  taMisc::types.Add(&TA_AvgMaxVals);
    TAI_AvgMaxVals = new AvgMaxVals;
    TA_AvgMaxVals.AddParFormal(&TA_class);
    TA_AvgMaxVals.AddParCache(&TA_taBase);
    TA_AvgMaxVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AvgMaxVals,TA_AvgMaxVals_MemberDef);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_SPtr_ref);
    TA_const_LeabraLayerSpec_SPtr_ref.AddParents(&TA_const_LeabraLayerSpec_SPtr);
  taMisc::types.Add(&TA_const_AvgMaxVals);
    TA_const_AvgMaxVals.AddParents(&TA_const, &TA_AvgMaxVals);
  taMisc::types.Add(&TA_const_AvgMaxVals_ref);
    TA_const_AvgMaxVals_ref.AddParents(&TA_const_AvgMaxVals);
  taMisc::types.Add(&TA_KWTAVals);
    TAI_KWTAVals = new KWTAVals;
    TA_KWTAVals.AddParFormal(&TA_class);
    TA_KWTAVals.AddParCache(&TA_taBase);
    TA_KWTAVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_KWTAVals,TA_KWTAVals_MemberDef);
    tac_AddMethods(TA_KWTAVals,TA_KWTAVals_MethodDef);
  taMisc::types.Add(&TA_const_KWTAVals);
    TA_const_KWTAVals.AddParents(&TA_const, &TA_KWTAVals);
  taMisc::types.Add(&TA_const_KWTAVals_ref);
    TA_const_KWTAVals_ref.AddParents(&TA_const_KWTAVals);
  taMisc::types.Add(&TA_AdaptIVals);
    TAI_AdaptIVals = new AdaptIVals;
    TA_AdaptIVals.AddParFormal(&TA_class);
    TA_AdaptIVals.AddParCache(&TA_taBase);
    TA_AdaptIVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AdaptIVals,TA_AdaptIVals_MemberDef);
  taMisc::types.Add(&TA_const_AdaptIVals);
    TA_const_AdaptIVals.AddParents(&TA_const, &TA_AdaptIVals);
  taMisc::types.Add(&TA_const_AdaptIVals_ref);
    TA_const_AdaptIVals_ref.AddParents(&TA_const_AdaptIVals);
  taMisc::types.Add(&TA_InhibVals);
    TAI_InhibVals = new InhibVals;
    TA_InhibVals.AddParFormal(&TA_class);
    TA_InhibVals.AddParCache(&TA_taBase);
    TA_InhibVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_InhibVals,TA_InhibVals_MemberDef);
  taMisc::types.Add(&TA_LeabraLayerSpec_ptr);
    TA_LeabraLayerSpec_ptr.AddParents(&TA_LeabraLayerSpec);
  taMisc::types.Add(&TA_const_InhibVals);
    TA_const_InhibVals.AddParents(&TA_const, &TA_InhibVals);
  taMisc::types.Add(&TA_const_LeabraInhib);
    TA_const_LeabraInhib.AddParents(&TA_const, &TA_LeabraInhib);
  taMisc::types.Add(&TA_const_InhibVals_ref);
    TA_const_InhibVals_ref.AddParents(&TA_const_InhibVals);
  taMisc::types.Add(&TA_const_LeabraInhib_ref);
    TA_const_LeabraInhib_ref.AddParents(&TA_const_LeabraInhib);
  taMisc::types.Add(&TA_const_LeabraLayer);
    TA_const_LeabraLayer.AddParents(&TA_const, &TA_LeabraLayer);
  taMisc::types.Add(&TA_const_LeabraLayer_ref);
    TA_const_LeabraLayer_ref.AddParents(&TA_const_LeabraLayer);
  taMisc::types.Add(&TA_const_LeabraUnit_Group);
    TA_const_LeabraUnit_Group.AddParents(&TA_const, &TA_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_LeabraUnit_Group_ref);
    TA_const_LeabraUnit_Group_ref.AddParents(&TA_const_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_LeabraNetwork);
    TA_const_LeabraNetwork.AddParents(&TA_const, &TA_LeabraNetwork);
  taMisc::types.Add(&TA_const_LeabraNetwork_ref);
    TA_const_LeabraNetwork_ref.AddParents(&TA_const_LeabraNetwork);
  taMisc::types.Add(&TA_const_LeabraProject);
    TA_const_LeabraProject.AddParents(&TA_const, &TA_LeabraProject);
  taMisc::types.Add(&TA_const_LeabraProject_ref);
    TA_const_LeabraProject_ref.AddParents(&TA_const_LeabraProject);
  taMisc::types.Add(&TA_LeabraWizard);
    TAI_LeabraWizard = new LeabraWizard;
    TA_LeabraWizard.AddParFormal(&TA_class);
    TA_LeabraWizard.AddParCache(&TA_taBase);
    TA_LeabraWizard.AddClassPar(&TA_Wizard,0);
    tac_AddMethods(TA_LeabraWizard,TA_LeabraWizard_MethodDef);
  taMisc::types.Add(&TA_const_LeabraWizard);
    TA_const_LeabraWizard.AddParents(&TA_const, &TA_LeabraWizard);
  taMisc::types.Add(&TA_MarkerConSpec);
    TAI_MarkerConSpec = new MarkerConSpec;
    TA_MarkerConSpec.AddParFormal(&TA_class);
    TA_MarkerConSpec.AddParCache(&TA_taBase);
    TA_MarkerConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_MarkerConSpec,TA_MarkerConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraWizard_ref);
    TA_const_LeabraWizard_ref.AddParents(&TA_const_LeabraWizard);
  taMisc::types.Add(&TA_const_MarkerConSpec);
    TA_const_MarkerConSpec.AddParents(&TA_const, &TA_MarkerConSpec);
  taMisc::types.Add(&TA_const_MarkerConSpec_ref);
    TA_const_MarkerConSpec_ref.AddParents(&TA_const_MarkerConSpec);
  taMisc::types.Add(&TA_CtxtUpdateSpec);
    TAI_CtxtUpdateSpec = new CtxtUpdateSpec;
    TA_CtxtUpdateSpec.AddParFormal(&TA_class);
    TA_CtxtUpdateSpec.AddParCache(&TA_taBase);
    TA_CtxtUpdateSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_CtxtUpdateSpec,TA_CtxtUpdateSpec_MemberDef);
  taMisc::types.Add(&TA_const_CtxtUpdateSpec);
    TA_const_CtxtUpdateSpec.AddParents(&TA_const, &TA_CtxtUpdateSpec);
  taMisc::types.Add(&TA_const_CtxtUpdateSpec_ref);
    TA_const_CtxtUpdateSpec_ref.AddParents(&TA_const_CtxtUpdateSpec);
  taMisc::types.Add(&TA_LeabraContextLayerSpec);
    TAI_LeabraContextLayerSpec = new LeabraContextLayerSpec;
    TA_LeabraContextLayerSpec.AddParFormal(&TA_class);
    TA_LeabraContextLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraContextLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_LeabraContextLayerSpec,TA_LeabraContextLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraContextLayerSpec,TA_LeabraContextLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraContextLayerSpec);
    TA_const_LeabraContextLayerSpec.AddParents(&TA_const, &TA_LeabraContextLayerSpec);
  taMisc::types.Add(&TA_const_LeabraContextLayerSpec_ref);
    TA_const_LeabraContextLayerSpec_ref.AddParents(&TA_const_LeabraContextLayerSpec);
  taMisc::types.Add(&TA_LeabraLinUnitSpec);
    TAI_LeabraLinUnitSpec = new LeabraLinUnitSpec;
    TA_LeabraLinUnitSpec.AddParFormal(&TA_class);
    TA_LeabraLinUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraLinUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
    tac_AddMethods(TA_LeabraLinUnitSpec,TA_LeabraLinUnitSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraLinUnitSpec);
    TA_const_LeabraLinUnitSpec.AddParents(&TA_const, &TA_LeabraLinUnitSpec);
  taMisc::types.Add(&TA_const_LeabraLinUnitSpec_ref);
    TA_const_LeabraLinUnitSpec_ref.AddParents(&TA_const_LeabraLinUnitSpec);
  taMisc::types.Add(&TA_LeabraNegBiasSpec);
    TAI_LeabraNegBiasSpec = new LeabraNegBiasSpec;
    TA_LeabraNegBiasSpec.AddParFormal(&TA_class);
    TA_LeabraNegBiasSpec.AddParCache(&TA_taBase);
    TA_LeabraNegBiasSpec.AddClassPar(&TA_LeabraBiasSpec,0);
    tac_AddMembers(TA_LeabraNegBiasSpec,TA_LeabraNegBiasSpec_MemberDef);
    tac_AddMethods(TA_LeabraNegBiasSpec,TA_LeabraNegBiasSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraNegBiasSpec);
    TA_const_LeabraNegBiasSpec.AddParents(&TA_const, &TA_LeabraNegBiasSpec);
  taMisc::types.Add(&TA_const_LeabraNegBiasSpec_ref);
    TA_const_LeabraNegBiasSpec_ref.AddParents(&TA_const_LeabraNegBiasSpec);
  taMisc::types.Add(&TA_TrialSynDepCon);
    TAI_TrialSynDepCon = new TrialSynDepCon;
    TA_TrialSynDepCon.AddParFormal(&TA_class);
    TA_TrialSynDepCon.AddParCache(&TA_taBase);
    TA_TrialSynDepCon.AddClassPar(&TA_LeabraCon,0);
    tac_AddMembers(TA_TrialSynDepCon,TA_TrialSynDepCon_MemberDef);
  taMisc::types.Add(&TA_const_TrialSynDepCon);
    TA_const_TrialSynDepCon.AddParents(&TA_const, &TA_TrialSynDepCon);
  taMisc::types.Add(&TA_const_TrialSynDepCon_ref);
    TA_const_TrialSynDepCon_ref.AddParents(&TA_const_TrialSynDepCon);
  taMisc::types.Add(&TA_SynDepSpec);
    TAI_SynDepSpec = new SynDepSpec;
    TA_SynDepSpec.AddParFormal(&TA_class);
    TA_SynDepSpec.AddParCache(&TA_taBase);
    TA_SynDepSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SynDepSpec,TA_SynDepSpec_MemberDef);
  taMisc::types.Add(&TA_TrialSynDepCon_ptr);
    TA_TrialSynDepCon_ptr.AddParents(&TA_TrialSynDepCon);
  taMisc::types.Add(&TA_const_SynDepSpec);
    TA_const_SynDepSpec.AddParents(&TA_const, &TA_SynDepSpec);
  taMisc::types.Add(&TA_const_SynDepSpec_ref);
    TA_const_SynDepSpec_ref.AddParents(&TA_const_SynDepSpec);
  taMisc::types.Add(&TA_TrialSynDepConSpec);
    TAI_TrialSynDepConSpec = new TrialSynDepConSpec;
    TA_TrialSynDepConSpec.AddParFormal(&TA_class);
    TA_TrialSynDepConSpec.AddParCache(&TA_taBase);
    TA_TrialSynDepConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_TrialSynDepConSpec,TA_TrialSynDepConSpec_MemberDef);
    tac_AddMethods(TA_TrialSynDepConSpec,TA_TrialSynDepConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TrialSynDepConSpec);
    TA_const_TrialSynDepConSpec.AddParents(&TA_const, &TA_TrialSynDepConSpec);
  taMisc::types.Add(&TA_const_TrialSynDepConSpec_ref);
    TA_const_TrialSynDepConSpec_ref.AddParents(&TA_const_TrialSynDepConSpec);
  taMisc::types.Add(&TA_FastWtCon);
    TAI_FastWtCon = new FastWtCon;
    TA_FastWtCon.AddParFormal(&TA_class);
    TA_FastWtCon.AddParCache(&TA_taBase);
    TA_FastWtCon.AddClassPar(&TA_LeabraCon,0);
    tac_AddMembers(TA_FastWtCon,TA_FastWtCon_MemberDef);
  taMisc::types.Add(&TA_const_FastWtCon);
    TA_const_FastWtCon.AddParents(&TA_const, &TA_FastWtCon);
  taMisc::types.Add(&TA_const_FastWtCon_ref);
    TA_const_FastWtCon_ref.AddParents(&TA_const_FastWtCon);
  taMisc::types.Add(&TA_FastWtSpec);
    TAI_FastWtSpec = new FastWtSpec;
    TA_FastWtSpec.AddParFormal(&TA_class);
    TA_FastWtSpec.AddParCache(&TA_taBase);
    TA_FastWtSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_FastWtSpec, "DecayMode", "", "", "", "", TA_FastWtSpec_DecayMode);
    tac_AddMembers(TA_FastWtSpec,TA_FastWtSpec_MemberDef);
  taMisc::types.Add(&TA_FastWtCon_ptr);
    TA_FastWtCon_ptr.AddParents(&TA_FastWtCon);
  taMisc::types.Add(&TA_const_FastWtSpec);
    TA_const_FastWtSpec.AddParents(&TA_const, &TA_FastWtSpec);
  taMisc::types.Add(&TA_const_FastWtSpec_ref);
    TA_const_FastWtSpec_ref.AddParents(&TA_const_FastWtSpec);
  taMisc::types.Add(&TA_FastWtConSpec);
    TAI_FastWtConSpec = new FastWtConSpec;
    TA_FastWtConSpec.AddParFormal(&TA_class);
    TA_FastWtConSpec.AddParCache(&TA_taBase);
    TA_FastWtConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_FastWtConSpec,TA_FastWtConSpec_MemberDef);
    tac_AddMethods(TA_FastWtConSpec,TA_FastWtConSpec_MethodDef);
  taMisc::types.Add(&TA_const_FastWtConSpec);
    TA_const_FastWtConSpec.AddParents(&TA_const, &TA_FastWtConSpec);
  taMisc::types.Add(&TA_const_FastWtConSpec_ref);
    TA_const_FastWtConSpec_ref.AddParents(&TA_const_FastWtConSpec);
  taMisc::types.Add(&TA_ActAvgHebbMixSpec);
    TAI_ActAvgHebbMixSpec = new ActAvgHebbMixSpec;
    TA_ActAvgHebbMixSpec.AddParFormal(&TA_class);
    TA_ActAvgHebbMixSpec.AddParCache(&TA_taBase);
    TA_ActAvgHebbMixSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActAvgHebbMixSpec,TA_ActAvgHebbMixSpec_MemberDef);
    tac_AddMethods(TA_ActAvgHebbMixSpec,TA_ActAvgHebbMixSpec_MethodDef);
  taMisc::types.Add(&TA_const_ActAvgHebbMixSpec);
    TA_const_ActAvgHebbMixSpec.AddParents(&TA_const, &TA_ActAvgHebbMixSpec);
  taMisc::types.Add(&TA_const_ActAvgHebbMixSpec_ref);
    TA_const_ActAvgHebbMixSpec_ref.AddParents(&TA_const_ActAvgHebbMixSpec);
  taMisc::types.Add(&TA_ActAvgHebbConSpec);
    TAI_ActAvgHebbConSpec = new ActAvgHebbConSpec;
    TA_ActAvgHebbConSpec.AddParFormal(&TA_class);
    TA_ActAvgHebbConSpec.AddParCache(&TA_taBase);
    TA_ActAvgHebbConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_ActAvgHebbConSpec,TA_ActAvgHebbConSpec_MemberDef);
    tac_AddMethods(TA_ActAvgHebbConSpec,TA_ActAvgHebbConSpec_MethodDef);
  taMisc::types.Add(&TA_const_ActAvgHebbConSpec);
    TA_const_ActAvgHebbConSpec.AddParents(&TA_const, &TA_ActAvgHebbConSpec);
  taMisc::types.Add(&TA_const_ActAvgHebbConSpec_ref);
    TA_const_ActAvgHebbConSpec_ref.AddParents(&TA_const_ActAvgHebbConSpec);
  taMisc::types.Add(&TA_ScalarValSpec);
    TAI_ScalarValSpec = new ScalarValSpec;
    TA_ScalarValSpec.AddParFormal(&TA_class);
    TA_ScalarValSpec.AddParCache(&TA_taBase);
    TA_ScalarValSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ScalarValSpec, "RepType", "", "", "", "", TA_ScalarValSpec_RepType);
    tac_AddMembers(TA_ScalarValSpec,TA_ScalarValSpec_MemberDef);
    tac_AddMethods(TA_ScalarValSpec,TA_ScalarValSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValSpec);
    TA_const_ScalarValSpec.AddParents(&TA_const, &TA_ScalarValSpec);
  taMisc::types.Add(&TA_const_ScalarValSpec_ref);
    TA_const_ScalarValSpec_ref.AddParents(&TA_const_ScalarValSpec);
  taMisc::types.Add(&TA_ScalarValBias);
    TAI_ScalarValBias = new ScalarValBias;
    TA_ScalarValBias.AddParFormal(&TA_class);
    TA_ScalarValBias.AddParCache(&TA_taBase);
    TA_ScalarValBias.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ScalarValBias, "UnitBias", " bias on individual units", "", "", "", TA_ScalarValBias_UnitBias);
    tac_AddEnum(TA_ScalarValBias, "BiasShape", " shape of the bias pattern", "", "", "", TA_ScalarValBias_BiasShape);
    tac_AddEnum(TA_ScalarValBias, "WeightBias", " bias on weights into units", "", "", "", TA_ScalarValBias_WeightBias);
    tac_AddMembers(TA_ScalarValBias,TA_ScalarValBias_MemberDef);
  taMisc::types.Add(&TA_const_ScalarValBias);
    TA_const_ScalarValBias.AddParents(&TA_const, &TA_ScalarValBias);
  taMisc::types.Add(&TA_const_ScalarValBias_ref);
    TA_const_ScalarValBias_ref.AddParents(&TA_const_ScalarValBias);
  taMisc::types.Add(&TA_ScalarValLayerSpec);
    TAI_ScalarValLayerSpec = new ScalarValLayerSpec;
    TA_ScalarValLayerSpec.AddParFormal(&TA_class);
    TA_ScalarValLayerSpec.AddParCache(&TA_taBase);
    TA_ScalarValLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_ScalarValLayerSpec,TA_ScalarValLayerSpec_MemberDef);
    tac_AddMethods(TA_ScalarValLayerSpec,TA_ScalarValLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValLayerSpec);
    TA_const_ScalarValLayerSpec.AddParents(&TA_const, &TA_ScalarValLayerSpec);
  taMisc::types.Add(&TA_const_ScalarValLayerSpec_ref);
    TA_const_ScalarValLayerSpec_ref.AddParents(&TA_const_ScalarValLayerSpec);
  taMisc::types.Add(&TA_ScalarValSelfPrjnSpec);
    TAI_ScalarValSelfPrjnSpec = new ScalarValSelfPrjnSpec;
    TA_ScalarValSelfPrjnSpec.AddParFormal(&TA_class);
    TA_ScalarValSelfPrjnSpec.AddParCache(&TA_taBase);
    TA_ScalarValSelfPrjnSpec.AddClassPar(&TA_ProjectionSpec,0);
    tac_AddMembers(TA_ScalarValSelfPrjnSpec,TA_ScalarValSelfPrjnSpec_MemberDef);
    tac_AddMethods(TA_ScalarValSelfPrjnSpec,TA_ScalarValSelfPrjnSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValSelfPrjnSpec);
    TA_const_ScalarValSelfPrjnSpec.AddParents(&TA_const, &TA_ScalarValSelfPrjnSpec);
  taMisc::types.Add(&TA_const_ScalarValSelfPrjnSpec_ref);
    TA_const_ScalarValSelfPrjnSpec_ref.AddParents(&TA_const_ScalarValSelfPrjnSpec);
  taMisc::types.Add(&TA_TwoDValSpec);
    TAI_TwoDValSpec = new TwoDValSpec;
    TA_TwoDValSpec.AddParFormal(&TA_class);
    TA_TwoDValSpec.AddParCache(&TA_taBase);
    TA_TwoDValSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_TwoDValSpec, "RepType", "", "", "", "", TA_TwoDValSpec_RepType);
    tac_AddMembers(TA_TwoDValSpec,TA_TwoDValSpec_MemberDef);
    tac_AddMethods(TA_TwoDValSpec,TA_TwoDValSpec_MethodDef);
  taMisc::types.Add(&TA_const_TwoDValSpec);
    TA_const_TwoDValSpec.AddParents(&TA_const, &TA_TwoDValSpec);
  taMisc::types.Add(&TA_const_TwoDValSpec_ref);
    TA_const_TwoDValSpec_ref.AddParents(&TA_const_TwoDValSpec);
  taMisc::types.Add(&TA_TwoDValBias);
    TAI_TwoDValBias = new TwoDValBias;
    TA_TwoDValBias.AddParFormal(&TA_class);
    TA_TwoDValBias.AddParCache(&TA_taBase);
    TA_TwoDValBias.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_TwoDValBias, "UnitBias", " bias on individual units", "", "", "", TA_TwoDValBias_UnitBias);
    tac_AddEnum(TA_TwoDValBias, "WeightBias", " bias on weights into units", "", "", "", TA_TwoDValBias_WeightBias);
    tac_AddMembers(TA_TwoDValBias,TA_TwoDValBias_MemberDef);
  taMisc::types.Add(&TA_const_TwoDValBias);
    TA_const_TwoDValBias.AddParents(&TA_const, &TA_TwoDValBias);
  taMisc::types.Add(&TA_const_TwoDValBias_ref);
    TA_const_TwoDValBias_ref.AddParents(&TA_const_TwoDValBias);
  taMisc::types.Add(&TA_TwoDValLayerSpec);
    TAI_TwoDValLayerSpec = new TwoDValLayerSpec;
    TA_TwoDValLayerSpec.AddParFormal(&TA_class);
    TA_TwoDValLayerSpec.AddParCache(&TA_taBase);
    TA_TwoDValLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_TwoDValLayerSpec,TA_TwoDValLayerSpec_MemberDef);
    tac_AddMethods(TA_TwoDValLayerSpec,TA_TwoDValLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TwoDValLayerSpec);
    TA_const_TwoDValLayerSpec.AddParents(&TA_const, &TA_TwoDValLayerSpec);
  taMisc::types.Add(&TA_const_TwoDValLayerSpec_ref);
    TA_const_TwoDValLayerSpec_ref.AddParents(&TA_const_TwoDValLayerSpec);
  taMisc::types.Add(&TA_DecodeTwoDValLayerSpec);
    TAI_DecodeTwoDValLayerSpec = new DecodeTwoDValLayerSpec;
    TA_DecodeTwoDValLayerSpec.AddParFormal(&TA_class);
    TA_DecodeTwoDValLayerSpec.AddParCache(&TA_taBase);
    TA_DecodeTwoDValLayerSpec.AddClassPar(&TA_TwoDValLayerSpec,0);
    tac_AddMethods(TA_DecodeTwoDValLayerSpec,TA_DecodeTwoDValLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_DecodeTwoDValLayerSpec);
    TA_const_DecodeTwoDValLayerSpec.AddParents(&TA_const, &TA_DecodeTwoDValLayerSpec);
  taMisc::types.Add(&TA_const_DecodeTwoDValLayerSpec_ref);
    TA_const_DecodeTwoDValLayerSpec_ref.AddParents(&TA_const_DecodeTwoDValLayerSpec);
  taMisc::types.Add(&TA_DaModUnit);
    TAI_DaModUnit = new DaModUnit;
    TA_DaModUnit.AddParFormal(&TA_class);
    TA_DaModUnit.AddParCache(&TA_taBase);
    TA_DaModUnit.AddClassPar(&TA_LeabraUnit,0);
    tac_AddMembers(TA_DaModUnit,TA_DaModUnit_MemberDef);
  taMisc::types.Add(&TA_const_DaModUnit);
    TA_const_DaModUnit.AddParents(&TA_const, &TA_DaModUnit);
  taMisc::types.Add(&TA_const_DaModUnit_ref);
    TA_const_DaModUnit_ref.AddParents(&TA_const_DaModUnit);
  taMisc::types.Add(&TA_DaModSpec);
    TAI_DaModSpec = new DaModSpec;
    TA_DaModSpec.AddParFormal(&TA_class);
    TA_DaModSpec.AddParCache(&TA_taBase);
    TA_DaModSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_DaModSpec, "ModType", "", "", "", "", TA_DaModSpec_ModType);
    tac_AddMembers(TA_DaModSpec,TA_DaModSpec_MemberDef);
  taMisc::types.Add(&TA_const_DaModSpec);
    TA_const_DaModSpec.AddParents(&TA_const, &TA_DaModSpec);
  taMisc::types.Add(&TA_const_DaModSpec_ref);
    TA_const_DaModSpec_ref.AddParents(&TA_const_DaModSpec);
  taMisc::types.Add(&TA_DaModUnitSpec);
    TAI_DaModUnitSpec = new DaModUnitSpec;
    TA_DaModUnitSpec.AddParFormal(&TA_class);
    TA_DaModUnitSpec.AddParCache(&TA_taBase);
    TA_DaModUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
    tac_AddMembers(TA_DaModUnitSpec,TA_DaModUnitSpec_MemberDef);
    tac_AddMethods(TA_DaModUnitSpec,TA_DaModUnitSpec_MethodDef);
  taMisc::types.Add(&TA_const_DaModUnitSpec);
    TA_const_DaModUnitSpec.AddParents(&TA_const, &TA_DaModUnitSpec);
  taMisc::types.Add(&TA_const_DaModUnitSpec_ref);
    TA_const_DaModUnitSpec_ref.AddParents(&TA_const_DaModUnitSpec);
  taMisc::types.Add(&TA_AvgExtRewSpec);
    TAI_AvgExtRewSpec = new AvgExtRewSpec;
    TA_AvgExtRewSpec.AddParFormal(&TA_class);
    TA_AvgExtRewSpec.AddParCache(&TA_taBase);
    TA_AvgExtRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AvgExtRewSpec,TA_AvgExtRewSpec_MemberDef);
  taMisc::types.Add(&TA_const_AvgExtRewSpec);
    TA_const_AvgExtRewSpec.AddParents(&TA_const, &TA_AvgExtRewSpec);
  taMisc::types.Add(&TA_const_AvgExtRewSpec_ref);
    TA_const_AvgExtRewSpec_ref.AddParents(&TA_const_AvgExtRewSpec);
  taMisc::types.Add(&TA_OutErrSpec);
    TAI_OutErrSpec = new OutErrSpec;
    TA_OutErrSpec.AddParFormal(&TA_class);
    TA_OutErrSpec.AddParCache(&TA_taBase);
    TA_OutErrSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_OutErrSpec,TA_OutErrSpec_MemberDef);
  taMisc::types.Add(&TA_const_OutErrSpec);
    TA_const_OutErrSpec.AddParents(&TA_const, &TA_OutErrSpec);
  taMisc::types.Add(&TA_const_OutErrSpec_ref);
    TA_const_OutErrSpec_ref.AddParents(&TA_const_OutErrSpec);
  taMisc::types.Add(&TA_ExtRewSpec);
    TAI_ExtRewSpec = new ExtRewSpec;
    TA_ExtRewSpec.AddParFormal(&TA_class);
    TA_ExtRewSpec.AddParCache(&TA_taBase);
    TA_ExtRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ExtRewSpec,TA_ExtRewSpec_MemberDef);
  taMisc::types.Add(&TA_DaModUnit_ptr);
    TA_DaModUnit_ptr.AddParents(&TA_DaModUnit);
  taMisc::types.Add(&TA_const_ExtRewSpec);
    TA_const_ExtRewSpec.AddParents(&TA_const, &TA_ExtRewSpec);
  taMisc::types.Add(&TA_const_ExtRewSpec_ref);
    TA_const_ExtRewSpec_ref.AddParents(&TA_const_ExtRewSpec);
  taMisc::types.Add(&TA_ExtRewLayerSpec);
    TAI_ExtRewLayerSpec = new ExtRewLayerSpec;
    TA_ExtRewLayerSpec.AddParFormal(&TA_class);
    TA_ExtRewLayerSpec.AddParCache(&TA_taBase);
    TA_ExtRewLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddEnum(TA_ExtRewLayerSpec, "RewardType", " how do we get the reward values?", "", "", "", TA_ExtRewLayerSpec_RewardType);
    tac_AddMembers(TA_ExtRewLayerSpec,TA_ExtRewLayerSpec_MemberDef);
    tac_AddMethods(TA_ExtRewLayerSpec,TA_ExtRewLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_ExtRewLayerSpec);
    TA_const_ExtRewLayerSpec.AddParents(&TA_const, &TA_ExtRewLayerSpec);
  taMisc::types.Add(&TA_const_ExtRewLayerSpec_ref);
    TA_const_ExtRewLayerSpec_ref.AddParents(&TA_const_ExtRewLayerSpec);
  taMisc::types.Add(&TA_TDRewPredConSpec);
    TAI_TDRewPredConSpec = new TDRewPredConSpec;
    TA_TDRewPredConSpec.AddParFormal(&TA_class);
    TA_TDRewPredConSpec.AddParCache(&TA_taBase);
    TA_TDRewPredConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_TDRewPredConSpec,TA_TDRewPredConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewPredConSpec);
    TA_const_TDRewPredConSpec.AddParents(&TA_const, &TA_TDRewPredConSpec);
  taMisc::types.Add(&TA_const_TDRewPredConSpec_ref);
    TA_const_TDRewPredConSpec_ref.AddParents(&TA_const_TDRewPredConSpec);
  taMisc::types.Add(&TA_TDRewPredLayerSpec);
    TAI_TDRewPredLayerSpec = new TDRewPredLayerSpec;
    TA_TDRewPredLayerSpec.AddParFormal(&TA_class);
    TA_TDRewPredLayerSpec.AddParCache(&TA_taBase);
    TA_TDRewPredLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMethods(TA_TDRewPredLayerSpec,TA_TDRewPredLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewPredLayerSpec);
    TA_const_TDRewPredLayerSpec.AddParents(&TA_const, &TA_TDRewPredLayerSpec);
  taMisc::types.Add(&TA_const_TDRewPredLayerSpec_ref);
    TA_const_TDRewPredLayerSpec_ref.AddParents(&TA_const_TDRewPredLayerSpec);
  taMisc::types.Add(&TA_TDRewIntegSpec);
    TAI_TDRewIntegSpec = new TDRewIntegSpec;
    TA_TDRewIntegSpec.AddParFormal(&TA_class);
    TA_TDRewIntegSpec.AddParCache(&TA_taBase);
    TA_TDRewIntegSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_TDRewIntegSpec,TA_TDRewIntegSpec_MemberDef);
  taMisc::types.Add(&TA_const_TDRewIntegSpec);
    TA_const_TDRewIntegSpec.AddParents(&TA_const, &TA_TDRewIntegSpec);
  taMisc::types.Add(&TA_const_TDRewIntegSpec_ref);
    TA_const_TDRewIntegSpec_ref.AddParents(&TA_const_TDRewIntegSpec);
  taMisc::types.Add(&TA_TDRewIntegLayerSpec);
    TAI_TDRewIntegLayerSpec = new TDRewIntegLayerSpec;
    TA_TDRewIntegLayerSpec.AddParFormal(&TA_class);
    TA_TDRewIntegLayerSpec.AddParCache(&TA_taBase);
    TA_TDRewIntegLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_TDRewIntegLayerSpec,TA_TDRewIntegLayerSpec_MemberDef);
    tac_AddMethods(TA_TDRewIntegLayerSpec,TA_TDRewIntegLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewIntegLayerSpec);
    TA_const_TDRewIntegLayerSpec.AddParents(&TA_const, &TA_TDRewIntegLayerSpec);
  taMisc::types.Add(&TA_const_TDRewIntegLayerSpec_ref);
    TA_const_TDRewIntegLayerSpec_ref.AddParents(&TA_const_TDRewIntegLayerSpec);
  taMisc::types.Add(&TA_TdLayerSpec);
    TAI_TdLayerSpec = new TdLayerSpec;
    TA_TdLayerSpec.AddParFormal(&TA_class);
    TA_TdLayerSpec.AddParCache(&TA_taBase);
    TA_TdLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMethods(TA_TdLayerSpec,TA_TdLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TdLayerSpec);
    TA_const_TdLayerSpec.AddParents(&TA_const, &TA_TdLayerSpec);
  taMisc::types.Add(&TA_const_TdLayerSpec_ref);
    TA_const_TdLayerSpec_ref.AddParents(&TA_const_TdLayerSpec);
  taMisc::types.Add(&TA_PVConSpec);
    TAI_PVConSpec = new PVConSpec;
    TA_PVConSpec.AddParFormal(&TA_class);
    TA_PVConSpec.AddParCache(&TA_taBase);
    TA_PVConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_PVConSpec,TA_PVConSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVConSpec);
    TA_const_PVConSpec.AddParents(&TA_const, &TA_PVConSpec);
  taMisc::types.Add(&TA_const_PVConSpec_ref);
    TA_const_PVConSpec_ref.AddParents(&TA_const_PVConSpec);
  taMisc::types.Add(&TA_PVDetectSpec);
    TAI_PVDetectSpec = new PVDetectSpec;
    TA_PVDetectSpec.AddParFormal(&TA_class);
    TA_PVDetectSpec.AddParCache(&TA_taBase);
    TA_PVDetectSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_PVDetectSpec,TA_PVDetectSpec_MemberDef);
  taMisc::types.Add(&TA_const_PVDetectSpec);
    TA_const_PVDetectSpec.AddParents(&TA_const, &TA_PVDetectSpec);
  taMisc::types.Add(&TA_const_PVDetectSpec_ref);
    TA_const_PVDetectSpec_ref.AddParents(&TA_const_PVDetectSpec);
  taMisc::types.Add(&TA_PViLayerSpec);
    TAI_PViLayerSpec = new PViLayerSpec;
    TA_PViLayerSpec.AddParFormal(&TA_class);
    TA_PViLayerSpec.AddParCache(&TA_taBase);
    TA_PViLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_PViLayerSpec,TA_PViLayerSpec_MemberDef);
    tac_AddMethods(TA_PViLayerSpec,TA_PViLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PViLayerSpec);
    TA_const_PViLayerSpec.AddParents(&TA_const, &TA_PViLayerSpec);
  taMisc::types.Add(&TA_const_PViLayerSpec_ref);
    TA_const_PViLayerSpec_ref.AddParents(&TA_const_PViLayerSpec);
  taMisc::types.Add(&TA_LVConSpec);
    TAI_LVConSpec = new LVConSpec;
    TA_LVConSpec.AddParFormal(&TA_class);
    TA_LVConSpec.AddParCache(&TA_taBase);
    TA_LVConSpec.AddClassPar(&TA_TrialSynDepConSpec,0);
    tac_AddMethods(TA_LVConSpec,TA_LVConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LVConSpec);
    TA_const_LVConSpec.AddParents(&TA_const, &TA_LVConSpec);
  taMisc::types.Add(&TA_const_LVConSpec_ref);
    TA_const_LVConSpec_ref.AddParents(&TA_const_LVConSpec);
  taMisc::types.Add(&TA_LVSpec);
    TAI_LVSpec = new LVSpec;
    TA_LVSpec.AddParFormal(&TA_class);
    TA_LVSpec.AddParCache(&TA_taBase);
    TA_LVSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LVSpec,TA_LVSpec_MemberDef);
  taMisc::types.Add(&TA_const_LVSpec);
    TA_const_LVSpec.AddParents(&TA_const, &TA_LVSpec);
  taMisc::types.Add(&TA_const_LVSpec_ref);
    TA_const_LVSpec_ref.AddParents(&TA_const_LVSpec);
  taMisc::types.Add(&TA_LVeLayerSpec);
    TAI_LVeLayerSpec = new LVeLayerSpec;
    TA_LVeLayerSpec.AddParFormal(&TA_class);
    TA_LVeLayerSpec.AddParCache(&TA_taBase);
    TA_LVeLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_LVeLayerSpec,TA_LVeLayerSpec_MemberDef);
    tac_AddMethods(TA_LVeLayerSpec,TA_LVeLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LVeLayerSpec);
    TA_const_LVeLayerSpec.AddParents(&TA_const, &TA_LVeLayerSpec);
  taMisc::types.Add(&TA_const_LVeLayerSpec_ref);
    TA_const_LVeLayerSpec_ref.AddParents(&TA_const_LVeLayerSpec);
  taMisc::types.Add(&TA_LViLayerSpec);
    TAI_LViLayerSpec = new LViLayerSpec;
    TA_LViLayerSpec.AddParFormal(&TA_class);
    TA_LViLayerSpec.AddParCache(&TA_taBase);
    TA_LViLayerSpec.AddClassPar(&TA_LVeLayerSpec,0);
  taMisc::types.Add(&TA_const_LViLayerSpec);
    TA_const_LViLayerSpec.AddParents(&TA_const, &TA_LViLayerSpec);
  taMisc::types.Add(&TA_const_LViLayerSpec_ref);
    TA_const_LViLayerSpec_ref.AddParents(&TA_const_LViLayerSpec);
  taMisc::types.Add(&TA_PVLVDaSpec);
    TAI_PVLVDaSpec = new PVLVDaSpec;
    TA_PVLVDaSpec.AddParFormal(&TA_class);
    TA_PVLVDaSpec.AddParCache(&TA_taBase);
    TA_PVLVDaSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PVLVDaSpec, "DaMode", "", "", "", "", TA_PVLVDaSpec_DaMode);
    tac_AddMembers(TA_PVLVDaSpec,TA_PVLVDaSpec_MemberDef);
  taMisc::types.Add(&TA_const_PVLVDaSpec);
    TA_const_PVLVDaSpec.AddParents(&TA_const, &TA_PVLVDaSpec);
  taMisc::types.Add(&TA_const_PVLVDaSpec_ref);
    TA_const_PVLVDaSpec_ref.AddParents(&TA_const_PVLVDaSpec);
  taMisc::types.Add(&TA_PVLVDaLayerSpec);
    TAI_PVLVDaLayerSpec = new PVLVDaLayerSpec;
    TA_PVLVDaLayerSpec.AddParFormal(&TA_class);
    TA_PVLVDaLayerSpec.AddParCache(&TA_taBase);
    TA_PVLVDaLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_PVLVDaLayerSpec,TA_PVLVDaLayerSpec_MemberDef);
    tac_AddMethods(TA_PVLVDaLayerSpec,TA_PVLVDaLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVLVDaLayerSpec);
    TA_const_PVLVDaLayerSpec.AddParents(&TA_const, &TA_PVLVDaLayerSpec);
  taMisc::types.Add(&TA_const_PVLVDaLayerSpec_ref);
    TA_const_PVLVDaLayerSpec_ref.AddParents(&TA_const_PVLVDaLayerSpec);
  taMisc::types.Add(&TA_PatchLayerSpec);
    TAI_PatchLayerSpec = new PatchLayerSpec;
    TA_PatchLayerSpec.AddParFormal(&TA_class);
    TA_PatchLayerSpec.AddParCache(&TA_taBase);
    TA_PatchLayerSpec.AddClassPar(&TA_LVeLayerSpec,0);
  taMisc::types.Add(&TA_const_PatchLayerSpec);
    TA_const_PatchLayerSpec.AddParents(&TA_const, &TA_PatchLayerSpec);
  taMisc::types.Add(&TA_const_PatchLayerSpec_ref);
    TA_const_PatchLayerSpec_ref.AddParents(&TA_const_PatchLayerSpec);
  taMisc::types.Add(&TA_SNcMiscSpec);
    TAI_SNcMiscSpec = new SNcMiscSpec;
    TA_SNcMiscSpec.AddParFormal(&TA_class);
    TA_SNcMiscSpec.AddParCache(&TA_taBase);
    TA_SNcMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_SNcMiscSpec, "PatchMode", "", "", "", "", TA_SNcMiscSpec_PatchMode);
    tac_AddMembers(TA_SNcMiscSpec,TA_SNcMiscSpec_MemberDef);
  taMisc::types.Add(&TA_const_SNcMiscSpec);
    TA_const_SNcMiscSpec.AddParents(&TA_const, &TA_SNcMiscSpec);
  taMisc::types.Add(&TA_const_SNcMiscSpec_ref);
    TA_const_SNcMiscSpec_ref.AddParents(&TA_const_SNcMiscSpec);
  taMisc::types.Add(&TA_SNcLayerSpec);
    TAI_SNcLayerSpec = new SNcLayerSpec;
    TA_SNcLayerSpec.AddParFormal(&TA_class);
    TA_SNcLayerSpec.AddParCache(&TA_taBase);
    TA_SNcLayerSpec.AddClassPar(&TA_PVLVDaLayerSpec,0);
    tac_AddMembers(TA_SNcLayerSpec,TA_SNcLayerSpec_MemberDef);
    tac_AddMethods(TA_SNcLayerSpec,TA_SNcLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_SNcLayerSpec);
    TA_const_SNcLayerSpec.AddParents(&TA_const, &TA_SNcLayerSpec);
  taMisc::types.Add(&TA_const_SNcLayerSpec_ref);
    TA_const_SNcLayerSpec_ref.AddParents(&TA_const_SNcLayerSpec);
  taMisc::types.Add(&TA_MatrixConSpec);
    TAI_MatrixConSpec = new MatrixConSpec;
    TA_MatrixConSpec.AddParFormal(&TA_class);
    TA_MatrixConSpec.AddParCache(&TA_taBase);
    TA_MatrixConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddEnum(TA_MatrixConSpec, "LearnRule", "", "", "", "", TA_MatrixConSpec_LearnRule);
    tac_AddMembers(TA_MatrixConSpec,TA_MatrixConSpec_MemberDef);
    tac_AddMethods(TA_MatrixConSpec,TA_MatrixConSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixConSpec);
    TA_const_MatrixConSpec.AddParents(&TA_const, &TA_MatrixConSpec);
  taMisc::types.Add(&TA_const_MatrixConSpec_ref);
    TA_const_MatrixConSpec_ref.AddParents(&TA_const_MatrixConSpec);
  taMisc::types.Add(&TA_MatrixBiasSpec);
    TAI_MatrixBiasSpec = new MatrixBiasSpec;
    TA_MatrixBiasSpec.AddParFormal(&TA_class);
    TA_MatrixBiasSpec.AddParCache(&TA_taBase);
    TA_MatrixBiasSpec.AddClassPar(&TA_LeabraBiasSpec,0);
    tac_AddEnum(TA_MatrixBiasSpec, "LearnRule", "", "", "", "", TA_MatrixBiasSpec_LearnRule);
    tac_AddMembers(TA_MatrixBiasSpec,TA_MatrixBiasSpec_MemberDef);
    tac_AddMethods(TA_MatrixBiasSpec,TA_MatrixBiasSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixBiasSpec);
    TA_const_MatrixBiasSpec.AddParents(&TA_const, &TA_MatrixBiasSpec);
  taMisc::types.Add(&TA_const_MatrixBiasSpec_ref);
    TA_const_MatrixBiasSpec_ref.AddParents(&TA_const_MatrixBiasSpec);
  taMisc::types.Add(&TA_MatrixUnitSpec);
    TAI_MatrixUnitSpec = new MatrixUnitSpec;
    TA_MatrixUnitSpec.AddParFormal(&TA_class);
    TA_MatrixUnitSpec.AddParCache(&TA_taBase);
    TA_MatrixUnitSpec.AddClassPar(&TA_DaModUnitSpec,0);
    tac_AddMembers(TA_MatrixUnitSpec,TA_MatrixUnitSpec_MemberDef);
    tac_AddMethods(TA_MatrixUnitSpec,TA_MatrixUnitSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixUnitSpec);
    TA_const_MatrixUnitSpec.AddParents(&TA_const, &TA_MatrixUnitSpec);
  taMisc::types.Add(&TA_const_MatrixUnitSpec_ref);
    TA_const_MatrixUnitSpec_ref.AddParents(&TA_const_MatrixUnitSpec);
  taMisc::types.Add(&TA_MatrixMiscSpec);
    TAI_MatrixMiscSpec = new MatrixMiscSpec;
    TA_MatrixMiscSpec.AddParFormal(&TA_class);
    TA_MatrixMiscSpec.AddParCache(&TA_taBase);
    TA_MatrixMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixMiscSpec,TA_MatrixMiscSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixMiscSpec);
    TA_const_MatrixMiscSpec.AddParents(&TA_const, &TA_MatrixMiscSpec);
  taMisc::types.Add(&TA_const_MatrixMiscSpec_ref);
    TA_const_MatrixMiscSpec_ref.AddParents(&TA_const_MatrixMiscSpec);
  taMisc::types.Add(&TA_ContrastSpec);
    TAI_ContrastSpec = new ContrastSpec;
    TA_ContrastSpec.AddParFormal(&TA_class);
    TA_ContrastSpec.AddParCache(&TA_taBase);
    TA_ContrastSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ContrastSpec,TA_ContrastSpec_MemberDef);
  taMisc::types.Add(&TA_const_ContrastSpec);
    TA_const_ContrastSpec.AddParents(&TA_const, &TA_ContrastSpec);
  taMisc::types.Add(&TA_const_ContrastSpec_ref);
    TA_const_ContrastSpec_ref.AddParents(&TA_const_ContrastSpec);
  taMisc::types.Add(&TA_MatrixRndGoSpec);
    TAI_MatrixRndGoSpec = new MatrixRndGoSpec;
    TA_MatrixRndGoSpec.AddParFormal(&TA_class);
    TA_MatrixRndGoSpec.AddParCache(&TA_taBase);
    TA_MatrixRndGoSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixRndGoSpec,TA_MatrixRndGoSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixRndGoSpec);
    TA_const_MatrixRndGoSpec.AddParents(&TA_const, &TA_MatrixRndGoSpec);
  taMisc::types.Add(&TA_const_MatrixRndGoSpec_ref);
    TA_const_MatrixRndGoSpec_ref.AddParents(&TA_const_MatrixRndGoSpec);
  taMisc::types.Add(&TA_MatrixErrRndGoSpec);
    TAI_MatrixErrRndGoSpec = new MatrixErrRndGoSpec;
    TA_MatrixErrRndGoSpec.AddParFormal(&TA_class);
    TA_MatrixErrRndGoSpec.AddParCache(&TA_taBase);
    TA_MatrixErrRndGoSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixErrRndGoSpec,TA_MatrixErrRndGoSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixErrRndGoSpec);
    TA_const_MatrixErrRndGoSpec.AddParents(&TA_const, &TA_MatrixErrRndGoSpec);
  taMisc::types.Add(&TA_const_MatrixErrRndGoSpec_ref);
    TA_const_MatrixErrRndGoSpec_ref.AddParents(&TA_const_MatrixErrRndGoSpec);
  taMisc::types.Add(&TA_MatrixAvgDaRndGoSpec);
    TAI_MatrixAvgDaRndGoSpec = new MatrixAvgDaRndGoSpec;
    TA_MatrixAvgDaRndGoSpec.AddParFormal(&TA_class);
    TA_MatrixAvgDaRndGoSpec.AddParCache(&TA_taBase);
    TA_MatrixAvgDaRndGoSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixAvgDaRndGoSpec,TA_MatrixAvgDaRndGoSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraUnit_Group_ptr);
    TA_LeabraUnit_Group_ptr.AddParents(&TA_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_MatrixAvgDaRndGoSpec);
    TA_const_MatrixAvgDaRndGoSpec.AddParents(&TA_const, &TA_MatrixAvgDaRndGoSpec);
  taMisc::types.Add(&TA_const_MatrixAvgDaRndGoSpec_ref);
    TA_const_MatrixAvgDaRndGoSpec_ref.AddParents(&TA_const_MatrixAvgDaRndGoSpec);
  taMisc::types.Add(&TA_MatrixLayerSpec);
    TAI_MatrixLayerSpec = new MatrixLayerSpec;
    TA_MatrixLayerSpec.AddParFormal(&TA_class);
    TA_MatrixLayerSpec.AddParCache(&TA_taBase);
    TA_MatrixLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_MatrixLayerSpec, "BGType", " which type of basal ganglia circuit is this?", "", "", "", TA_MatrixLayerSpec_BGType);
    tac_AddMembers(TA_MatrixLayerSpec,TA_MatrixLayerSpec_MemberDef);
    tac_AddMethods(TA_MatrixLayerSpec,TA_MatrixLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixLayerSpec);
    TA_const_MatrixLayerSpec.AddParents(&TA_const, &TA_MatrixLayerSpec);
  taMisc::types.Add(&TA_const_MatrixLayerSpec_ref);
    TA_const_MatrixLayerSpec_ref.AddParents(&TA_const_MatrixLayerSpec);
  taMisc::types.Add(&TA_SNrThalMiscSpec);
    TAI_SNrThalMiscSpec = new SNrThalMiscSpec;
    TA_SNrThalMiscSpec.AddParFormal(&TA_class);
    TA_SNrThalMiscSpec.AddParCache(&TA_taBase);
    TA_SNrThalMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SNrThalMiscSpec,TA_SNrThalMiscSpec_MemberDef);
  taMisc::types.Add(&TA_const_SNrThalMiscSpec);
    TA_const_SNrThalMiscSpec.AddParents(&TA_const, &TA_SNrThalMiscSpec);
  taMisc::types.Add(&TA_const_SNrThalMiscSpec_ref);
    TA_const_SNrThalMiscSpec_ref.AddParents(&TA_const_SNrThalMiscSpec);
  taMisc::types.Add(&TA_SNrThalLayerSpec);
    TAI_SNrThalLayerSpec = new SNrThalLayerSpec;
    TA_SNrThalLayerSpec.AddParFormal(&TA_class);
    TA_SNrThalLayerSpec.AddParCache(&TA_taBase);
    TA_SNrThalLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_SNrThalLayerSpec,TA_SNrThalLayerSpec_MemberDef);
    tac_AddMethods(TA_SNrThalLayerSpec,TA_SNrThalLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_SNrThalLayerSpec);
    TA_const_SNrThalLayerSpec.AddParents(&TA_const, &TA_SNrThalLayerSpec);
  taMisc::types.Add(&TA_const_SNrThalLayerSpec_ref);
    TA_const_SNrThalLayerSpec_ref.AddParents(&TA_const_SNrThalLayerSpec);
  taMisc::types.Add(&TA_PFCGateSpec);
    TAI_PFCGateSpec = new PFCGateSpec;
    TA_PFCGateSpec.AddParFormal(&TA_class);
    TA_PFCGateSpec.AddParCache(&TA_taBase);
    TA_PFCGateSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PFCGateSpec, "GateSignal", "", "", "", "", TA_PFCGateSpec_GateSignal);
    tac_AddEnum(TA_PFCGateSpec, "GateState", " what happened on last gating action, stored in misc_state1 on unit group", "", "", "", TA_PFCGateSpec_GateState);
    tac_AddMembers(TA_PFCGateSpec,TA_PFCGateSpec_MemberDef);
  taMisc::types.Add(&TA_const_PFCGateSpec);
    TA_const_PFCGateSpec.AddParents(&TA_const, &TA_PFCGateSpec);
  taMisc::types.Add(&TA_const_PFCGateSpec_ref);
    TA_const_PFCGateSpec_ref.AddParents(&TA_const_PFCGateSpec);
  taMisc::types.Add(&TA_PFCLayerSpec);
    TAI_PFCLayerSpec = new PFCLayerSpec;
    TA_PFCLayerSpec.AddParFormal(&TA_class);
    TA_PFCLayerSpec.AddParCache(&TA_taBase);
    TA_PFCLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_PFCLayerSpec, "MaintUpdtAct", "", "", "", "", TA_PFCLayerSpec_MaintUpdtAct);
    tac_AddMembers(TA_PFCLayerSpec,TA_PFCLayerSpec_MemberDef);
    tac_AddMethods(TA_PFCLayerSpec,TA_PFCLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PFCLayerSpec);
    TA_const_PFCLayerSpec.AddParents(&TA_const, &TA_PFCLayerSpec);
  taMisc::types.Add(&TA_const_PFCLayerSpec_ref);
    TA_const_PFCLayerSpec_ref.AddParents(&TA_const_PFCLayerSpec);
  taMisc::types.Add(&TA_PFCOutGateSpec);
    TAI_PFCOutGateSpec = new PFCOutGateSpec;
    TA_PFCOutGateSpec.AddParFormal(&TA_class);
    TA_PFCOutGateSpec.AddParCache(&TA_taBase);
    TA_PFCOutGateSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_PFCOutGateSpec,TA_PFCOutGateSpec_MemberDef);
  taMisc::types.Add(&TA_const_PFCOutGateSpec);
    TA_const_PFCOutGateSpec.AddParents(&TA_const, &TA_PFCOutGateSpec);
  taMisc::types.Add(&TA_const_PFCOutGateSpec_ref);
    TA_const_PFCOutGateSpec_ref.AddParents(&TA_const_PFCOutGateSpec);
  taMisc::types.Add(&TA_PFCOutLayerSpec);
    TAI_PFCOutLayerSpec = new PFCOutLayerSpec;
    TA_PFCOutLayerSpec.AddParFormal(&TA_class);
    TA_PFCOutLayerSpec.AddParCache(&TA_taBase);
    TA_PFCOutLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_PFCOutLayerSpec,TA_PFCOutLayerSpec_MemberDef);
    tac_AddMethods(TA_PFCOutLayerSpec,TA_PFCOutLayerSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraCycle);
    TAI_LeabraCycle = new LeabraCycle;
    TA_LeabraCycle.AddParFormal(&TA_class);
    TA_LeabraCycle.AddParCache(&TA_taBase);
    TA_LeabraCycle.AddClassPar(&TA_CycleProcess,0);
    tac_AddMembers(TA_LeabraCycle,TA_LeabraCycle_MemberDef);
  taMisc::types.Add(&TA_const_PFCOutLayerSpec);
    TA_const_PFCOutLayerSpec.AddParents(&TA_const, &TA_PFCOutLayerSpec);
  taMisc::types.Add(&TA_LeabraSettle);
    TAI_LeabraSettle = new LeabraSettle;
    TA_LeabraSettle.AddParFormal(&TA_class);
    TA_LeabraSettle.AddParCache(&TA_taBase);
    TA_LeabraSettle.AddClassPar(&TA_SettleProcess,0);
    tac_AddMembers(TA_LeabraSettle,TA_LeabraSettle_MemberDef);
  taMisc::types.Add(&TA_const_PFCOutLayerSpec_ref);
    TA_const_PFCOutLayerSpec_ref.AddParents(&TA_const_PFCOutLayerSpec);
  taMisc::types.Add(&TA_LeabraTrial);
    TAI_LeabraTrial = new LeabraTrial;
    TA_LeabraTrial.AddParFormal(&TA_class);
    TA_LeabraTrial.AddParCache(&TA_taBase);
    TA_LeabraTrial.AddClassPar(&TA_TrialProcess,0);
    tac_AddEnum(TA_LeabraTrial, "StateInit", " ways of initializing the state of the network", "", "", "", TA_LeabraTrial_StateInit);
    tac_AddEnum(TA_LeabraTrial, "Phase", "", "", "", "", TA_LeabraTrial_Phase);
    tac_AddEnum(TA_LeabraTrial, "PhaseOrder", "", "", "", "", TA_LeabraTrial_PhaseOrder);
    tac_AddEnum(TA_LeabraTrial, "FirstPlusdWt", "", "", "", "", TA_LeabraTrial_FirstPlusdWt);
    tac_AddMembers(TA_LeabraTrial,TA_LeabraTrial_MemberDef);
  taMisc::types.Add(&TA_LeabraMaxDa);
    TAI_LeabraMaxDa = new LeabraMaxDa;
    TA_LeabraMaxDa.AddParFormal(&TA_class);
    TA_LeabraMaxDa.AddParCache(&TA_taBase);
    TA_LeabraMaxDa.AddClassPar(&TA_Stat,0);
    tac_AddEnum(TA_LeabraMaxDa, "dAType", "", "", "", "", TA_LeabraMaxDa_dAType);
    tac_AddMembers(TA_LeabraMaxDa,TA_LeabraMaxDa_MemberDef);
  taMisc::types.Add(&TA_LeabraSettle_ptr);
    TA_LeabraSettle_ptr.AddParents(&TA_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraCycle);
    TA_const_LeabraCycle.AddParents(&TA_const, &TA_LeabraCycle);
  taMisc::types.Add(&TA_const_LeabraCycle_ref);
    TA_const_LeabraCycle_ref.AddParents(&TA_const_LeabraCycle);
  taMisc::types.Add(&TA_LeabraTrial_ptr);
    TA_LeabraTrial_ptr.AddParents(&TA_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraSettle);
    TA_const_LeabraSettle.AddParents(&TA_const, &TA_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraSettle_ref);
    TA_const_LeabraSettle_ref.AddParents(&TA_const_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraTrial);
    TA_const_LeabraTrial.AddParents(&TA_const, &TA_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraTrial_ref);
    TA_const_LeabraTrial_ref.AddParents(&TA_const_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraMaxDa);
    TA_const_LeabraMaxDa.AddParents(&TA_const, &TA_LeabraMaxDa);
  taMisc::types.Add(&TA_const_LeabraMaxDa_ref);
    TA_const_LeabraMaxDa_ref.AddParents(&TA_const_LeabraMaxDa);
  taMisc::types.Add(&TA_LeabraSE_Stat);
    TAI_LeabraSE_Stat = new LeabraSE_Stat;
    TA_LeabraSE_Stat.AddParFormal(&TA_class);
    TA_LeabraSE_Stat.AddParCache(&TA_taBase);
    TA_LeabraSE_Stat.AddClassPar(&TA_SE_Stat,0);
    tac_AddMembers(TA_LeabraSE_Stat,TA_LeabraSE_Stat_MemberDef);
  taMisc::types.Add(&TA_const_LeabraSE_Stat);
    TA_const_LeabraSE_Stat.AddParents(&TA_const, &TA_LeabraSE_Stat);
  taMisc::types.Add(&TA_LeabraGoodStat);
    TAI_LeabraGoodStat = new LeabraGoodStat;
    TA_LeabraGoodStat.AddParFormal(&TA_class);
    TA_LeabraGoodStat.AddParCache(&TA_taBase);
    TA_LeabraGoodStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraGoodStat,TA_LeabraGoodStat_MemberDef);
  taMisc::types.Add(&TA_const_LeabraSE_Stat_ref);
    TA_const_LeabraSE_Stat_ref.AddParents(&TA_const_LeabraSE_Stat);
  taMisc::types.Add(&TA_const_LeabraGoodStat);
    TA_const_LeabraGoodStat.AddParents(&TA_const, &TA_LeabraGoodStat);
  taMisc::types.Add(&TA_const_LeabraGoodStat_ref);
    TA_const_LeabraGoodStat_ref.AddParents(&TA_const_LeabraGoodStat);
  taMisc::types.Add(&TA_LeabraSharpStat);
    TAI_LeabraSharpStat = new LeabraSharpStat;
    TA_LeabraSharpStat.AddParFormal(&TA_class);
    TA_LeabraSharpStat.AddParCache(&TA_taBase);
    TA_LeabraSharpStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraSharpStat,TA_LeabraSharpStat_MemberDef);
  taMisc::types.Add(&TA_const_LeabraSharpStat);
    TA_const_LeabraSharpStat.AddParents(&TA_const, &TA_LeabraSharpStat);
  taMisc::types.Add(&TA_const_LeabraSharpStat_ref);
    TA_const_LeabraSharpStat_ref.AddParents(&TA_const_LeabraSharpStat);
  taMisc::types.Add(&TA_WrongOnStat);
    TAI_WrongOnStat = new WrongOnStat;
    TA_WrongOnStat.AddParFormal(&TA_class);
    TA_WrongOnStat.AddParCache(&TA_taBase);
    TA_WrongOnStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_WrongOnStat,TA_WrongOnStat_MemberDef);
  taMisc::types.Add(&TA_const_WrongOnStat);
    TA_const_WrongOnStat.AddParents(&TA_const, &TA_WrongOnStat);
  taMisc::types.Add(&TA_const_WrongOnStat_ref);
    TA_const_WrongOnStat_ref.AddParents(&TA_const_WrongOnStat);
  taMisc::types.Add(&TA_LeabraPrjnRelNetinStat);
    TAI_LeabraPrjnRelNetinStat = new LeabraPrjnRelNetinStat;
    TA_LeabraPrjnRelNetinStat.AddParFormal(&TA_class);
    TA_LeabraPrjnRelNetinStat.AddParCache(&TA_taBase);
    TA_LeabraPrjnRelNetinStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraPrjnRelNetinStat,TA_LeabraPrjnRelNetinStat_MemberDef);
  taMisc::types.Add(&TA_const_LeabraPrjnRelNetinStat);
    TA_const_LeabraPrjnRelNetinStat.AddParents(&TA_const, &TA_LeabraPrjnRelNetinStat);
  taMisc::types.Add(&TA_const_LeabraPrjnRelNetinStat_ref);
    TA_const_LeabraPrjnRelNetinStat_ref.AddParents(&TA_const_LeabraPrjnRelNetinStat);
  taMisc::types.Add(&TA_ExtRew_Stat);
    TAI_ExtRew_Stat = new ExtRew_Stat;
    TA_ExtRew_Stat.AddParFormal(&TA_class);
    TA_ExtRew_Stat.AddParCache(&TA_taBase);
    TA_ExtRew_Stat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_ExtRew_Stat,TA_ExtRew_Stat_MemberDef);
  taMisc::types.Add(&TA_const_ExtRew_Stat);
    TA_const_ExtRew_Stat.AddParents(&TA_const, &TA_ExtRew_Stat);
  taMisc::types.Add(&TA_const_ExtRew_Stat_ref);
    TA_const_ExtRew_Stat_ref.AddParents(&TA_const_ExtRew_Stat);
  taMisc::types.Add(&TA_PhaseOrderEventSpec);
    TAI_PhaseOrderEventSpec = new PhaseOrderEventSpec;
    TA_PhaseOrderEventSpec.AddParFormal(&TA_class);
    TA_PhaseOrderEventSpec.AddParCache(&TA_taBase);
    TA_PhaseOrderEventSpec.AddClassPar(&TA_EventSpec,0);
    tac_AddEnum(TA_PhaseOrderEventSpec, "PhaseOrder", "", "", "", "", TA_PhaseOrderEventSpec_PhaseOrder);
    tac_AddMembers(TA_PhaseOrderEventSpec,TA_PhaseOrderEventSpec_MemberDef);
  taMisc::types.Add(&TA_const_PhaseOrderEventSpec);
    TA_const_PhaseOrderEventSpec.AddParents(&TA_const, &TA_PhaseOrderEventSpec);
  taMisc::types.Add(&TA_const_PhaseOrderEventSpec_ref);
    TA_const_PhaseOrderEventSpec_ref.AddParents(&TA_const_PhaseOrderEventSpec);
  taMisc::types.Add(&TA_V3LeabraProject);
    TAI_V3LeabraProject = new V3LeabraProject;
    TA_V3LeabraProject.AddParFormal(&TA_class);
    TA_V3LeabraProject.AddParCache(&TA_taBase);
    TA_V3LeabraProject.AddClassPar(&TA_V3ProjectBase,0);
    tac_AddMethods(TA_V3LeabraProject,TA_V3LeabraProject_MethodDef);
  taMisc::types.Add(&TA_const_V3LeabraProject);
    TA_const_V3LeabraProject.AddParents(&TA_const, &TA_V3LeabraProject);
  taMisc::types.Add(&TA_const_V3LeabraProject_ref);
    TA_const_V3LeabraProject_ref.AddParents(&TA_const_V3LeabraProject);


  taMisc::in_init = false;
} 

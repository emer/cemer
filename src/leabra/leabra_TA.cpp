// Copyright, 1995-2005, Regents of the University of Colorado,
// Carnegie Mellon University, Princeton University.
//
// This file is part of TA/PDP++
//
//   TA/PDP++ is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//   TA/PDP++ is distributed in the hope that it will be useful,
//   but WITHOUT ANY WARRANTY; without even the implied warranty of
//   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   GNU General Public License for more details.


// File Automatically Generated by MakeTA
// DO NOT EDIT


#include "ta_type.h"
#include "ta_type_constr.h"
#include "css_basic_types.h"
#include "css_c_ptr_types.h"
#include "ta_css.h"
#include "ta_TA_type.h"
#include "tamisc_TA_type.h"
#include "pdp_TA_type.h"
#include "leabra.h"
#include "leabra_TA_type.h"
#include "leabra_TA_inst.h"


// Types

TypeDef TA_LeabraCon("LeabraCon", " Leabra connection", 
	"", "INSTANCE ", "", sizeof(LeabraCon), (void**)&TAI_LeabraCon, 0, 0, 0,1);
TypeDef TA_LeabraConSpec("LeabraConSpec", " Leabra connection specs", 
	"", "INSTANCE ", "", sizeof(LeabraConSpec), (void**)&TAI_LeabraConSpec, 1, 0, 0,1);
TypeDef TA_LeabraBiasSpec("LeabraBiasSpec", " Leabra bias-weight connection specs (bias wts are a little bit special)", 
	"", "INSTANCE ", "", sizeof(LeabraBiasSpec), (void**)&TAI_LeabraBiasSpec, 1, 0, 0,1);
TypeDef TA_LeabraCon_Group("LeabraCon_Group", " Leabra connection group", 
	"", "INSTANCE ", "", sizeof(LeabraCon_Group), (void**)&TAI_LeabraCon_Group, 0, 0, 0,1);
TypeDef TA_LeabraUnitSpec("LeabraUnitSpec", " Leabra unit specifications, point-neuron approximation", 
	"", "INSTANCE ", "", sizeof(LeabraUnitSpec), (void**)&TAI_LeabraUnitSpec, 1, 0, 0,1);
TypeDef TA_LeabraUnit("LeabraUnit", " Leabra unit, point-neuron approximation", 
	"DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "DMEM_SHARE_SETS_3 INSTANCE DMEM_SHARE_SETS_5 ", "", sizeof(LeabraUnit), (void**)&TAI_LeabraUnit, 0, 0, 0,1);
TypeDef TA_LeabraInhib("LeabraInhib", " holds threshold-computation values, used as a parent class for layers, etc", 
	"", "", "", sizeof(LeabraInhib), (void**)&TAI_LeabraInhib, 1, 0, 0,1);
TypeDef TA_LeabraLayerSpec("LeabraLayerSpec", " Leabra layer specs, computes inhibitory input for all units in layer", 
	"", "INSTANCE ", "", sizeof(LeabraLayerSpec), (void**)&TAI_LeabraLayerSpec, 1, 0, 0,1);
TypeDef TA_LeabraUnit_Group("LeabraUnit_Group", " for independent subgroups of competing units within a single layer", 
	"", "MULT_INHERIT ", "", sizeof(LeabraUnit_Group), (void**)&TAI_LeabraUnit_Group, 0, 0, 0,1);
TypeDef TA_LeabraLayer("LeabraLayer", " Leabra Layer: implicit inhibition for soft kWTA behavior", 
	"", "INSTANCE MULT_INHERIT ", "", sizeof(LeabraLayer), (void**)&TAI_LeabraLayer, 1, 0, 0,1);
TypeDef TA_LeabraCycle("LeabraCycle", " one Leabra cycle of activation updating", 
	"AGGOP_SUM ", "AGGOP_SUM INSTANCE ", "", sizeof(LeabraCycle), (void**)&TAI_LeabraCycle, 1, 0, 0,1);
TypeDef TA_LeabraSettle("LeabraSettle", " Leabra settling phase of activation updating", 
	"AGGOP_SUM ", "AGGOP_SUM INSTANCE ", "", sizeof(LeabraSettle), (void**)&TAI_LeabraSettle, 1, 0, 0,1);
TypeDef TA_LeabraTrial("LeabraTrial", " Leabra trial process, iterates over phases", 
	"AGGOP_SUM ", "AGGOP_SUM INSTANCE ", "", sizeof(LeabraTrial), (void**)&TAI_LeabraTrial, 1, 0, 0,1);
TypeDef TA_LeabraMaxDa("LeabraMaxDa", " _ stat that computes when equilibrium is", 
	"LOOP_STAT ", "COMPUTE_IN_SettleProcess LOOP_STAT ", "", sizeof(LeabraMaxDa), (void**)&TAI_LeabraMaxDa, 1, 0, 0,1);
TypeDef TA_const_LeabraCon("const_LeabraCon", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraCon_ref("const_LeabraCon_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_WtScaleSpec("WtScaleSpec", " weight scaling specification", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(WtScaleSpec), (void**)&TAI_WtScaleSpec, 0, 0, 0,1);
TypeDef TA_const_WtScaleSpec("const_WtScaleSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_WtSigSpec("WtSigSpec", " sigmoidal weight function specification", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(WtSigSpec), (void**)&TAI_WtSigSpec, 0, 0, 0,1);
TypeDef TA_const_WtScaleSpec_ref("const_WtScaleSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_WtSigSpec("const_WtSigSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_WtSigSpec_ref("const_WtSigSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LearnMixSpec("LearnMixSpec", " mixture of learning factors (hebbian vs. error-driven) specification", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(LearnMixSpec), (void**)&TAI_LearnMixSpec, 0, 0, 0,1);
TypeDef TA_const_LearnMixSpec("const_LearnMixSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LearnMixSpec_ref("const_LearnMixSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SAvgCorSpec("SAvgCorSpec", " sending average activation correction specifications: affects hebbian learning and netinput computation", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(SAvgCorSpec), (void**)&TAI_SAvgCorSpec, 0, 0, 0,1);
TypeDef TA_LeabraCon_Group_ptr("LeabraCon_Group_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_SAvgCorSpec("const_SAvgCorSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraCon_ptr("LeabraCon_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_SAvgCorSpec_ref("const_SAvgCorSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraUnit_ptr("LeabraUnit_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_LeabraUnitSpec_ptr("LeabraUnitSpec_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_LeabraTrial_ptr("LeabraTrial_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_LeabraConSpec("const_LeabraConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraConSpec_ref("const_LeabraConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraBiasSpec("const_LeabraBiasSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraBiasSpec_ref("const_LeabraBiasSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraCon_Group("const_LeabraCon_Group", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraCon_Group_ref("const_LeabraCon_Group_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ActFunSpec("ActFunSpec", " activation function specifications", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ActFunSpec), (void**)&TAI_ActFunSpec, 0, 0, 0,1);
TypeDef TA_const_ActFunSpec("const_ActFunSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_SpikeFunSpec("SpikeFunSpec", " spiking activation function specs", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(SpikeFunSpec), (void**)&TAI_SpikeFunSpec, 0, 0, 0,1);
TypeDef TA_const_ActFunSpec_ref("const_ActFunSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_SpikeFunSpec("const_SpikeFunSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SpikeFunSpec_ref("const_SpikeFunSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DepressSpec("DepressSpec", " depressing synapses activation function specs", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(DepressSpec), (void**)&TAI_DepressSpec, 0, 0, 0,1);
TypeDef TA_const_DepressSpec("const_DepressSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DepressSpec_ref("const_DepressSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_OptThreshSpec("OptThreshSpec", " optimization thresholds for faster processing", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(OptThreshSpec), (void**)&TAI_OptThreshSpec, 0, 0, 0,1);
TypeDef TA_const_OptThreshSpec("const_OptThreshSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_OptThreshSpec_ref("const_OptThreshSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DtSpec("DtSpec", " time constants", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(DtSpec), (void**)&TAI_DtSpec, 0, 0, 0,1);
TypeDef TA_const_DtSpec("const_DtSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DtSpec_ref("const_DtSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraChannels("LeabraChannels", " channels used in Leabra", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(LeabraChannels), (void**)&TAI_LeabraChannels, 0, 0, 0,1);
TypeDef TA_const_LeabraChannels("const_LeabraChannels", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraChannels_ref("const_LeabraChannels_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_VChanSpec("VChanSpec", " voltage gated channel specs", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(VChanSpec), (void**)&TAI_VChanSpec, 0, 0, 0,1);
TypeDef TA_const_VChanSpec("const_VChanSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_ActRegSpec("ActRegSpec", " activity regulation via weight adjustment", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ActRegSpec), (void**)&TAI_ActRegSpec, 0, 0, 0,1);
TypeDef TA_const_VChanSpec_ref("const_VChanSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraLayer_ptr("LeabraLayer_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_ActRegSpec("const_ActRegSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraInhib_ptr("LeabraInhib_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_ActRegSpec_ref("const_ActRegSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnitSpec("const_LeabraUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnitSpec_ref("const_LeabraUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_VChanBasis("VChanBasis", " basis variables for vchannels", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(VChanBasis), (void**)&TAI_VChanBasis, 0, 0, 0,1);
TypeDef TA_const_VChanBasis("const_VChanBasis", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraUnitChans("LeabraUnitChans", " channels used in Leabra units", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(LeabraUnitChans), (void**)&TAI_LeabraUnitChans, 0, 0, 0,1);
TypeDef TA_const_VChanBasis_ref("const_VChanBasis_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnit("const_LeabraUnit", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnitChans("const_LeabraUnitChans", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnit_ref("const_LeabraUnit_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnitChans_ref("const_LeabraUnitChans_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_taPtrList_LeabraUnit_("taPtrList_LeabraUnit_", " ", 
	"", "NO_UPDATE_AFTER ", "", sizeof(taPtrList<LeabraUnit>), (void**)&TAI_taPtrList_LeabraUnit_, 0, 0, 0,1);
TypeDef TA_LeabraSort("LeabraSort", " used for sorting units in kwta computation", 
	"", "", "", sizeof(LeabraSort), (void**)&TAI_LeabraSort, 0, 0, 0,1);
TypeDef TA_KWTASpec("KWTASpec", " specifies k-winner-take-all parameters", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(KWTASpec), (void**)&TAI_KWTASpec, 0, 0, 0,1);
TypeDef TA_const_KWTASpec("const_KWTASpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_AdaptISpec("AdaptISpec", " specifies adaptive kwta specs (esp for avg-based)", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(AdaptISpec), (void**)&TAI_AdaptISpec, 0, 0, 0,1);
TypeDef TA_const_KWTASpec_ref("const_KWTASpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_AdaptISpec("const_AdaptISpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AdaptISpec_ref("const_AdaptISpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ClampSpec("ClampSpec", " specs for clamping ", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ClampSpec), (void**)&TAI_ClampSpec, 0, 0, 0,1);
TypeDef TA_const_ClampSpec("const_ClampSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ClampSpec_ref("const_ClampSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DecaySpec("DecaySpec", " holds decay values", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(DecaySpec), (void**)&TAI_DecaySpec, 0, 0, 0,1);
TypeDef TA_const_DecaySpec("const_DecaySpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_KWTASpec_ref("KWTASpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_DecaySpec_ref("const_DecaySpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraLayerSpec("const_LeabraLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraLayerSpec_ref("const_LeabraLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SpecPtr_LeabraLayerSpec_("SpecPtr_LeabraLayerSpec_", "", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER INSTANCE ", "", sizeof(SpecPtr<LeabraLayerSpec>), (void**)&TAI_SpecPtr_LeabraLayerSpec_, 0, 0, 0,1);
TypeDef TA_LeabraLayerSpec_SPtr("LeabraLayerSpec_SPtr", "", 
	"NO_UPDATE_AFTER ", "NO_UPDATE_AFTER INSTANCE ", "", sizeof(LeabraLayerSpec_SPtr), (void**)&TAI_LeabraLayerSpec_SPtr, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_SPtr("const_LeabraLayerSpec_SPtr", 1, 0, 0, 0, 1, 0);
TypeDef TA_AvgMaxVals("AvgMaxVals", " holds average and max statistics", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(AvgMaxVals), (void**)&TAI_AvgMaxVals, 0, 0, 0,1);
TypeDef TA_const_LeabraLayerSpec_SPtr_ref("const_LeabraLayerSpec_SPtr_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_AvgMaxVals("const_AvgMaxVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AvgMaxVals_ref("const_AvgMaxVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_KWTAVals("KWTAVals", " holds values for kwta stuff", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(KWTAVals), (void**)&TAI_KWTAVals, 0, 0, 0,1);
TypeDef TA_const_KWTAVals("const_KWTAVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_KWTAVals_ref("const_KWTAVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_AdaptIVals("AdaptIVals", " holds values for adapting kwta stuff", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(AdaptIVals), (void**)&TAI_AdaptIVals, 0, 0, 0,1);
TypeDef TA_const_AdaptIVals("const_AdaptIVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AdaptIVals_ref("const_AdaptIVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_InhibVals("InhibVals", " holds values for inhibition", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(InhibVals), (void**)&TAI_InhibVals, 0, 0, 0,1);
TypeDef TA_LeabraLayerSpec_ptr("LeabraLayerSpec_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_InhibVals("const_InhibVals", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraInhib("const_LeabraInhib", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_InhibVals_ref("const_InhibVals_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraInhib_ref("const_LeabraInhib_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraLayer("const_LeabraLayer", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraLayer_ref("const_LeabraLayer_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraUnit_Group("const_LeabraUnit_Group", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraUnit_Group_ref("const_LeabraUnit_Group_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraSettle_ptr("LeabraSettle_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_LeabraCycle("const_LeabraCycle", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraCycle_ref("const_LeabraCycle_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraSettle("const_LeabraSettle", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraSettle_ref("const_LeabraSettle_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraTrial("const_LeabraTrial", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraTrial_ref("const_LeabraTrial_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraMaxDa("const_LeabraMaxDa", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraMaxDa_ref("const_LeabraMaxDa_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraSE_Stat("LeabraSE_Stat", " squared error for leabra, controls when to compute SE ", 
	"", "INSTANCE ", "", sizeof(LeabraSE_Stat), (void**)&TAI_LeabraSE_Stat, 1, 0, 0,1);
TypeDef TA_const_LeabraSE_Stat("const_LeabraSE_Stat", 1, 0, 0, 0, 1, 0);
TypeDef TA_LeabraGoodStat("LeabraGoodStat", " constraint satisfaction goodness statistic", 
	"", "COMPUTE_IN_TrialProcess ", "", sizeof(LeabraGoodStat), (void**)&TAI_LeabraGoodStat, 1, 0, 0,1);
TypeDef TA_const_LeabraSE_Stat_ref("const_LeabraSE_Stat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_LeabraGoodStat("const_LeabraGoodStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraGoodStat_ref("const_LeabraGoodStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraSharpStat("LeabraSharpStat", " layer sharpness statistic: just max / avg", 
	"", "COMPUTE_IN_TrialProcess ", "", sizeof(LeabraSharpStat), (void**)&TAI_LeabraSharpStat, 1, 0, 0,1);
TypeDef TA_const_LeabraSharpStat("const_LeabraSharpStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraSharpStat_ref("const_LeabraSharpStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_WrongOnStat("WrongOnStat", " Reports an error if a unit is on when it shouldn't have been (for multiple output cases)", 
	"", "COMPUTE_IN_TrialProcess ", "", sizeof(WrongOnStat), (void**)&TAI_WrongOnStat, 1, 0, 0,1);
TypeDef TA_const_WrongOnStat("const_WrongOnStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_WrongOnStat_ref("const_WrongOnStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraPrjnRelNetinStat("LeabraPrjnRelNetinStat", " computes overall relative netinput contributions for the different projections into a layer. Useful for setting wt_scale parameters to achieve desired relative contributions of different inputs. you MUST set the layer parameter to the layer in question", 
	"", "COMPUTE_IN_TrialProcess ", "", sizeof(LeabraPrjnRelNetinStat), (void**)&TAI_LeabraPrjnRelNetinStat, 1, 0, 0,1);
TypeDef TA_const_LeabraPrjnRelNetinStat("const_LeabraPrjnRelNetinStat", 1, 0, 0, 0, 1, 0);
TypeDef TA_CtxtUpdateSpec("CtxtUpdateSpec", " context updating specifications", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(CtxtUpdateSpec), (void**)&TAI_CtxtUpdateSpec, 0, 0, 0,1);
TypeDef TA_const_LeabraPrjnRelNetinStat_ref("const_LeabraPrjnRelNetinStat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_const_CtxtUpdateSpec("const_CtxtUpdateSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_CtxtUpdateSpec_ref("const_CtxtUpdateSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraContextLayerSpec("LeabraContextLayerSpec", " context layer that copies from its recv projection (like an input layer)", 
	"", "INSTANCE ", "", sizeof(LeabraContextLayerSpec), (void**)&TAI_LeabraContextLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraContextLayerSpec("const_LeabraContextLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraContextLayerSpec_ref("const_LeabraContextLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PhaseOrderEventSpec("PhaseOrderEventSpec", " event specification including order of phases", 
	"SCOPE_Environment IMMEDIATE_UPDATE ", "SCOPE_Environment IMMEDIATE_UPDATE INSTANCE ", "", sizeof(PhaseOrderEventSpec), (void**)&TAI_PhaseOrderEventSpec, 1, 0, 0,1);
TypeDef TA_const_PhaseOrderEventSpec("const_PhaseOrderEventSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PhaseOrderEventSpec_ref("const_PhaseOrderEventSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraLinUnitSpec("LeabraLinUnitSpec", " a pure linear unit (suitable for an AC unit spec unit)", 
	"", "INSTANCE ", "", sizeof(LeabraLinUnitSpec), (void**)&TAI_LeabraLinUnitSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraLinUnitSpec("const_LeabraLinUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraLinUnitSpec_ref("const_LeabraLinUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraNegBiasSpec("LeabraNegBiasSpec", " only learns negative bias changes, not positive ones (decay restores back to zero)", 
	"", "INSTANCE ", "", sizeof(LeabraNegBiasSpec), (void**)&TAI_LeabraNegBiasSpec, 1, 0, 0,1);
TypeDef TA_const_LeabraNegBiasSpec("const_LeabraNegBiasSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraNegBiasSpec_ref("const_LeabraNegBiasSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TrialSynDepCon("TrialSynDepCon", " synaptic depression connection at the trial level (as opposed to cycle level)", 
	"", "INSTANCE ", "", sizeof(TrialSynDepCon), (void**)&TAI_TrialSynDepCon, 0, 0, 0,1);
TypeDef TA_const_TrialSynDepCon("const_TrialSynDepCon", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TrialSynDepCon_ref("const_TrialSynDepCon_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SynDepSpec("SynDepSpec", " specs for synaptic depression", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(SynDepSpec), (void**)&TAI_SynDepSpec, 0, 0, 0,1);
TypeDef TA_TrialSynDepCon_ptr("TrialSynDepCon_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_SynDepSpec("const_SynDepSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SynDepSpec_ref("const_SynDepSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TrialSynDepConSpec("TrialSynDepConSpec", " synaptic depression connection at the trial level (as opposed to cycle level)", 
	"", "INSTANCE ", "", sizeof(TrialSynDepConSpec), (void**)&TAI_TrialSynDepConSpec, 1, 0, 0,1);
TypeDef TA_const_TrialSynDepConSpec("const_TrialSynDepConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TrialSynDepConSpec_ref("const_TrialSynDepConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_FastWtCon("FastWtCon", " fast weight connection: standard wt learns fast, but decays toward slow weight value", 
	"", "INSTANCE ", "", sizeof(FastWtCon), (void**)&TAI_FastWtCon, 0, 0, 0,1);
TypeDef TA_const_FastWtCon("const_FastWtCon", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_FastWtCon_ref("const_FastWtCon_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_FastWtSpec("FastWtSpec", " specificiations for fast weights", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(FastWtSpec), (void**)&TAI_FastWtSpec, 0, 0, 0,1);
TypeDef TA_FastWtCon_ptr("FastWtCon_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_FastWtSpec("const_FastWtSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_FastWtSpec_ref("const_FastWtSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_FastWtConSpec("FastWtConSpec", " fast weight connection: standard wt learns fast, but decays toward slow weight value", 
	"", "INSTANCE ", "", sizeof(FastWtConSpec), (void**)&TAI_FastWtConSpec, 1, 0, 0,1);
TypeDef TA_const_FastWtConSpec("const_FastWtConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_FastWtConSpec_ref("const_FastWtConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValSpec("ScalarValSpec", " specs for scalar values", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ScalarValSpec), (void**)&TAI_ScalarValSpec, 0, 0, 0,1);
TypeDef TA_const_ScalarValSpec("const_ScalarValSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValSpec_ref("const_ScalarValSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValBias("ScalarValBias", " initial bias for given activation value for scalar value units", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ScalarValBias), (void**)&TAI_ScalarValBias, 0, 0, 0,1);
TypeDef TA_const_ScalarValBias("const_ScalarValBias", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValBias_ref("const_ScalarValBias_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValLayerSpec("ScalarValLayerSpec", " represents a scalar value using a coarse-coded distributed code over units. first unit represents scalar value.", 
	"", "INSTANCE ", "", sizeof(ScalarValLayerSpec), (void**)&TAI_ScalarValLayerSpec, 1, 0, 0,1);
TypeDef TA_const_ScalarValLayerSpec("const_ScalarValLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValLayerSpec_ref("const_ScalarValLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ScalarValSelfPrjnSpec("ScalarValSelfPrjnSpec", " special projection for making self-connection that establishes neighbor similarity in scalar val", 
	"", "INSTANCE ", "", sizeof(ScalarValSelfPrjnSpec), (void**)&TAI_ScalarValSelfPrjnSpec, 1, 0, 0,1);
TypeDef TA_const_ScalarValSelfPrjnSpec("const_ScalarValSelfPrjnSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ScalarValSelfPrjnSpec_ref("const_ScalarValSelfPrjnSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TwoDValSpec("TwoDValSpec", " specs for two-dimensional values", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(TwoDValSpec), (void**)&TAI_TwoDValSpec, 0, 0, 0,1);
TypeDef TA_const_TwoDValSpec("const_TwoDValSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TwoDValSpec_ref("const_TwoDValSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TwoDValBias("TwoDValBias", " initial bias for given activation value for scalar value units", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(TwoDValBias), (void**)&TAI_TwoDValBias, 0, 0, 0,1);
TypeDef TA_const_TwoDValBias("const_TwoDValBias", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TwoDValBias_ref("const_TwoDValBias_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TwoDValLayerSpec("TwoDValLayerSpec", " represents one or more two-d value(s) using a coarse-coded distributed code over units. first row represents scalar value(s). one val readout is weighted-average; multiple vals = max bumps over 3x3 local grid", 
	"", "INSTANCE ", "", sizeof(TwoDValLayerSpec), (void**)&TAI_TwoDValLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TwoDValLayerSpec("const_TwoDValLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TwoDValLayerSpec_ref("const_TwoDValLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MarkerConSpec("MarkerConSpec", " connection spec that marks special projections: doesn't send netin or adapt weights", 
	"", "INSTANCE ", "", sizeof(MarkerConSpec), (void**)&TAI_MarkerConSpec, 1, 0, 0,1);
TypeDef TA_const_MarkerConSpec("const_MarkerConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MarkerConSpec_ref("const_MarkerConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DaModUnit("DaModUnit", " Leabra unit with dopamine-like modulation of minus phase activation for learning", 
	"DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 ", "DMEM_SHARE_SETS_3 DMEM_SHARE_SETS_5 INSTANCE ", "", sizeof(DaModUnit), (void**)&TAI_DaModUnit, 0, 0, 0,1);
TypeDef TA_const_DaModUnit("const_DaModUnit", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DaModUnit_ref("const_DaModUnit_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DaModSpec("DaModSpec", " specs for effects of da-based modulation: plus-phase = learning effects", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(DaModSpec), (void**)&TAI_DaModSpec, 0, 0, 0,1);
TypeDef TA_const_DaModSpec("const_DaModSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DaModSpec_ref("const_DaModSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_DaModUnitSpec("DaModUnitSpec", " Leabra unit with temporal-differences error modulation of minus phase activation for learning", 
	"", "INSTANCE ", "", sizeof(DaModUnitSpec), (void**)&TAI_DaModUnitSpec, 1, 0, 0,1);
TypeDef TA_const_DaModUnitSpec("const_DaModUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_DaModUnitSpec_ref("const_DaModUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_AvgExtRewSpec("AvgExtRewSpec", " specs for computing average external rewards", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(AvgExtRewSpec), (void**)&TAI_AvgExtRewSpec, 0, 0, 0,1);
TypeDef TA_const_AvgExtRewSpec("const_AvgExtRewSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_AvgExtRewSpec_ref("const_AvgExtRewSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_OutErrSpec("OutErrSpec", " specs for computing external rewards based on output performance of network", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(OutErrSpec), (void**)&TAI_OutErrSpec, 0, 0, 0,1);
TypeDef TA_const_OutErrSpec("const_OutErrSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_OutErrSpec_ref("const_OutErrSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ExtRewSpec("ExtRewSpec", " specs for computing external rewards", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ExtRewSpec), (void**)&TAI_ExtRewSpec, 0, 0, 0,1);
TypeDef TA_DaModUnit_ptr("DaModUnit_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_ExtRewSpec("const_ExtRewSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ExtRewSpec_ref("const_ExtRewSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ExtRewLayerSpec("ExtRewLayerSpec", " computes external reward feedback: minus phase is zero, plus phase is reward value derived from network performance or other inputs (computed at start of 1+)", 
	"", "INSTANCE ", "", sizeof(ExtRewLayerSpec), (void**)&TAI_ExtRewLayerSpec, 1, 0, 0,1);
TypeDef TA_const_ExtRewLayerSpec("const_ExtRewLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ExtRewLayerSpec_ref("const_ExtRewLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ExtRew_Stat("ExtRew_Stat", " external reward statistic", 
	"FINAL_STAT ", "COMPUTE_IN_TrialProcess FINAL_STAT ", "", sizeof(ExtRew_Stat), (void**)&TAI_ExtRew_Stat, 1, 0, 0,1);
TypeDef TA_const_ExtRew_Stat("const_ExtRew_Stat", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ExtRew_Stat_ref("const_ExtRew_Stat_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewPredConSpec("TDRewPredConSpec", " Reward Prediction connections: for TD RewPred Layer, uses TD algorithm for predicting rewards", 
	"", "INSTANCE ", "", sizeof(TDRewPredConSpec), (void**)&TAI_TDRewPredConSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewPredConSpec("const_TDRewPredConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewPredConSpec_ref("const_TDRewPredConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewPredLayerSpec("TDRewPredLayerSpec", " predicts rewards: minus phase = clamped prior expected reward V^(t), plus = settles on expectation of future reward V^(t+1)", 
	"", "INSTANCE ", "", sizeof(TDRewPredLayerSpec), (void**)&TAI_TDRewPredLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewPredLayerSpec("const_TDRewPredLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewPredLayerSpec_ref("const_TDRewPredLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewIntegSpec("TDRewIntegSpec", " misc specs for TDRewIntegLayerSpec", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(TDRewIntegSpec), (void**)&TAI_TDRewIntegSpec, 0, 0, 0,1);
TypeDef TA_const_TDRewIntegSpec("const_TDRewIntegSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewIntegSpec_ref("const_TDRewIntegSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TDRewIntegLayerSpec("TDRewIntegLayerSpec", " integrates perceived and external rewards: delta over phases = DA td-like signal. minus phase = prev exp rew V^(t), plus phase = extrew (r) + tdrewpred computing V(t+1)", 
	"", "INSTANCE ", "", sizeof(TDRewIntegLayerSpec), (void**)&TAI_TDRewIntegLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TDRewIntegLayerSpec("const_TDRewIntegLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TDRewIntegLayerSpec_ref("const_TDRewIntegLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_TdLayerSpec("TdLayerSpec", " computes activation = temporal derivative (act_eq - act_m) of sending units in plus phases: note, act will go negative!", 
	"", "INSTANCE ", "", sizeof(TdLayerSpec), (void**)&TAI_TdLayerSpec, 1, 0, 0,1);
TypeDef TA_const_TdLayerSpec("const_TdLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_TdLayerSpec_ref("const_TdLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVConSpec("PVConSpec", " primary value connection spec: learns using delta rule from PVe - PVi values", 
	"", "INSTANCE ", "", sizeof(PVConSpec), (void**)&TAI_PVConSpec, 1, 0, 0,1);
TypeDef TA_const_PVConSpec("const_PVConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVConSpec_ref("const_PVConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVDetectSpec("PVDetectSpec", " specs for detecting if a primary value is present or expected", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(PVDetectSpec), (void**)&TAI_PVDetectSpec, 0, 0, 0,1);
TypeDef TA_const_PVDetectSpec("const_PVDetectSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVDetectSpec_ref("const_PVDetectSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PViLayerSpec("PViLayerSpec", " primary value inhibitory (PVi) layer: continously learns to expect primary reward values", 
	"", "INSTANCE ", "", sizeof(PViLayerSpec), (void**)&TAI_PViLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PViLayerSpec("const_PViLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PViLayerSpec_ref("const_PViLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LVConSpec("LVConSpec", " learned value connection spec: learns using delta rule from PVe - LV values; also does synaptic depression to do novelty filtering", 
	"", "INSTANCE ", "", sizeof(LVConSpec), (void**)&TAI_LVConSpec, 1, 0, 0,1);
TypeDef TA_const_LVConSpec("const_LVConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LVConSpec_ref("const_LVConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LVSpec("LVSpec", " specs for learned value layers", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(LVSpec), (void**)&TAI_LVSpec, 0, 0, 0,1);
TypeDef TA_const_LVSpec("const_LVSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LVSpec_ref("const_LVSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LVeLayerSpec("LVeLayerSpec", " learns value based on inputs that are associated with rewards, only learns at time of primary rewards (filtered by PV system). This is excitatory version", 
	"", "INSTANCE ", "", sizeof(LVeLayerSpec), (void**)&TAI_LVeLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LVeLayerSpec("const_LVeLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LVeLayerSpec_ref("const_LVeLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LViLayerSpec("LViLayerSpec", " inhibitory/slow version of LV layer spec: (just a marker for layer; same functionality as LVeLayerSpec)", 
	"", "INSTANCE ", "", sizeof(LViLayerSpec), (void**)&TAI_LViLayerSpec, 1, 0, 0,1);
TypeDef TA_const_LViLayerSpec("const_LViLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LViLayerSpec_ref("const_LViLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVLVDaSpec("PVLVDaSpec", " specs for PVLV da parameters", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(PVLVDaSpec), (void**)&TAI_PVLVDaSpec, 0, 0, 0,1);
TypeDef TA_const_PVLVDaSpec("const_PVLVDaSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVLVDaSpec_ref("const_PVLVDaSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PVLVDaLayerSpec("PVLVDaLayerSpec", " computes PVLV 'Da' signal: typically if(ER), da = ER-PV, else LVe - LVs", 
	"", "INSTANCE ", "", sizeof(PVLVDaLayerSpec), (void**)&TAI_PVLVDaLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PVLVDaLayerSpec("const_PVLVDaLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PVLVDaLayerSpec_ref("const_PVLVDaLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PatchLayerSpec("PatchLayerSpec", " simulates Patch as a LV layer: currently no doing anything different than regular LV", 
	"", "INSTANCE ", "", sizeof(PatchLayerSpec), (void**)&TAI_PatchLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PatchLayerSpec("const_PatchLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PatchLayerSpec_ref("const_PatchLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNcMiscSpec("SNcMiscSpec", " misc parameters for SNc layer", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(SNcMiscSpec), (void**)&TAI_SNcMiscSpec, 0, 0, 0,1);
TypeDef TA_const_SNcMiscSpec("const_SNcMiscSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNcMiscSpec_ref("const_SNcMiscSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNcLayerSpec("SNcLayerSpec", " computes PVLV 'Da' signal, uses inputs from the patch to provide stripe-specific modulation (NOTE: not currently supported); Does not do SNrThal modulation, which is computed directly in Matrix units", 
	"", "INSTANCE ", "", sizeof(SNcLayerSpec), (void**)&TAI_SNcLayerSpec, 1, 0, 0,1);
TypeDef TA_const_SNcLayerSpec("const_SNcLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNcLayerSpec_ref("const_SNcLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixConSpec("MatrixConSpec", " Learning of matrix input connections based on dopamine modulation of activation", 
	"", "INSTANCE ", "", sizeof(MatrixConSpec), (void**)&TAI_MatrixConSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixConSpec("const_MatrixConSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixConSpec_ref("const_MatrixConSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixBiasSpec("MatrixBiasSpec", " noise bias connection -- holds noise value separate from orig value", 
	"", "INSTANCE ", "", sizeof(MatrixBiasSpec), (void**)&TAI_MatrixBiasSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixBiasSpec("const_MatrixBiasSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixBiasSpec_ref("const_MatrixBiasSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixUnitSpec("MatrixUnitSpec", " basal ganglia matrix units: fire actions or WM updates. modulated by da signals", 
	"", "INSTANCE ", "", sizeof(MatrixUnitSpec), (void**)&TAI_MatrixUnitSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixUnitSpec("const_MatrixUnitSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixUnitSpec_ref("const_MatrixUnitSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_ContrastSpec("ContrastSpec", " contrast enhancement of the GO units", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(ContrastSpec), (void**)&TAI_ContrastSpec, 0, 0, 0,1);
TypeDef TA_const_ContrastSpec("const_ContrastSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_ContrastSpec_ref("const_ContrastSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixRndGoSpec("MatrixRndGoSpec", " matrix random GO firing to encourage exploration for non-productive stripes based on avg_go_da for that stripe (matrix_u->misc_1)", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(MatrixRndGoSpec), (void**)&TAI_MatrixRndGoSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoSpec("const_MatrixRndGoSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixRndGoSpec_ref("const_MatrixRndGoSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixRndGoThrSpec("MatrixRndGoThrSpec", " thresholds for matrix random Go firing to encourage exploration for non-productive stripes based on avg_go_da for that stripe (matrix_u->misc_1)", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(MatrixRndGoThrSpec), (void**)&TAI_MatrixRndGoThrSpec, 0, 0, 0,1);
TypeDef TA_const_MatrixRndGoThrSpec("const_MatrixRndGoThrSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixRndGoThrSpec_ref("const_MatrixRndGoThrSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixMiscSpec("MatrixMiscSpec", " misc specs for the matrix layer", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(MatrixMiscSpec), (void**)&TAI_MatrixMiscSpec, 0, 0, 0,1);
TypeDef TA_LeabraUnit_Group_ptr("LeabraUnit_Group_ptr", 1, 1, 0, 0, 1, 0);
TypeDef TA_const_MatrixMiscSpec("const_MatrixMiscSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixMiscSpec_ref("const_MatrixMiscSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_MatrixLayerSpec("MatrixLayerSpec", " basal ganglia matrix layer: fire actions/WM updates, or nogo; PFC = gate in 1+ and 2+, MOTOR = gate in -", 
	"", "INSTANCE ", "", sizeof(MatrixLayerSpec), (void**)&TAI_MatrixLayerSpec, 1, 0, 0,1);
TypeDef TA_const_MatrixLayerSpec("const_MatrixLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_MatrixLayerSpec_ref("const_MatrixLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_SNrThalLayerSpec("SNrThalLayerSpec", " computes activation = GO - NOGO from MatrixLayerSpec", 
	"", "INSTANCE ", "", sizeof(SNrThalLayerSpec), (void**)&TAI_SNrThalLayerSpec, 1, 0, 0,1);
TypeDef TA_const_SNrThalLayerSpec("const_SNrThalLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_SNrThalLayerSpec_ref("const_SNrThalLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PFCGateSpec("PFCGateSpec", " basal ganglia gating specifications", 
	"", "NO_TOKENS NO_UPDATE_AFTER ", "", sizeof(PFCGateSpec), (void**)&TAI_PFCGateSpec, 0, 0, 0,1);
TypeDef TA_const_PFCGateSpec("const_PFCGateSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PFCGateSpec_ref("const_PFCGateSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_PFCLayerSpec("PFCLayerSpec", " Prefrontal cortex layer: gets gating signal from matrix, gate updates before each plus phase (toggle off, toggle on)", 
	"", "INSTANCE ", "", sizeof(PFCLayerSpec), (void**)&TAI_PFCLayerSpec, 1, 0, 0,1);
TypeDef TA_const_PFCLayerSpec("const_PFCLayerSpec", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_PFCLayerSpec_ref("const_PFCLayerSpec_ref", 1, 0, 1, 0, 1, 0);
TypeDef TA_LeabraWiz("LeabraWiz", " Leabra-specific wizard for automating construction of simulation objects", 
	"", "INSTANCE ", "", sizeof(LeabraWiz), (void**)&TAI_LeabraWiz, 1, 0, 0,1);
TypeDef TA_const_LeabraWiz("const_LeabraWiz", 1, 0, 0, 0, 1, 0);
TypeDef TA_const_LeabraWiz_ref("const_LeabraWiz_ref", 1, 0, 1, 0, 1, 0);

// Instances

LeabraCon*		 TAI_LeabraCon=NULL;
LeabraConSpec*		 TAI_LeabraConSpec=NULL;
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtState((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Net((LeabraCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_WtFmLin((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_WtFmLin((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_LinFmWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_LinFmWt((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_LinFmWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_LinFmWt((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_InitWtState_Post((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Compute_SAvgCor_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Compute_SAvgCor((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_B_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->B_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_Compute_ActReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_Compute_ActReg((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_C_UpdateWeightsActReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->C_UpdateWeightsActReg((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_B_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->B_UpdateWeights((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnitSpec*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->SetCurLrate((int)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_CreateWtSigFun_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->CreateWtSigFun();
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_LeabraConSpec_GraphWtSigFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraConSpec*)ths)->GraphWtSigFun((GraphLog*)(void*)*arg[1]);
    return rval;}
LeabraBiasSpec*		 TAI_LeabraBiasSpec=NULL;
LeabraCon_Group*		 TAI_LeabraCon_Group=NULL;
  static cssEl* cssElCFun_LeabraCon_Group_Compute_LinFmWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Compute_LinFmWt();
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Compute_WtFmLin_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Compute_WtFmLin();
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_C_InitWtState_Post_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->C_InitWtState_Post((Connection*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->SetCurLrate((int)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Send_ClampNet((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraCon_Group_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCon_Group*)ths)->Send_NetDelta((LeabraUnit*)(void*)*arg[1]);
    return rval;}
LeabraUnitSpec*		 TAI_LeabraUnitSpec=NULL;
  static cssEl* cssElCFun_LeabraUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitWtState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_Net((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Act((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssInt((int)((LeabraUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssInt((int)((LeabraUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->SetCurLrate((LeabraUnit*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_InitDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->InitDelta((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetScale((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_ClampNet((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Send_NetDelta((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_NetAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_InhibAvg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_HardClamp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_HardClampNoClip_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_HardClampNoClip((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnitSpec*)ths)->Compute_SoftClamp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThresh_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThresh((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshAll_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshAll((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoA_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoA((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoH((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_IThreshNoAH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnitSpec*)ths)->Compute_IThreshNoAH((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Conduct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Conduct((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_Vm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_Vm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_ActFmVm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_ActFmVm((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_SelfReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_SelfReg((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->PhaseInit((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->DecayPhase((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->DecayEvent((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->ExtToComp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->TargExtToComp((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->PostSettle((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4], (bool)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_dWt_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_dWt_impl((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Compute_WtFmLin((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->EncodeState((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_CreateNXX1Fun_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->CreateNXX1Fun();
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnitSpec*)ths)->Defaults();
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_GraphVmFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->GraphVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_GraphActFmVmFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->GraphActFmVmFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnitSpec_GraphActFmNetFun_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2]);}
    if(na == 3) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);}
    if(na == 4) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4]);}
    if(na == 5) {
      ((LeabraUnitSpec*)ths)->GraphActFmNetFun((GraphLog*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]);}
    return rval;}
LeabraUnit*		 TAI_LeabraUnit=NULL;
  static cssEl* cssElCFun_LeabraUnit_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_Net((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->SetCurLrate((LeabraTrial*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Send_NetDelta((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_HardClampNoClip_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_HardClampNoClip((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit*)ths)->Compute_SoftClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_IThresh_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnit*)ths)->Compute_IThresh((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_IThreshNoAH_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LeabraUnit*)ths)->Compute_IThreshNoAH((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->PhaseInit((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->DecayEvent((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->DecayPhase((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->ExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->TargExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      ((LeabraUnit*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);}
    if(na == 4) {
      ((LeabraUnit*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraInhib*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3], (bool)*arg[4]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->Compute_WtFmLin((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_EncodeState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->EncodeState((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_GetInSubGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit*)ths)->GetInSubGp();
    return rval;}
LeabraInhib*		 TAI_LeabraInhib=NULL;
  static cssEl* cssElCFun_LeabraInhib_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraInhib_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraInhib*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
LeabraLayerSpec*		 TAI_LeabraLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraLayerSpec_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitWtState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->SetCurLrate((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Active_K_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Active_K((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Active_K_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    KWTASpec& refarg_3=*(KWTASpec*)arg[4]->GetVoidPtrOfType(&TA_KWTASpec);
    ((LeabraLayerSpec*)ths)->Compute_Active_K_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], refarg_3);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Pat_K_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayerSpec*)ths)->Compute_Pat_K((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitState((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_HardClampPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_HardClampPhase2((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_HardClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetScale((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_ClampNet((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_Net((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Send_NetDelta((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Clamp_NetAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_NetAvg((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_SoftClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_SoftClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_InitInhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->InitInhib((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA_Avg((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_AvgMaxPt((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Inhib_kWTA_Gps((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_InhibAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_InhibAvg_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_InhibAvg_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActMAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActMAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActMAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActMAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActPAvg_ugp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActPAvg_ugp((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_ActPAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_ActPAvg((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Act((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_Act_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_Act_impl((LeabraLayer*)(void*)*arg[1], (Unit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->PhaseInit((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayEvent((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayPhase((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_DecayPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->DecayPhase2((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->ExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->TargExtToComp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);}
    if(na == 3) {
      ((LeabraLayerSpec*)ths)->PostSettle((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_AdaptGBarI_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->AdaptGBarI((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_AdaptKWTAPt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->AdaptKWTAPt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_dWt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Compute_WtFmLin((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpec((LeabraLayer*)(void*)*arg[1], refarg_1, (TypeDef*)*arg[3]), 1, &TA_LeabraLayer);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpecExact_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpecExact((LeabraLayer*)(void*)*arg[1], refarg_1, (TypeDef*)*arg[3]), 1, &TA_LeabraLayer);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_FindLayerFmSpecNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayerSpec*)ths)->FindLayerFmSpecNet((Network*)(void*)*arg[1], (TypeDef*)*arg[2]), 1, &TA_LeabraLayer);
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));}
    if(na == 3) {
      rval=new cssInt((int)((LeabraLayerSpec*)ths)->CheckConfig((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (bool)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayerSpec_Defaults_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayerSpec*)ths)->Defaults();
    return rval;}
LeabraUnit_Group*		 TAI_LeabraUnit_Group=NULL;
  static cssEl* cssElCFun_LeabraUnit_Group_GetColText_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetColText((int)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetColText((int)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChildQueryEditActions_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_3=(int)*arg[4];    int refarg_4=(int)*arg[5];
    ((LeabraUnit_Group*)ths)->ChildQueryEditActions((MemberDef*)*arg[1], (const taBase*)(void*)*arg[2], (taiMimeSource*)(void*)*arg[3], refarg_3, refarg_4);
    *arg[4]=(Int)refarg_3;    *arg[5]=(Int)refarg_4;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChildEditAction_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ChildEditAction((MemberDef*)*arg[1], (taBase*)(void*)*arg[2], (taiMimeSource*)(void*)*arg[3], (int)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_QueryEditActions_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];    int refarg_2=(int)*arg[3];
    ((LeabraUnit_Group*)ths)->QueryEditActions((const taiMimeSource*)(void*)*arg[1], refarg_1, refarg_2);
    *arg[2]=(Int)refarg_1;    *arg[3]=(Int)refarg_2;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EditAction_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->EditAction((taiMimeSource*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetDataLink_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraUnit_Group*)ths)->GetDataLink(), 1, &TA_taDataLink);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnRef_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UnRef();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnRefNoDelete_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UnRefNoDelete();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnSafeCopy_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UnSafeCopy((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CastCopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->CastCopyTo((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetOwner_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->GetOwner((TypeDef*)*arg[1]), 1, &TA_taBase);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath());}
    if(na == 1) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraUnit_Group*)ths)->GetPath((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindFromPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      taString refarg_0=arg[1]->GetStr();
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(refarg_0), 1, &TA_taBase);    *arg[1]=(String)refarg_0;
}
    if(na == 2) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(refarg_0, refarg_1), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    if(na == 3) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindFromPath(refarg_0, refarg_1, (int)*arg[3]), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_New_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New(), 1, &TA_taBase);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New((int)*arg[1]), 1, &TA_taBase);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->New((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taBase);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAllViews_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAllViews();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_StructUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->StructUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DataUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DataUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddDataView((taDataView*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveDataView((taDataView*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InheritsFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->InheritsFrom((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetEnumString_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraUnit_Group*)ths)->GetEnumString((const char*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetEnumVal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetEnumVal((const char*)*arg[1]));}
    if(na == 2) {
      taString refarg_1=arg[2]->GetStr();
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->GetEnumVal((const char*)*arg[1], refarg_1));    *arg[2]=(String)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Load_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0));}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Save_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SaveAs_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Edit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Edit());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CloseEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CloseEdit());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReShowEdit_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReShowEdit());}
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReShowEdit((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Close_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Close();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CopyFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CopyFrom((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CopyTo((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChildUpdateAfterEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    bool refarg_1=(bool)*arg[2];
    ((LeabraUnit_Group*)ths)->ChildUpdateAfterEdit((taBase*)(void*)*arg[1], refarg_1);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DuplicateMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->DuplicateMe());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChangeMyType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ChangeMyType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SelectForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SelectForEdit((MemberDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SelectFunForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SelectFunForEdit((MethodDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Help_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Help();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CallFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->CallFun((const char*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetAdapter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->SetAdapter((taBaseAdapter*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_addr_data_link_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraUnit_Group*)ths)->addr_data_link(), 2, &TA_taDataLink);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetTA_Element__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    TypeDef* refarg_1=(TypeDef*)*arg[2];
    rval=new cssTA((void*)((LeabraUnit_Group*)ths)->GetTA_Element_((int)*arg[1], refarg_1), 1, &TA_void);
    *arg[2]=(void*)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DataChanged_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->DataChanged((int)*arg[1]);}
    if(na == 2) {
      ((LeabraUnit_Group*)ths)->DataChanged((int)*arg[1], (void*)(void*)*arg[2]);}
    if(na == 3) {
      ((LeabraUnit_Group*)ths)->DataChanged((int)*arg[1], (void*)(void*)*arg[2], (void*)(void*)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Alloc_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Alloc((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Reset_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Reset();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_IsEmpty_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->IsEmpty());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BuildHashTable_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BuildHashTable((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Find_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Find((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Remove_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Remove((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLast_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLast());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveAll_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->RemoveAll();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Move_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Move((int)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Swap_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Swap((int)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PopAll_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->PopAll();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Permute_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Permute();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Sort_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->Sort();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->Sort((bool)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Sort__stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->Sort_();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->Sort_((bool)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UpdateAllIndicies_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->UpdateAllIndicies();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FirstEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FirstEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NextEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    taLeafItr& refarg_0=*(taLeafItr*)arg[1]->GetVoidPtrOfType(&TA_taLeafItr);
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NextEl(refarg_0), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Duplicate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Duplicate(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DupeUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DupeUniqNameNew(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DupeUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->DupeUniqNameOld(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Stealth_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Stealth_Borrow(*(taPtrList_impl*)arg[1]->GetVoidPtrOfType(&TA_taPtrList_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Borrow(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUnique(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUniqNameNew(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_BorrowUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->BorrowUniqNameOld(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Common_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Common(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Duplicate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Duplicate(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Borrow_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Borrow(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NumListCols_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->NumListCols());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_GetColHeading_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraUnit_Group*)ths)->GetColHeading((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChildGetColText_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssString(((LeabraUnit_Group*)ths)->ChildGetColText((void*)(void*)*arg[1], (TypeDef*)*arg[2], (int)*arg[3]));}
    if(na == 4) {
      rval=new cssString(((LeabraUnit_Group*)ths)->ChildGetColText((void*)(void*)*arg[1], (TypeDef*)*arg[2], (int)*arg[3], (int)*arg[4]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_List_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->List();}
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->List(refarg_0);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddEl((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Add_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Add((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->AddUnique((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->AddUniqNameNew((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Insert_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Insert((taBase*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Replace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Replace((int)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceName((const char*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DuplicateEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->DuplicateEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Link_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Link((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->LinkUnique((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->LinkUniqNameNew((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InsertLink_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->InsertLink((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->InsertLink((taBase*)(void*)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceLink((int)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLinkEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceLinkEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceLinkName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceLinkName((const char*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Push_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Push((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->MoveEl((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Transfer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Transfer((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->MoveBefore((Unit*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->MoveAfter((Unit*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Dump_Save_PathR_impl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Dump_Save_PathR_impl(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultElName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultElName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetDefaultElType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetDefaultElType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceSize_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceSize((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceType_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceType();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceSameStru_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceSameStru(*(taGroup_impl*)arg[1]->GetVoidPtrOfType(&TA_taGroup_impl));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ChangeType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ChangeType((taBase*)(void*)*arg[1], (TypeDef*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReplaceType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->ReplaceType((TypeDef*)*arg[1], (TypeDef*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetBaseType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->SetBaseType((TypeDef*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReturnFindMd_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraUnit_Group*)ths)->ReturnFindMd(), 1, &TA_MemberDef);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_InitLeafGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->InitLeafGp();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLeaf((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeafName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLeafName((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveLeafEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveLeafEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RemoveGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->RemoveGp((taGroup_impl*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EditSubGps_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->EditSubGps(), 1, &TA_TALOG);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_EnforceLeaves_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->EnforceLeaves((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindLeaf((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->FindLeafEl((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeEl((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastEl((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_DefaultEl_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->DefaultEl(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Edit_El((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SafeGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->SafeGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FastGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FastGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Leaf_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Leaf((int)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LeafGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->LeafGp((int)*arg[1]), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RootGp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->RootGp(), 1, &TA_taGroup);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FirstGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FirstGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NextGp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_0=(int)*arg[1];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NextGp(refarg_0), 1, &TA_taGroup);
    *arg[1]=(Int)refarg_0;
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NewEl_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl(), 1, &TA_Unit);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl((int)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewEl((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_Unit);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_NewGp_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp(), 1, &TA_taGroup);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp((int)*arg[1]), 1, &TA_taGroup);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->NewGp((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taGroup);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindName((const char*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindType((TypeDef*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindType((TypeDef*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Pop(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->Peek(), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->AddUniqNameOld((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->LinkUniqNameOld((Unit*)(void*)*arg[1]), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafName((const char*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafName((const char*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindLeafType_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafType((TypeDef*)*arg[1]), 1, &TA_Unit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindLeafType((TypeDef*)*arg[1], refarg_1), 1, &TA_Unit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Copy_Weights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Copy_Weights((const Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_WriteWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->WriteWeights(refarg_0);}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraUnit_Group*)ths)->WriteWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_ReadWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraUnit_Group*)ths)->ReadWeights(refarg_0);}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraUnit_Group*)ths)->ReadWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Build_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->Build());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_CheckBuild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->CheckBuild());
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LayoutUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraUnit_Group*)ths)->LayoutUnits();}
    if(na == 1) {
      ((LeabraUnit_Group*)ths)->LayoutUnits((Unit*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_RecomputeGeometry_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->RecomputeGeometry();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetUnitSpec((UnitSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_SetConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->SetConSpec((ConSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_TransformWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->TransformWeights(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_AddNoiseToWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->AddNoiseToWeights(*(Random*)arg[1]->GetVoidPtrOfType(&TA_Random));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_PruneCons_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraUnit_Group*)ths)->PruneCons(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec), (CountParam::Relation)(int)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LesionCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionCons((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_LesionUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionUnits((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraUnit_Group*)ths)->LesionUnits((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnitValuesToArray_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float_RArray& refarg_0=*(float_RArray*)arg[1]->GetVoidPtrOfType(&TA_float_RArray);
    ((LeabraUnit_Group*)ths)->UnitValuesToArray(refarg_0, (const char*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_UnitValuesFromArray_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float_RArray& refarg_0=*(float_RArray*)arg[1]->GetVoidPtrOfType(&TA_float_RArray);
    ((LeabraUnit_Group*)ths)->UnitValuesFromArray(refarg_0, (const char*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_FindUnitFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraUnit_Group*)ths)->FindUnitFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraUnit_Group_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraUnit_Group*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
LeabraLayer*		 TAI_LeabraLayer=NULL;
  static cssEl* cssElCFun_LeabraLayer_GetColText_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssString(((LeabraLayer*)ths)->GetColText((int)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraLayer*)ths)->GetColText((int)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ChildQueryEditActions_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_3=(int)*arg[4];    int refarg_4=(int)*arg[5];
    ((LeabraLayer*)ths)->ChildQueryEditActions((MemberDef*)*arg[1], (const taBase*)(void*)*arg[2], (taiMimeSource*)(void*)*arg[3], refarg_3, refarg_4);
    *arg[4]=(Int)refarg_3;    *arg[5]=(Int)refarg_4;
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ChildEditAction_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ChildEditAction((MemberDef*)*arg[1], (taBase*)(void*)*arg[2], (taiMimeSource*)(void*)*arg[3], (int)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_QueryEditActions_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    int refarg_1=(int)*arg[2];    int refarg_2=(int)*arg[3];
    ((LeabraLayer*)ths)->QueryEditActions((const taiMimeSource*)(void*)*arg[1], refarg_1, refarg_2);
    *arg[2]=(Int)refarg_1;    *arg[3]=(Int)refarg_2;
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_EditAction_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->EditAction((taiMimeSource*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetDataLink_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraLayer*)ths)->GetDataLink(), 1, &TA_taDataLink);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UnRef_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnRef();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UnRefNoDelete_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnRefNoDelete();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UnSafeCopy_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnSafeCopy((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CastCopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->CastCopyTo((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetOwner_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->GetOwner((TypeDef*)*arg[1]), 1, &TA_taBase);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath());}
    if(na == 1) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath((taBase*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssString(((LeabraLayer*)ths)->GetPath((taBase*)(void*)*arg[1], (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindFromPath_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      taString refarg_0=arg[1]->GetStr();
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(refarg_0), 1, &TA_taBase);    *arg[1]=(String)refarg_0;
}
    if(na == 2) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(refarg_0, refarg_1), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    if(na == 3) {
      taString refarg_0=arg[1]->GetStr();    MemberDef* refarg_1=(MemberDef*)*arg[2];
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindFromPath(refarg_0, refarg_1, (int)*arg[3]), 1, &TA_taBase);    *arg[1]=(String)refarg_0;    *arg[2]=(void*)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_New_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New(), 1, &TA_taBase);}
    if(na == 1) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New((int)*arg[1]), 1, &TA_taBase);}
    if(na == 2) {
      rval=new cssTA_Base((void*)((LeabraLayer*)ths)->New((int)*arg[1], (TypeDef*)*arg[2]), 1, &TA_taBase);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateAfterEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateAfterEdit();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateAllViews_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateAllViews();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_StructUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->StructUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DataUpdate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DataUpdate((bool)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_AddDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->AddDataView((taDataView*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveDataView_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->RemoveDataView((taDataView*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InheritsFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->InheritsFrom((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetEnumString_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraLayer*)ths)->GetEnumString((const char*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetEnumVal_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->GetEnumVal((const char*)*arg[1]));}
    if(na == 2) {
      taString refarg_1=arg[2]->GetStr();
    rval=new cssInt((int)((LeabraLayer*)ths)->GetEnumVal((const char*)*arg[1], refarg_1));    *arg[2]=(String)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Load_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0));}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Load(refarg_0, (taBase*)(void*)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Save_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->Save(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SaveAs_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0));}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2]));}
    if(na == 3) {
      ostream& refarg_0=*(ostream*)*arg[1];
    rval=new cssInt((int)((LeabraLayer*)ths)->SaveAs(refarg_0, (taBase*)(void*)*arg[2], (int)*arg[3]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Edit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->Edit());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CloseEdit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CloseEdit());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReShowEdit_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ReShowEdit());}
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ReShowEdit((bool)*arg[1]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Close_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Close();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CopyFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CopyFrom((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CopyTo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CopyTo((taBase*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ChildUpdateAfterEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    bool refarg_1=(bool)*arg[2];
    ((LeabraLayer*)ths)->ChildUpdateAfterEdit((taBase*)(void*)*arg[1], refarg_1);
    *arg[2]=(Int)refarg_1;
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DuplicateMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->DuplicateMe());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ChangeMyType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ChangeMyType((TypeDef*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SelectForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SelectForEdit((MemberDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SelectFunForEdit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SelectFunForEdit((MethodDef*)*arg[1], (SelectEdit*)(void*)*arg[2], (const char*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Help_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Help();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CallFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->CallFun((const char*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetAdapter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetAdapter((taBaseAdapter*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_addr_data_link_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraLayer*)ths)->addr_data_link(), 2, &TA_taDataLink);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_can_sequence__stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->can_sequence_());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_sequencer__stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraLayer*)ths)->sequencer_(), 1, &TA_ISequencable);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_source_channels__stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->source_channels_();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetData_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA((void*)((LeabraLayer*)ths)->GetData((SourceChannel*)(void*)*arg[1]), 1, &TA_taMatrix_impl);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Copy_Weights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Copy_Weights((const Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_WriteWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraLayer*)ths)->WriteWeights(refarg_0);}
    if(na == 2) {
      ostream& refarg_0=*(ostream*)*arg[1];
    ((LeabraLayer*)ths)->WriteWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReadWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraLayer*)ths)->ReadWeights(refarg_0);}
    if(na == 2) {
      istream& refarg_0=*(istream*)*arg[1];
    ((LeabraLayer*)ths)->ReadWeights(refarg_0, (Con_Group::WtSaveFormat)(int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Build_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Build();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RecomputeGeometry_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RecomputeGeometry();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LayoutUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraLayer*)ths)->LayoutUnits();}
    if(na == 1) {
      ((LeabraLayer*)ths)->LayoutUnits((Unit*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LayoutUnitGroups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->LayoutUnitGroups();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ConnectFrom_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ConnectFrom((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Connect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Connect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckBuild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CheckBuild());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CheckConnect());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveCons_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveCons();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveUnits_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveUnits();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_RemoveUnitGroups_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->RemoveUnitGroups();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PreConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->PreConnect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SyncSendPrjns_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SyncSendPrjns();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DisConnect_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DisConnect();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CountRecvCons_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CountRecvCons());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitExterns_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitExterns();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ModifyState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ModifyState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitWtDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitWtDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitWtState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitWtState();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetToLay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetToLay((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetToMe_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetToMe();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Act_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Act((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UpdateWeights();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_TransformWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->TransformWeights(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_AddNoiseToWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->AddNoiseToWeights(*(Random*)arg[1]->GetVoidPtrOfType(&TA_Random));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PruneCons_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->PruneCons(*(SimpleMathSpec*)arg[1]->GetVoidPtrOfType(&TA_SimpleMathSpec), (CountParam::Relation)(int)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ProbAddCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ProbAddCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->ProbAddCons((float)*arg[1], (float)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LesionCons_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionCons((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionCons((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_LesionUnits_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionUnits((float)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->LesionUnits((float)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetLayerSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SetLayerSpec((LayerSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetLayerSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->GetLayerSpec(), 1, &TA_LayerSpec);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SetUnitSpec((UnitSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetUnitType_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetUnitType((TypeDef*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->SetConSpec((ConSpec*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckTypes_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->CheckTypes());
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((LeabraLayer*)ths)->CheckConfig((TrialProcess*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((LeabraLayer*)ths)->CheckConfig((TrialProcess*)(void*)*arg[1], (bool)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FixPrjnIndexes_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->FixPrjnIndexes();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceUnitSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceUnitSpec((UnitSpec*)(void*)*arg[1], (UnitSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceConSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceConSpec((ConSpec*)(void*)*arg[1], (ConSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplacePrjnSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplacePrjnSpec((ProjectionSpec*)(void*)*arg[1], (ProjectionSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ReplaceLayerSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraLayer*)ths)->ReplaceLayerSpec((LayerSpec*)(void*)*arg[1], (LayerSpec*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GridViewWeights_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2]);}
    if(na == 3) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4]);}
    if(na == 5) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4], (int)*arg[5]);}
    if(na == 6) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4], (int)*arg[5], (int)*arg[6]);}
    if(na == 7) {
      ((LeabraLayer*)ths)->GridViewWeights((GridLog*)(void*)*arg[1], (Layer*)(void*)*arg[2], (bool)*arg[3], (int)*arg[4], (int)*arg[5], (int)*arg[6], (int)*arg[7]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_WeightsToEnv_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->WeightsToEnv((Environment*)(void*)*arg[1], (Layer*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetExtFlag_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetExtFlag((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_UnSetExtFlag_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->UnSetExtFlag((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_FindUnitGpFmCoord_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((LeabraLayer*)ths)->FindUnitGpFmCoord(*(TwoDCoord*)arg[1]->GetVoidPtrOfType(&TA_TwoDCoord)), 1, &TA_Unit_Group);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_GetActGeomNoSpc_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    PosTDCoord& refarg_0=*(PosTDCoord*)arg[1]->GetVoidPtrOfType(&TA_PosTDCoord);
    ((LeabraLayer*)ths)->GetActGeomNoSpc(refarg_0);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_SetVals_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_SetVals((float)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_ResetSortBuf();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_InitState((LeabraLayerSpec*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_Initialize_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_Initialize();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Inhib_Copy__stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Inhib_Copy_(*(LeabraInhib*)arg[1]->GetVoidPtrOfType(&TA_LeabraInhib));
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_InitInhib_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->InitInhib();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_SetCurLrate_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->SetCurLrate((LeabraTrial*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Active_K_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Active_K();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_HardClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_HardClamp((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_NetScale_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_NetScale((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_ClampNet((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Send_NetDelta_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Send_NetDelta();
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Clamp_NetAvg((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_Inhib((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_InhibAvg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_InhibAvg((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PhaseInit_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->PhaseInit((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayEvent_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayEvent((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayPhase((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_DecayPhase2_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->DecayPhase2((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ExtToComp((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_TargExtToComp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->TargExtToComp((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_PostSettle_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraLayer*)ths)->PostSettle((LeabraTrial*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraLayer*)ths)->PostSettle((LeabraTrial*)(void*)*arg[1], (bool)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_Compute_WtFmLin_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->Compute_WtFmLin((LeabraTrial*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraLayer_ResetSortBuf_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraLayer*)ths)->ResetSortBuf();
    return rval;}
LeabraCycle*		 TAI_LeabraCycle=NULL;
  static cssEl* cssElCFun_LeabraCycle_Compute_Net_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Net();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_Clamp_NetAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Clamp_NetAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_Inhib_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Inhib();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_InhibAvg_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_InhibAvg();
    return rval;}
  static cssEl* cssElCFun_LeabraCycle_Compute_Act_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraCycle*)ths)->Compute_Act();
    return rval;}
LeabraSettle*		 TAI_LeabraSettle=NULL;
  static cssEl* cssElCFun_LeabraSettle_Compute_Active_K_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_Active_K();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_DecayEvent_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->DecayEvent();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_DecayPhase_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->DecayPhase();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_DecayPhase2_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->DecayPhase2();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_PhaseInit_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->PhaseInit();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_ExtToComp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->ExtToComp();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_TargExtToComp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->TargExtToComp();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_HardClamp_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_HardClamp();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_NetScale_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_NetScale();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Send_ClampNet_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Send_ClampNet();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_PostSettle_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->PostSettle();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_PostSettle_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->PostSettle_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_dWt_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_dWt_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraSettle_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSettle*)ths)->UpdateWeights();
    return rval;}
LeabraTrial*		 TAI_LeabraTrial=NULL;
  static cssEl* cssElCFun_LeabraTrial_GenCntrLog_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->GenCntrLog((LogData*)(void*)*arg[1], (bool)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_InitState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->InitState();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_SetCurLrate_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->SetCurLrate();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_DecayState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->DecayState();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_EncodeState_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->EncodeState();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_Compute_dWt_NStdLay_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->Compute_dWt_NStdLay();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_Compute_dWt_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->Compute_dWt();
    return rval;}
  static cssEl* cssElCFun_LeabraTrial_UpdateWeights_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraTrial*)ths)->UpdateWeights();
    return rval;}
LeabraMaxDa*		 TAI_LeabraMaxDa=NULL;
  static cssEl* cssElCFun_LeabraMaxDa_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaxDa*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraMaxDa_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaxDa*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraMaxDa_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraMaxDa*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
WtScaleSpec*		 TAI_WtScaleSpec=NULL;
  static cssEl* cssElCFun_WtScaleSpec_NetScale_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtScaleSpec*)ths)->NetScale());
    return rval;}
WtSigSpec*		 TAI_WtSigSpec=NULL;
  static cssEl* cssElCFun_WtSigSpec_SigFun_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtSigSpec*)ths)->SigFun((float)*arg[1], (float)*arg[2], (float)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_WtSigSpec_SigFunInv_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((WtSigSpec*)ths)->SigFunInv((float)*arg[1], (float)*arg[2], (float)*arg[3]));
    return rval;}
LearnMixSpec*		 TAI_LearnMixSpec=NULL;
SAvgCorSpec*		 TAI_SAvgCorSpec=NULL;
ActFunSpec*		 TAI_ActFunSpec=NULL;
SpikeFunSpec*		 TAI_SpikeFunSpec=NULL;
DepressSpec*		 TAI_DepressSpec=NULL;
OptThreshSpec*		 TAI_OptThreshSpec=NULL;
DtSpec*		 TAI_DtSpec=NULL;
LeabraChannels*		 TAI_LeabraChannels=NULL;
VChanSpec*		 TAI_VChanSpec=NULL;
  static cssEl* cssElCFun_VChanSpec_UpdateBasis_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float refarg_0=(float)*arg[1];    bool refarg_1=(bool)*arg[2];    float refarg_2=(float)*arg[3];
    ((VChanSpec*)ths)->UpdateBasis(refarg_0, refarg_1, refarg_2, (float)*arg[4]);
    *arg[1]=(Real)refarg_0;    *arg[2]=(Int)refarg_1;    *arg[3]=(Real)refarg_2;
    return rval;}
ActRegSpec*		 TAI_ActRegSpec=NULL;
VChanBasis*		 TAI_VChanBasis=NULL;
LeabraUnitChans*		 TAI_LeabraUnitChans=NULL;
taPtrList<LeabraUnit>*		 TAI_taPtrList_LeabraUnit_=NULL;
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Find_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Find((const char*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Remove_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Remove((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__SafeEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->SafeEl((int)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FastEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FastEl((int)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Edit_El_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Edit_El((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FindName_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FindName((const char*)*arg[1]), 1, &TA_LeabraUnit);}
    if(na == 2) {
      int refarg_1=(int)*arg[2];
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->FindName((const char*)*arg[1], refarg_1), 1, &TA_LeabraUnit);    *arg[2]=(Int)refarg_1;
}
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Pop_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Pop(), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Peek_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->Peek(), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->AddUniqNameOld((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUniqNameOld_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((taPtrList<LeabraUnit>*)ths)->LinkUniqNameOld((LeabraUnit*)(void*)*arg[1]), 1, &TA_LeabraUnit);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__FindEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->FindEl((const LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->AddEl((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Add_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Add((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->AddUnique((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__AddUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->AddUniqNameNew((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Insert_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Insert((LeabraUnit*)(void*)*arg[1], (int)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Replace_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Replace((int)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceName((const char*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__RemoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->RemoveEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__DuplicateEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->DuplicateEl((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Link_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Link((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUnique_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->LinkUnique((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__LinkUniqNameNew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->LinkUniqNameNew((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__InsertLink_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->InsertLink((LeabraUnit*)(void*)*arg[1]));}
    if(na == 2) {
      rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->InsertLink((LeabraUnit*)(void*)*arg[1], (int)*arg[2]));}
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceLink((int)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLinkEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceLinkEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__ReplaceLinkName_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->ReplaceLinkName((const char*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Push_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((taPtrList<LeabraUnit>*)ths)->Push((LeabraUnit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveEl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->MoveEl((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__Transfer_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->Transfer((LeabraUnit*)(void*)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveBefore_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->MoveBefore((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_taPtrList_LeabraUnit__MoveAfter_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((taPtrList<LeabraUnit>*)ths)->MoveAfter((LeabraUnit*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]));
    return rval;}
LeabraSort*		 TAI_LeabraSort=NULL;
  static cssEl* cssElCFun_LeabraSort_FindNewNetPos_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((LeabraSort*)ths)->FindNewNetPos((float)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_LeabraSort_FastInsertLink_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSort*)ths)->FastInsertLink((void*)(void*)*arg[1], (int)*arg[2]);
    return rval;}
KWTASpec*		 TAI_KWTASpec=NULL;
AdaptISpec*		 TAI_AdaptISpec=NULL;
ClampSpec*		 TAI_ClampSpec=NULL;
DecaySpec*		 TAI_DecaySpec=NULL;
SpecPtr<LeabraLayerSpec>*		 TAI_SpecPtr_LeabraLayerSpec_=NULL;
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__SetDefaultSpec_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SpecPtr<LeabraLayerSpec>*)ths)->SetDefaultSpec((taBase*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__CheckSpec_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((SpecPtr<LeabraLayerSpec>*)ths)->CheckSpec());
    return rval;}
  static cssEl* cssElCFun_SpecPtr_LeabraLayerSpec__NewChild_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssTA_Base((void*)((SpecPtr<LeabraLayerSpec>*)ths)->NewChild(), 1, &TA_LeabraLayerSpec);
    return rval;}
LeabraLayerSpec_SPtr*		 TAI_LeabraLayerSpec_SPtr=NULL;
AvgMaxVals*		 TAI_AvgMaxVals=NULL;
KWTAVals*		 TAI_KWTAVals=NULL;
  static cssEl* cssElCFun_KWTAVals_Compute_Pct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((KWTAVals*)ths)->Compute_Pct((int)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_KWTAVals_Compute_IThrR_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((KWTAVals*)ths)->Compute_IThrR();
    return rval;}
AdaptIVals*		 TAI_AdaptIVals=NULL;
InhibVals*		 TAI_InhibVals=NULL;
LeabraSE_Stat*		 TAI_LeabraSE_Stat=NULL;
  static cssEl* cssElCFun_LeabraSE_Stat_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSE_Stat*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
LeabraGoodStat*		 TAI_LeabraGoodStat=NULL;
  static cssEl* cssElCFun_LeabraGoodStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGoodStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraGoodStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGoodStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraGoodStat_Unit_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraGoodStat*)ths)->Unit_Stat((Unit*)(void*)*arg[1]);
    return rval;}
LeabraSharpStat*		 TAI_LeabraSharpStat=NULL;
  static cssEl* cssElCFun_LeabraSharpStat_Unit_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->Unit_Run((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraSharpStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraSharpStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraSharpStat_Layer_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraSharpStat*)ths)->Layer_Stat((Layer*)(void*)*arg[1]);
    return rval;}
WrongOnStat*		 TAI_WrongOnStat=NULL;
  static cssEl* cssElCFun_WrongOnStat_Unit_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((WrongOnStat*)ths)->Unit_Run((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_WrongOnStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((WrongOnStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_WrongOnStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((WrongOnStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
LeabraPrjnRelNetinStat*		 TAI_LeabraPrjnRelNetinStat=NULL;
  static cssEl* cssElCFun_LeabraPrjnRelNetinStat_Unit_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraPrjnRelNetinStat*)ths)->Unit_Run((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraPrjnRelNetinStat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraPrjnRelNetinStat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraPrjnRelNetinStat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraPrjnRelNetinStat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraPrjnRelNetinStat_Layer_Stat_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraPrjnRelNetinStat*)ths)->Layer_Stat((Layer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraPrjnRelNetinStat_GetPrjnNm_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssString(((LeabraPrjnRelNetinStat*)ths)->GetPrjnNm((const char*)*arg[1]));
    return rval;}
CtxtUpdateSpec*		 TAI_CtxtUpdateSpec=NULL;
LeabraContextLayerSpec*		 TAI_LeabraContextLayerSpec=NULL;
  static cssEl* cssElCFun_LeabraContextLayerSpec_Compute_Context_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraContextLayerSpec*)ths)->Compute_Context((LeabraLayer*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
PhaseOrderEventSpec*		 TAI_PhaseOrderEventSpec=NULL;
LeabraLinUnitSpec*		 TAI_LeabraLinUnitSpec=NULL;
LeabraNegBiasSpec*		 TAI_LeabraNegBiasSpec=NULL;
TrialSynDepCon*		 TAI_TrialSynDepCon=NULL;
SynDepSpec*		 TAI_SynDepSpec=NULL;
TrialSynDepConSpec*		 TAI_TrialSynDepConSpec=NULL;
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TrialSynDepConSpec*)ths)->C_Compute_Net((TrialSynDepCon*)(void*)*arg[1], (Unit*)(void*)*arg[2], (Unit*)(void*)*arg[3]));
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TrialSynDepConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_Net((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_Inhib_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_Inhib((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_NetDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_NetDelta((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_InhibDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_InhibDelta((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Send_ClampNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Send_ClampNet((LeabraCon_Group*)(void*)*arg[1], (TrialSynDepCon*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Depress_Wt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Depress_Wt((TrialSynDepCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Depress_Wt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Depress_Wt((LeabraCon_Group*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_C_Reset_EffWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->C_Reset_EffWt((TrialSynDepCon*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TrialSynDepConSpec_Reset_EffWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TrialSynDepConSpec*)ths)->Reset_EffWt((LeabraCon_Group*)(void*)*arg[1]);
    return rval;}
FastWtCon*		 TAI_FastWtCon=NULL;
FastWtSpec*		 TAI_FastWtSpec=NULL;
FastWtConSpec*		 TAI_FastWtConSpec=NULL;
  static cssEl* cssElCFun_FastWtConSpec_C_InitWtDelta_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_InitWtDelta((Con_Group*)(void*)*arg[1], (Connection*)(void*)*arg[2], (Unit*)(void*)*arg[3], (Unit*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_dWt((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_UpdateWeights((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_UpdateWeightsActReg_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_UpdateWeightsActReg((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3], (LeabraUnit*)(void*)*arg[4], (LeabraUnitSpec*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowHebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FastWtConSpec*)ths)->C_Compute_SlowHebb((FastWtCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowErr_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((FastWtConSpec*)ths)->C_Compute_SlowErr((FastWtCon*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (float)*arg[4], (float)*arg[5]));
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_SlowdWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_SlowdWt((FastWtCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_FastWtConSpec_C_Compute_FastDecay_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((FastWtConSpec*)ths)->C_Compute_FastDecay((FastWtCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]);
    return rval;}
ScalarValSpec*		 TAI_ScalarValSpec=NULL;
  static cssEl* cssElCFun_ScalarValSpec_InitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSpec*)ths)->InitVal((float)*arg[1], (int)*arg[2], (float)*arg[3], (float)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSpec_GetUnitAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValSpec*)ths)->GetUnitAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_ScalarValSpec_GetUnitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValSpec*)ths)->GetUnitVal((int)*arg[1]));
    return rval;}
ScalarValBias*		 TAI_ScalarValBias=NULL;
ScalarValLayerSpec*		 TAI_ScalarValLayerSpec=NULL;
  static cssEl* cssElCFun_ScalarValLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ClampValue_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((ScalarValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);}
    if(na == 3) {
      ((ScalarValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ClampAvgAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValLayerSpec*)ths)->ClampAvgAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ReadValue_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ScalarValLayerSpec*)ths)->ReadValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ResetAfterClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->ResetAfterClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_HardClampExt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->HardClampExt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnits_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnits_impl((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnits_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnits((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_LabelUnitsNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->LabelUnitsNet((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_WtBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_WtBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_NegSlp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_NegSlp((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_UnBias_PosSlp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_UnBias_PosSlp((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_BiasVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_BiasVal((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_Compute_dWtUgp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValLayerSpec*)ths)->Compute_dWtUgp((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_ScalarValLayerSpec_ReConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((ScalarValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((ScalarValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
ScalarValSelfPrjnSpec*		 TAI_ScalarValSelfPrjnSpec=NULL;
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_Connect_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->Connect_impl((Projection*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_C_InitWtState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->C_InitWtState((Projection*)(void*)*arg[1], (Con_Group*)(void*)*arg[2], (Unit*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_ScalarValSelfPrjnSpec_Connect_UnitGroup_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ScalarValSelfPrjnSpec*)ths)->Connect_UnitGroup((Unit_Group*)(void*)*arg[1], (Projection*)(void*)*arg[2]);
    return rval;}
TwoDValSpec*		 TAI_TwoDValSpec=NULL;
  static cssEl* cssElCFun_TwoDValSpec_InitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValSpec*)ths)->InitVal((float)*arg[1], (float)*arg[2], (int)*arg[3], (int)*arg[4], (float)*arg[5], (float)*arg[6], (float)*arg[7], (float)*arg[8]);
    return rval;}
  static cssEl* cssElCFun_TwoDValSpec_GetUnitAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TwoDValSpec*)ths)->GetUnitAct((int)*arg[1]));
    return rval;}
  static cssEl* cssElCFun_TwoDValSpec_GetUnitVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    float refarg_1=(float)*arg[2];    float refarg_2=(float)*arg[3];
    ((TwoDValSpec*)ths)->GetUnitVal((int)*arg[1], refarg_1, refarg_2);
    *arg[2]=(Real)refarg_1;    *arg[3]=(Real)refarg_2;
    return rval;}
TwoDValBias*		 TAI_TwoDValBias=NULL;
TwoDValLayerSpec*		 TAI_TwoDValLayerSpec=NULL;
  static cssEl* cssElCFun_TwoDValLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ClampValue_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((TwoDValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);}
    if(na == 3) {
      ((TwoDValLayerSpec*)ths)->ClampValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], (float)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ReadValue_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->ReadValue((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ResetAfterClamp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->ResetAfterClamp((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_HardClampExt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->HardClampExt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_LabelUnits_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->LabelUnits_impl((Unit_Group*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_LabelUnits_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->LabelUnits((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_LabelUnitsNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->LabelUnitsNet((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_WtBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_WtBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_UnBias_Val_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_UnBias_Val((Unit_Group*)(void*)*arg[1], (float)*arg[2], (float)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_BiasVal_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_BiasVal((LeabraLayer*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_Compute_dWtUgp_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TwoDValLayerSpec*)ths)->Compute_dWtUgp((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_TwoDValLayerSpec_ReConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((TwoDValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((TwoDValLayerSpec*)ths)->ReConfig((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
MarkerConSpec*		 TAI_MarkerConSpec=NULL;
  static cssEl* cssElCFun_MarkerConSpec_Compute_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MarkerConSpec*)ths)->Compute_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Send_Net_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Send_Net((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MarkerConSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MarkerConSpec*)ths)->UpdateWeights((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
DaModUnit*		 TAI_DaModUnit=NULL;
DaModSpec*		 TAI_DaModSpec=NULL;
DaModUnitSpec*		 TAI_DaModUnitSpec=NULL;
  static cssEl* cssElCFun_DaModUnitSpec_InitState_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->InitState((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->Compute_dWt((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_UpdateWeights_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((DaModUnitSpec*)ths)->UpdateWeights((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_DaModUnitSpec_CheckConfig_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 3) {
      rval=new cssInt((int)((DaModUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3]));}
    if(na == 4) {
      rval=new cssInt((int)((DaModUnitSpec*)ths)->CheckConfig((Unit*)(void*)*arg[1], (Layer*)(void*)*arg[2], (TrialProcess*)(void*)*arg[3], (bool)*arg[4]));}
    return rval;}
AvgExtRewSpec*		 TAI_AvgExtRewSpec=NULL;
OutErrSpec*		 TAI_OutErrSpec=NULL;
ExtRewSpec*		 TAI_ExtRewSpec=NULL;
ExtRewLayerSpec*		 TAI_ExtRewLayerSpec=NULL;
  static cssEl* cssElCFun_ExtRewLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_OutErrRewAvail_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssInt((int)((ExtRewLayerSpec*)ths)->OutErrRewAvail((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_GetOutErrRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((ExtRewLayerSpec*)ths)->GetOutErrRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]));
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_OutErrRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_OutErrRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_ExtRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_ExtRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_DaRew_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_DaRew((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_UnitDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_UnitDa((float)*arg[1], (DaModUnit*)(void*)*arg[2], (Unit_Group*)(void*)*arg[3], (LeabraLayer*)(void*)*arg[4], (LeabraTrial*)(void*)*arg[5]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_ExtRewLayerSpec_Compute_NoRewAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRewLayerSpec*)ths)->Compute_NoRewAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
ExtRew_Stat*		 TAI_ExtRew_Stat=NULL;
  static cssEl* cssElCFun_ExtRew_Stat_RecvCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRew_Stat*)ths)->RecvCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_ExtRew_Stat_SendCon_Run_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((ExtRew_Stat*)ths)->SendCon_Run((Unit*)(void*)*arg[1]);
    return rval;}
TDRewPredConSpec*		 TAI_TDRewPredConSpec=NULL;
  static cssEl* cssElCFun_TDRewPredConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((TDRewPredConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (DaModUnit*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3]));
    return rval;}
TDRewPredLayerSpec*		 TAI_TDRewPredLayerSpec=NULL;
  static cssEl* cssElCFun_TDRewPredLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_SavePred_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_SavePred((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ClampPred_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ClampPred((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ClampPrev_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ClampPrev((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_TdPlusPhase_impl((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewPredLayerSpec*)ths)->Compute_TdPlusPhase((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
TDRewIntegSpec*		 TAI_TDRewIntegSpec=NULL;
TDRewIntegLayerSpec*		 TAI_TDRewIntegLayerSpec=NULL;
  static cssEl* cssElCFun_TDRewIntegLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TDRewIntegLayerSpec*)ths)->HelpConfig();
    return rval;}
TdLayerSpec*		 TAI_TdLayerSpec=NULL;
  static cssEl* cssElCFun_TdLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Compute_Td_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Compute_Td((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_TdLayerSpec_Send_Td_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((TdLayerSpec*)ths)->Send_Td((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PVConSpec*		 TAI_PVConSpec=NULL;
  static cssEl* cssElCFun_PVConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((PVConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]));
    return rval;}
PVDetectSpec*		 TAI_PVDetectSpec=NULL;
PViLayerSpec*		 TAI_PViLayerSpec=NULL;
  static cssEl* cssElCFun_PViLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_PVe_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    bool refarg_2=(bool)*arg[3];    bool refarg_3=(bool)*arg[4];
    rval=new cssReal((double)((PViLayerSpec*)ths)->Compute_PVe((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2], refarg_2, refarg_3));
    *arg[3]=(Int)refarg_2;    *arg[4]=(Int)refarg_3;
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PViLayerSpec_Compute_PVPlusPhaseDwt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PViLayerSpec*)ths)->Compute_PVPlusPhaseDwt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
LVConSpec*		 TAI_LVConSpec=NULL;
  static cssEl* cssElCFun_LVConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((LVConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (LeabraUnit*)(void*)*arg[2], (LeabraUnit*)(void*)*arg[3]));
    return rval;}
LVSpec*		 TAI_LVSpec=NULL;
LVeLayerSpec*		 TAI_LVeLayerSpec=NULL;
  static cssEl* cssElCFun_LVeLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_ExtToPlus_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_ExtToPlus((Unit_Group*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_DepressWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_DepressWt((Unit_Group*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_LVeLayerSpec_Compute_LVPlusPhaseDwt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LVeLayerSpec*)ths)->Compute_LVPlusPhaseDwt((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
LViLayerSpec*		 TAI_LViLayerSpec=NULL;
PVLVDaSpec*		 TAI_PVLVDaSpec=NULL;
PVLVDaLayerSpec*		 TAI_PVLVDaLayerSpec=NULL;
  static cssEl* cssElCFun_PVLVDaLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_ZeroAct_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_ZeroAct((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Compute_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Compute_Da((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PVLVDaLayerSpec_Send_Da_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PVLVDaLayerSpec*)ths)->Send_Da((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PatchLayerSpec*		 TAI_PatchLayerSpec=NULL;
SNcMiscSpec*		 TAI_SNcMiscSpec=NULL;
SNcLayerSpec*		 TAI_SNcLayerSpec=NULL;
  static cssEl* cssElCFun_SNcLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNcLayerSpec*)ths)->HelpConfig();
    return rval;}
MatrixConSpec*		 TAI_MatrixConSpec=NULL;
  static cssEl* cssElCFun_MatrixConSpec_Compute_dWt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixConSpec*)ths)->Compute_dWt((Con_Group*)(void*)*arg[1], (Unit*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixConSpec_C_Compute_Hebb_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MatrixConSpec*)ths)->C_Compute_Hebb((LeabraCon*)(void*)*arg[1], (LeabraCon_Group*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3], (DaModUnit*)(void*)*arg[4]));
    return rval;}
  static cssEl* cssElCFun_MatrixConSpec_C_Compute_Err_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    rval=new cssReal((double)((MatrixConSpec*)ths)->C_Compute_Err((LeabraCon*)(void*)*arg[1], (DaModUnit*)(void*)*arg[2], (DaModUnit*)(void*)*arg[3]));
    return rval;}
MatrixBiasSpec*		 TAI_MatrixBiasSpec=NULL;
MatrixUnitSpec*		 TAI_MatrixUnitSpec=NULL;
ContrastSpec*		 TAI_ContrastSpec=NULL;
MatrixRndGoSpec*		 TAI_MatrixRndGoSpec=NULL;
MatrixRndGoThrSpec*		 TAI_MatrixRndGoThrSpec=NULL;
MatrixMiscSpec*		 TAI_MatrixMiscSpec=NULL;
MatrixLayerSpec*		 TAI_MatrixLayerSpec=NULL;
  static cssEl* cssElCFun_MatrixLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_RndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_RndGo((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_ClearRndGo_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_ClearRndGo((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaModUnit_NoContrast_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaModUnit_NoContrast((DaModUnit*)(void*)*arg[1], (float)*arg[2], (int)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaModUnit_Contrast_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaModUnit_Contrast((DaModUnit*)(void*)*arg[1], (float)*arg[2], (float)*arg[3], (int)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaTonicMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaTonicMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaPerfMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaPerfMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_DaLearnMod_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_DaLearnMod((LeabraLayer*)(void*)*arg[1], (LeabraUnit_Group*)(void*)*arg[2], (LeabraInhib*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_MatrixLayerSpec_Compute_AvgGoDa_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((MatrixLayerSpec*)ths)->Compute_AvgGoDa((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
SNrThalLayerSpec*		 TAI_SNrThalLayerSpec=NULL;
  static cssEl* cssElCFun_SNrThalLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_SNrThalLayerSpec_Compute_GoNogoNet_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((SNrThalLayerSpec*)ths)->Compute_GoNogoNet((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
PFCGateSpec*		 TAI_PFCGateSpec=NULL;
PFCLayerSpec*		 TAI_PFCLayerSpec=NULL;
  static cssEl* cssElCFun_PFCLayerSpec_HelpConfig_stub(void* ths,int, cssEl**) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->HelpConfig();
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_ResetSynDep_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->ResetSynDep((LeabraUnit*)(void*)*arg[1], (LeabraLayer*)(void*)*arg[2], (LeabraTrial*)(void*)*arg[3]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_MaintUpdt_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_MaintUpdt((LeabraUnit_Group*)(void*)*arg[1], (PFCLayerSpec::MaintUpdtAct)(int)*arg[2], (LeabraLayer*)(void*)*arg[3], (LeabraTrial*)(void*)*arg[4]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_SendGateStates_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->SendGateStates((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_TmpClear_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_TmpClear((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_GatingTrans_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_GatingTrans((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
  static cssEl* cssElCFun_PFCLayerSpec_Compute_GatingGOGO_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((PFCLayerSpec*)ths)->Compute_GatingGOGO((LeabraLayer*)(void*)*arg[1], (LeabraTrial*)(void*)*arg[2]);
    return rval;}
LeabraWiz*		 TAI_LeabraWiz=NULL;
  static cssEl* cssElCFun_LeabraWiz_StdNetwork_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 0) {
      ((LeabraWiz*)ths)->StdNetwork();}
    if(na == 1) {
      ((LeabraWiz*)ths)->StdNetwork((Network*)(void*)*arg[1]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_StdLayerSpecs_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWiz*)ths)->StdLayerSpecs((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_SRNContext_stub(void* ths,int, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    ((LeabraWiz*)ths)->SRNContext((Network*)(void*)*arg[1]);
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_UnitInhib_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->UnitInhib((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->UnitInhib((Network*)(void*)*arg[1], (int)*arg[2]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_TD_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->TD((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->TD((Network*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->TD((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_PVLV_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4]);}
    if(na == 5) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5]);}
    if(na == 6) {
      ((LeabraWiz*)ths)->PVLV((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (bool)*arg[4], (bool)*arg[5], (bool)*arg[6]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_BgPFC_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 1) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1]);}
    if(na == 2) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3]);}
    if(na == 4) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4]);}
    if(na == 5) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5]);}
    if(na == 6) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5], (bool)*arg[6]);}
    if(na == 7) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7]);}
    if(na == 8) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7], (bool)*arg[8]);}
    if(na == 9) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7], (bool)*arg[8], (bool)*arg[9]);}
    if(na == 10) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7], (bool)*arg[8], (bool)*arg[9], (bool)*arg[10]);}
    if(na == 11) {
      ((LeabraWiz*)ths)->BgPFC((Network*)(void*)*arg[1], (bool)*arg[2], (bool)*arg[3], (int)*arg[4], (bool)*arg[5], (bool)*arg[6], (bool)*arg[7], (bool)*arg[8], (bool)*arg[9], (bool)*arg[10], (bool)*arg[11]);}
    return rval;}
  static cssEl* cssElCFun_LeabraWiz_SetPFCStripes_stub(void* ths,int na, cssEl** arg) {
    cssEl* rval=&cssMisc::Void;
    if(na == 2) {
      ((LeabraWiz*)ths)->SetPFCStripes((Network*)(void*)*arg[1], (int)*arg[2]);}
    if(na == 3) {
      ((LeabraWiz*)ths)->SetPFCStripes((Network*)(void*)*arg[1], (int)*arg[2], (int)*arg[3]);}
    return rval;}

// Type Data

static int LeabraCon::* TA_LeabraCon_MbrOff;
static MemberDef_data TA_LeabraCon_MemberDef[]={
  {&TA_float,NULL,"dwt"," resulting net weight change","NO_VIEW NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_MbrOff=(int LeabraCon::*)(&LeabraCon::dwt))),0,NULL,0},
  {&TA_float,NULL,"pdw"," previous delta-weight change","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_MbrOff=(int LeabraCon::*)(&LeabraCon::pdw))),0,NULL,0},
  NULL};
static EnumDef_data TA_LeabraConSpec_LRSValue[]={
  {"NO_LRS"," don't use a learning rate schedule","",0},
  {"EPOCH"," current epoch counter","",1},
  {"SE_STAT"," LeabraSE_Stat value at epoch-level (in process above epoch)","",2},
  {"EXT_REW_STAT"," ExtRew_Stat value at epoch-level (in process above epoch): value is * 100 (0..100) ","",3},
  {"EXT_REW_AVG"," uses average reward computed by ExtRew layer (if present): value is units[0].act_avg (avg_rew) * 100 (0..100) ","",4},
  NULL};
static int LeabraConSpec::* TA_LeabraConSpec_MbrOff;
static MemberDef_data TA_LeabraConSpec_MemberDef[]={
  {&TA_bool,NULL,"inhib"," makes the connection inhibitory (to g_i instead of net)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::inhib))),0,NULL,0},
  {&TA_WtScaleSpec,NULL,"wt_scale"," scale weight values, both relative and absolute factors","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_scale))),0,NULL,0},
  {&TA_WtSigSpec,NULL,"wt_sig"," sigmoidal weight function for contrast enhancement: high gain makes weights more binary & discriminative","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig))),0,NULL,0},
  {&TA_float,NULL,"lrate"," learning rate -- how fast do the weights change per experience","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrate))),0,NULL,0},
  {&TA_float,NULL,"cur_lrate"," current actual learning rate = lrate * lrate_sched current value (* 1 if no lrate_sched)","READ_ONLY NO_INHERIT SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::cur_lrate))),0,NULL,0},
  {NULL,"::LRSValue","lrs_value"," what value to drive the learning rate schedule with (Important: affects values entered in start_ctr fields of schedule!)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrs_value))),0,NULL,0},
  {&TA_Schedule,NULL,"lrate_sched"," schedule of learning rate over training epochs (multiplies lrate!)","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lrate_sched))),0,NULL,0},
  {&TA_LearnMixSpec,NULL,"lmix"," mixture of hebbian & err-driven learning","","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::lmix))),0,NULL,0},
  {&TA_SAvgCorSpec,NULL,"savg_cor"," for Hebbian and netinput computation: correction for sending average act levels (i.e., renormalization); also norm_con_n for normalizing netinput computation","AKA_fix_savg ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::savg_cor))),0,NULL,0},
  {&TA_FunLookup,NULL,"wt_sig_fun"," computes wt sigmoidal fun","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun))),0,NULL,0},
  {&TA_FunLookup,NULL,"wt_sig_fun_inv"," computes inverse of wt sigmoidal fun","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_inv))),0,NULL,0},
  {&TA_WtSigSpec,NULL,"wt_sig_fun_lst"," last values of wt sig parameters for which the wt_sig_fun's were computed; prevents excessive updating","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_lst))),0,NULL,0},
  {&TA_float,NULL,"wt_sig_fun_res"," last values of resolution parameters for which the wt_sig_fun's were computed","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraConSpec_MbrOff=(int LeabraConSpec::*)(&LeabraConSpec::wt_sig_fun_res))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtState_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Net_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"gp",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_LinFmWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"na",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_LinFmWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"gp",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_InitWtState_Post_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Connection_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_delta_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_delta_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_float,NULL,"su_act_eff",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_Compute_SAvgCor_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"na",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"su_act_m",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_B_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_Compute_ActReg_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_C_UpdateWeightsActReg_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_B_UpdateWeights_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraConSpec_GraphWtSigFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  NULL};
static MethodDef_data TA_LeabraConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtState","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtState_stub,TA_LeabraConSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtDelta_stub,TA_LeabraConSpec_C_InitWtDelta_MethArgs},
  {&TA_float,NULL,"C_Compute_Net","","","",
    1,3,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Net_stub,TA_LeabraConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_Net_stub,TA_LeabraConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_Net_stub,TA_LeabraConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_Net_stub,TA_LeabraConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    1,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_dWt_stub,TA_LeabraConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_dWt_stub,TA_LeabraConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights"," update weights, if activation regulation is NOT in effect","","",
    1,5,-1,0,NULL,cssElCFun_LeabraConSpec_C_UpdateWeights_stub,TA_LeabraConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_LeabraConSpec_UpdateWeights_stub,TA_LeabraConSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"C_Compute_WtFmLin"," weight is negative if it is in its linear form, only perform if negative","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_WtFmLin_stub,TA_LeabraConSpec_C_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," compute actual weight value from linear weight value","","",
    0,1,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_WtFmLin_stub,TA_LeabraConSpec_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"C_Compute_LinFmWt"," weight is negative if it is in its linear form, only perform if positive","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_LinFmWt_stub,TA_LeabraConSpec_C_Compute_LinFmWt_MethArgs},
  {&TA_void,NULL,"Compute_LinFmWt"," compute linear weight value from actual weight value","","",
    0,1,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_LinFmWt_stub,TA_LeabraConSpec_Compute_LinFmWt_MethArgs},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_InitWtState_Post_stub,TA_LeabraConSpec_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"C_Send_Inhib","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_Inhib_stub,TA_LeabraConSpec_C_Send_Inhib_MethArgs},
  {&TA_void,NULL,"Send_Inhib"," sender-based inhibitiory net input computation","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_Inhib_stub,TA_LeabraConSpec_Send_Inhib_MethArgs},
  {&TA_void,NULL,"C_Send_NetDelta","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_NetDelta_stub,TA_LeabraConSpec_C_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," sender-based delta net input computation (send_delta mode only)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_NetDelta_stub,TA_LeabraConSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"C_Send_InhibDelta","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_InhibDelta_stub,TA_LeabraConSpec_C_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"Send_InhibDelta"," sender-based delta inhibitiory net input computation (send_delta mode only)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_InhibDelta_stub,TA_LeabraConSpec_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"C_Send_ClampNet","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Send_ClampNet_stub,TA_LeabraConSpec_C_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," sender-based net input computation for clamp net","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Send_ClampNet_stub,TA_LeabraConSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Compute_SAvgCor"," compute hebb correction scaling term for sending average act (cg->savg_cor) based on layer target activity percent","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_Compute_SAvgCor_stub,TA_LeabraConSpec_Compute_SAvgCor_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," compute Hebbian associative learning","","",
    0,4,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Hebb_stub,TA_LeabraConSpec_C_Compute_Hebb_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    0,5,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_Err_stub,TA_LeabraConSpec_C_Compute_Err_MethArgs},
  {&TA_void,NULL,"B_Compute_dWt"," compute bias weight change for netin model of bias weight","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_B_Compute_dWt_stub,TA_LeabraConSpec_B_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_Compute_ActReg"," compute dwt for activation regulation","","",
    0,5,-1,0,NULL,cssElCFun_LeabraConSpec_C_Compute_ActReg_stub,TA_LeabraConSpec_C_Compute_ActReg_MethArgs},
  {&TA_void,NULL,"C_UpdateWeightsActReg"," update weights, if activation regulation is in effect","","",
    0,5,-1,0,NULL,cssElCFun_LeabraConSpec_C_UpdateWeightsActReg_stub,TA_LeabraConSpec_C_UpdateWeightsActReg_MethArgs},
  {&TA_void,NULL,"B_UpdateWeights","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraConSpec_B_UpdateWeights_stub,TA_LeabraConSpec_B_UpdateWeights_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on schedule given epoch (or error value)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraConSpec_SetCurLrate_stub,TA_LeabraConSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"CreateWtSigFun"," create the wt_sig_fun and wt_sig_fun_inv","","",
    0,0,-1,0,NULL,cssElCFun_LeabraConSpec_CreateWtSigFun_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraConSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"GraphWtSigFun"," graph the sigmoidal weight contrast enhancement function (NULL = new graph log)","BUTTON NULL_OK ","",
    0,1,-1,0,NULL,cssElCFun_LeabraConSpec_GraphWtSigFun_stub,TA_LeabraConSpec_GraphWtSigFun_MethArgs},
  NULL};
static int LeabraBiasSpec::* TA_LeabraBiasSpec_MbrOff;
static MemberDef_data TA_LeabraBiasSpec_MemberDef[]={
  {&TA_float,NULL,"dwt_thresh"," don't change if dwt < thresh, prevents buildup of small changes","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_LeabraBiasSpec_MbrOff=(int LeabraBiasSpec::*)(&LeabraBiasSpec::dwt_thresh))),0,NULL,0},
  NULL};
static int LeabraCon_Group::* TA_LeabraCon_Group_MbrOff;
static MemberDef_data TA_LeabraCon_Group_MemberDef[]={
  {&TA_float,NULL,"scale_eff"," effective scale parameter for netin","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::scale_eff))),0,NULL,0},
  {&TA_float,NULL,"savg_cor"," savg correction factor for hebbian learning","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::savg_cor))),0,NULL,0},
  {&TA_float,NULL,"net"," netinput to this con_group: not normally computed!","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCon_Group_MbrOff=(int LeabraCon_Group::*)(&LeabraCon_Group::net))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_C_InitWtState_Post_MethArgs[]={
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_SetCurLrate_MethArgs[]={
  {&TA_int,NULL,"epoch",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_Send_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_LeabraCon_Group_Send_NetDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LeabraCon_Group_MethodDef[]={
  {&TA_void,NULL,"Compute_LinFmWt","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCon_Group_Compute_LinFmWt_stub,NULL},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCon_Group_Compute_WtFmLin_stub,NULL},
  {&TA_void,NULL,"C_InitWtState_Post"," hook for setting other weight-like values after initializing the weight value","","",
    0,3,-1,0,NULL,cssElCFun_LeabraCon_Group_C_InitWtState_Post_stub,TA_LeabraCon_Group_C_InitWtState_Post_MethArgs},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraCon_Group_SetCurLrate_stub,TA_LeabraCon_Group_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraCon_Group_Send_ClampNet_stub,TA_LeabraCon_Group_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraCon_Group_Send_NetDelta_stub,TA_LeabraCon_Group_Send_NetDelta_MethArgs},
  NULL};
static EnumDef_data TA_LeabraUnitSpec_ActFun[]={
  {"NOISY_XX1"," x over x plus 1 convolved with Gaussian noise (noise is nvar)","",0},
  {"XX1"," x over x plus 1, hard threshold, no noise convolution","",1},
  {"NOISY_LINEAR"," simple linear output function (still thesholded) convolved with Gaussian noise (noise is nvar)","",2},
  {"LINEAR"," simple linear output function (still thesholded)","",3},
  {"DEPRESS"," depressing synapses activation function (rate coded)","",4},
  {"SPIKE"," discrete spiking activations (spike when > thr)","",5},
  NULL};
static EnumDef_data TA_LeabraUnitSpec_NoiseType[]={
  {"NO_NOISE"," no noise added to processing","",0},
  {"VM_NOISE"," noise in the value of v_m (membrane potential)","",1},
  {"NETIN_NOISE"," noise in the net input (g_e)","",2},
  {"ACT_NOISE"," noise in the activations","",3},
  NULL};
static int LeabraUnitSpec::* TA_LeabraUnitSpec_MbrOff;
static MemberDef_data TA_LeabraUnitSpec_MemberDef[]={
  {NULL,"::ActFun","act_fun"," activation function to use","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act_fun))),0,NULL,0},
  {&TA_ActFunSpec,NULL,"act"," activation function specs","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act))),0,NULL,0},
  {&TA_SpikeFunSpec,NULL,"spike"," spiking function specs (only for act_fun = SPIKE)","CONDEDIT_ON_act_fun:SPIKE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::spike))),0,NULL,0},
  {&TA_DepressSpec,NULL,"depress"," depressing synapses activation function specs, note that act_range deterimines range of spk_amp spiking amplitude, max should be > 1","CONDEDIT_ON_act_fun:DEPRESS ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::depress))),0,NULL,0},
  {&TA_OptThreshSpec,NULL,"opt_thresh"," optimization thresholds for speeding up processing when units are basically inactive","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::opt_thresh))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"clamp_range"," range of clamped activation values (min, max, 0, .95 std), don't clamp to 1 because acts can't reach, so .95 instead","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::clamp_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"vm_range"," membrane potential range (min, max, 0-1 for normalized, -90-50 for bio-based)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::vm_range))),0,NULL,0},
  {&TA_Random,NULL,"v_m_init"," what to initialize the membrane potential to (mean = .15, var = 0 std)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::v_m_init))),0,NULL,0},
  {&TA_DtSpec,NULL,"dt"," time constants (rate of updating): membrane potential (vm) and net input (net)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::dt))),0,NULL,0},
  {&TA_LeabraChannels,NULL,"g_bar"," [Defaults: 1, .1, 1, .1, .5] maximal conductances for channels","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::g_bar))),0,NULL,0},
  {&TA_LeabraChannels,NULL,"e_rev"," [Defaults: 1, .15, .15, 1, 0] reversal potentials for each channel","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::e_rev))),0,NULL,0},
  {&TA_VChanSpec,NULL,"hyst"," [Defaults: .05, .8, .7, .1] hysteresis (excitatory) v-gated chan (Ca2+, NMDA)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::hyst))),0,NULL,0},
  {&TA_VChanSpec,NULL,"acc"," [Defaults: .01, .5, .1, .1] accomodation (inhibitory) v-gated chan (K+)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::acc))),0,NULL,0},
  {&TA_ActRegSpec,NULL,"act_reg"," activity regulation via global scaling of weight values","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::act_reg))),0,NULL,0},
  {NULL,"::NoiseType","noise_type"," where to add random noise in the processing (if at all)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_type))),0,NULL,0},
  {&TA_Random,NULL,"noise"," distribution parameters for random added noise","CONDEDIT_OFF_noise_type:NO_NOISE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise))),0,NULL,0},
  {&TA_Schedule,NULL,"noise_sched"," schedule of noise variance over settling cycles","CONDEDIT_OFF_noise_type:NO_NOISE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_sched))),0,NULL,0},
  {&TA_FunLookup,NULL,"nxx1_fun"," convolved gaussian and x/x+1 function as lookup table","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::nxx1_fun))),0,NULL,0},
  {&TA_FunLookup,NULL,"noise_conv"," gaussian for convolution","HIDDEN NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitSpec_MbrOff=(int LeabraUnitSpec::*)(&LeabraUnitSpec::noise_conv))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitWtState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_Net_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_SetCurLrate_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_InitDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_HardClampNoClip_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThresh_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshAll_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoA_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoH_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_IThreshNoAH_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Conduct_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_Vm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_ActFmVm_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_SelfReg_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_PhaseInit_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_DecayPhase_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_ExtToComp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_TargExtToComp_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_PostSettle_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_dWt_impl_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_EncodeState_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_GraphVmFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"g_i"," .5"},
  {&TA_float,NULL,"min"," 0.0"},
  {&TA_float,NULL,"max"," 1.0"},
  {&TA_float,NULL,"incr"," .01"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_GraphActFmVmFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"min"," .15"},
  {&TA_float,NULL,"max"," .50"},
  {&TA_float,NULL,"incr"," .001"},
  NULL};
static MethodArgs_data TA_LeabraUnitSpec_GraphActFmNetFun_MethArgs[]={
  {&TA_GraphLog_ptr,NULL,"graph_log",""},
  {&TA_float,NULL,"g_i"," .5"},
  {&TA_float,NULL,"min"," 0.0"},
  {&TA_float,NULL,"max"," 1.0"},
  {&TA_float,NULL,"incr"," .001"},
  NULL};
static MethodDef_data TA_LeabraUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_InitState_stub,TA_LeabraUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"InitWtState"," init weight state variables","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_InitWtState_stub,TA_LeabraUnitSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"Send_Net"," send net input to all units I send to add ext input, sender-based","","",
    2,2,-1,0,NULL,cssElCFun_LeabraUnitSpec_Send_Net_stub,TA_LeabraUnitSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act"," compute the final activation: calls following function steps","","",
    2,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Act_stub,TA_LeabraUnitSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    2,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_dWt_stub,TA_LeabraUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights from deltas","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_UpdateWeights_stub,TA_LeabraUnitSpec_UpdateWeights_MethArgs},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,4,3,0,NULL,cssElCFun_LeabraUnitSpec_CheckConfig_stub,TA_LeabraUnitSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on epoch","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_SetCurLrate_stub,TA_LeabraUnitSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"InitDelta","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnitSpec_InitDelta_stub,TA_LeabraUnitSpec_InitDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," compute net input scaling values and input from hard-clamped inputs","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetScale_stub,TA_LeabraUnitSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," compute net input from hard-clamped inputs (sender based)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Send_ClampNet_stub,TA_LeabraUnitSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," //////////////////////////////////////////////////////////////","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnitSpec_Send_NetDelta_stub,TA_LeabraUnitSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg"," compute netin average","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_NetAvg_stub,TA_LeabraUnitSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," compute inhib netin average","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_InhibAvg_stub,TA_LeabraUnitSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," force units to external values provided by environment: also optimizes settling by only computing netinput once","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_HardClamp_stub,TA_LeabraUnitSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_HardClampNoClip"," hard-clamp units without clipping values to clamp_range (use for second plus phase clamping to settled values)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_HardClampNoClip_stub,TA_LeabraUnitSpec_Compute_HardClampNoClip_MethArgs},
  {&TA_bool,NULL,"Compute_SoftClamp"," soft-clamps unit, returns true if unit is not above .5","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SoftClamp_stub,TA_LeabraUnitSpec_Compute_SoftClamp_MethArgs},
  {&TA_float,NULL,"Compute_IThresh"," compute inhibitory value that would place unit directly at threshold","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThresh_stub,TA_LeabraUnitSpec_Compute_IThresh_MethArgs},
  {&TA_float,NULL,"Compute_IThreshAll"," compute inhibitory value that would place unit directly at threshold, using all currents","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshAll_stub,TA_LeabraUnitSpec_Compute_IThreshAll_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoA"," compute inhibitory value that would place unit directly at threshold, excluding gc.a current","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoA_stub,TA_LeabraUnitSpec_Compute_IThreshNoA_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoH"," compute inhibitory value that would place unit directly at threshold, excluding gc.a current","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoH_stub,TA_LeabraUnitSpec_Compute_IThreshNoH_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoAH"," compute inhibitory value that would place unit directly at threshold, excluding any gc.a, gc.h currents","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_IThreshNoAH_stub,TA_LeabraUnitSpec_Compute_IThreshNoAH_MethArgs},
  {&TA_void,NULL,"Compute_Conduct"," compute input conductance values in the gc variables","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Conduct_stub,TA_LeabraUnitSpec_Compute_Conduct_MethArgs},
  {&TA_void,NULL,"Compute_Vm"," compute the membrante potential from input conductances","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_Vm_stub,TA_LeabraUnitSpec_Compute_Vm_MethArgs},
  {&TA_void,NULL,"Compute_ActFmVm"," compute the activation from membrane potential","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_ActFmVm_stub,TA_LeabraUnitSpec_Compute_ActFmVm_MethArgs},
  {&TA_void,NULL,"Compute_SelfReg"," compute self-regulatory currents (hysteresis, accommodation)","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_SelfReg_stub,TA_LeabraUnitSpec_Compute_SelfReg_MethArgs},
  {&TA_void,NULL,"PhaseInit"," initialize external input flags based on phase","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_PhaseInit_stub,TA_LeabraUnitSpec_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayPhase"," decay activation states towards initial values: at phase-level boundary","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_DecayPhase_stub,TA_LeabraUnitSpec_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay activation states towards initial values: at event-level boundary","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnitSpec_DecayEvent_stub,TA_LeabraUnitSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"ExtToComp"," change external inputs to comparisons (remove input)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_ExtToComp_stub,TA_LeabraUnitSpec_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp"," change target & external inputs to comparisons (remove targ & input)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_TargExtToComp_stub,TA_LeabraUnitSpec_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle"," set stuff after settling is over (set_both = both _m and _p for current)","","",
    0,5,4,0,NULL,cssElCFun_LeabraUnitSpec_PostSettle_stub,TA_LeabraUnitSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_dWt_impl"," actually do wt change","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_dWt_impl_stub,TA_LeabraUnitSpec_Compute_dWt_impl_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," if weights need to be updated from linear values without doing updatewts","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_Compute_WtFmLin_stub,TA_LeabraUnitSpec_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"EncodeState"," encode current state information (hook for time-based learning)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnitSpec_EncodeState_stub,TA_LeabraUnitSpec_EncodeState_MethArgs},
  {&TA_void,NULL,"CreateNXX1Fun"," create convolved gaussian and x/x+1 ","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnitSpec_CreateNXX1Fun_stub,NULL},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnitSpec_Defaults_stub,NULL},
  {&TA_void,NULL,"GraphVmFun"," graph membrane potential (v_m) as a function of excitatory net input (net) for given inhib conductance (g_i) (NULL = new graph log)","BUTTON NULL_OK ","",
    0,5,1,0,NULL,cssElCFun_LeabraUnitSpec_GraphVmFun_stub,TA_LeabraUnitSpec_GraphVmFun_MethArgs},
  {&TA_void,NULL,"GraphActFmVmFun"," graph the activation function as a function of membrane potential (v_m) (NULL = new graph log)","BUTTON NULL_OK ","",
    0,4,1,0,NULL,cssElCFun_LeabraUnitSpec_GraphActFmVmFun_stub,TA_LeabraUnitSpec_GraphActFmVmFun_MethArgs},
  {&TA_void,NULL,"GraphActFmNetFun"," graph the activation function as a function of net input (projected through membrane potential) (NULL = new graph log)","BUTTON NULL_OK ","",
    0,5,1,0,NULL,cssElCFun_LeabraUnitSpec_GraphActFmNetFun_stub,TA_LeabraUnitSpec_GraphActFmNetFun_MethArgs},
  NULL};
static int LeabraUnit::* TA_LeabraUnit_MbrOff;
static MemberDef_data TA_LeabraUnit_MemberDef[]={
  {&TA_float,NULL,"act_eq"," rate-code equivalent activity value (time-averaged spikes or just act)","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_eq))),0,NULL,0},
  {&TA_float,NULL,"act_avg"," average activation over long time intervals (dt = act.avg_dt)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_avg))),0,NULL,0},
  {&TA_float,NULL,"act_m"," minus_phase activation, set after settling, used for learning","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_m))),0,NULL,0},
  {&TA_float,NULL,"act_p"," plus_phase activation, set after settling, used for learning","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_p))),0,NULL,0},
  {&TA_float,NULL,"act_dif"," difference between plus and minus phase acts, gives unit err contribution","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_dif))),0,NULL,0},
  {&TA_float,NULL,"da"," delta activation: change in act from one cycle to next, used to stop settling","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::da))),0,NULL,0},
  {&TA_VChanBasis,NULL,"vcb"," voltage-gated channel basis variables","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::vcb))),0,NULL,0},
  {&TA_LeabraUnitChans,NULL,"gc"," current unit channel conductances","DMEM_SHARE_SET_1 NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::gc))),0,NULL,0},
  {&TA_float,NULL,"I_net"," net current produced by all channels","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::I_net))),0,NULL,0},
  {&TA_float,NULL,"v_m"," membrane potential","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::v_m))),0,NULL,0},
  {&TA_bool,NULL,"in_subgp"," determine if unit is in a subgroup","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::in_subgp))),0,NULL,0},
  {&TA_float,NULL,"clmp_net"," hard-clamp net input (no need to recompute)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_4 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::clmp_net))),0,NULL,0},
  {&TA_float,NULL,"net_scale"," total netinput scaling basis","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_scale))),0,NULL,0},
  {&TA_float,NULL,"bias_scale"," bias weight scaling factor","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::bias_scale))),0,NULL,0},
  {&TA_float,NULL,"prv_net"," previous net input (for time averaging)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::prv_net))),0,NULL,0},
  {&TA_float,NULL,"prv_g_i"," previous inhibitory conductance value (for time averaging)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::prv_g_i))),0,NULL,0},
  {&TA_float,NULL,"act_sent"," last activation value sent (only send when diff is over threshold)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_sent))),0,NULL,0},
  {&TA_float,NULL,"act_delta"," change in activation to send to other units","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::act_delta))),0,NULL,0},
  {&TA_float,NULL,"net_raw"," raw net input received from sending units (increments the deltas in send_delta)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_raw))),0,NULL,0},
  {&TA_float,NULL,"net_delta"," change in netinput received from other units (send_delta mode only)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_3 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::net_delta))),0,NULL,0},
  {&TA_float,NULL,"g_i_raw"," raw inhib net input received from sending units (increments the deltas in send_delta)","NO_VIEW NO_SAVE DETAIL ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::g_i_raw))),0,NULL,0},
  {&TA_float,NULL,"g_i_delta"," change in inhibitory netinput received from other units (send_delta mode only)","NO_VIEW NO_SAVE DETAIL DMEM_SHARE_SET_3 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::g_i_delta))),0,NULL,0},
  {&TA_float,NULL,"i_thr"," inhibitory threshold value for computing kWTA","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::i_thr))),0,NULL,0},
  {&TA_float,NULL,"spk_amp"," amplitude of spiking output (for depressing synapse activation function)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::spk_amp))),0,NULL,0},
  {&TA_float,NULL,"misc_1"," miscellaneous variable for other algorithms that need it (e.g., TdLayerSpec)","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_MbrOff=(int LeabraUnit::*)(&LeabraUnit::misc_1))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnit_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_Net_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_SetCurLrate_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Send_NetDelta_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_HardClampNoClip_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_IThresh_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_IThreshNoAH_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_PhaseInit_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_DecayEvent_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_DecayPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"decay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_ExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_TargExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraInhib_ptr,NULL,"athr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_EncodeState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LeabraUnit_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","MENU ","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_InitState_stub,TA_LeabraUnit_InitState_MethArgs},
  {&TA_void,NULL,"Send_Net","","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Send_Net_stub,TA_LeabraUnit_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_Act","","","",
    1,3,-1,0,NULL,cssElCFun_LeabraUnit_Compute_Act_stub,TA_LeabraUnit_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_dWt_stub,TA_LeabraUnit_Compute_dWt_MethArgs},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_SetCurLrate_stub,TA_LeabraUnit_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_NetScale_stub,TA_LeabraUnit_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Send_ClampNet_stub,TA_LeabraUnit_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Send_NetDelta_stub,TA_LeabraUnit_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Compute_NetAvg_stub,TA_LeabraUnit_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Compute_InhibAvg_stub,TA_LeabraUnit_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_HardClamp_stub,TA_LeabraUnit_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_HardClampNoClip","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_HardClampNoClip_stub,TA_LeabraUnit_Compute_HardClampNoClip_MethArgs},
  {&TA_bool,NULL,"Compute_SoftClamp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_SoftClamp_stub,TA_LeabraUnit_Compute_SoftClamp_MethArgs},
  {&TA_float,NULL,"Compute_IThresh","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_IThresh_stub,TA_LeabraUnit_Compute_IThresh_MethArgs},
  {&TA_float,NULL,"Compute_IThreshNoAH","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_IThreshNoAH_stub,TA_LeabraUnit_Compute_IThreshNoAH_MethArgs},
  {&TA_void,NULL,"PhaseInit","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_PhaseInit_stub,TA_LeabraUnit_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_DecayEvent_stub,TA_LeabraUnit_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase","","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_DecayPhase_stub,TA_LeabraUnit_DecayPhase_MethArgs},
  {&TA_void,NULL,"ExtToComp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_ExtToComp_stub,TA_LeabraUnit_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_TargExtToComp_stub,TA_LeabraUnit_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle","","","",
    0,4,3,0,NULL,cssElCFun_LeabraUnit_PostSettle_stub,TA_LeabraUnit_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Compute_WtFmLin_stub,TA_LeabraUnit_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"EncodeState","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_EncodeState_stub,TA_LeabraUnit_EncodeState_MethArgs},
  {&TA_void,NULL,"GetInSubGp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_GetInSubGp_stub,NULL},
  NULL};
static int LeabraInhib::* TA_LeabraInhib_MbrOff;
static MemberDef_data TA_LeabraInhib_MemberDef[]={
  {&TA_LeabraSort,NULL,"active_buf"," list of active units","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::active_buf))),0,NULL,0},
  {&TA_LeabraSort,NULL,"inact_buf"," list of inactive units","HIDDEN NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::inact_buf))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"netin"," net input values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::netin))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"i_thrs"," inhibitory threshold values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::i_thrs))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts"," activation values for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts_p"," plus-phase activation stats for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts_p))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"acts_m"," minus-phase activation stats for the layer","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::acts_m))),0,NULL,0},
  {&TA_float,NULL,"phase_dif_ratio"," phase-difference ratio (acts_m.avg / acts_p.avg)","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::phase_dif_ratio))),0,NULL,0},
  {&TA_KWTAVals,NULL,"kwta"," values for kwta -- activity levels, etc NOTE THIS IS A COMPUTED VALUE: k IS SET IN LayerSpec!","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::kwta))),0,NULL,0},
  {&TA_InhibVals,NULL,"i_val"," inhibitory values computed by kwta","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::i_val))),0,NULL,0},
  {&TA_AvgMaxVals,NULL,"un_g_i"," average and stdev (not max) values for unit inhib-to-thresh","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::un_g_i))),0,NULL,0},
  {&TA_AdaptIVals,NULL,"adapt_i"," adapting inhibition values","READ_ONLY AKA_adapt_pt ","",
    *((ta_memb_ptr*)&(TA_LeabraInhib_MbrOff=(int LeabraInhib::*)(&LeabraInhib::adapt_i))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraInhib_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodDef_data TA_LeabraInhib_MethodDef[]={
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_SetVals_stub,TA_LeabraInhib_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_InitState_stub,TA_LeabraInhib_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraInhib_Inhib_Copy__stub,TA_LeabraInhib_Inhib_Copy__MethArgs},
  NULL};
static EnumDef_data TA_LeabraLayerSpec_Compute_I[]={
  {"KWTA_INHIB"," between thresholds of k and k+1th most activated units (sets precise k value, should use i_kwta_pt = .25 std)","",0},
  {"KWTA_AVG_INHIB"," average of top k vs avg of rest (provides more flexibility in actual k value, should use i_kwta_pt = .6 std)","",1},
  {"AVG_MAX_PT_INHIB"," put inhib value at i_kwta_pt between avg and max values for layer!","",2},
  {"UNIT_INHIB"," unit-based inhibition (g_i from netinput -- requires connections with inhib flag set to provide inhibition)","",3},
  NULL};
static EnumDef_data TA_LeabraLayerSpec_InhibGroup[]={
  {"ENTIRE_LAYER"," treat entire layer as one inhibitory group (even if subgroups exist)","",0},
  {"UNIT_GROUPS"," treat sub unit groups as separate inhibitory groups","",1},
  {"LAY_AND_GPS"," compute inhib over both groups and whole layer, inhibi is max of layer and group inhib","",2},
  {"GPS_THEN_UNITS"," first find top gp_kwta.k most active (on average) groups, then find top kwta.k units within those groups (else all units inhibbed)","",3},
  NULL};
static int LeabraLayerSpec::* TA_LeabraLayerSpec_MbrOff;
static MemberDef_data TA_LeabraLayerSpec_MemberDef[]={
  {&TA_KWTASpec,NULL,"kwta"," desired activity level over entire layer (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)","CONDEDIT_OFF_inhib_group:UNIT_GROUPS ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::kwta))),0,NULL,0},
  {&TA_KWTASpec,NULL,"gp_kwta"," desired activity level for units within unit groups (not for ENTIRE_LAYER) (NOTE: used to set target activity for UNIT_INHIB, AVG_MAX_PT_INHIB, but not used for actually computing inhib for these cases)","CONDEDIT_OFF_inhib_group:ENTIRE_LAYER ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::gp_kwta))),0,NULL,0},
  {NULL,"::InhibGroup","inhib_group"," what to consider the inhibitory group (layer or unit subgroups, or both)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::inhib_group))),0,NULL,0},
  {NULL,"::Compute_I","compute_i"," how to compute inhibition (g_i): two forms of kwta or unit-level inhibition","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::compute_i))),0,NULL,0},
  {&TA_float,NULL,"i_kwta_pt"," [Default: .25 for KWTA_INHIB, .6 for KWTA_AVG, .2 for AVG_MAX_PT_INHIB] point to place inhibition between k and k+1 (or avg and max for AVG_MAX_PT_INHIB)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::i_kwta_pt))),0,NULL,0},
  {&TA_float,NULL,"gp_i_pt"," [Default: .2] for unit groups: point to place inhibition between avg and max for AVG_MAX_PT_INHIB","CONDEDIT_ON_compute_i:AVG_MAX_PT_INHIB ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::gp_i_pt))),0,NULL,0},
  {&TA_AdaptISpec,NULL,"adapt_i"," adapt the inhibition: either i_kwta_pt point based on diffs between actual and target k level (for avg-based), or g_bar.i for unit-inhib","AKA_adapt_pt ","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::adapt_i))),0,NULL,0},
  {&TA_ClampSpec,NULL,"clamp"," how to clamp external inputs to units (hard vs. soft)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::clamp))),0,NULL,0},
  {&TA_DecaySpec,NULL,"decay"," decay of activity state vars between events, -/+ phase, and 2nd set of phases (if appl)","","",
    *((ta_memb_ptr*)&(TA_LeabraLayerSpec_MbrOff=(int LeabraLayerSpec::*)(&LeabraLayerSpec::decay))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitWtState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_SetCurLrate_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Active_K_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Active_K_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_KWTASpec_ref,NULL,"kwtspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Pat_K_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitState_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_HardClampPhase2_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetScale_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_ClampNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_Net_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Send_NetDelta_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_NetAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_SoftClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_InitInhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_InhibAvg_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActMAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActMAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActPAvg_ugp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"na",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_ActPAvg_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Act_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_Act_impl_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_Unit_Group_ptr,NULL,"ug",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_PhaseInit_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayEvent_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_DecayPhase2_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_ExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_TargExtToComp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_PostSettle_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_AdaptGBarI_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_AdaptKWTAPt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpec_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int_ref,NULL,"prjn_idx",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpecExact_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_int_ref,NULL,"prjn_idx",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_FindLayerFmSpecNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_TypeDef_ptr,NULL,"layer_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayerSpec_CheckConfig_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodDef_data TA_LeabraLayerSpec_MethodDef[]={
  {&TA_void,NULL,"InitWtState"," initialize weight values and other permanent state","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_InitWtState_stub,TA_LeabraLayerSpec_InitWtState_MethArgs},
  {&TA_void,NULL,"SetCurLrate"," set current learning rate based on epoch","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_SetCurLrate_stub,TA_LeabraLayerSpec_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_Active_K"," prior to settling: compute actual activity levels based on spec, inputs, etc","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Active_K_stub,TA_LeabraLayerSpec_Compute_Active_K_MethArgs},
  {&TA_void,NULL,"Compute_Active_K_impl","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Active_K_impl_stub,TA_LeabraLayerSpec_Compute_Active_K_impl_MethArgs},
  {&TA_int,NULL,"Compute_Pat_K"," above are implementation helpers","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Pat_K_stub,TA_LeabraLayerSpec_Compute_Pat_K_MethArgs},
  {&TA_void,NULL,"InitState"," prior to settling: initialize dynamic state variables","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_InitState_stub,TA_LeabraLayerSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_HardClampPhase2"," prior to settling: hard-clamp inputs (special code for hard clamping in phase 2 based on prior acts)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_HardClampPhase2_stub,TA_LeabraLayerSpec_Compute_HardClampPhase2_MethArgs},
  {&TA_void,NULL,"Compute_HardClamp"," prior to settling: hard-clamp inputs","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_HardClamp_stub,TA_LeabraLayerSpec_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale"," prior to settling: compute netinput scaling values","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetScale_stub,TA_LeabraLayerSpec_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet"," prior to settling: compute input from hard-clamped","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Send_ClampNet_stub,TA_LeabraLayerSpec_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_Net"," compute net inputs","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_Send_Net_stub,TA_LeabraLayerSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_NetDelta"," compute net inputs as changes in activation","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_Send_NetDelta_stub,TA_LeabraLayerSpec_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"Compute_Clamp_NetAvg"," clamp and compute averages of net inputs that were already computed","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Clamp_NetAvg_stub,TA_LeabraLayerSpec_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_NetAvg","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_NetAvg_stub,TA_LeabraLayerSpec_Compute_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_SoftClamp"," soft-clamp inputs by adding to net input","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_SoftClamp_stub,TA_LeabraLayerSpec_Compute_SoftClamp_MethArgs},
  {&TA_void,NULL,"InitInhib"," initialize the inhibitory state values","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayerSpec_InitInhib_stub,TA_LeabraLayerSpec_InitInhib_MethArgs},
  {&TA_void,NULL,"Compute_Inhib"," stage two: compute the inhibition for layer","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_stub,TA_LeabraLayerSpec_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_impl"," implementation of inhibition computation for either layer or unit group","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_impl_stub,TA_LeabraLayerSpec_Compute_Inhib_impl_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA"," implementation of basic kwta inhibition computation","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA_Avg"," implementation of kwta avg-based inhibition computation","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_Avg_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_AvgMaxPt"," implementation of avg-max-pt inhibition computation","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_stub,TA_LeabraLayerSpec_Compute_Inhib_AvgMaxPt_MethArgs},
  {&TA_void,NULL,"Compute_Inhib_kWTA_Gps"," implementation of GPS_THEN_UNITS kwta on groups","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_stub,TA_LeabraLayerSpec_Compute_Inhib_kWTA_Gps_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg"," stage three: compute final activation","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_InhibAvg_stub,TA_LeabraLayerSpec_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg_impl"," //////////////////////////////////////","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_InhibAvg_impl_stub,TA_LeabraLayerSpec_Compute_InhibAvg_impl_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg_ugp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActAvg"," helper function to compute acts.avg from act_eq","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActAvg_stub,TA_LeabraLayerSpec_Compute_ActAvg_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg_ugp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActMAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActMAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActMAvg"," helper function to compute acts_m.avg from act_m","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActMAvg_stub,TA_LeabraLayerSpec_Compute_ActMAvg_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg_ugp","","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActPAvg_ugp_stub,TA_LeabraLayerSpec_Compute_ActPAvg_ugp_MethArgs},
  {&TA_void,NULL,"Compute_ActPAvg"," helper function to compute acts_p.avg from act_p","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_ActPAvg_stub,TA_LeabraLayerSpec_Compute_ActPAvg_MethArgs},
  {&TA_void,NULL,"Compute_Act"," stage three: compute final activation","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Act_stub,TA_LeabraLayerSpec_Compute_Act_MethArgs},
  {&TA_void,NULL,"Compute_Act_impl"," //////////////////////////////////////","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_Act_impl_stub,TA_LeabraLayerSpec_Compute_Act_impl_MethArgs},
  {&TA_void,NULL,"PhaseInit"," initialize start of a setting phase, set input flags appropriately, etc","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_PhaseInit_stub,TA_LeabraLayerSpec_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_DecayEvent_stub,TA_LeabraLayerSpec_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_DecayPhase_stub,TA_LeabraLayerSpec_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayPhase2","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_DecayPhase2_stub,TA_LeabraLayerSpec_DecayPhase2_MethArgs},
  {&TA_void,NULL,"ExtToComp"," change external inputs to comparisons (remove input)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_ExtToComp_stub,TA_LeabraLayerSpec_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp"," change target & external inputs to comparisons (remove targ & input)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_TargExtToComp_stub,TA_LeabraLayerSpec_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle"," after settling, keep track of phase variables, etc.","","",
    0,3,2,0,NULL,cssElCFun_LeabraLayerSpec_PostSettle_stub,TA_LeabraLayerSpec_PostSettle_MethArgs},
  {&TA_void,NULL,"AdaptGBarI"," adapt inhibitory conductances based on target activation values relative to current values","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_AdaptGBarI_stub,TA_LeabraLayerSpec_AdaptGBarI_MethArgs},
  {&TA_void,NULL,"AdaptKWTAPt"," adapt the kwta point based on average activity","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_AdaptKWTAPt_stub,TA_LeabraLayerSpec_AdaptKWTAPt_MethArgs},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_dWt_stub,TA_LeabraLayerSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin"," use this if weights will be used again for activations prior to being updated","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayerSpec_Compute_WtFmLin_stub,TA_LeabraLayerSpec_Compute_WtFmLin_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpec"," find a layer that given layer receives from based on the type of layer spec","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_FindLayerFmSpec_stub,TA_LeabraLayerSpec_FindLayerFmSpec_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpecExact"," find a layer that given layer receives from based on the type of layer spec: uses exact type match, not inherits!","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayerSpec_FindLayerFmSpecExact_stub,TA_LeabraLayerSpec_FindLayerFmSpecExact_MethArgs},
  {&TA_LeabraLayer_ptr,NULL,"FindLayerFmSpecNet"," find a layer in network based on the type of layer spec","","",
    0,2,-1,1,(ta_void_fun)(LeabraLayerSpec::FindLayerFmSpecNet),cssElCFun_LeabraLayerSpec_FindLayerFmSpecNet_stub,TA_LeabraLayerSpec_FindLayerFmSpecNet_MethArgs},
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayerSpec_HelpConfig_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    0,3,2,0,NULL,cssElCFun_LeabraLayerSpec_CheckConfig_stub,TA_LeabraLayerSpec_CheckConfig_MethArgs},
  {&TA_void,NULL,"Defaults"," restores default parameter settings: warning -- you will lose any unique parameters you might have set!","BUTTON CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayerSpec_Defaults_stub,NULL},
  NULL};
static int LeabraUnit_Group::* TA_LeabraUnit_Group_MbrOff;
static MemberDef_data TA_LeabraUnit_Group_MemberDef[]={
  {&TA_int,NULL,"misc_state"," miscellaneous state variable","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state))),0,NULL,0},
  {&TA_int,NULL,"misc_state1"," second miscellaneous state variable ","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state1))),0,NULL,0},
  {&TA_int,NULL,"misc_state2"," third miscellaneous state variable ","","",
    *((ta_memb_ptr*)&(TA_LeabraUnit_Group_MbrOff=(int LeabraUnit_Group::*)(&LeabraUnit_Group::misc_state2))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetColText_MethArgs[]={
  {&TA_int,NULL,"col",""},
  {&TA_int,NULL,"itm_idx"," -1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChildQueryEditActions_MethArgs[]={
  {&TA_const_MemberDef_ptr,NULL,"md",""},
  {&TA_const_taBase_ptr,NULL,"child",""},
  {&TA_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int_ref,NULL,"allowed",""},
  {&TA_int_ref,NULL,"forbidden",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChildEditAction_MethArgs[]={
  {&TA_const_MemberDef_ptr,NULL,"md",""},
  {&TA_taBase_ptr,NULL,"child",""},
  {&TA_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int,NULL,"ea",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_QueryEditActions_MethArgs[]={
  {&TA_const_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int_ref,NULL,"allowed",""},
  {&TA_int_ref,NULL,"forbidden",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EditAction_MethArgs[]={
  {&TA_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int,NULL,"ea",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnSafeCopy_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CastCopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetOwner_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"tp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetPath_MethArgs[]={
  {&TA_TAPtr,NULL,"ta","((void *)0)"},
  {&TA_TAPtr,NULL,"par_stop","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindFromPath_MethArgs[]={
  {&TA_taString_ref,NULL,"path",""},
  {&TA_MemberDef_ptr_ref,NULL,"ret_md","no_mdef"},
  {&TA_int,NULL,"start","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_New_MethArgs[]={
  {&TA_int,NULL,"n_objs","0"},
  {&TA_TypeDef_ptr,NULL,"typ","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_StructUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DataUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_InheritsFrom_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetEnumString_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_tp_nm",""},
  {&TA_int,NULL,"enum_val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetEnumVal_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_nm",""},
  {&TA_taString_ref,NULL,"enum_tp_nm"," no_name"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Load_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Save_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SaveAs_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReShowEdit_MethArgs[]={
  {&TA_bool,NULL,"force"," false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CopyFrom_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_from",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChildUpdateAfterEdit_MethArgs[]={
  {&TA_TAPtr,NULL,"child",""},
  {&TA_bool_ref,NULL,"handled",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChangeMyType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SelectForEdit_MethArgs[]={
  {&TA_MemberDef_ptr,NULL,"member",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SelectFunForEdit_MethArgs[]={
  {&TA_MethodDef_ptr,NULL,"function",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_CallFun_MethArgs[]={
  {&TA_const_char_ptr,NULL,"fun_name",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetAdapter_MethArgs[]={
  {&TA_taBaseAdapter_ptr,NULL,"adapter_",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetTA_Element__MethArgs[]={
  {&TA_int,NULL,"i",""},
  {&TA_TypeDef_ptr_ref,NULL,"eltd",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DataChanged_MethArgs[]={
  {&TA_int,NULL,"dcr",""},
  {&TA_void_ptr,NULL,"op1"," ((void *)0)"},
  {&TA_void_ptr,NULL,"op2"," ((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Alloc_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BuildHashTable_MethArgs[]={
  {&TA_int,NULL,"n_buckets",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Find_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Remove_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Move_MethArgs[]={
  {&TA_int,NULL,"from",""},
  {&TA_int,NULL,"to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Swap_MethArgs[]={
  {&TA_int,NULL,"pos1",""},
  {&TA_int,NULL,"pos2",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Sort_MethArgs[]={
  {&TA_bool,NULL,"descending","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Sort__MethArgs[]={
  {&TA_bool,NULL,"descending","false"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FirstEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NextEl_MethArgs[]={
  {&TA_taLeafItr_ref,NULL,"lf",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Duplicate_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DupeUniqNameNew_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DupeUniqNameOld_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Stealth_Borrow_MethArgs[]={
  {&TA_const_taPtrList_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Borrow_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUnique_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUniqNameNew_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_BorrowUniqNameOld_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Common_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Duplicate_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Borrow_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_GetColHeading_MethArgs[]={
  {&TA_int,NULL,"col",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChildGetColText_MethArgs[]={
  {&TA_void_ptr,NULL,"child",""},
  {&TA_TypeDef_ptr,NULL,"typ",""},
  {&TA_int,NULL,"col",""},
  {&TA_int,NULL,"itm_idx"," -1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_List_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm","cout"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Add_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUnique_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUniqNameNew_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Insert_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  {&TA_int,NULL,"where",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Replace_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","old_it",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_DuplicateEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Link_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUnique_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUniqNameNew_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_InsertLink_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  {&TA_int,NULL,"idx"," -1"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLink_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLinkEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","old_it",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceLinkName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Push_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveEl_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","from",""},
  {NULL,"taPtrList_base_taBase_::taBase_ptr","to",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Transfer_MethArgs[]={
  {NULL,"taPtrList_base_taBase_::taBase_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveBefore_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","trg",""},
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_MoveAfter_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","trg",""},
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Dump_Save_PathR_impl_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultEl_MethArgs[]={
  {&TA_TAPtr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultElName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetDefaultElType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceSize_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceSameStru_MethArgs[]={
  {&TA_const_taGroup_impl_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ChangeType_MethArgs[]={
  {&TA_TAPtr,NULL,"itm",""},
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReplaceType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"old_type",""},
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetBaseType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"it",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveLeafEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_RemoveGp_MethArgs[]={
  {&TA_TAGPtr,NULL,"group",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_EnforceLeaves_MethArgs[]={
  {&TA_int,NULL,"sz",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeaf_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafEl_MethArgs[]={
  {&TA_TAPtr,NULL,"item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeEl_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Edit_El_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SafeGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FastGp_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Leaf_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LeafGp_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FirstGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NextGp_MethArgs[]={
  {&TA_int_ref,NULL,"g",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NewEl_MethArgs[]={
  {&TA_int,NULL,"n_els","0"},
  {&TA_TypeDef_ptr,NULL,"typ","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_NewGp_MethArgs[]={
  {&TA_int,NULL,"n_gps","0"},
  {&TA_TypeDef_ptr,NULL,"typ","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddUniqNameOld_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LinkUniqNameOld_MethArgs[]={
  {NULL,"taGroup_Unit_::Unit_ptr","item",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindLeafType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"item_tp",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Copy_Weights_MethArgs[]={
  {&TA_const_Unit_Group_ptr,NULL,"src",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_WriteWeights_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_ReadWeights_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LayoutUnits_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u"," ((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"unitspec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_SetConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"conspec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_TransformWeights_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"trans",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_AddNoiseToWeights_MethArgs[]={
  {&TA_const_Random_ref,NULL,"noise_spec",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_PruneCons_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"pre_proc",""},
  {NULL,"CountParam::Relation","rel",""},
  {&TA_float,NULL,"cmp_val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LesionCons_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_LesionUnits_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnitValuesToArray_MethArgs[]={
  {&TA_float_RArray_ref,NULL,"ary",""},
  {&TA_const_char_ptr,NULL,"variable",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_UnitValuesFromArray_MethArgs[]={
  {&TA_float_RArray_ref,NULL,"ary",""},
  {&TA_const_char_ptr,NULL,"variable",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_FindUnitFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraUnit_Group_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodDef_data TA_LeabraUnit_Group_MethodDef[]={
  {&TA_taString,NULL,"GetColText"," text for the indicated column in browse lists (may be ignored and controlled by parent list; by convention, 0=name, 1=type; itm_idx is usually ignored by items","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_GetColText_stub,TA_LeabraUnit_Group_GetColText_MethArgs},
  {&TA_void,NULL,"ChildQueryEditActions"," gives ops allowed on child, with ms being clipboard or drop contents, md valid if we are a member, o/w NULL","","",
    0,5,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChildQueryEditActions_stub,TA_LeabraUnit_Group_ChildQueryEditActions_MethArgs},
  {&TA_int,NULL,"ChildEditAction"," note: multi source ops will have child=NULL","","",
    0,4,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChildEditAction_stub,TA_LeabraUnit_Group_ChildEditAction_MethArgs},
  {&TA_void,NULL,"QueryEditActions"," ms is null for Src-op query","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_QueryEditActions_stub,TA_LeabraUnit_Group_QueryEditActions_MethArgs},
  {&TA_int,NULL,"EditAction","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_EditAction_stub,TA_LeabraUnit_Group_EditAction_MethArgs},
  {&TA_taDataLink_ptr,NULL,"GetDataLink"," forces creation; can still be NULL if the type doesn't support datalinks","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetDataLink_stub,NULL},
  {&TA_void,NULL,"UnRef"," note: overridden by ref-semantic classes to delete","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnRef_stub,NULL},
  {&TA_void,NULL,"UnRefNoDelete","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnRefNoDelete_stub,NULL},
  {&TA_void,NULL,"UnSafeCopy","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnSafeCopy_stub,TA_LeabraUnit_Group_UnSafeCopy_MethArgs},
  {&TA_void,NULL,"CastCopyTo","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CastCopyTo_stub,TA_LeabraUnit_Group_CastCopyTo_MethArgs},
  {&TA_TAPtr,NULL,"GetOwner","","","",
    3,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetOwner_stub,TA_LeabraUnit_Group_GetOwner_MethArgs},
  {&TA_taString,NULL,"GetPath"," get path without name informtation, stop at par_stop if non-null","","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_GetPath_stub,TA_LeabraUnit_Group_GetPath_MethArgs},
  {&TA_TAPtr,NULL,"FindFromPath"," find object from path (starting from this, and position start of the path)","","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_FindFromPath_stub,TA_LeabraUnit_Group_FindFromPath_MethArgs},
  {&TA_TAPtr,NULL,"New"," create n_objs new objects of given type","MENU MENU_ON_Object ARGC_0 UPDATE_MENUS NO_SCRIPT MENU_CONTEXT ","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_New_stub,TA_LeabraUnit_Group_New_MethArgs},
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAfterEdit_stub,NULL},
  {&TA_void,NULL,"UpdateAllViews"," called after data changes, to update views","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAllViews_stub,NULL},
  {&TA_void,NULL,"StructUpdate"," bracket structural changes with (nestable) true/false calls;","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_StructUpdate_stub,TA_LeabraUnit_Group_StructUpdate_MethArgs},
  {&TA_void,NULL,"DataUpdate"," bracket data value changes with (nestable) true/false calls;","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DataUpdate_stub,TA_LeabraUnit_Group_DataUpdate_MethArgs},
  {&TA_void,NULL,"AddDataView"," add a dataview (not usually overridden)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddDataView_stub,TA_LeabraUnit_Group_AddDataView_MethArgs},
  {&TA_bool,NULL,"RemoveDataView"," removes a dataview (not usually overridden)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveDataView_stub,TA_LeabraUnit_Group_RemoveDataView_MethArgs},
  {&TA_bool,NULL,"InheritsFrom"," does this inherit from given type?","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_InheritsFrom_stub,TA_LeabraUnit_Group_InheritsFrom_MethArgs},
  {&TA_taString,NULL,"GetEnumString"," get the name corresponding to given enum value in enum type enum_tp_nm","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetEnumString_stub,TA_LeabraUnit_Group_GetEnumString_MethArgs},
  {&TA_int,NULL,"GetEnumVal"," get the enum value corresponding to the given enum name (-1 if not found), and sets enum_tp_nm to name of type this enum belongs in (empty if not found)","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_GetEnumVal_stub,TA_LeabraUnit_Group_GetEnumVal_MethArgs},
  {&TA_int,NULL,"Load"," Load object data from a file","MENU MENU_ON_Object ARGC_1 UPDATE_MENUS MENU_CONTEXT ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_Load_stub,TA_LeabraUnit_Group_Load_MethArgs},
  {&TA_int,NULL,"Save"," Save object data to a file","MENU MENU_ON_Object ARGC_1 QUICK_SAVE ","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_Save_stub,TA_LeabraUnit_Group_Save_MethArgs},
  {&TA_int,NULL,"SaveAs"," Save object data to a new file","MENU ARGC_1 ","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_SaveAs_stub,TA_LeabraUnit_Group_SaveAs_MethArgs},
  {&TA_int,NULL,"Edit"," Edit this object using the gui","MENU ARGC_0 MENU_ON_Object LABEL_Properties MENU_CONTEXT NO_SCRIPT ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Edit_stub,NULL},
  {&TA_bool,NULL,"CloseEdit"," close any open edit dialogs for this object","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_CloseEdit_stub,NULL},
  {&TA_bool,NULL,"ReShowEdit"," reshows any open edit dialogs for this object","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_ReShowEdit_stub,TA_LeabraUnit_Group_ReShowEdit_MethArgs},
  {&TA_void,NULL,"Close"," PERMANENTLY Destroy this object! This is not Iconify.","MENU CONFIRM NO_REVERT_AFTER LABEL_Close_(Destroy) NO_MENU_CONTEXT ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Close_stub,NULL},
  {&TA_bool,NULL,"CopyFrom"," Copy from given object into this object","MENU MENU_ON_Object MENU_SEP_BEFORE TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CopyFrom_stub,TA_LeabraUnit_Group_CopyFrom_MethArgs},
  {&TA_bool,NULL,"CopyTo"," Copy to given object from this object","MENU TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CopyTo_stub,TA_LeabraUnit_Group_CopyTo_MethArgs},
  {&TA_void,NULL,"ChildUpdateAfterEdit"," if enabled by UAE_OWNER directive, notifies parent; altered in lists/groups to send to their owner","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChildUpdateAfterEdit_stub,TA_LeabraUnit_Group_ChildUpdateAfterEdit_MethArgs},
  {&TA_bool,NULL,"DuplicateMe"," Make another copy of myself (done through owner)","MENU CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_DuplicateMe_stub,NULL},
  {&TA_bool,NULL,"ChangeMyType"," Change me into a different type of object, copying current info (done through owner)","MENU TYPE_this UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChangeMyType_stub,TA_LeabraUnit_Group_ChangeMyType_MethArgs},
  {&TA_bool,NULL,"SelectForEdit"," select a given member for editing --<br>if already on dialog, removes it & returns false (else true)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_SelectForEdit_stub,TA_LeabraUnit_Group_SelectForEdit_MethArgs},
  {&TA_bool,NULL,"SelectFunForEdit"," select a given function (method) for calling in a select edit dialog --\nif already on dialog, removes it & returns false (else true)","MENU ","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_SelectFunForEdit_stub,TA_LeabraUnit_Group_SelectFunForEdit_MethArgs},
  {&TA_void,NULL,"Help"," get help on using this object","MENU ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Help_stub,NULL},
  {&TA_void,NULL,"CallFun"," call function of given name on this object, prompting for args using gui interface","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_CallFun_stub,TA_LeabraUnit_Group_CallFun_MethArgs},
  {&TA_void,NULL,"SetAdapter","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetAdapter_stub,TA_LeabraUnit_Group_SetAdapter_MethArgs},
  {&TA_taDataLink_ptr_ptr,NULL,"addr_data_link","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_addr_data_link_stub,NULL},
  {&TA_void_ptr,NULL,"GetTA_Element_","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetTA_Element__stub,TA_LeabraUnit_Group_GetTA_Element__MethArgs},
  {&TA_void,NULL,"DataChanged"," called when list has changed -- more fine-grained than Dirty(), and may be multiple calls per event","","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_DataChanged_stub,TA_LeabraUnit_Group_DataChanged_MethArgs},
  {&TA_void,NULL,"Alloc"," allocate a list big enough for given number of elements (or current size)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Alloc_stub,TA_LeabraUnit_Group_Alloc_MethArgs},
  {&TA_void,NULL,"Reset"," reset the list (remove all elements)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Reset_stub,NULL},
  {&TA_bool,NULL,"IsEmpty","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_IsEmpty_stub,NULL},
  {&TA_void,NULL,"BuildHashTable"," build a hash table with given number of buckets (not dynamic, so make it big)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BuildHashTable_stub,TA_LeabraUnit_Group_BuildHashTable_MethArgs},
  {&TA_int,NULL,"Find"," find named element in list find element in list (-1 if not there) virtual int	Find(const TAPtr item) const	{ return taPtrList_ta_base::Find(item); } find element of given type","","",
    4,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Find_stub,TA_LeabraUnit_Group_Find_MethArgs},
  {&TA_bool,NULL,"Remove"," remove (and delete) element from list at index Remove object at given index on list","","",
    10,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Remove_stub,TA_LeabraUnit_Group_Remove_MethArgs},
  {&TA_bool,NULL,"RemoveName"," remove given named element from list (if on list)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveName_stub,TA_LeabraUnit_Group_RemoveName_MethArgs},
  {&TA_bool,NULL,"RemoveLast"," remove the last element on the list","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLast_stub,NULL},
  {&TA_void,NULL,"RemoveAll"," Remove all elements on the list","MENU MENU_ON_Edit CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveAll_stub,NULL},
  {&TA_bool,NULL,"Move"," Move element from (from) to position (to) in list","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Move_stub,TA_LeabraUnit_Group_Move_MethArgs},
  {&TA_bool,NULL,"Swap"," Swap the elements in the two given positions on the list","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Swap_stub,TA_LeabraUnit_Group_Swap_MethArgs},
  {&TA_void,NULL,"PopAll"," pop all elements off the stack","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_PopAll_stub,NULL},
  {&TA_void,NULL,"Permute"," permute the items in the list into a random order","MENU CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Permute_stub,NULL},
  {&TA_void,NULL,"Sort"," sort the items in the list in alpha order according to name (or El_Compare_)","MENU CONFIRM UPDATE_MENUS ","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_Sort_stub,TA_LeabraUnit_Group_Sort_MethArgs},
  {&TA_void,NULL,"Sort_"," implementation of sorting function","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_Sort__stub,TA_LeabraUnit_Group_Sort__MethArgs},
  {&TA_void,NULL,"UpdateAllIndicies"," update all indices of elements in list","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_UpdateAllIndicies_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","FirstEl"," for ta_group::FOR_ITR_EL macro returns first leaf element and inits indexes","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FirstEl_stub,TA_LeabraUnit_Group_FirstEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","NextEl"," for ta_group::FOR_ITR_EL macro returns next leaf element and incs indexes","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_NextEl_stub,TA_LeabraUnit_Group_NextEl_MethArgs},
  {&TA_void,NULL,"Duplicate"," duplicate (clone & add) elements of given list into this one","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Duplicate_stub,TA_LeabraUnit_Group_Duplicate_MethArgs},
  {&TA_void,NULL,"DupeUniqNameNew"," duplicate so result is unique names, replacing with new ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DupeUniqNameNew_stub,TA_LeabraUnit_Group_DupeUniqNameNew_MethArgs},
  {&TA_void,NULL,"DupeUniqNameOld"," duplicate so result is unique names, using old ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DupeUniqNameOld_stub,TA_LeabraUnit_Group_DupeUniqNameOld_MethArgs},
  {&TA_void,NULL,"Stealth_Borrow"," borrow without referencing the borrowed elements (i.e. use AddEl_())","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Stealth_Borrow_stub,TA_LeabraUnit_Group_Stealth_Borrow_MethArgs},
  {&TA_void,NULL,"Borrow"," borrow (link) elements of given list into this one","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Borrow_stub,TA_LeabraUnit_Group_Borrow_MethArgs},
  {&TA_void,NULL,"BorrowUnique"," borrow so result is unique list","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUnique_stub,TA_LeabraUnit_Group_BorrowUnique_MethArgs},
  {&TA_void,NULL,"BorrowUniqNameNew"," borrow so result is unique names, replacing with new ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUniqNameNew_stub,TA_LeabraUnit_Group_BorrowUniqNameNew_MethArgs},
  {&TA_void,NULL,"BorrowUniqNameOld"," borrow so result is unique names, using old ones where dupl","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_BorrowUniqNameOld_stub,TA_LeabraUnit_Group_BorrowUniqNameOld_MethArgs},
  {&TA_void,NULL,"Copy_Common"," apply copy operator to only those items in common between the two lists","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Common_stub,TA_LeabraUnit_Group_Copy_Common_MethArgs},
  {&TA_void,NULL,"Copy_Duplicate"," apply copy operator to items, use duplicate to add new ones from cp (if necc)","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Duplicate_stub,TA_LeabraUnit_Group_Copy_Duplicate_MethArgs},
  {&TA_void,NULL,"Copy_Borrow"," apply copy operator to items, use borrow to add new ones from cp (if necc)","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Borrow_stub,TA_LeabraUnit_Group_Copy_Borrow_MethArgs},
  {&TA_int,NULL,"NumListCols"," number of columns in a list view for this item type","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_NumListCols_stub,NULL},
  {&TA_taString,NULL,"GetColHeading"," header text for the indicated column","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_GetColHeading_stub,TA_LeabraUnit_Group_GetColHeading_MethArgs},
  {&TA_taString,NULL,"ChildGetColText"," itm_idx is a hint from source, -1 means not specified or ignore","","",
    0,4,3,0,NULL,cssElCFun_LeabraUnit_Group_ChildGetColText_stub,TA_LeabraUnit_Group_ChildGetColText_MethArgs},
  {&TA_void,NULL,"List"," List the group items","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_List_stub,TA_LeabraUnit_Group_List_MethArgs},
  {&TA_int,NULL,"FindEl"," find given element in list (-1 if not there)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindEl_stub,TA_LeabraUnit_Group_FindEl_MethArgs},
  {&TA_void,NULL,"AddEl"," append a new pointer to end of list","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddEl_stub,TA_LeabraUnit_Group_AddEl_MethArgs},
  {&TA_void,NULL,"Add"," add element to the list and 'own' item","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Add_stub,TA_LeabraUnit_Group_Add_MethArgs},
  {&TA_bool,NULL,"AddUnique"," add so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddUnique_stub,TA_LeabraUnit_Group_AddUnique_MethArgs},
  {&TA_bool,NULL,"AddUniqNameNew"," add so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddUniqNameNew_stub,TA_LeabraUnit_Group_AddUniqNameNew_MethArgs},
  {&TA_bool,NULL,"Insert"," insert element at index (-1 for end)","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Insert_stub,TA_LeabraUnit_Group_Insert_MethArgs},
  {&TA_bool,NULL,"Replace"," replace element at index with the new one","","",
    2,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_Replace_stub,TA_LeabraUnit_Group_Replace_MethArgs},
  {&TA_bool,NULL,"ReplaceEl"," replace given element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceEl_stub,TA_LeabraUnit_Group_ReplaceEl_MethArgs},
  {&TA_bool,NULL,"ReplaceName"," replace named element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceName_stub,TA_LeabraUnit_Group_ReplaceName_MethArgs},
  {&TA_bool,NULL,"RemoveEl"," Remove given item from list Remove given item from the list","MENU LABEL_Remove ARG_ON_OBJ UPDATE_MENUS ","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveEl_stub,TA_LeabraUnit_Group_RemoveEl_MethArgs},
  {&TA_bool,NULL,"DuplicateEl"," Duplicate given list item and Add to list","MENU ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_DuplicateEl_stub,TA_LeabraUnit_Group_DuplicateEl_MethArgs},
  {&TA_void,NULL,"Link"," Link an item to list without owning it","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Link_stub,TA_LeabraUnit_Group_Link_MethArgs},
  {&TA_bool,NULL,"LinkUnique"," link so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUnique_stub,TA_LeabraUnit_Group_LinkUnique_MethArgs},
  {&TA_bool,NULL,"LinkUniqNameNew"," link so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUniqNameNew_stub,TA_LeabraUnit_Group_LinkUniqNameNew_MethArgs},
  {&TA_bool,NULL,"InsertLink"," Insert a link at index (-1 for end)","MENU LABEL_Link UPDATE_MENUS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_InsertLink_stub,TA_LeabraUnit_Group_InsertLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLink"," replace element with a link to the new one","","",
    2,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLink_stub,TA_LeabraUnit_Group_ReplaceLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkEl"," replace given element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLinkEl_stub,TA_LeabraUnit_Group_ReplaceLinkEl_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkName"," replace given named element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceLinkName_stub,TA_LeabraUnit_Group_ReplaceLinkName_MethArgs},
  {&TA_void,NULL,"Push"," push item on stack (for temporary use, not 'owned')","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Push_stub,TA_LeabraUnit_Group_Push_MethArgs},
  {&TA_bool,NULL,"MoveEl"," Move item (from) to position of (to)","MENU LABEL_Move ARG_ON_OBJ UPDATE_MENUS ","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_MoveEl_stub,TA_LeabraUnit_Group_MoveEl_MethArgs},
  {&TA_bool,NULL,"Transfer"," Transfer element to this list","MENU MENU_ON_Edit NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Transfer_stub,TA_LeabraUnit_Group_Transfer_MethArgs},
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list move item so that it appears just before the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_MoveBefore_stub,TA_LeabraUnit_Group_MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list move item so that it appears just after the target item trg in the list","","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_MoveAfter_stub,TA_LeabraUnit_Group_MoveAfter_MethArgs},
  {&TA_int,NULL,"Dump_Save_PathR_impl","","","",
    0,3,1,0,NULL,cssElCFun_LeabraUnit_Group_Dump_Save_PathR_impl_stub,TA_LeabraUnit_Group_Dump_Save_PathR_impl_MethArgs},
  {&TA_int,NULL,"SetDefaultEl"," set the default element to be given item","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultEl_stub,TA_LeabraUnit_Group_SetDefaultEl_MethArgs},
  {&TA_int,NULL,"SetDefaultElName"," set the default element to be item with given name","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultElName_stub,TA_LeabraUnit_Group_SetDefaultElName_MethArgs},
  {&TA_int,NULL,"SetDefaultElType"," set the default element to be item with given type","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetDefaultElType_stub,TA_LeabraUnit_Group_SetDefaultElType_MethArgs},
  {&TA_void,NULL,"EnforceSize"," add or remove elements to force list to be of given size","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceSize_stub,TA_LeabraUnit_Group_EnforceSize_MethArgs},
  {&TA_void,NULL,"EnforceType"," enforce current type (all elements have to be of this type)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceType_stub,NULL},
  {&TA_void,NULL,"EnforceSameStru"," make the two lists identical in terms of size and types of objects","","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceSameStru_stub,TA_LeabraUnit_Group_EnforceSameStru_MethArgs},
  {&TA_bool,NULL,"ChangeType"," change type of item at index change type of item to new type, copying current info","MENU MENU_ON_Object UPDATE_MENUS ARG_ON_OBJ TYPE_ON_el_base ","",
    1,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ChangeType_stub,TA_LeabraUnit_Group_ChangeType_MethArgs},
  {&TA_int,NULL,"ReplaceType"," replace all items of old type with new type (returns number changed)","MENU MENU_ON_Object USE_RVAL UPDATE_MENUS TYPE_ON_el_base ","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReplaceType_stub,TA_LeabraUnit_Group_ReplaceType_MethArgs},
  {&TA_void,NULL,"SetBaseType"," set base (and default) type to given td","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetBaseType_stub,TA_LeabraUnit_Group_SetBaseType_MethArgs},
  {&TA_MemberDef_ptr,NULL,"ReturnFindMd"," return the find_md variable, initialized if necessary","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_ReturnFindMd_stub,NULL},
  {&TA_void,NULL,"InitLeafGp"," Initialize the leaf group","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_InitLeafGp_stub,NULL},
  {&TA_bool,NULL,"RemoveLeaf"," remove given leaf element Remove leaf element at leaf index","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeaf_stub,TA_LeabraUnit_Group_RemoveLeaf_MethArgs},
  {&TA_bool,NULL,"RemoveLeafName"," remove given named leaf element","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeafName_stub,TA_LeabraUnit_Group_RemoveLeafName_MethArgs},
  {&TA_bool,NULL,"RemoveLeafEl"," Remove given leaf element","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveLeafEl_stub,TA_LeabraUnit_Group_RemoveLeafEl_MethArgs},
  {&TA_bool,NULL,"RemoveGp"," remove group at given index remove given group","MENU FROM_GROUP_gp MENU_ON_Edit UPDATE_MENUS ","",
    1,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_RemoveGp_stub,TA_LeabraUnit_Group_RemoveGp_MethArgs},
  {&TA_TALOG_ptr,NULL,"EditSubGps"," edit the list of sub-groups (e.g., so you can move around subgroups)","MENU USE_RVAL ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_EditSubGps_stub,NULL},
  {&TA_void,NULL,"EnforceLeaves"," ensure that sz leaves exits by adding new ones to top group and removing old ones from end","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_EnforceLeaves_stub,TA_LeabraUnit_Group_EnforceLeaves_MethArgs},
  {&TA_int,NULL,"FindLeaf"," find given leaf element (-1 = not here) find named leaf element","","",
    2,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeaf_stub,TA_LeabraUnit_Group_FindLeaf_MethArgs},
  {&TA_int,NULL,"FindLeafEl"," find given leaf element -1 = not here.","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafEl_stub,TA_LeabraUnit_Group_FindLeafEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","SafeEl"," get element at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SafeEl_stub,TA_LeabraUnit_Group_SafeEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FastEl"," fast element (no checking)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FastEl_stub,TA_LeabraUnit_Group_FastEl_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","DefaultEl"," returns the element specified as the default for this group","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_DefaultEl_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","Edit_El"," Edit given group item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Edit_El_stub,TA_LeabraUnit_Group_Edit_El_MethArgs},
  {&TA_taGroup_ptr,NULL,"SafeGp"," get group at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SafeGp_stub,TA_LeabraUnit_Group_SafeGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"FastGp"," the sub group at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FastGp_stub,TA_LeabraUnit_Group_FastGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","Leaf"," get leaf element at index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Leaf_stub,TA_LeabraUnit_Group_Leaf_MethArgs},
  {&TA_taGroup_ptr,NULL,"LeafGp"," the group containing given leaf","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LeafGp_stub,TA_LeabraUnit_Group_LeafGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"RootGp"," the root group ('this' for the root group)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RootGp_stub,NULL},
  {&TA_taGroup_ptr,NULL,"FirstGp"," returns first leaf group and inits index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FirstGp_stub,TA_LeabraUnit_Group_FirstGp_MethArgs},
  {&TA_taGroup_ptr,NULL,"NextGp"," returns next leaf group and incs index","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_NextGp_stub,TA_LeabraUnit_Group_NextGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","NewEl"," Create and add (n_els) new element(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_NewEl_stub,TA_LeabraUnit_Group_NewEl_MethArgs},
  {&TA_taGroup_ptr,NULL,"NewGp"," Create and add (n_gps) new group(s) of given type","","",
    0,2,0,0,NULL,cssElCFun_LeabraUnit_Group_NewGp_stub,TA_LeabraUnit_Group_NewGp_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindName"," Find element with given name (nm) (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindName_stub,TA_LeabraUnit_Group_FindName_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindType"," find given type element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindType_stub,TA_LeabraUnit_Group_FindType_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Pop_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Peek_stub,NULL},
  {NULL,"taGroup_Unit_::Unit_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddUniqNameOld_stub,TA_LeabraUnit_Group_AddUniqNameOld_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_LinkUniqNameOld_stub,TA_LeabraUnit_Group_LinkUniqNameOld_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindLeafName"," Find element with given name (el_nm)","MENU MENU_ON_Edit USE_RVAL ARGC_1 LABEL_Find ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafName_stub,TA_LeabraUnit_Group_FindLeafName_MethArgs},
  {NULL,"taGroup_Unit_::Unit_ptr","FindLeafType"," find given type leaf element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_FindLeafType_stub,TA_LeabraUnit_Group_FindLeafType_MethArgs},
  {&TA_void,NULL,"Copy_Weights"," copies weights from other unit group (incl wts assoc with unit bias member)","MENU MENU_ON_Object ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Copy_Weights_stub,TA_LeabraUnit_Group_Copy_Weights_MethArgs},
  {&TA_void,NULL,"WriteWeights"," write weight values out in a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_WriteWeights_stub,TA_LeabraUnit_Group_WriteWeights_MethArgs},
  {&TA_void,NULL,"ReadWeights"," read weight values in from a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_ReadWeights_stub,TA_LeabraUnit_Group_ReadWeights_MethArgs},
  {&TA_bool,NULL,"Build"," for subgroups: build units to specs (true if changed)","MENU MENU_ON_Actions ","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Build_stub,NULL},
  {&TA_bool,NULL,"CheckBuild"," check if build needs to be performed (true if yes, false if no)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_CheckBuild_stub,NULL},
  {&TA_void,NULL,"LayoutUnits"," for subgroups: redistribute units within the given geometry of the group","","",
    0,1,0,0,NULL,cssElCFun_LeabraUnit_Group_LayoutUnits_stub,TA_LeabraUnit_Group_LayoutUnits_MethArgs},
  {&TA_void,NULL,"RecomputeGeometry"," re compute geometry based on parent layer","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_RecomputeGeometry_stub,NULL},
  {&TA_bool,NULL,"SetUnitSpec"," set for all units in group","MENU MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetUnitSpec_stub,TA_LeabraUnit_Group_SetUnitSpec_MethArgs},
  {&TA_bool,NULL,"SetConSpec"," set for all unit's connections in group","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_SetConSpec_stub,TA_LeabraUnit_Group_SetConSpec_MethArgs},
  {&TA_void,NULL,"TransformWeights"," apply given transformation to weights","MENU MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_TransformWeights_stub,TA_LeabraUnit_Group_TransformWeights_MethArgs},
  {&TA_void,NULL,"AddNoiseToWeights"," add noise to weights using given noise specification","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_AddNoiseToWeights_stub,TA_LeabraUnit_Group_AddNoiseToWeights_MethArgs},
  {&TA_int,NULL,"PruneCons"," remove weights that (after pre-proc) meet relation to compare val","MENU USE_RVAL ","",
    0,3,-1,0,NULL,cssElCFun_LeabraUnit_Group_PruneCons_stub,TA_LeabraUnit_Group_PruneCons_MethArgs},
  {&TA_int,NULL,"LesionCons"," remove connections with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_LesionCons_stub,TA_LeabraUnit_Group_LesionCons_MethArgs},
  {&TA_int,NULL,"LesionUnits"," remove units with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraUnit_Group_LesionUnits_stub,TA_LeabraUnit_Group_LesionUnits_MethArgs},
  {&TA_void,NULL,"UnitValuesToArray"," adds values of variable from the units into the given array","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnitValuesToArray_stub,TA_LeabraUnit_Group_UnitValuesToArray_MethArgs},
  {&TA_void,NULL,"UnitValuesFromArray"," sets unit values from values in the given array","","",
    0,2,-1,0,NULL,cssElCFun_LeabraUnit_Group_UnitValuesFromArray_stub,TA_LeabraUnit_Group_UnitValuesFromArray_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmCoord"," returns unit at given coordinates within layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_FindUnitFmCoord_stub,TA_LeabraUnit_Group_FindUnitFmCoord_MethArgs},
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_SetVals_stub,TA_LeabraUnit_Group_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_InitState_stub,TA_LeabraUnit_Group_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraUnit_Group_Inhib_Copy__stub,TA_LeabraUnit_Group_Inhib_Copy__MethArgs},
  NULL};
static int LeabraLayer::* TA_LeabraLayer_MbrOff;
static MemberDef_data TA_LeabraLayer_MemberDef[]={
  {&TA_LeabraLayerSpec_SPtr,NULL,"spec"," the spec for this layer: controls all functions of layer","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::spec))),0,NULL,0},
  {&TA_float,NULL,"stm_gain"," actual stim gain for soft clamping, can be incremented to ensure clamped units active","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::stm_gain))),0,NULL,0},
  {&TA_bool,NULL,"hard_clamped"," this layer is actually hard clamped","","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::hard_clamped))),0,NULL,0},
  {&TA_int,NULL,"prv_phase"," previous phase value (needed for 2nd plus phases and the like)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::prv_phase))),0,NULL,0},
  {&TA_float,NULL,"dav"," dopamine-like modulatory value (where applicable)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::dav))),0,NULL,0},
  {&TA_int,NULL,"da_updt"," true if da triggered an update (either + to store or - reset)","READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::da_updt))),0,NULL,0},
  {&TA_int_Array,NULL,"misc_iar"," misc int array of data","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_LeabraLayer_MbrOff=(int LeabraLayer::*)(&LeabraLayer::misc_iar))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetColText_MethArgs[]={
  {&TA_int,NULL,"col",""},
  {&TA_int,NULL,"itm_idx"," -1"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ChildQueryEditActions_MethArgs[]={
  {&TA_const_MemberDef_ptr,NULL,"md",""},
  {&TA_const_taBase_ptr,NULL,"child",""},
  {&TA_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int_ref,NULL,"allowed",""},
  {&TA_int_ref,NULL,"forbidden",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ChildEditAction_MethArgs[]={
  {&TA_const_MemberDef_ptr,NULL,"md",""},
  {&TA_taBase_ptr,NULL,"child",""},
  {&TA_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int,NULL,"ea",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_QueryEditActions_MethArgs[]={
  {&TA_const_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int_ref,NULL,"allowed",""},
  {&TA_int_ref,NULL,"forbidden",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_EditAction_MethArgs[]={
  {&TA_taiMimeSource_ptr,NULL,"ms",""},
  {&TA_int,NULL,"ea",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_UnSafeCopy_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CastCopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetOwner_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"tp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetPath_MethArgs[]={
  {&TA_TAPtr,NULL,"ta","((void *)0)"},
  {&TA_TAPtr,NULL,"par_stop","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindFromPath_MethArgs[]={
  {&TA_taString_ref,NULL,"path",""},
  {&TA_MemberDef_ptr_ref,NULL,"ret_md","no_mdef"},
  {&TA_int,NULL,"start","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_New_MethArgs[]={
  {&TA_int,NULL,"n_objs","0"},
  {&TA_TypeDef_ptr,NULL,"type","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraLayer_StructUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DataUpdate_MethArgs[]={
  {&TA_bool,NULL,"begin",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_AddDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_RemoveDataView_MethArgs[]={
  {&TA_taDataView_ptr,NULL,"dv",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_InheritsFrom_MethArgs[]={
  {&TA_const_char_ptr,NULL,"nm",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetEnumString_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_tp_nm",""},
  {&TA_int,NULL,"enum_val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetEnumVal_MethArgs[]={
  {&TA_const_char_ptr,NULL,"enum_nm",""},
  {&TA_taString_ref,NULL,"enum_tp_nm"," no_name"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Load_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Save_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SaveAs_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {&TA_TAPtr,NULL,"par","((void *)0)"},
  {&TA_int,NULL,"indent","0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReShowEdit_MethArgs[]={
  {&TA_bool,NULL,"force"," false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_CopyFrom_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_from",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CopyTo_MethArgs[]={
  {&TA_TAPtr,NULL,"cpy_to",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ChildUpdateAfterEdit_MethArgs[]={
  {&TA_TAPtr,NULL,"child",""},
  {&TA_bool_ref,NULL,"handled",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ChangeMyType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"new_type",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SelectForEdit_MethArgs[]={
  {&TA_MemberDef_ptr,NULL,"member",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SelectFunForEdit_MethArgs[]={
  {&TA_MethodDef_ptr,NULL,"function",""},
  {&TA_SelectEdit_ptr,NULL,"editor",""},
  {&TA_const_char_ptr,NULL,"extra_label",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CallFun_MethArgs[]={
  {&TA_const_char_ptr,NULL,"fun_name",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetAdapter_MethArgs[]={
  {&TA_taBaseAdapter_ptr,NULL,"adapter_",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetData_MethArgs[]={
  {&TA_SourceChannel_ptr,NULL,"ch",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Copy_Weights_MethArgs[]={
  {&TA_const_Layer_ptr,NULL,"src",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_WriteWeights_MethArgs[]={
  {&TA_ostream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReadWeights_MethArgs[]={
  {&TA_istream_ref,NULL,"strm",""},
  {NULL,"Con_Group::WtSaveFormat","fmt"," Con_Group::TEXT"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LayoutUnits_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u","((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ConnectFrom_MethArgs[]={
  {&TA_Layer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Send_NetToLay_MethArgs[]={
  {&TA_Layer_ptr,NULL,"tolay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Act_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_TransformWeights_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"trans",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_AddNoiseToWeights_MethArgs[]={
  {&TA_const_Random_ref,NULL,"noise_spec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PruneCons_MethArgs[]={
  {&TA_const_SimpleMathSpec_ref,NULL,"pre_proc",""},
  {NULL,"CountParam::Relation","rel",""},
  {&TA_float,NULL,"cmp_val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ProbAddCons_MethArgs[]={
  {&TA_float,NULL,"p_add_con",""},
  {&TA_float,NULL,"init_wt"," 0.0"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LesionCons_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraLayer_LesionUnits_MethArgs[]={
  {&TA_float,NULL,"p_lesion",""},
  {&TA_bool,NULL,"permute","true"},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetLayerSpec_MethArgs[]={
  {&TA_LayerSpec_ptr,NULL,"sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"unitspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetUnitType_MethArgs[]={
  {&TA_TypeDef_ptr,NULL,"td",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"conspec",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_CheckConfig_MethArgs[]={
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceUnitSpec_MethArgs[]={
  {&TA_UnitSpec_ptr,NULL,"old_sp",""},
  {&TA_UnitSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceConSpec_MethArgs[]={
  {&TA_ConSpec_ptr,NULL,"old_sp",""},
  {&TA_ConSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplacePrjnSpec_MethArgs[]={
  {&TA_ProjectionSpec_ptr,NULL,"old_sp",""},
  {&TA_ProjectionSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ReplaceLayerSpec_MethArgs[]={
  {&TA_LayerSpec_ptr,NULL,"old_sp",""},
  {&TA_LayerSpec_ptr,NULL,"new_sp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GridViewWeights_MethArgs[]={
  {&TA_GridLog_ptr,NULL,"grid_log",""},
  {&TA_Layer_ptr,NULL,"send_lay",""},
  {&TA_bool,NULL,"use_swt","false"},
  {&TA_int,NULL,"un_x","-1"},
  {&TA_int,NULL,"un_y","-1"},
  {&TA_int,NULL,"wt_x","-1"},
  {&TA_int,NULL,"wt_y","-1"},
  NULL};
static MethodArgs_data TA_LeabraLayer_WeightsToEnv_MethArgs[]={
  {&TA_Environment_ptr,NULL,"env",""},
  {&TA_Layer_ptr,NULL,"send_lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetExtFlag_MethArgs[]={
  {&TA_int,NULL,"flg",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_UnSetExtFlag_MethArgs[]={
  {&TA_int,NULL,"flg",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_FindUnitGpFmCoord_MethArgs[]={
  {&TA_const_TwoDCoord_ref,NULL,"coord",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_GetActGeomNoSpc_MethArgs[]={
  {&TA_PosTDCoord_ref,NULL,"nospc_geom",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_SetVals_MethArgs[]={
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_InitState_MethArgs[]={
  {&TA_LeabraLayerSpec_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Inhib_Copy__MethArgs[]={
  {&TA_const_LeabraInhib_ref,NULL,"cp",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_SetCurLrate_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_int,NULL,"epoch",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_HardClamp_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_NetScale_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Send_ClampNet_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Clamp_NetAvg_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_Inhib_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_InhibAvg_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PhaseInit_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayEvent_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayPhase_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_DecayPhase2_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_ExtToComp_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_TargExtToComp_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LeabraLayer_PostSettle_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool,NULL,"set_both","false"},
  NULL};
static MethodArgs_data TA_LeabraLayer_Compute_WtFmLin_MethArgs[]={
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LeabraLayer_MethodDef[]={
  {&TA_taString,NULL,"GetColText"," text for the indicated column in browse lists (may be ignored and controlled by parent list; by convention, 0=name, 1=type; itm_idx is usually ignored by items","","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_GetColText_stub,TA_LeabraLayer_GetColText_MethArgs},
  {&TA_void,NULL,"ChildQueryEditActions"," gives ops allowed on child, with ms being clipboard or drop contents, md valid if we are a member, o/w NULL","","",
    0,5,-1,0,NULL,cssElCFun_LeabraLayer_ChildQueryEditActions_stub,TA_LeabraLayer_ChildQueryEditActions_MethArgs},
  {&TA_int,NULL,"ChildEditAction"," note: multi source ops will have child=NULL","","",
    0,4,-1,0,NULL,cssElCFun_LeabraLayer_ChildEditAction_stub,TA_LeabraLayer_ChildEditAction_MethArgs},
  {&TA_void,NULL,"QueryEditActions"," ms is null for Src-op query","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_QueryEditActions_stub,TA_LeabraLayer_QueryEditActions_MethArgs},
  {&TA_int,NULL,"EditAction","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_EditAction_stub,TA_LeabraLayer_EditAction_MethArgs},
  {&TA_taDataLink_ptr,NULL,"GetDataLink"," forces creation; can still be NULL if the type doesn't support datalinks","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_GetDataLink_stub,NULL},
  {&TA_void,NULL,"UnRef"," note: overridden by ref-semantic classes to delete","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UnRef_stub,NULL},
  {&TA_void,NULL,"UnRefNoDelete","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UnRefNoDelete_stub,NULL},
  {&TA_void,NULL,"UnSafeCopy","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_UnSafeCopy_stub,TA_LeabraLayer_UnSafeCopy_MethArgs},
  {&TA_void,NULL,"CastCopyTo","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CastCopyTo_stub,TA_LeabraLayer_CastCopyTo_MethArgs},
  {&TA_TAPtr,NULL,"GetOwner","","","",
    3,1,-1,0,NULL,cssElCFun_LeabraLayer_GetOwner_stub,TA_LeabraLayer_GetOwner_MethArgs},
  {&TA_taString,NULL,"GetPath"," get path without name informtation, stop at par_stop if non-null","","",
    0,2,0,0,NULL,cssElCFun_LeabraLayer_GetPath_stub,TA_LeabraLayer_GetPath_MethArgs},
  {&TA_TAPtr,NULL,"FindFromPath"," find object from path (starting from this, and position start of the path)","","",
    0,3,1,0,NULL,cssElCFun_LeabraLayer_FindFromPath_stub,TA_LeabraLayer_FindFromPath_MethArgs},
  {&TA_TAPtr,NULL,"New"," Create n_objs objects of given type (type is optional)","","",
    0,2,0,0,NULL,cssElCFun_LeabraLayer_New_stub,TA_LeabraLayer_New_MethArgs},
  {&TA_void,NULL,"UpdateAfterEdit"," called after editing, or any user change to members (eg. in the interface, script)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UpdateAfterEdit_stub,NULL},
  {&TA_void,NULL,"UpdateAllViews"," called after data changes, to update views","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UpdateAllViews_stub,NULL},
  {&TA_void,NULL,"StructUpdate"," bracket structural changes with (nestable) true/false calls;","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_StructUpdate_stub,TA_LeabraLayer_StructUpdate_MethArgs},
  {&TA_void,NULL,"DataUpdate"," bracket data value changes with (nestable) true/false calls;","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DataUpdate_stub,TA_LeabraLayer_DataUpdate_MethArgs},
  {&TA_void,NULL,"AddDataView"," add a dataview (not usually overridden)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_AddDataView_stub,TA_LeabraLayer_AddDataView_MethArgs},
  {&TA_bool,NULL,"RemoveDataView"," removes a dataview (not usually overridden)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_RemoveDataView_stub,TA_LeabraLayer_RemoveDataView_MethArgs},
  {&TA_bool,NULL,"InheritsFrom"," does this inherit from given type?","","",
    2,1,-1,0,NULL,cssElCFun_LeabraLayer_InheritsFrom_stub,TA_LeabraLayer_InheritsFrom_MethArgs},
  {&TA_taString,NULL,"GetEnumString"," get the name corresponding to given enum value in enum type enum_tp_nm","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_GetEnumString_stub,TA_LeabraLayer_GetEnumString_MethArgs},
  {&TA_int,NULL,"GetEnumVal"," get the enum value corresponding to the given enum name (-1 if not found), and sets enum_tp_nm to name of type this enum belongs in (empty if not found)","","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_GetEnumVal_stub,TA_LeabraLayer_GetEnumVal_MethArgs},
  {&TA_int,NULL,"Load"," Load object data from a file","MENU MENU_ON_Object ARGC_1 UPDATE_MENUS MENU_CONTEXT ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_Load_stub,TA_LeabraLayer_Load_MethArgs},
  {&TA_int,NULL,"Save"," Save object data to a file","MENU MENU_ON_Object ARGC_1 QUICK_SAVE ","",
    0,3,1,0,NULL,cssElCFun_LeabraLayer_Save_stub,TA_LeabraLayer_Save_MethArgs},
  {&TA_int,NULL,"SaveAs"," Save object data to a new file","MENU ARGC_1 ","",
    0,3,1,0,NULL,cssElCFun_LeabraLayer_SaveAs_stub,TA_LeabraLayer_SaveAs_MethArgs},
  {&TA_int,NULL,"Edit"," Edit this object using the gui","MENU ARGC_0 MENU_ON_Object LABEL_Properties MENU_CONTEXT NO_SCRIPT ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Edit_stub,NULL},
  {&TA_bool,NULL,"CloseEdit"," close any open edit dialogs for this object","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CloseEdit_stub,NULL},
  {&TA_bool,NULL,"ReShowEdit"," reshows any open edit dialogs for this object","","",
    0,1,0,0,NULL,cssElCFun_LeabraLayer_ReShowEdit_stub,TA_LeabraLayer_ReShowEdit_MethArgs},
  {&TA_void,NULL,"Close"," PERMANENTLY Destroy this object! This is not Iconify.","MENU CONFIRM NO_REVERT_AFTER LABEL_Close_(Destroy) NO_MENU_CONTEXT ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Close_stub,NULL},
  {&TA_bool,NULL,"CopyFrom"," Copy from given object into this object","MENU MENU_ON_Object MENU_SEP_BEFORE TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CopyFrom_stub,TA_LeabraLayer_CopyFrom_MethArgs},
  {&TA_bool,NULL,"CopyTo"," Copy to given object from this object","MENU TYPE_ON_this NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CopyTo_stub,TA_LeabraLayer_CopyTo_MethArgs},
  {&TA_void,NULL,"ChildUpdateAfterEdit"," if enabled by UAE_OWNER directive, notifies parent; altered in lists/groups to send to their owner","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ChildUpdateAfterEdit_stub,TA_LeabraLayer_ChildUpdateAfterEdit_MethArgs},
  {&TA_bool,NULL,"DuplicateMe"," Make another copy of myself (done through owner)","MENU CONFIRM UPDATE_MENUS ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_DuplicateMe_stub,NULL},
  {&TA_bool,NULL,"ChangeMyType"," Change me into a different type of object, copying current info (done through owner)","MENU TYPE_this UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_ChangeMyType_stub,TA_LeabraLayer_ChangeMyType_MethArgs},
  {&TA_bool,NULL,"SelectForEdit"," select a given member for editing --<br>if already on dialog, removes it & returns false (else true)","","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_SelectForEdit_stub,TA_LeabraLayer_SelectForEdit_MethArgs},
  {&TA_bool,NULL,"SelectFunForEdit"," select a given function (method) for calling in a select edit dialog --\nif already on dialog, removes it & returns false (else true)","MENU ","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_SelectFunForEdit_stub,TA_LeabraLayer_SelectFunForEdit_MethArgs},
  {&TA_void,NULL,"Help"," get help on using this object","MENU ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Help_stub,NULL},
  {&TA_void,NULL,"CallFun"," call function of given name on this object, prompting for args using gui interface","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_CallFun_stub,TA_LeabraLayer_CallFun_MethArgs},
  {&TA_void,NULL,"SetAdapter","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetAdapter_stub,TA_LeabraLayer_SetAdapter_MethArgs},
  {&TA_taDataLink_ptr_ptr,NULL,"addr_data_link","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_addr_data_link_stub,NULL},
  {&TA_bool,NULL,"can_sequence_"," true if has a ISequencable interface","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_can_sequence__stub,NULL},
  {&TA_ISequencable_ptr,NULL,"sequencer_"," sequencing interface, if sequencable","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_sequencer__stub,NULL},
  {&TA_SourceChannel_List_ref,NULL,"source_channels_","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_source_channels__stub,NULL},
  {&TA_taMatrix_impl_ptr,NULL,"GetData","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_GetData_stub,TA_LeabraLayer_GetData_MethArgs},
  {&TA_void,NULL,"Copy_Weights"," copies weights from other layer (incl wts assoc with unit bias member)","MENU MENU_ON_Object MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Copy_Weights_stub,TA_LeabraLayer_Copy_Weights_MethArgs},
  {&TA_void,NULL,"WriteWeights"," write weight values out in a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_WriteWeights_stub,TA_LeabraLayer_WriteWeights_MethArgs},
  {&TA_void,NULL,"ReadWeights"," read weight values in from a simple ordered list of weights (optionally in binary fmt)","MENU EXT_strm_wts COMPRESS ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_ReadWeights_stub,TA_LeabraLayer_ReadWeights_MethArgs},
  {&TA_void,NULL,"Build"," build the units based on n_units, geom","MENU MENU_ON_Actions CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Build_stub,NULL},
  {&TA_void,NULL,"RecomputeGeometry"," recompute the layer's geometry specifcations","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RecomputeGeometry_stub,NULL},
  {&TA_void,NULL,"LayoutUnits"," layout the units according to layer geometry","ARGC_0 ","",
    0,1,0,0,NULL,cssElCFun_LeabraLayer_LayoutUnits_stub,TA_LeabraLayer_LayoutUnits_MethArgs},
  {&TA_void,NULL,"LayoutUnitGroups"," layout the unit groups according to layer group geometry and spacing","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_LayoutUnitGroups_stub,NULL},
  {&TA_void,NULL,"ConnectFrom"," connect one or more other layers to this layer","DYN12N ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_ConnectFrom_stub,TA_LeabraLayer_ConnectFrom_MethArgs},
  {&TA_void,NULL,"Connect"," connect the layer","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Connect_stub,NULL},
  {&TA_bool,NULL,"CheckBuild"," check if build needs to be performed (true if yes, false if no)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CheckBuild_stub,NULL},
  {&TA_bool,NULL,"CheckConnect"," check if connect needs to be performed (true if yes, false if no)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CheckConnect_stub,NULL},
  {&TA_void,NULL,"RemoveCons"," remove all connections in this layer","MENU CONFIRM MENU_SEP_BEFORE ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RemoveCons_stub,NULL},
  {&TA_void,NULL,"RemoveUnits"," remove all units in this layer (preserving groups)","MENU DYN1 ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RemoveUnits_stub,NULL},
  {&TA_void,NULL,"RemoveUnitGroups"," remove all unit groups in this layer","MENU DYN1 ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_RemoveUnitGroups_stub,NULL},
  {&TA_void,NULL,"PreConnect"," prepare to connect the layer (create con_groups)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_PreConnect_stub,NULL},
  {&TA_void,NULL,"SyncSendPrjns"," synchronize sending projections with the recv projections so everyone's happy","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_SyncSendPrjns_stub,NULL},
  {&TA_void,NULL,"DisConnect"," disconnect layer from all others","MENU CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_DisConnect_stub,NULL},
  {&TA_int,NULL,"CountRecvCons"," count recv connections for all units in layer","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CountRecvCons_stub,NULL},
  {&TA_void,NULL,"InitExterns"," Initializes external and target inputs","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitExterns_stub,NULL},
  {&TA_void,NULL,"InitDelta"," Initialize the unit deltas","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitDelta_stub,NULL},
  {&TA_void,NULL,"InitState"," Initialize the unit state variables","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitState_stub,NULL},
  {&TA_void,NULL,"ModifyState"," Alters state in an algorithm-specific way (e.g., decay)","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_ModifyState_stub,NULL},
  {&TA_void,NULL,"InitWtDelta"," Initialize the deltas","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitWtDelta_stub,NULL},
  {&TA_void,NULL,"InitWtState"," Initialize the weights","MENU LABEL_Init_Weights CONFIRM ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitWtState_stub,NULL},
  {&TA_void,NULL,"Compute_Net"," Compute NetInput","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Send_Net"," sender-based compute net-input sending to all layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Send_Net_stub,NULL},
  {&TA_void,NULL,"Send_NetToLay"," sender-based compute net-input sending only to tolay layer","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Send_NetToLay_stub,TA_LeabraLayer_Send_NetToLay_MethArgs},
  {&TA_void,NULL,"Send_NetToMe"," tell all layers that I receive from to send their net input to me","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Send_NetToMe_stub,NULL},
  {&TA_void,NULL,"Compute_Act"," Compute Activation","","",
    1,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Act_stub,TA_LeabraLayer_Compute_Act_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights for whole layer","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_UpdateWeights_stub,NULL},
  {&TA_void,NULL,"Compute_dWt"," update weights for whole layer","","",
    2,0,-1,0,NULL,cssElCFun_LeabraLayer_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"TransformWeights"," apply given transformation to weights","MENU MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_TransformWeights_stub,TA_LeabraLayer_TransformWeights_MethArgs},
  {&TA_void,NULL,"AddNoiseToWeights"," add noise to weights using given noise specification","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_AddNoiseToWeights_stub,TA_LeabraLayer_AddNoiseToWeights_MethArgs},
  {&TA_int,NULL,"PruneCons"," remove weights that (after pre-proc) meet relation to compare val","MENU USE_RVAL ","",
    0,3,-1,0,NULL,cssElCFun_LeabraLayer_PruneCons_stub,TA_LeabraLayer_PruneCons_MethArgs},
  {&TA_int,NULL,"ProbAddCons"," probabilistically add new connections (assuming prior pruning), init_wt = initial weight value of new connection","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_ProbAddCons_stub,TA_LeabraLayer_ProbAddCons_MethArgs},
  {&TA_int,NULL,"LesionCons"," remove connectiosn with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_LesionCons_stub,TA_LeabraLayer_LesionCons_MethArgs},
  {&TA_int,NULL,"LesionUnits"," remove units with prob p_lesion (permute = fixed no. lesioned)","MENU USE_RVAL ","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_LesionUnits_stub,TA_LeabraLayer_LesionUnits_MethArgs},
  {&TA_bool,NULL,"SetLayerSpec"," set the layer specification","MENU MENU_SEP_BEFORE ","",
    1,1,-1,0,NULL,cssElCFun_LeabraLayer_SetLayerSpec_stub,TA_LeabraLayer_SetLayerSpec_MethArgs},
  {&TA_LayerSpec_ptr,NULL,"GetLayerSpec","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_GetLayerSpec_stub,NULL},
  {&TA_bool,NULL,"SetUnitSpec"," set for all units in layer","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetUnitSpec_stub,TA_LeabraLayer_SetUnitSpec_MethArgs},
  {&TA_void,NULL,"SetUnitType"," set unit type for all units in layer (created by Build)","MENU TYPE_Unit ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetUnitType_stub,TA_LeabraLayer_SetUnitType_MethArgs},
  {&TA_bool,NULL,"SetConSpec"," set for all unit's connections in layer","MENU ","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetConSpec_stub,TA_LeabraLayer_SetConSpec_MethArgs},
  {&TA_bool,NULL,"CheckTypes"," check that the object and spec types are all ok","MENU USE_RVAL ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_CheckTypes_stub,NULL},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,2,1,0,NULL,cssElCFun_LeabraLayer_CheckConfig_stub,TA_LeabraLayer_CheckConfig_MethArgs},
  {&TA_void,NULL,"FixPrjnIndexes"," fix the projection indicies of the connection groups (other_idx)","MENU ","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_FixPrjnIndexes_stub,NULL},
  {&TA_int,NULL,"ReplaceUnitSpec"," switch any units/layers using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplaceUnitSpec_stub,TA_LeabraLayer_ReplaceUnitSpec_MethArgs},
  {&TA_int,NULL,"ReplaceConSpec"," switch any connections/projections using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplaceConSpec_stub,TA_LeabraLayer_ReplaceConSpec_MethArgs},
  {&TA_int,NULL,"ReplacePrjnSpec"," switch any projections using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplacePrjnSpec_stub,TA_LeabraLayer_ReplacePrjnSpec_MethArgs},
  {&TA_int,NULL,"ReplaceLayerSpec"," switch any layers using old_sp to using new_sp","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_ReplaceLayerSpec_stub,TA_LeabraLayer_ReplaceLayerSpec_MethArgs},
  {&TA_void,NULL,"GridViewWeights"," display entire set of weights from sending layer (use sending weights if use_swt) in grid log, -1 for x,y = use layer geometry (otherwise limits range, un= unit range, wt = weight (sending lay) range) ","MENU MENU_SEP_BEFORE NULL_OK ","",
    0,7,2,0,NULL,cssElCFun_LeabraLayer_GridViewWeights_stub,TA_LeabraLayer_GridViewWeights_MethArgs},
  {&TA_void,NULL,"WeightsToEnv"," send entire set of weights from sending layer to given environment (e.g., for analysis), with one event per receiving unit, and the pattern in the event reflects the weights into that unit","MENU NULL_OK ","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_WeightsToEnv_stub,TA_LeabraLayer_WeightsToEnv_MethArgs},
  {&TA_void,NULL,"SetExtFlag","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_SetExtFlag_stub,TA_LeabraLayer_SetExtFlag_MethArgs},
  {&TA_void,NULL,"UnSetExtFlag","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_UnSetExtFlag_stub,TA_LeabraLayer_UnSetExtFlag_MethArgs},
  {&TA_Unit_ptr,NULL,"FindUnitFmCoord"," get unit from coordinates, taking into account group geometry if present (subtracts any gp_spc -- as if it is not present).","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_FindUnitFmCoord_stub,TA_LeabraLayer_FindUnitFmCoord_MethArgs},
  {&TA_Unit_Group_ptr,NULL,"FindUnitGpFmCoord"," get unit group from group coordinates (i.e., within gp_geom, not unit coordinates)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_FindUnitGpFmCoord_stub,TA_LeabraLayer_FindUnitGpFmCoord_MethArgs},
  {&TA_void,NULL,"GetActGeomNoSpc"," get the actual geometry of the layer, subtracting any gp_spc that might be present (as if there were no spaces between unit groups)","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_GetActGeomNoSpc_stub,TA_LeabraLayer_GetActGeomNoSpc_MethArgs},
  {&TA_void,NULL,"Inhib_SetVals","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_SetVals_stub,TA_LeabraLayer_Inhib_SetVals_MethArgs},
  {&TA_void,NULL,"Inhib_ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_ResetSortBuf_stub,NULL},
  {&TA_void,NULL,"Inhib_InitState","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_InitState_stub,TA_LeabraLayer_Inhib_InitState_MethArgs},
  {&TA_void,NULL,"Inhib_Initialize","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_Initialize_stub,NULL},
  {&TA_void,NULL,"Inhib_Copy_","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Inhib_Copy__stub,TA_LeabraLayer_Inhib_Copy__MethArgs},
  {&TA_void,NULL,"InitInhib"," initialize inhibitory state","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_InitInhib_stub,NULL},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,2,-1,0,NULL,cssElCFun_LeabraLayer_SetCurLrate_stub,TA_LeabraLayer_SetCurLrate_MethArgs},
  {&TA_void,NULL,"Compute_Active_K","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Active_K_stub,NULL},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_HardClamp_stub,TA_LeabraLayer_Compute_HardClamp_MethArgs},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_NetScale_stub,TA_LeabraLayer_Compute_NetScale_MethArgs},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Send_ClampNet_stub,TA_LeabraLayer_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"Send_NetDelta","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_Send_NetDelta_stub,NULL},
  {&TA_void,NULL,"Compute_Clamp_NetAvg","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Clamp_NetAvg_stub,TA_LeabraLayer_Compute_Clamp_NetAvg_MethArgs},
  {&TA_void,NULL,"Compute_Inhib","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_Inhib_stub,TA_LeabraLayer_Compute_Inhib_MethArgs},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_InhibAvg_stub,TA_LeabraLayer_Compute_InhibAvg_MethArgs},
  {&TA_void,NULL,"PhaseInit","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_PhaseInit_stub,TA_LeabraLayer_PhaseInit_MethArgs},
  {&TA_void,NULL,"DecayEvent"," decay between events","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DecayEvent_stub,TA_LeabraLayer_DecayEvent_MethArgs},
  {&TA_void,NULL,"DecayPhase"," decay between phases","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DecayPhase_stub,TA_LeabraLayer_DecayPhase_MethArgs},
  {&TA_void,NULL,"DecayPhase2"," decay between 2nd set of phases","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_DecayPhase2_stub,TA_LeabraLayer_DecayPhase2_MethArgs},
  {&TA_void,NULL,"ExtToComp","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_ExtToComp_stub,TA_LeabraLayer_ExtToComp_MethArgs},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_TargExtToComp_stub,TA_LeabraLayer_TargExtToComp_MethArgs},
  {&TA_void,NULL,"PostSettle","","","",
    0,2,1,0,NULL,cssElCFun_LeabraLayer_PostSettle_stub,TA_LeabraLayer_PostSettle_MethArgs},
  {&TA_void,NULL,"Compute_WtFmLin","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraLayer_Compute_WtFmLin_stub,TA_LeabraLayer_Compute_WtFmLin_MethArgs},
  {&TA_void,NULL,"ResetSortBuf","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraLayer_ResetSortBuf_stub,NULL},
  NULL};
static int LeabraCycle::* TA_LeabraCycle_MbrOff;
static MemberDef_data TA_LeabraCycle_MemberDef[]={
  {&TA_LeabraSettle_ptr,NULL,"leabra_settle"," pointer to parent settle proc","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraCycle_MbrOff=(int LeabraCycle::*)(&LeabraCycle::leabra_settle))),0,NULL,0},
  NULL};
static MethodDef_data TA_LeabraCycle_MethodDef[]={
  {&TA_void,NULL,"Compute_Net","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Net_stub,NULL},
  {&TA_void,NULL,"Compute_Clamp_NetAvg","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Clamp_NetAvg_stub,NULL},
  {&TA_void,NULL,"Compute_Inhib","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Inhib_stub,NULL},
  {&TA_void,NULL,"Compute_InhibAvg","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_InhibAvg_stub,NULL},
  {&TA_void,NULL,"Compute_Act","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraCycle_Compute_Act_stub,NULL},
  NULL};
static int LeabraSettle::* TA_LeabraSettle_MbrOff;
static MemberDef_data TA_LeabraSettle_MemberDef[]={
  {&TA_LeabraTrial_ptr,NULL,"leabra_trial"," pointer to parent phase trial","NO_SUBTYPE READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::leabra_trial))),0,NULL,0},
  {&TA_int,NULL,"min_cycles"," minimum number of cycles to settle for","DEF_15 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::min_cycles))),0,NULL,0},
  {&TA_int,NULL,"min_cycles_phase2"," minimum number of cycles to settle for in second phase","DEF_15 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::min_cycles_phase2))),0,NULL,0},
  {&TA_int,NULL,"netin_mod"," net input computation modulus: how often to compute netinput vs. activation update (2 = faster)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::netin_mod))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send netin deltas instead of raw netin: more efficient (automatically sets corresponding unitspec flag)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LeabraSettle_MbrOff=(int LeabraSettle::*)(&LeabraSettle::send_delta))),0,NULL,0},
  NULL};
static MethodDef_data TA_LeabraSettle_MethodDef[]={
  {&TA_void,NULL,"Compute_Active_K","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_Active_K_stub,NULL},
  {&TA_void,NULL,"DecayEvent","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_DecayEvent_stub,NULL},
  {&TA_void,NULL,"DecayPhase","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_DecayPhase_stub,NULL},
  {&TA_void,NULL,"DecayPhase2","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_DecayPhase2_stub,NULL},
  {&TA_void,NULL,"PhaseInit","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_PhaseInit_stub,NULL},
  {&TA_void,NULL,"ExtToComp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_ExtToComp_stub,NULL},
  {&TA_void,NULL,"TargExtToComp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_TargExtToComp_stub,NULL},
  {&TA_void,NULL,"Compute_HardClamp","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_HardClamp_stub,NULL},
  {&TA_void,NULL,"Compute_NetScale","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_NetScale_stub,NULL},
  {&TA_void,NULL,"Send_ClampNet","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Send_ClampNet_stub,NULL},
  {&TA_void,NULL,"PostSettle","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_PostSettle_stub,NULL},
  {&TA_void,NULL,"PostSettle_NStdLay","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_PostSettle_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_dWt_NStdLay"," on non-nstandard layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_dWt_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_dWt"," on all layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"UpdateWeights","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraSettle_UpdateWeights_stub,NULL},
  NULL};
static EnumDef_data TA_LeabraTrial_StateInit[]={
  {"DO_NOTHING"," do nothing","",0},
  {"INIT_STATE"," initialize state","",1},
  {"DECAY_STATE"," decay the state","",2},
  NULL};
static EnumDef_data TA_LeabraTrial_Phase[]={
  {"MINUS_PHASE"," minus phase","",0},
  {"PLUS_PHASE"," plus phase","",1},
  {"MINUS_2"," second minus phase","",2},
  {"PLUS_2"," second plus phase","",3},
  NULL};
static EnumDef_data TA_LeabraTrial_PhaseOrder[]={
  {"MINUS_PLUS"," standard minus-plus (err and assoc)","",0},
  {"PLUS_ONLY"," only present the plus phase (hebbian-only)","",1},
  {"MINUS_PLUS_NOTHING"," auto-encoder version with final 'nothing' minus phase","",2},
  {"PLUS_NOTHING"," just the auto-encoder (no initial minus phase)","",3},
  {"MINUS_PLUS_PLUS"," two plus phases for gated context layer updating","",4},
  {"MINUS_PLUS_2"," two minus-plus phases (for pfc/bg system)","",5},
  NULL};
static EnumDef_data TA_LeabraTrial_FirstPlusdWt[]={
  {"NO_FIRST_DWT"," for three phase cases: don't change weights after first plus","",0},
  {"ONLY_FIRST_DWT"," for three phase cases: only change weights after first plus","",1},
  {"ALL_DWT"," for three phase cases: change weights after *both* post-minus phases","",2},
  NULL};
static int LeabraTrial::* TA_LeabraTrial_MbrOff;
static MemberDef_data TA_LeabraTrial_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," [Default: MINUS_PLUS] number and order of phases to present","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase_order))),0,NULL,0},
  {&TA_Counter,NULL,"phase_no"," Current phase number","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase_no))),0,NULL,0},
  {NULL,"::Phase","phase"," Type of current phase: minus or plus","","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::phase))),0,NULL,0},
  {NULL,"::StateInit","trial_init"," how to initialize network state at start of trial","DEF_DECAY_STATE ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::trial_init))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_stats"," don't do stats/logging in the plus phase","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::no_plus_stats))),0,NULL,0},
  {&TA_bool,NULL,"no_plus_test"," don't run the plus phase when testing","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::no_plus_test))),0,NULL,0},
  {NULL,"::FirstPlusdWt","first_plus_dwt"," how to change weights on first plus phase if 2 plus phases (applies only to standard leabralayer specs -- others must decide on their own!)","CONDEDIT_ON_phase_order:MINUS_PLUS_PLUS ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::first_plus_dwt))),0,NULL,0},
  {&TA_int,NULL,"cycle"," current cycle value as copied from settle process ONLY VALID DURING PROCESSING","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraTrial_MbrOff=(int LeabraTrial::*)(&LeabraTrial::cycle))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraTrial_GenCntrLog_MethArgs[]={
  {&TA_LogData_ptr,NULL,"ld",""},
  {&TA_bool,NULL,"gen",""},
  NULL};
static MethodDef_data TA_LeabraTrial_MethodDef[]={
  {&TA_void,NULL,"GenCntrLog"," generate log data for the counters","","",
    1,2,-1,0,NULL,cssElCFun_LeabraTrial_GenCntrLog_stub,TA_LeabraTrial_GenCntrLog_MethArgs},
  {&TA_void,NULL,"InitState","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_InitState_stub,NULL},
  {&TA_void,NULL,"SetCurLrate","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_SetCurLrate_stub,NULL},
  {&TA_void,NULL,"DecayState","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_DecayState_stub,NULL},
  {&TA_void,NULL,"EncodeState","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_EncodeState_stub,NULL},
  {&TA_void,NULL,"Compute_dWt_NStdLay"," on non-nstandard layers","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_Compute_dWt_NStdLay_stub,NULL},
  {&TA_void,NULL,"Compute_dWt","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_Compute_dWt_stub,NULL},
  {&TA_void,NULL,"UpdateWeights","","","",
    0,0,-1,0,NULL,cssElCFun_LeabraTrial_UpdateWeights_stub,NULL},
  NULL};
static EnumDef_data TA_LeabraMaxDa_dAType[]={
  {"DA_ONLY"," just use da","",0},
  {"INET_ONLY"," just use inet","",1},
  {"INET_DA"," use inet if no activity, then use da","",2},
  NULL};
static int LeabraMaxDa::* TA_LeabraMaxDa_MbrOff;
static MemberDef_data TA_LeabraMaxDa_MemberDef[]={
  {&TA_LeabraSettle_ptr,NULL,"settle_proc"," the settle process","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::settle_proc))),0,NULL,0},
  {NULL,"::dAType","da_type"," type of activation change measure to use","DEF_INET_DA ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::da_type))),0,NULL,0},
  {&TA_float,NULL,"inet_scale"," how to scale the inet measure to be like da","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::inet_scale))),0,NULL,0},
  {&TA_float,NULL,"lay_avg_thr"," threshold for layer average activation to switch to da fm Inet","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::lay_avg_thr))),0,NULL,0},
  {&TA_StatVal,NULL,"da"," absolute value of activation change","","",
    *((ta_memb_ptr*)&(TA_LeabraMaxDa_MbrOff=(int LeabraMaxDa::*)(&LeabraMaxDa::da))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraMaxDa_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraMaxDa_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraMaxDa_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"unit",""},
  NULL};
static MethodDef_data TA_LeabraMaxDa_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraMaxDa_RecvCon_Run_stub,TA_LeabraMaxDa_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraMaxDa_SendCon_Run_stub,TA_LeabraMaxDa_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraMaxDa_Unit_Stat_stub,TA_LeabraMaxDa_Unit_Stat_MethArgs},
  NULL};
static int WtScaleSpec::* TA_WtScaleSpec_MbrOff;
static MemberDef_data TA_WtScaleSpec_MemberDef[]={
  {&TA_float,NULL,"abs"," absolute scaling (not subject to normalization: directly multiplies weight values)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_WtScaleSpec_MbrOff=(int WtScaleSpec::*)(&WtScaleSpec::abs))),0,NULL,0},
  {&TA_float,NULL,"rel"," [Default: 1] relative scaling (subject to normalization across all other projections into unit)","","",
    *((ta_memb_ptr*)&(TA_WtScaleSpec_MbrOff=(int WtScaleSpec::*)(&WtScaleSpec::rel))),0,NULL,0},
  NULL};
static MethodDef_data TA_WtScaleSpec_MethodDef[]={
  {&TA_float,NULL,"NetScale","","","",
    0,0,-1,0,NULL,cssElCFun_WtScaleSpec_NetScale_stub,NULL},
  NULL};
static int WtSigSpec::* TA_WtSigSpec_MbrOff;
static MemberDef_data TA_WtSigSpec_MemberDef[]={
  {&TA_float,NULL,"gain"," gain (contrast, sharpness) of the weight contrast function (1 = linear)","DEF_6 ","",
    *((ta_memb_ptr*)&(TA_WtSigSpec_MbrOff=(int WtSigSpec::*)(&WtSigSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"off"," offset of the function (1=centered at .5, >1=higher, <1=lower)","DEF_1.25 ","",
    *((ta_memb_ptr*)&(TA_WtSigSpec_MbrOff=(int WtSigSpec::*)(&WtSigSpec::off))),0,NULL,0},
  NULL};
static MethodArgs_data TA_WtSigSpec_SigFun_MethArgs[]={
  {&TA_float,NULL,"w",""},
  {&TA_float,NULL,"gain",""},
  {&TA_float,NULL,"off",""},
  NULL};
static MethodArgs_data TA_WtSigSpec_SigFunInv_MethArgs[]={
  {&TA_float,NULL,"w",""},
  {&TA_float,NULL,"gain",""},
  {&TA_float,NULL,"off",""},
  NULL};
static MethodDef_data TA_WtSigSpec_MethodDef[]={
  {&TA_float,NULL,"SigFun"," function for implementing inverse of weight sigmoid","","",
    0,3,-1,1,(ta_void_fun)(WtSigSpec::SigFun),cssElCFun_WtSigSpec_SigFun_stub,TA_WtSigSpec_SigFun_MethArgs},
  {&TA_float,NULL,"SigFunInv","","","",
    0,3,-1,1,(ta_void_fun)(WtSigSpec::SigFunInv),cssElCFun_WtSigSpec_SigFunInv_stub,TA_WtSigSpec_SigFunInv_MethArgs},
  NULL};
static int LearnMixSpec::* TA_LearnMixSpec_MbrOff;
static MemberDef_data TA_LearnMixSpec_MemberDef[]={
  {&TA_float,NULL,"hebb"," [Default: .01] amount of hebbian learning (should be relatively small, can be effective at .0001)","","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::hebb))),0,NULL,0},
  {&TA_float,NULL,"err"," [Default: .99] amount of error driven learning, automatically computed to be 1-hebb","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::err))),0,NULL,0},
  {&TA_bool,NULL,"err_sb"," apply exponential soft-bounding to the error learning component","DEF_true ","",
    *((ta_memb_ptr*)&(TA_LearnMixSpec_MbrOff=(int LearnMixSpec::*)(&LearnMixSpec::err_sb))),0,NULL,0},
  NULL};
static int SAvgCorSpec::* TA_SAvgCorSpec_MbrOff;
static MemberDef_data TA_SAvgCorSpec_MemberDef[]={
  {&TA_float,NULL,"cor"," proportion of correction to apply (0=none, 1=all, .5=half, etc)","DEF_0.4 ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::cor))),0,NULL,0},
  {&TA_float,NULL,"thresh"," threshold of sending average activation below which learning does not occur (prevents learning when there is no input)","DEF_0.001 ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::thresh))),0,NULL,0},
  {&TA_bool,NULL,"norm_con_n"," in normalizing netinput, divide by the actual number of connections (recv group n), not the overall number of units in the sending layer; this is good when units only receive from a small fraction of sending layer units","DEF_false AKA_div_gp_n ","",
    *((ta_memb_ptr*)&(TA_SAvgCorSpec_MbrOff=(int SAvgCorSpec::*)(&SAvgCorSpec::norm_con_n))),0,NULL,0},
  NULL};
static EnumDef_data TA_ActFunSpec_IThrFun[]={
  {"STD"," include all currents (except bias weights) in inhibitory threshold computation","",0},
  {"NO_A"," exclude gc.a current: allows accommodation to knock out units from kwta active list, without other units coming in to take their place","",1},
  {"NO_H"," exclude gc.h current: prevent hysteresis current from affecting inhibitory threshold computation","",2},
  {"NO_AH"," exclude gc.a and gc.h currents: prevent both accommodation and hysteresis currents from affecting inhibitory threshold computation","",3},
  NULL};
static int ActFunSpec::* TA_ActFunSpec_MbrOff;
static MemberDef_data TA_ActFunSpec_MemberDef[]={
  {&TA_float,NULL,"thr"," threshold value Theta (Q) for firing output activation ","DEF_0.25 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::thr))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain (gamma) of the sigmoidal rate-coded activation function ","DEF_600 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"nvar"," variance of the Gaussian noise kernel for convolving with XX1 in NOISY_XX1","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::nvar))),0,NULL,0},
  {&TA_float,NULL,"avg_dt"," time constant for integrating activation average (computed across trials)","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::avg_dt))),0,NULL,0},
  {&TA_bool,NULL,"send_delta"," send only changes in activation when it changes beyond opt_thresh.delta: COPIED FROM LeabraSettle!","DEF_false READ_ONLY ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::send_delta))),0,NULL,0},
  {NULL,"::IThrFun","i_thr"," how to compute the inhibitory threshold for kWTA functions (what currents to include or exclude in determining what amount of inhibition would keep the unit just at threshold firing)","DEF_STD ","",
    *((ta_memb_ptr*)&(TA_ActFunSpec_MbrOff=(int ActFunSpec::*)(&ActFunSpec::i_thr))),0,NULL,0},
  NULL};
static int SpikeFunSpec::* TA_SpikeFunSpec_MbrOff;
static MemberDef_data TA_SpikeFunSpec_MemberDef[]={
  {&TA_float,NULL,"decay"," exponential decay of activation produced by a spike (act(t+1) = act(t) * (1-decay))","DEF_0.05 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::decay))),0,NULL,0},
  {&TA_float,NULL,"v_m_r"," post-spiking membrane potential to reset to, produces refractory effect","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::v_m_r))),0,NULL,0},
  {&TA_float,NULL,"eq_gain"," gain for computing act_eq relative to actual average: act_eq = eq_gain * (spikes/cycles)","DEF_10 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::eq_gain))),0,NULL,0},
  {&TA_float,NULL,"eq_dt"," if non-zero, eq is computed as a running average with this time constant","DEF_0.02 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::eq_dt))),0,NULL,0},
  {&TA_float,NULL,"hard_gain"," gain for hard-clamped external inputs, mutliplies ext. constant external inputs otherwise have too much influence compared to spiking ones: Note: soft clamping is strongly recommended","DEF_0.4 ","",
    *((ta_memb_ptr*)&(TA_SpikeFunSpec_MbrOff=(int SpikeFunSpec::*)(&SpikeFunSpec::hard_gain))),0,NULL,0},
  NULL};
static EnumDef_data TA_DepressSpec_PSpike[]={
  {"P_NXX1"," probability of spiking is based on NOISY_XX1 f(Vm - Q)","",0},
  {"P_LINEAR"," probability of spiking is based on LINEAR f(Vm - Q)","",1},
  NULL};
static int DepressSpec::* TA_DepressSpec_MbrOff;
static MemberDef_data TA_DepressSpec_MemberDef[]={
  {NULL,"::PSpike","p_spike"," how to compute the probability of spiking, which is then mult by amp of spiking","","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::p_spike))),0,NULL,0},
  {&TA_float,NULL,"rec"," rate of recovery of spike amplitude (determines overall time constant of depression function)","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::rec))),0,NULL,0},
  {&TA_float,NULL,"asymp_act"," asymptotic activation value (as proportion of 1) for a fully active unit (determines depl value)","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::asymp_act))),0,NULL,0},
  {&TA_float,NULL,"depl"," rate of depletion of spike amplitude as a function of activation output (computed from rec, asymp_act)","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::depl))),0,NULL,0},
  {&TA_float,NULL,"max_amp"," maximum amplitude required to maintain asymptotic firing at normal clamp levels (copied to act_range.max) ","READ_ONLY SHOW ","",
    *((ta_memb_ptr*)&(TA_DepressSpec_MbrOff=(int DepressSpec::*)(&DepressSpec::max_amp))),0,NULL,0},
  NULL};
static int OptThreshSpec::* TA_OptThreshSpec_MbrOff;
static MemberDef_data TA_OptThreshSpec_MemberDef[]={
  {&TA_float,NULL,"send"," don't send activation when act <= send -- greatly speeds processing","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::send))),0,NULL,0},
  {&TA_float,NULL,"delta"," don't send activation changes until they exceed this threshold: only for when LeabraSettle::send_delta is on!","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::delta))),0,NULL,0},
  {&TA_float,NULL,"learn"," don't learn on recv unit weights when both phase acts <= learn","DEF_0.01 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::learn))),0,NULL,0},
  {&TA_bool,NULL,"updt_wts"," whether to apply learn threshold to updating weights (otherwise always update)","DEF_true ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::updt_wts))),0,NULL,0},
  {&TA_float,NULL,"phase_dif"," don't learn when +/- phase difference ratio (- / +) < phase_dif (.8 when used, but off by default)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_OptThreshSpec_MbrOff=(int OptThreshSpec::*)(&OptThreshSpec::phase_dif))),0,NULL,0},
  NULL};
static int DtSpec::* TA_DtSpec_MbrOff;
static MemberDef_data TA_DtSpec_MemberDef[]={
  {&TA_float,NULL,"vm"," membrane potential time constant -- if units oscillate between 0 and 1, this is too high! reduce.","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::vm))),0,NULL,0},
  {&TA_float,NULL,"net"," net input time constant -- how fast to update net input (damps oscillations)","DEF_0.7 ","",
    *((ta_memb_ptr*)&(TA_DtSpec_MbrOff=(int DtSpec::*)(&DtSpec::net))),0,NULL,0},
  NULL};
static int LeabraChannels::* TA_LeabraChannels_MbrOff;
static MemberDef_data TA_LeabraChannels_MemberDef[]={
  {&TA_float,NULL,"e"," Excitatory (glutamatergic synaptic sodium (Na) channel)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::e))),0,NULL,0},
  {&TA_float,NULL,"l"," Constant leak (potassium, K+) channel ","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::l))),0,NULL,0},
  {&TA_float,NULL,"i"," inhibitory","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::i))),0,NULL,0},
  {&TA_float,NULL,"h"," hysteresis (Ca)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::h))),0,NULL,0},
  {&TA_float,NULL,"a"," accomodation (k)","","",
    *((ta_memb_ptr*)&(TA_LeabraChannels_MbrOff=(int LeabraChannels::*)(&LeabraChannels::a))),0,NULL,0},
  NULL};
static int VChanSpec::* TA_VChanSpec_MbrOff;
static MemberDef_data TA_VChanSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," true if channel is on","DEF_false ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::on))),0,NULL,0},
  {&TA_float,NULL,"b_dt"," time constant for integrating basis variable (basis ~ intracellular calcium which builds up slowly as function of activation)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::b_dt))),0,NULL,0},
  {&TA_float,NULL,"a_thr"," activation threshold of the channel: when basis > a_thr, conductance starts to build up (channels open)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::a_thr))),0,NULL,0},
  {&TA_float,NULL,"d_thr"," deactivation threshold of the channel: when basis < d_thr, conductance diminshes (channels close)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::d_thr))),0,NULL,0},
  {&TA_float,NULL,"g_dt"," time constant for changing conductance (activating or deactivating)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::g_dt))),0,NULL,0},
  {&TA_bool,NULL,"init"," initialize variables when state is intialized between trials (else with weights)","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_VChanSpec_MbrOff=(int VChanSpec::*)(&VChanSpec::init))),0,NULL,0},
  NULL};
static MethodArgs_data TA_VChanSpec_UpdateBasis_MethArgs[]={
  {&TA_float_ref,NULL,"basis",""},
  {&TA_bool_ref,NULL,"on_off",""},
  {&TA_float_ref,NULL,"gc",""},
  {&TA_float,NULL,"act",""},
  NULL};
static MethodDef_data TA_VChanSpec_MethodDef[]={
  {&TA_void,NULL,"UpdateBasis","","","",
    0,4,-1,0,NULL,cssElCFun_VChanSpec_UpdateBasis_stub,TA_VChanSpec_UpdateBasis_MethArgs},
  NULL};
static int ActRegSpec::* TA_ActRegSpec_MbrOff;
static MemberDef_data TA_ActRegSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to activity regulation is on (active) or not","","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::on))),0,NULL,0},
  {&TA_float,NULL,"min"," increase weights for units below this level of average activation","CONDEDIT_ON_on:true DEF_0 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::min))),0,NULL,0},
  {&TA_float,NULL,"max"," decrease weights for units above this level of average activation ","CONDEDIT_ON_on:true DEF_0.35 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::max))),0,NULL,0},
  {&TA_float,NULL,"wt_dt"," pre-lrate rate constant for making weight changes to rectify over-activation (dwt = cur_lrate * wt_dt * wt)","CONDEDIT_ON_on:true DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_ActRegSpec_MbrOff=(int ActRegSpec::*)(&ActRegSpec::wt_dt))),0,NULL,0},
  NULL};
static int VChanBasis::* TA_VChanBasis_MbrOff;
static MemberDef_data TA_VChanBasis_MemberDef[]={
  {&TA_float,NULL,"hyst"," hysteresis","","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::hyst))),0,NULL,0},
  {&TA_float,NULL,"acc"," fast accomodation","","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::acc))),0,NULL,0},
  {&TA_bool,NULL,"hyst_on"," binary thresholded mode state variable, hyst","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::hyst_on))),0,NULL,0},
  {&TA_bool,NULL,"acc_on"," binary thresholded mode state variable, acc","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::acc_on))),0,NULL,0},
  {&TA_float,NULL,"g_h"," hysteresis conductance","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::g_h))),0,NULL,0},
  {&TA_float,NULL,"g_a"," accomodation conductance","NO_VIEW ","",
    *((ta_memb_ptr*)&(TA_VChanBasis_MbrOff=(int VChanBasis::*)(&VChanBasis::g_a))),0,NULL,0},
  NULL};
static int LeabraUnitChans::* TA_LeabraUnitChans_MbrOff;
static MemberDef_data TA_LeabraUnitChans_MemberDef[]={
  {&TA_float,NULL,"l"," leak","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::l))),0,NULL,0},
  {&TA_float,NULL,"i"," inhibitory","DMEM_SHARE_SET_1 ","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::i))),0,NULL,0},
  {&TA_float,NULL,"h"," hysteresis (Ca)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::h))),0,NULL,0},
  {&TA_float,NULL,"a"," accomodation (K)","","",
    *((ta_memb_ptr*)&(TA_LeabraUnitChans_MbrOff=(int LeabraUnitChans::*)(&LeabraUnitChans::a))),0,NULL,0},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Find_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Remove_MethArgs[]={
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__SafeEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FastEl_MethArgs[]={
  {&TA_int,NULL,"i",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Edit_El_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FindName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"item_nm",""},
  {&TA_int_ref,NULL,"idx","Idx"},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUniqNameOld_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUniqNameOld_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__FindEl_MethArgs[]={
  {NULL,"::const_LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Add_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUnique_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__AddUniqNameNew_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Insert_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  {&TA_int,NULL,"idx",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Replace_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","old_it",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__RemoveEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__DuplicateEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Link_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUnique_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__LinkUniqNameNew_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__InsertLink_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  {&TA_int,NULL,"idx"," -1"},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLink_MethArgs[]={
  {&TA_int,NULL,"old_idx",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLinkEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","old_it",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__ReplaceLinkName_MethArgs[]={
  {&TA_const_char_ptr,NULL,"old_nm",""},
  {NULL,"::LeabraUnit_ptr","new_it",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Push_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveEl_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","from",""},
  {NULL,"::LeabraUnit_ptr","to",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__Transfer_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveBefore_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","trg",""},
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodArgs_data TA_taPtrList_LeabraUnit__MoveAfter_MethArgs[]={
  {NULL,"::LeabraUnit_ptr","trg",""},
  {NULL,"::LeabraUnit_ptr","item",""},
  NULL};
static MethodDef_data TA_taPtrList_LeabraUnit__MethodDef[]={
  {&TA_int,NULL,"Find"," find named element in list find element in list (-1 if not there)","","",
    2,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Find_stub,TA_taPtrList_LeabraUnit__Find_MethArgs},
  {&TA_bool,NULL,"Remove"," remove (and delete) element from list at index Remove element at given index","","",
    4,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Remove_stub,TA_taPtrList_LeabraUnit__Remove_MethArgs},
  {NULL,"::LeabraUnit_ptr","SafeEl"," element at index","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__SafeEl_stub,TA_taPtrList_LeabraUnit__SafeEl_MethArgs},
  {NULL,"::LeabraUnit_ptr","FastEl"," fast element (no range checking)","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FastEl_stub,TA_taPtrList_LeabraUnit__FastEl_MethArgs},
  {NULL,"::LeabraUnit_ptr","Edit_El"," Edit given list item","MENU MENU_ON_Edit USE_RVAL ARG_ON_OBJ ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Edit_El_stub,TA_taPtrList_LeabraUnit__Edit_El_MethArgs},
  {NULL,"::LeabraUnit_ptr","FindName"," find given named element (NULL = not here), sets idx","","",
    0,2,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FindName_stub,TA_taPtrList_LeabraUnit__FindName_MethArgs},
  {NULL,"::LeabraUnit_ptr","Pop"," pop the last element off the stack","","",
    0,0,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Pop_stub,NULL},
  {NULL,"::LeabraUnit_ptr","Peek"," peek at the last element on the stack","","",
    0,0,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Peek_stub,NULL},
  {NULL,"::LeabraUnit_ptr","AddUniqNameOld"," add so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUniqNameOld_stub,TA_taPtrList_LeabraUnit__AddUniqNameOld_MethArgs},
  {NULL,"::LeabraUnit_ptr","LinkUniqNameOld"," link so that name is unique, old used if dupl, returns one used","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUniqNameOld_stub,TA_taPtrList_LeabraUnit__LinkUniqNameOld_MethArgs},
  {&TA_int,NULL,"FindEl"," find given element in list (-1 if not there)","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__FindEl_stub,TA_taPtrList_LeabraUnit__FindEl_MethArgs},
  {&TA_void,NULL,"AddEl"," append a new pointer to end of list","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddEl_stub,TA_taPtrList_LeabraUnit__AddEl_MethArgs},
  {&TA_void,NULL,"Add"," add element to the list and 'own' item","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Add_stub,TA_taPtrList_LeabraUnit__Add_MethArgs},
  {&TA_bool,NULL,"AddUnique"," add so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUnique_stub,TA_taPtrList_LeabraUnit__AddUnique_MethArgs},
  {&TA_bool,NULL,"AddUniqNameNew"," add so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__AddUniqNameNew_stub,TA_taPtrList_LeabraUnit__AddUniqNameNew_MethArgs},
  {&TA_bool,NULL,"Insert"," Add or insert element at idx (-1 for end)","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Insert_stub,TA_taPtrList_LeabraUnit__Insert_MethArgs},
  {&TA_bool,NULL,"Replace"," replace element at index with the new one","","",
    2,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Replace_stub,TA_taPtrList_LeabraUnit__Replace_MethArgs},
  {&TA_bool,NULL,"ReplaceEl"," replace given element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceEl_stub,TA_taPtrList_LeabraUnit__ReplaceEl_MethArgs},
  {&TA_bool,NULL,"ReplaceName"," replace named element with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceName_stub,TA_taPtrList_LeabraUnit__ReplaceName_MethArgs},
  {&TA_bool,NULL,"RemoveEl"," Remove given item from list","MENU LABEL_Remove ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__RemoveEl_stub,TA_taPtrList_LeabraUnit__RemoveEl_MethArgs},
  {&TA_bool,NULL,"DuplicateEl"," Duplicate given list item and Add to list","MENU ARG_ON_OBJ UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__DuplicateEl_stub,TA_taPtrList_LeabraUnit__DuplicateEl_MethArgs},
  {&TA_void,NULL,"Link"," Link an item to list without owning it","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Link_stub,TA_taPtrList_LeabraUnit__Link_MethArgs},
  {&TA_bool,NULL,"LinkUnique"," link so that object is unique, true if unique","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUnique_stub,TA_taPtrList_LeabraUnit__LinkUnique_MethArgs},
  {&TA_bool,NULL,"LinkUniqNameNew"," link so that name is unique, true if unique, new replaces existing","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__LinkUniqNameNew_stub,TA_taPtrList_LeabraUnit__LinkUniqNameNew_MethArgs},
  {&TA_bool,NULL,"InsertLink"," Insert a link at index (-1 for end)","MENU LABEL_Link UPDATE_MENUS ","",
    0,2,1,0,NULL,cssElCFun_taPtrList_LeabraUnit__InsertLink_stub,TA_taPtrList_LeabraUnit__InsertLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLink"," replace element with a link to the new one","","",
    2,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLink_stub,TA_taPtrList_LeabraUnit__ReplaceLink_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkEl"," replace given element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLinkEl_stub,TA_taPtrList_LeabraUnit__ReplaceLinkEl_MethArgs},
  {&TA_bool,NULL,"ReplaceLinkName"," replace given named element (if on list) with the new one","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__ReplaceLinkName_stub,TA_taPtrList_LeabraUnit__ReplaceLinkName_MethArgs},
  {&TA_void,NULL,"Push"," push item on stack (for temporary use, not 'owned')","","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Push_stub,TA_taPtrList_LeabraUnit__Push_MethArgs},
  {&TA_bool,NULL,"MoveEl"," Move item (from) to position of (to)","MENU LABEL_Move ARG_ON_OBJ UPDATE_MENUS ","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveEl_stub,TA_taPtrList_LeabraUnit__MoveEl_MethArgs},
  {&TA_bool,NULL,"Transfer"," Transfer item to this list","MENU MENU_ON_Edit NO_SCOPE UPDATE_MENUS ","",
    0,1,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__Transfer_stub,TA_taPtrList_LeabraUnit__Transfer_MethArgs},
  {&TA_bool,NULL,"MoveBefore"," move item so that it appears just before the target item trg in the list","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveBefore_stub,TA_taPtrList_LeabraUnit__MoveBefore_MethArgs},
  {&TA_bool,NULL,"MoveAfter"," move item so that it appears just after the target item trg in the list","","",
    0,2,-1,0,NULL,cssElCFun_taPtrList_LeabraUnit__MoveAfter_stub,TA_taPtrList_LeabraUnit__MoveAfter_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraSort_FindNewNetPos_MethArgs[]={
  {&TA_float,NULL,"nw_net",""},
  NULL};
static MethodArgs_data TA_LeabraSort_FastInsertLink_MethArgs[]={
  {&TA_void_ptr,NULL,"it",""},
  {&TA_int,NULL,"where",""},
  NULL};
static MethodDef_data TA_LeabraSort_MethodDef[]={
  {&TA_int,NULL,"FindNewNetPos"," find position in list for a new net value","","",
    0,1,-1,0,NULL,cssElCFun_LeabraSort_FindNewNetPos_stub,TA_LeabraSort_FindNewNetPos_MethArgs},
  {&TA_void,NULL,"FastInsertLink"," faster version of insert link fun","","",
    0,2,-1,0,NULL,cssElCFun_LeabraSort_FastInsertLink_stub,TA_LeabraSort_FastInsertLink_MethArgs},
  NULL};
static EnumDef_data TA_KWTASpec_K_From[]={
  {"USE_K"," use the k specified directly","",0},
  {"USE_PCT"," use the percentage pct to compute the k as a function of layer size","",1},
  {"USE_PAT_K"," use the activity level of the current event pattern (k = of units > pat_q)"," ",2},
  NULL};
static int KWTASpec::* TA_KWTASpec_MbrOff;
static MemberDef_data TA_KWTASpec_MemberDef[]={
  {NULL,"::K_From","k_from"," how is the active_k determined: directly by k, by pct, or by no. of units where ext > pat_q","","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::k_from))),0,NULL,0},
  {&TA_int,NULL,"k"," desired number of active units in the layer","CONDEDIT_ON_k_from:USE_K ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::k))),0,NULL,0},
  {&TA_float,NULL,"pct"," desired proportion of activity (used to compute a k value based on layer size, .25 std)","CONDEDIT_ON_k_from:USE_PCT ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::pct))),0,NULL,0},
  {&TA_float,NULL,"pat_q"," threshold for pat_k based activity level: add to k if ext > pat_q","HIDDEN DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::pat_q))),0,NULL,0},
  {&TA_bool,NULL,"diff_act_pct"," if true, use different actual percent activity for overall layer activation","DEF_false ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::diff_act_pct))),0,NULL,0},
  {&TA_float,NULL,"act_pct"," actual percent activity to put in kwta.pct field of layer","CONDEDIT_ON_diff_act_pct:true ","",
    *((ta_memb_ptr*)&(TA_KWTASpec_MbrOff=(int KWTASpec::*)(&KWTASpec::act_pct))),0,NULL,0},
  NULL};
static EnumDef_data TA_AdaptISpec_AdaptType[]={
  {"NONE"," don't adapt anything","",0},
  {"KWTA_PT"," adapt kwta point (i_kwta_pt) based on running-average layer activation as compared to target value","",1},
  {"G_BAR_I"," adapt g_bar.i for unit inhibition values based on layer activation at any point in time","",2},
  {"G_BAR_IL"," adapt g_bar.i and g_bar.l for unit inhibition & leak values based on layer activation at any point in time","",3},
  NULL};
static int AdaptISpec::* TA_AdaptISpec_MbrOff;
static MemberDef_data TA_AdaptISpec_MemberDef[]={
  {NULL,"::AdaptType","type"," what to adapt, or none for nothing","","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::type))),0,NULL,0},
  {&TA_float,NULL,"tol"," tolerance around target avg act before changing parameter","CONDEDIT_OFF_type:NONE DEF_0.02 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::tol))),0,NULL,0},
  {&TA_float,NULL,"p_dt"," time constant for changing the parameter (i_kwta_pt or g_bar.i)","CONDEDIT_OFF_type:NONE DEF_0.1 AKA_pt_dt ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::p_dt))),0,NULL,0},
  {&TA_float,NULL,"mx_d"," maximum deviation (proportion) from initial parameter setting allowed","CONDEDIT_OFF_type:NONE DEF_0.9 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::mx_d))),0,NULL,0},
  {&TA_float,NULL,"l"," proportion of difference from target activation to allocate to the leak in G_BAR_IL mode","CONDEDIT_ON_type:G_BAR_IL ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::l))),0,NULL,0},
  {&TA_float,NULL,"a_dt"," time constant for integrating average average activation, which is basis for adapting i_kwta_pt","CONDEDIT_ON_type:KWTA_PT DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_AdaptISpec_MbrOff=(int AdaptISpec::*)(&AdaptISpec::a_dt))),0,NULL,0},
  NULL};
static int ClampSpec::* TA_ClampSpec_MbrOff;
static MemberDef_data TA_ClampSpec_MemberDef[]={
  {&TA_bool,NULL,"hard"," whether to hard clamp inputs to this layer or not","DEF_true ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::hard))),0,NULL,0},
  {&TA_float,NULL,"gain"," starting soft clamp gain factor (net = gain * ext)","CONDEDIT_OFF_hard:true DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"d_gain"," [Default: 0] for soft clamp, delta to increase gain when target units not > .5 (0 = off, .1 std when used)","CONDEDIT_OFF_hard:true ","",
    *((ta_memb_ptr*)&(TA_ClampSpec_MbrOff=(int ClampSpec::*)(&ClampSpec::d_gain))),0,NULL,0},
  NULL};
static int DecaySpec::* TA_DecaySpec_MbrOff;
static MemberDef_data TA_DecaySpec_MemberDef[]={
  {&TA_float,NULL,"event"," proportion decay of state vars between events","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::event))),0,NULL,0},
  {&TA_float,NULL,"phase"," proportion decay of state vars between minus and plus phases ","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::phase))),0,NULL,0},
  {&TA_float,NULL,"phase2"," proportion decay of state vars between 2nd set of phases (if appl, 0 std)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::phase2))),0,NULL,0},
  {&TA_bool,NULL,"clamp_phase2"," if true, hard-clamp second plus phase activations to prev plus phase (only special layers will then update -- optimizes speed)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_DecaySpec_MbrOff=(int DecaySpec::*)(&DecaySpec::clamp_phase2))),0,NULL,0},
  NULL};
static EnumDef_data TA_SpecPtr_LeabraLayerSpec__Orientation[]={
  {"Horizontal","","",0},
  {"Vertical","","",1},
  NULL};
static int SpecPtr<LeabraLayerSpec>::* TA_SpecPtr_LeabraLayerSpec__MbrOff;
static MemberDef_data TA_SpecPtr_LeabraLayerSpec__MemberDef[]={
  {NULL,"::LeabraLayerSpec_ptr","spec"," the actual spec itself","","",
    *((ta_memb_ptr*)&(TA_SpecPtr_LeabraLayerSpec__MbrOff=(int SpecPtr<LeabraLayerSpec>::*)(&SpecPtr<LeabraLayerSpec>::spec))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SpecPtr_LeabraLayerSpec__SetDefaultSpec_MethArgs[]={
  {&TA_TAPtr,NULL,"ownr",""},
  NULL};
static MethodDef_data TA_SpecPtr_LeabraLayerSpec__MethodDef[]={
  {&TA_void,NULL,"SetDefaultSpec"," for class that owns ptr","","",
    1,1,-1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__SetDefaultSpec_stub,TA_SpecPtr_LeabraLayerSpec__SetDefaultSpec_MethArgs},
  {&TA_bool,NULL,"CheckSpec","","","",
    1,0,-1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__CheckSpec_stub,NULL},
  {NULL,"::LeabraLayerSpec_ptr","NewChild","","","",
    0,0,-1,0,NULL,cssElCFun_SpecPtr_LeabraLayerSpec__NewChild_stub,NULL},
  NULL};
static int AvgMaxVals::* TA_AvgMaxVals_MbrOff;
static MemberDef_data TA_AvgMaxVals_MemberDef[]={
  {&TA_float,NULL,"avg"," average value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::avg))),0,NULL,0},
  {&TA_float,NULL,"max"," maximum value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::max))),0,NULL,0},
  {&TA_int,NULL,"max_i"," index of unit with maximum value","","",
    *((ta_memb_ptr*)&(TA_AvgMaxVals_MbrOff=(int AvgMaxVals::*)(&AvgMaxVals::max_i))),0,NULL,0},
  NULL};
static int KWTAVals::* TA_KWTAVals_MbrOff;
static MemberDef_data TA_KWTAVals_MemberDef[]={
  {&TA_int,NULL,"k"," target number of active units for this collection","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k))),0,NULL,0},
  {&TA_float,NULL,"pct"," actual percent activity in group","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::pct))),0,NULL,0},
  {&TA_float,NULL,"pct_c"," complement of (1.0 - ) actual percent activity in group","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::pct_c))),0,NULL,0},
  {&TA_int,NULL,"adth_k"," adapting threshold k value -- how many units can adapt per time","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::adth_k))),0,NULL,0},
  {&TA_float,NULL,"k_ithr"," inhib threshold for k unit (top k for kwta_avg)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k_ithr))),0,NULL,0},
  {&TA_float,NULL,"k1_ithr"," inhib threshold for k+1 unit (other units for kwta_avg)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::k1_ithr))),0,NULL,0},
  {&TA_float,NULL,"ithr_r"," log of ratio of ithr values (indicates signal differentiation)","","",
    *((ta_memb_ptr*)&(TA_KWTAVals_MbrOff=(int KWTAVals::*)(&KWTAVals::ithr_r))),0,NULL,0},
  NULL};
static MethodArgs_data TA_KWTAVals_Compute_Pct_MethArgs[]={
  {&TA_int,NULL,"n_units",""},
  NULL};
static MethodDef_data TA_KWTAVals_MethodDef[]={
  {&TA_void,NULL,"Compute_Pct","","","",
    0,1,-1,0,NULL,cssElCFun_KWTAVals_Compute_Pct_stub,TA_KWTAVals_Compute_Pct_MethArgs},
  {&TA_void,NULL,"Compute_IThrR"," compute ithr_r ratio value","","",
    0,0,-1,0,NULL,cssElCFun_KWTAVals_Compute_IThrR_stub,NULL},
  NULL};
static int AdaptIVals::* TA_AdaptIVals_MbrOff;
static MemberDef_data TA_AdaptIVals_MemberDef[]={
  {&TA_float,NULL,"avg_avg"," average of the average activation in a layer","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::avg_avg))),0,NULL,0},
  {&TA_float,NULL,"i_kwta_pt"," adapting point to place inhibition between k and k+1 for kwta","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::i_kwta_pt))),0,NULL,0},
  {&TA_float,NULL,"g_bar_i"," adapting g_bar.i value ","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::g_bar_i))),0,NULL,0},
  {&TA_float,NULL,"g_bar_l"," adapting g_bar.l value ","","",
    *((ta_memb_ptr*)&(TA_AdaptIVals_MbrOff=(int AdaptIVals::*)(&AdaptIVals::g_bar_l))),0,NULL,0},
  NULL};
static int InhibVals::* TA_InhibVals_MbrOff;
static MemberDef_data TA_InhibVals_MemberDef[]={
  {&TA_float,NULL,"kwta"," inhibition due to kwta function","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::kwta))),0,NULL,0},
  {&TA_float,NULL,"g_i"," overall value of the inhibition","","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::g_i))),0,NULL,0},
  {&TA_float,NULL,"g_i_orig"," original value of the inhibition (before linking)","HIDDEN ","",
    *((ta_memb_ptr*)&(TA_InhibVals_MbrOff=(int InhibVals::*)(&InhibVals::g_i_orig))),0,NULL,0},
  NULL};
static int LeabraSE_Stat::* TA_LeabraSE_Stat_MbrOff;
static MemberDef_data TA_LeabraSE_Stat_MemberDef[]={
  {&TA_LeabraTrial_ptr,NULL,"trial_proc"," the trial process to get phase info","READ_ONLY NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::trial_proc))),0,NULL,0},
  {NULL,"Unit::ExtType","targ_or_comp"," when to compute SE: targ = 1st minus, comp = 2nd minus, both = both","","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::targ_or_comp))),0,NULL,0},
  {&TA_bool,NULL,"no_off_err"," do not count a unit wrong if it is off but target says on -- only count wrong units that are on but should be off","","",
    *((ta_memb_ptr*)&(TA_LeabraSE_Stat_MbrOff=(int LeabraSE_Stat::*)(&LeabraSE_Stat::no_off_err))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraSE_Stat_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"unit",""},
  NULL};
static MethodDef_data TA_LeabraSE_Stat_MethodDef[]={
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSE_Stat_Unit_Stat_stub,TA_LeabraSE_Stat_Unit_Stat_MethArgs},
  NULL};
static int LeabraGoodStat::* TA_LeabraGoodStat_MbrOff;
static MemberDef_data TA_LeabraGoodStat_MemberDef[]={
  {&TA_bool,NULL,"subtr_inhib"," subtract inhibition from harmony?","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::subtr_inhib))),0,NULL,0},
  {&TA_StatVal,NULL,"hrmny"," harmony = act * netin = a_i sum_j a_j w_ij","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::hrmny))),0,NULL,0},
  {&TA_StatVal,NULL,"strss"," stress = act * log(act)","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::strss))),0,NULL,0},
  {&TA_StatVal,NULL,"gdnss"," goodness = harmony + stress","","",
    *((ta_memb_ptr*)&(TA_LeabraGoodStat_MbrOff=(int LeabraGoodStat::*)(&LeabraGoodStat::gdnss))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraGoodStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraGoodStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraGoodStat_Unit_Stat_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  NULL};
static MethodDef_data TA_LeabraGoodStat_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraGoodStat_RecvCon_Run_stub,TA_LeabraGoodStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraGoodStat_SendCon_Run_stub,TA_LeabraGoodStat_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Unit_Stat"," Compute statistic on a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraGoodStat_Unit_Stat_stub,TA_LeabraGoodStat_Unit_Stat_MethArgs},
  NULL};
static int LeabraSharpStat::* TA_LeabraSharpStat_MbrOff;
static MemberDef_data TA_LeabraSharpStat_MemberDef[]={
  {&TA_StatVal,NULL,"sharp"," sharpness = max / avg ","","",
    *((ta_memb_ptr*)&(TA_LeabraSharpStat_MbrOff=(int LeabraSharpStat::*)(&LeabraSharpStat::sharp))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_Unit_Run_MethArgs[]={
  {&TA_Layer_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraSharpStat_Layer_Stat_MethArgs[]={
  {&TA_Layer_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_LeabraSharpStat_MethodDef[]={
  {&TA_void,NULL,"Unit_Run"," Compute over units in a layer no unit stat","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_Unit_Run_stub,TA_LeabraSharpStat_Unit_Run_MethArgs},
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_RecvCon_Run_stub,TA_LeabraSharpStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_SendCon_Run_stub,TA_LeabraSharpStat_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Layer_Stat"," Compute statistic on a layer","","",
    1,1,-1,0,NULL,cssElCFun_LeabraSharpStat_Layer_Stat_stub,TA_LeabraSharpStat_Layer_Stat_MethArgs},
  NULL};
static int WrongOnStat::* TA_WrongOnStat_MbrOff;
static MemberDef_data TA_WrongOnStat_MemberDef[]={
  {&TA_Layer_ptr,NULL,"trg_lay"," target layer, containing activation pattern for all possible correct responses","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::trg_lay))),0,NULL,0},
  {&TA_StatVal,NULL,"wrng"," wrong on error statistic","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::wrng))),0,NULL,0},
  {&TA_float,NULL,"threshold"," activation value to consider unit being on","","",
    *((ta_memb_ptr*)&(TA_WrongOnStat_MbrOff=(int WrongOnStat::*)(&WrongOnStat::threshold))),0,NULL,0},
  NULL};
static MethodArgs_data TA_WrongOnStat_Unit_Run_MethArgs[]={
  {&TA_Layer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_WrongOnStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_WrongOnStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_WrongOnStat_MethodDef[]={
  {&TA_void,NULL,"Unit_Run"," Compute over units in a layer","","",
    1,1,-1,0,NULL,cssElCFun_WrongOnStat_Unit_Run_stub,TA_WrongOnStat_Unit_Run_MethArgs},
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_WrongOnStat_RecvCon_Run_stub,TA_WrongOnStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_WrongOnStat_SendCon_Run_stub,TA_WrongOnStat_SendCon_Run_MethArgs},
  NULL};
static int LeabraPrjnRelNetinStat::* TA_LeabraPrjnRelNetinStat_MbrOff;
static MemberDef_data TA_LeabraPrjnRelNetinStat_MemberDef[]={
  {&TA_StatVal_List,NULL,"relnet"," relative netinput contributions for the different projections into units in this layer","","",
    *((ta_memb_ptr*)&(TA_LeabraPrjnRelNetinStat_MbrOff=(int LeabraPrjnRelNetinStat::*)(&LeabraPrjnRelNetinStat::relnet))),0,NULL,0},
  {&TA_float,NULL,"recv_act_thr"," only compute netinput for receiving units that are active above this threshold (prevents dilution by varying numbers of inactive units)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_LeabraPrjnRelNetinStat_MbrOff=(int LeabraPrjnRelNetinStat::*)(&LeabraPrjnRelNetinStat::recv_act_thr))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraPrjnRelNetinStat_Unit_Run_MethArgs[]={
  {&TA_Layer_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraPrjnRelNetinStat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraPrjnRelNetinStat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraPrjnRelNetinStat_Layer_Stat_MethArgs[]={
  {&TA_Layer_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_LeabraPrjnRelNetinStat_GetPrjnNm_MethArgs[]={
  {&TA_const_char_ptr,NULL,"prjn_nm",""},
  NULL};
static MethodDef_data TA_LeabraPrjnRelNetinStat_MethodDef[]={
  {&TA_void,NULL,"Unit_Run"," Compute over units in a layer no unit stat","","",
    1,1,-1,0,NULL,cssElCFun_LeabraPrjnRelNetinStat_Unit_Run_stub,TA_LeabraPrjnRelNetinStat_Unit_Run_MethArgs},
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_LeabraPrjnRelNetinStat_RecvCon_Run_stub,TA_LeabraPrjnRelNetinStat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_LeabraPrjnRelNetinStat_SendCon_Run_stub,TA_LeabraPrjnRelNetinStat_SendCon_Run_MethArgs},
  {&TA_void,NULL,"Layer_Stat"," Compute statistic on a layer","","",
    1,1,-1,0,NULL,cssElCFun_LeabraPrjnRelNetinStat_Layer_Stat_stub,TA_LeabraPrjnRelNetinStat_Layer_Stat_MethArgs},
  {&TA_taString,NULL,"GetPrjnNm","","","",
    0,1,-1,0,NULL,cssElCFun_LeabraPrjnRelNetinStat_GetPrjnNm_stub,TA_LeabraPrjnRelNetinStat_GetPrjnNm_MethArgs},
  NULL};
static int CtxtUpdateSpec::* TA_CtxtUpdateSpec_MbrOff;
static MemberDef_data TA_CtxtUpdateSpec_MemberDef[]={
  {&TA_float,NULL,"fm_hid"," from hidden (inputs to context layer)","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::fm_hid))),0,NULL,0},
  {&TA_float,NULL,"fm_prv"," from previous context layer values (maintenance)","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::fm_prv))),0,NULL,0},
  {&TA_float,NULL,"to_out"," outputs from context layer","","",
    *((ta_memb_ptr*)&(TA_CtxtUpdateSpec_MbrOff=(int CtxtUpdateSpec::*)(&CtxtUpdateSpec::to_out))),0,NULL,0},
  NULL};
static int LeabraContextLayerSpec::* TA_LeabraContextLayerSpec_MbrOff;
static MemberDef_data TA_LeabraContextLayerSpec_MemberDef[]={
  {&TA_CtxtUpdateSpec,NULL,"updt"," ctxt updating constants: from hidden, from previous values (hysteresis), outputs from context (n/a on simple gate layer)","","",
    *((ta_memb_ptr*)&(TA_LeabraContextLayerSpec_MbrOff=(int LeabraContextLayerSpec::*)(&LeabraContextLayerSpec::updt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LeabraContextLayerSpec_Compute_Context_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LeabraContextLayerSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_Context"," get context source value for given context unit","","",
    0,3,-1,0,NULL,cssElCFun_LeabraContextLayerSpec_Compute_Context_stub,TA_LeabraContextLayerSpec_Compute_Context_MethArgs},
  NULL};
static EnumDef_data TA_PhaseOrderEventSpec_PhaseOrder[]={
  {"MINUS_PLUS"," minus phase, then plus phase","",0},
  {"PLUS_MINUS"," plus phase, then minus phase","",1},
  {"MINUS_ONLY"," only present minus","",2},
  {"PLUS_ONLY"," only present plus","",3},
  NULL};
static int PhaseOrderEventSpec::* TA_PhaseOrderEventSpec_MbrOff;
static MemberDef_data TA_PhaseOrderEventSpec_MemberDef[]={
  {NULL,"::PhaseOrder","phase_order"," order to present phases of stimuli to network","","",
    *((ta_memb_ptr*)&(TA_PhaseOrderEventSpec_MbrOff=(int PhaseOrderEventSpec::*)(&PhaseOrderEventSpec::phase_order))),0,NULL,0},
  NULL};
static int LeabraNegBiasSpec::* TA_LeabraNegBiasSpec_MbrOff;
static MemberDef_data TA_LeabraNegBiasSpec_MemberDef[]={
  {&TA_float,NULL,"decay"," rate of weight decay towards zero ","","",
    *((ta_memb_ptr*)&(TA_LeabraNegBiasSpec_MbrOff=(int LeabraNegBiasSpec::*)(&LeabraNegBiasSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"updt_immed"," update weights immediately when weights are changed","","",
    *((ta_memb_ptr*)&(TA_LeabraNegBiasSpec_MbrOff=(int LeabraNegBiasSpec::*)(&LeabraNegBiasSpec::updt_immed))),0,NULL,0},
  NULL};
static int TrialSynDepCon::* TA_TrialSynDepCon_MbrOff;
static MemberDef_data TA_TrialSynDepCon_MemberDef[]={
  {&TA_float,NULL,"effwt"," effective weight value (can be depressed) -- used for sending ativation","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_TrialSynDepCon_MbrOff=(int TrialSynDepCon::*)(&TrialSynDepCon::effwt))),0,NULL,0},
  NULL};
static int SynDepSpec::* TA_SynDepSpec_MbrOff;
static MemberDef_data TA_SynDepSpec_MemberDef[]={
  {&TA_float,NULL,"rec"," rate of recovery from depression","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_SynDepSpec_MbrOff=(int SynDepSpec::*)(&SynDepSpec::rec))),0,NULL,0},
  {&TA_float,NULL,"depl"," rate of depletion of synaptic efficacy as a function of sender-receiver activations","DEF_1.1 ","",
    *((ta_memb_ptr*)&(TA_SynDepSpec_MbrOff=(int SynDepSpec::*)(&SynDepSpec::depl))),0,NULL,0},
  NULL};
static int TrialSynDepConSpec::* TA_TrialSynDepConSpec_MbrOff;
static MemberDef_data TA_TrialSynDepConSpec_MemberDef[]={
  {&TA_SynDepSpec,NULL,"syn_dep"," synaptic depression specifications","","",
    *((ta_memb_ptr*)&(TA_TrialSynDepConSpec_MbrOff=(int TrialSynDepConSpec::*)(&TrialSynDepConSpec::syn_dep))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Compute_Net_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_Net_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_Inhib_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_NetDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_InhibDelta_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Send_ClampNet_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Depress_Wt_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Depress_Wt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_C_Reset_EffWt_MethArgs[]={
  {&TA_TrialSynDepCon_ptr,NULL,"cn",""},
  NULL};
static MethodArgs_data TA_TrialSynDepConSpec_Reset_EffWt_MethArgs[]={
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  NULL};
static MethodDef_data TA_TrialSynDepConSpec_MethodDef[]={
  {&TA_float,NULL,"C_Compute_Net","","","",
    2,3,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Compute_Net_stub,TA_TrialSynDepConSpec_C_Compute_Net_MethArgs},
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Compute_Net_stub,TA_TrialSynDepConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"C_Send_Net","","","",
    2,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_Net_stub,TA_TrialSynDepConSpec_C_Send_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Send_Net_stub,TA_TrialSynDepConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Compute_dWt_stub,TA_TrialSynDepConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_Send_Inhib","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_Inhib_stub,TA_TrialSynDepConSpec_C_Send_Inhib_MethArgs},
  {&TA_void,NULL,"C_Send_NetDelta","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_NetDelta_stub,TA_TrialSynDepConSpec_C_Send_NetDelta_MethArgs},
  {&TA_void,NULL,"C_Send_InhibDelta","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_InhibDelta_stub,TA_TrialSynDepConSpec_C_Send_InhibDelta_MethArgs},
  {&TA_void,NULL,"C_Send_ClampNet","","","",
    1,4,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Send_ClampNet_stub,TA_TrialSynDepConSpec_C_Send_ClampNet_MethArgs},
  {&TA_void,NULL,"C_Depress_Wt","","","",
    0,3,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Depress_Wt_stub,TA_TrialSynDepConSpec_C_Depress_Wt_MethArgs},
  {&TA_void,NULL,"Depress_Wt","","","",
    0,2,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Depress_Wt_stub,TA_TrialSynDepConSpec_Depress_Wt_MethArgs},
  {&TA_void,NULL,"C_Reset_EffWt","","","",
    0,1,-1,0,NULL,cssElCFun_TrialSynDepConSpec_C_Reset_EffWt_stub,TA_TrialSynDepConSpec_C_Reset_EffWt_MethArgs},
  {&TA_void,NULL,"Reset_EffWt","","","",
    0,1,-1,0,NULL,cssElCFun_TrialSynDepConSpec_Reset_EffWt_stub,TA_TrialSynDepConSpec_Reset_EffWt_MethArgs},
  NULL};
static int FastWtCon::* TA_FastWtCon_MbrOff;
static MemberDef_data TA_FastWtCon_MemberDef[]={
  {&TA_float,NULL,"swt"," slow weight value","","",
    *((ta_memb_ptr*)&(TA_FastWtCon_MbrOff=(int FastWtCon::*)(&FastWtCon::swt))),0,NULL,0},
  {&TA_float,NULL,"sdwt"," slow weight delta-weight change","NO_SAVE ","",
    *((ta_memb_ptr*)&(TA_FastWtCon_MbrOff=(int FastWtCon::*)(&FastWtCon::sdwt))),0,NULL,0},
  NULL};
static EnumDef_data TA_FastWtSpec_DecayMode[]={
  {"ALWAYS"," always decay all weights toward slow weight (swt)","",0},
  {"SU_PROP"," decay in proportion to the sending unit activation: decay only happens after sending activity dissipates","",1},
  {"SU_THR"," decay only weights with sending unit activations below sending threshold (nom .1): decay only happens after sending activity dissipates","",2},
  NULL};
static int FastWtSpec::* TA_FastWtSpec_MbrOff;
static MemberDef_data TA_FastWtSpec_MemberDef[]={
  {&TA_float,NULL,"lrate"," learning rate","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::lrate))),0,NULL,0},
  {&TA_bool,NULL,"use_lrs"," use learning rate schedule to modify cur_lrate learning rate?","DEF_false ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::use_lrs))),0,NULL,0},
  {&TA_float,NULL,"cur_lrate"," current learning rate with lrate schedule factored in","READ_ONLY NO_INHERIT SHOW ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::cur_lrate))),0,NULL,0},
  {&TA_float,NULL,"decay"," rate of decay toward the slow weight values","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::decay))),0,NULL,0},
  {&TA_bool,NULL,"slw_sat"," does fast weight contribute to saturation of slow weights?","DEF_true ","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::slw_sat))),0,NULL,0},
  {NULL,"::DecayMode","dk_mode"," how to apply the decay of fast weights back to the slow weight (swt) value","","",
    *((ta_memb_ptr*)&(TA_FastWtSpec_MbrOff=(int FastWtSpec::*)(&FastWtSpec::dk_mode))),0,NULL,0},
  NULL};
static int FastWtConSpec::* TA_FastWtConSpec_MbrOff;
static MemberDef_data TA_FastWtConSpec_MemberDef[]={
  {&TA_FastWtSpec,NULL,"fast_wt"," fast weight specs: fast weights are added in separately to overall weight value as an increment (","","",
    *((ta_memb_ptr*)&(TA_FastWtConSpec_MbrOff=(int FastWtConSpec::*)(&FastWtConSpec::fast_wt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_InitWtDelta_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Connection_ptr,NULL,"cn",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  {&TA_Unit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_dWt_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_UpdateWeights_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_UpdateWeightsActReg_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  {&TA_LeabraUnitSpec_ptr,NULL,"rus",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowHebb_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_float,NULL,"ru_act",""},
  {&TA_float,NULL,"su_act",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowErr_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_float,NULL,"ru_act_p",""},
  {&TA_float,NULL,"ru_act_m",""},
  {&TA_float,NULL,"su_act_p",""},
  {&TA_float,NULL,"su_act_m",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_SlowdWt_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_float,NULL,"heb",""},
  {&TA_float,NULL,"err",""},
  NULL};
static MethodArgs_data TA_FastWtConSpec_C_Compute_FastDecay_MethArgs[]={
  {&TA_FastWtCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"na",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_FastWtConSpec_MethodDef[]={
  {&TA_void,NULL,"C_InitWtDelta","","","",
    1,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_InitWtDelta_stub,TA_FastWtConSpec_C_InitWtDelta_MethArgs},
  {&TA_void,NULL,"C_Compute_dWt"," combine associative and error-driven weight change, actually update dwt","","",
    1,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_dWt_stub,TA_FastWtConSpec_C_Compute_dWt_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_FastWtConSpec_Compute_dWt_stub,TA_FastWtConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"C_UpdateWeights"," update weights, if activation regulation is NOT in effect","","",
    2,5,-1,0,NULL,cssElCFun_FastWtConSpec_C_UpdateWeights_stub,TA_FastWtConSpec_C_UpdateWeights_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_FastWtConSpec_UpdateWeights_stub,TA_FastWtConSpec_UpdateWeights_MethArgs},
  {&TA_void,NULL,"C_UpdateWeightsActReg"," update weights, if activation regulation is in effect","","",
    1,5,-1,0,NULL,cssElCFun_FastWtConSpec_C_UpdateWeightsActReg_stub,TA_FastWtConSpec_C_UpdateWeightsActReg_MethArgs},
  {&TA_float,NULL,"C_Compute_SlowHebb"," todo: somewhat inefficient to do this computation twice..","","",
    0,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowHebb_stub,TA_FastWtConSpec_C_Compute_SlowHebb_MethArgs},
  {&TA_float,NULL,"C_Compute_SlowErr","","","",
    0,5,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowErr_stub,TA_FastWtConSpec_C_Compute_SlowErr_MethArgs},
  {&TA_void,NULL,"C_Compute_SlowdWt"," combine hebbian and error-driven","","",
    0,4,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_SlowdWt_stub,TA_FastWtConSpec_C_Compute_SlowdWt_MethArgs},
  {&TA_void,NULL,"C_Compute_FastDecay","","","",
    0,3,-1,0,NULL,cssElCFun_FastWtConSpec_C_Compute_FastDecay_stub,TA_FastWtConSpec_C_Compute_FastDecay_MethArgs},
  NULL};
static EnumDef_data TA_ScalarValSpec_RepType[]={
  {"GAUSSIAN"," gaussian bump, with value = weighted average of tuned unit values","",0},
  {"LOCALIST"," each unit represents a distinct value; intermediate values represented by graded activity of neighbors; overall activity is weighted-average across all units","",1},
  {"SUM_BAR"," bar of increasing activation threshold across units, with value = sum of overall activation. This has more natural activation dynamics than GAUSSIAN","",2},
  NULL};
static int ScalarValSpec::* TA_ScalarValSpec_MbrOff;
static MemberDef_data TA_ScalarValSpec_MemberDef[]={
  {NULL,"::RepType","rep"," type of representation of scalar value to use","","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::rep))),0,NULL,0},
  {&TA_float,NULL,"un_width"," sigma parameter of a gaussian specifying the tuning width of the coarse-coded units (in min-max units)","CONDEDIT_ON_rep:GAUSSIAN ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::un_width))),0,NULL,0},
  {&TA_float,NULL,"min_net"," minimum netinput value for purposes of computing gc.i in sum_bar","CONDEDIT_ON_rep:SUM_BAR DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min_net))),0,NULL,0},
  {&TA_bool,NULL,"clamp_pat"," if true, environment provides full set of values to clamp over entire layer (instead of providing single scalar value to clamp on 1st unit, which then generates a corresponding distributed pattern)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::clamp_pat))),0,NULL,0},
  {&TA_float,NULL,"min_sum_act"," minimum total activity of all the units representing a value: when computing weighted average value, this is used as a minimum for the sum that you divide by","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min_sum_act))),0,NULL,0},
  {&TA_bool,NULL,"val_mult_lrn"," for learning, effectively multiply the learning rate by the minus-plus phase difference in overall represented value (i.e., if overall value is the same, no learning takes place)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::val_mult_lrn))),0,NULL,0},
  {&TA_float,NULL,"min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::min))),0,NULL,0},
  {&TA_float,NULL,"range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::range))),0,NULL,0},
  {&TA_float,NULL,"val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::val))),0,NULL,0},
  {&TA_float,NULL,"incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::incr))),0,NULL,0},
  {&TA_int,NULL,"sb_lt"," sum_bar lower threshold index (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::sb_lt))),0,NULL,0},
  {&TA_float,NULL,"sb_ev"," sum_bar 'edge' unit value (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValSpec_MbrOff=(int ScalarValSpec::*)(&ScalarValSpec::sb_ev))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValSpec_InitVal_MethArgs[]={
  {&TA_float,NULL,"sval",""},
  {&TA_int,NULL,"ugp_size",""},
  {&TA_float,NULL,"umin",""},
  {&TA_float,NULL,"urng",""},
  NULL};
static MethodArgs_data TA_ScalarValSpec_GetUnitAct_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodArgs_data TA_ScalarValSpec_GetUnitVal_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodDef_data TA_ScalarValSpec_MethodDef[]={
  {&TA_void,NULL,"InitVal"," initialize implementational values for subsequently computing GetUnitAct to represent scalar val sval over unit group of ugp_size","","",
    0,4,-1,0,NULL,cssElCFun_ScalarValSpec_InitVal_stub,TA_ScalarValSpec_InitVal_MethArgs},
  {&TA_float,NULL,"GetUnitAct"," get activation under current representation for unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValSpec_GetUnitAct_stub,TA_ScalarValSpec_GetUnitAct_MethArgs},
  {&TA_float,NULL,"GetUnitVal"," get target value associated with unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValSpec_GetUnitVal_stub,TA_ScalarValSpec_GetUnitVal_MethArgs},
  NULL};
static EnumDef_data TA_ScalarValBias_UnitBias[]={
  {"NO_UN"," no unit bias","",0},
  {"GC"," bias value enters as a conductance in gc.h or gc.a","",1},
  {"BWT"," bias value enters as a bias.wt","",2},
  NULL};
static EnumDef_data TA_ScalarValBias_BiasShape[]={
  {"VAL"," bias as a particular value representation","",0},
  {"NEG_SLP"," bias as an increasingly negative slope (gc.a or -bwt) as unit values increase","",1},
  {"POS_SLP"," bias as an increasingly positive slope (gc.h or +bwt) as unit values increase","",2},
  NULL};
static EnumDef_data TA_ScalarValBias_WeightBias[]={
  {"NO_WT"," no weight bias","",0},
  {"WT"," input weights","",1},
  NULL};
static int ScalarValBias::* TA_ScalarValBias_MbrOff;
static MemberDef_data TA_ScalarValBias_MemberDef[]={
  {NULL,"::UnitBias","un"," bias on individual units","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un))),0,NULL,0},
  {NULL,"::BiasShape","un_shp"," shape of unit bias","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un_shp))),0,NULL,0},
  {&TA_float,NULL,"un_gain"," gain multiplier (strength) of bias to apply for units. WT = .03 as basic weight multiplier","CONDEDIT_OFF_un:NO_UN DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::un_gain))),0,NULL,0},
  {NULL,"::WeightBias","wt"," bias on weights: always uses a val-shaped bias","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::wt))),0,NULL,0},
  {&TA_float,NULL,"wt_gain"," gain multiplier (strength) of bias to apply for weights (gain 1 = .03 wt value)","CONDEDIT_OFF_wt:NO_WT DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::wt_gain))),0,NULL,0},
  {&TA_float,NULL,"val"," value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_ScalarValBias_MbrOff=(int ScalarValBias::*)(&ScalarValBias::val))),0,NULL,0},
  NULL};
static int ScalarValLayerSpec::* TA_ScalarValLayerSpec_MbrOff;
static MemberDef_data TA_ScalarValLayerSpec_MemberDef[]={
  {&TA_ScalarValSpec,NULL,"scalar"," specifies how values are represented in terms of distributed patterns of activation across the layer","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::scalar))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"unit_range"," range of values represented across the units; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::unit_range))),0,NULL,0},
  {&TA_ScalarValBias,NULL,"bias_val"," specifies bias for given value (as gaussian bump) ","","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::bias_val))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_ScalarValLayerSpec_MbrOff=(int ScalarValLayerSpec::*)(&ScalarValLayerSpec::val_range))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ClampValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"rescale","1.0f"},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ClampAvgAct_MethArgs[]={
  {&TA_int,NULL,"ugp_size",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ReadValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ResetAfterClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_HardClampExt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnits_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnits_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_LabelUnitsNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_WtBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"val",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_NegSlp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_UnBias_PosSlp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_BiasVal_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_Compute_dWtUgp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ScalarValLayerSpec_ReConfig_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_units"," -1"},
  NULL};
static MethodDef_data TA_ScalarValLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_ScalarValLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ClampValue"," clamp value in the first unit's ext field to the units in the group","","",
    0,3,2,0,NULL,cssElCFun_ScalarValLayerSpec_ClampValue_stub,TA_ScalarValLayerSpec_ClampValue_MethArgs},
  {&TA_float,NULL,"ClampAvgAct"," computes the average activation for a clamped unit pattern (for computing rescaling)","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_ClampAvgAct_stub,TA_ScalarValLayerSpec_ClampAvgAct_MethArgs},
  {&TA_float,NULL,"ReadValue"," read out current value represented by activations in layer","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_ReadValue_stub,TA_ScalarValLayerSpec_ReadValue_MethArgs},
  {&TA_void,NULL,"ResetAfterClamp"," reset activation of first unit(s) after hard clamping","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_ResetAfterClamp_stub,TA_ScalarValLayerSpec_ResetAfterClamp_MethArgs},
  {&TA_void,NULL,"HardClampExt"," hard clamp current ext values (on all units, after ClampValue called) to all the units","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_HardClampExt_stub,TA_ScalarValLayerSpec_HardClampExt_MethArgs},
  {&TA_void,NULL,"LabelUnits_impl"," label units with their underlying values","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnits_impl_stub,TA_ScalarValLayerSpec_LabelUnits_impl_MethArgs},
  {&TA_void,NULL,"LabelUnits"," label units in given layer with their underlying values","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnits_stub,TA_ScalarValLayerSpec_LabelUnits_MethArgs},
  {&TA_void,NULL,"LabelUnitsNet"," label all layers in given network using this spec","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_LabelUnitsNet_stub,TA_ScalarValLayerSpec_LabelUnitsNet_MethArgs},
  {&TA_void,NULL,"Compute_WtBias_Val","","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_WtBias_Val_stub,TA_ScalarValLayerSpec_Compute_WtBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_Val","","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_Val_stub,TA_ScalarValLayerSpec_Compute_UnBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_NegSlp","","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_NegSlp_stub,TA_ScalarValLayerSpec_Compute_UnBias_NegSlp_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_PosSlp","","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_UnBias_PosSlp_stub,TA_ScalarValLayerSpec_Compute_UnBias_PosSlp_MethArgs},
  {&TA_void,NULL,"Compute_BiasVal"," initialize the bias value ","","",
    0,1,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_BiasVal_stub,TA_ScalarValLayerSpec_Compute_BiasVal_MethArgs},
  {&TA_void,NULL,"Compute_dWtUgp"," compute weight changes just for one unit group","","",
    0,3,-1,0,NULL,cssElCFun_ScalarValLayerSpec_Compute_dWtUgp_stub,TA_ScalarValLayerSpec_Compute_dWtUgp_MethArgs},
  {&TA_void,NULL,"ReConfig"," reconfigure layer and associated specs for current scalar.rep type; if n_units > 0, changes number of units in layer to specified value","BUTTON ","",
    0,2,1,0,NULL,cssElCFun_ScalarValLayerSpec_ReConfig_stub,TA_ScalarValLayerSpec_ReConfig_MethArgs},
  NULL};
static int ScalarValSelfPrjnSpec::* TA_ScalarValSelfPrjnSpec_MbrOff;
static MemberDef_data TA_ScalarValSelfPrjnSpec_MemberDef[]={
  {&TA_int,NULL,"width"," width of neighborhood, in units (i.e., connect width units to the left, and width units to the right)","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::width))),0,NULL,0},
  {&TA_float,NULL,"wt_width"," width of the sigmoid for providing initial weight values","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::wt_width))),0,NULL,0},
  {&TA_float,NULL,"wt_max"," maximum weight value (of 1st neighbor -- not of self unit!)","","",
    *((ta_memb_ptr*)&(TA_ScalarValSelfPrjnSpec_MbrOff=(int ScalarValSelfPrjnSpec::*)(&ScalarValSelfPrjnSpec::wt_max))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_Connect_impl_MethArgs[]={
  {&TA_Projection_ptr,NULL,"prjn",""},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_C_InitWtState_MethArgs[]={
  {&TA_Projection_ptr,NULL,"prjn",""},
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_ScalarValSelfPrjnSpec_Connect_UnitGroup_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"gp",""},
  {&TA_Projection_ptr,NULL,"prjn",""},
  NULL};
static MethodDef_data TA_ScalarValSelfPrjnSpec_MethodDef[]={
  {&TA_void,NULL,"Connect_impl"," actually implements specific connection code","","",
    1,1,-1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_Connect_impl_stub,TA_ScalarValSelfPrjnSpec_Connect_impl_MethArgs},
  {&TA_void,NULL,"C_InitWtState"," custom initialize weights in this con group for given receiving unit ru uses weight values as specified in the tesselel's","","",
    1,3,-1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_C_InitWtState_stub,TA_ScalarValSelfPrjnSpec_C_InitWtState_MethArgs},
  {&TA_void,NULL,"Connect_UnitGroup","","","",
    0,2,-1,0,NULL,cssElCFun_ScalarValSelfPrjnSpec_Connect_UnitGroup_stub,TA_ScalarValSelfPrjnSpec_Connect_UnitGroup_MethArgs},
  NULL};
static EnumDef_data TA_TwoDValSpec_RepType[]={
  {"GAUSSIAN"," gaussian bump, with value = weighted average of tuned unit values","",0},
  {"LOCALIST"," each unit represents a distinct value; intermediate values represented by graded activity of neighbors; overall activity is weighted-average across all units","",1},
  NULL};
static int TwoDValSpec::* TA_TwoDValSpec_MbrOff;
static MemberDef_data TA_TwoDValSpec_MemberDef[]={
  {NULL,"::RepType","rep"," type of representation of scalar value to use","","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::rep))),0,NULL,0},
  {&TA_int,NULL,"n_vals"," number of values to represent in layer: layer geom.x must be >= 2 * n_vals because vals are represented in first row of layer!","","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::n_vals))),0,NULL,0},
  {&TA_float,NULL,"un_width"," sigma parameter of a gaussian specifying the tuning width of the coarse-coded units (in min-max units)","CONDEDIT_ON_rep:GAUSSIAN ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::un_width))),0,NULL,0},
  {&TA_bool,NULL,"clamp_pat"," if true, environment provides full set of values to clamp over entire layer (instead of providing single scalar value to clamp on 1st unit, which then generates a corresponding distributed pattern)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::clamp_pat))),0,NULL,0},
  {&TA_float,NULL,"min_sum_act"," minimum total activity of all the units representing a value: when computing weighted average value, this is used as a minimum for the sum that you divide by","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::min_sum_act))),0,NULL,0},
  {&TA_float,NULL,"mn_dst"," minimum distance factor for reading out multiple bumps: must be at least this times un_width far away from other bumps","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::mn_dst))),0,NULL,0},
  {&TA_float,NULL,"x_min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_min))),0,NULL,0},
  {&TA_float,NULL,"x_range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_range))),0,NULL,0},
  {&TA_float,NULL,"y_min"," minimum unit value","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_min))),0,NULL,0},
  {&TA_float,NULL,"y_range"," range of unit values","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_range))),0,NULL,0},
  {&TA_float,NULL,"x_val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_val))),0,NULL,0},
  {&TA_float,NULL,"y_val"," current val being represented (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_val))),0,NULL,0},
  {&TA_float,NULL,"x_incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_incr))),0,NULL,0},
  {&TA_float,NULL,"y_incr"," increment per unit (implementational, computed in InitVal())","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_incr))),0,NULL,0},
  {&TA_int,NULL,"x_size"," size of axis","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::x_size))),0,NULL,0},
  {&TA_int,NULL,"y_size"," size of axis","READ_ONLY NO_SAVE NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValSpec_MbrOff=(int TwoDValSpec::*)(&TwoDValSpec::y_size))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TwoDValSpec_InitVal_MethArgs[]={
  {&TA_float,NULL,"xval",""},
  {&TA_float,NULL,"yval",""},
  {&TA_int,NULL,"xsize",""},
  {&TA_int,NULL,"ysize",""},
  {&TA_float,NULL,"xmin",""},
  {&TA_float,NULL,"xrng",""},
  {&TA_float,NULL,"ymin",""},
  {&TA_float,NULL,"yrng",""},
  NULL};
static MethodArgs_data TA_TwoDValSpec_GetUnitAct_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  NULL};
static MethodArgs_data TA_TwoDValSpec_GetUnitVal_MethArgs[]={
  {&TA_int,NULL,"unit_idx",""},
  {&TA_float_ref,NULL,"x_cur",""},
  {&TA_float_ref,NULL,"y_cur",""},
  NULL};
static MethodDef_data TA_TwoDValSpec_MethodDef[]={
  {&TA_void,NULL,"InitVal"," initialize implementational values for subsequently computing GetUnitAct to represent scalar val sval over unit group of ugp_size","","",
    0,8,-1,0,NULL,cssElCFun_TwoDValSpec_InitVal_stub,TA_TwoDValSpec_InitVal_MethArgs},
  {&TA_float,NULL,"GetUnitAct"," get activation under current representation for unit at given index: MUST CALL InitVal first!","","",
    0,1,-1,0,NULL,cssElCFun_TwoDValSpec_GetUnitAct_stub,TA_TwoDValSpec_GetUnitAct_MethArgs},
  {&TA_void,NULL,"GetUnitVal"," get target values associated with unit at given index: MUST CALL InitVal first!","","",
    0,3,-1,0,NULL,cssElCFun_TwoDValSpec_GetUnitVal_stub,TA_TwoDValSpec_GetUnitVal_MethArgs},
  NULL};
static EnumDef_data TA_TwoDValBias_UnitBias[]={
  {"NO_UN"," no unit bias","",0},
  {"GC"," bias value enters as a conductance in gc.h or gc.a","",1},
  {"BWT"," bias value enters as a bias.wt","",2},
  NULL};
static EnumDef_data TA_TwoDValBias_WeightBias[]={
  {"NO_WT"," no weight bias","",0},
  {"WT"," input weights","",1},
  NULL};
static int TwoDValBias::* TA_TwoDValBias_MbrOff;
static MemberDef_data TA_TwoDValBias_MemberDef[]={
  {NULL,"::UnitBias","un"," bias on individual units","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::un))),0,NULL,0},
  {&TA_float,NULL,"un_gain"," gain multiplier (strength) of bias to apply for units. WT = .03 as basic weight multiplier","CONDEDIT_OFF_un:NO_UN DEF_1 ","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::un_gain))),0,NULL,0},
  {NULL,"::WeightBias","wt"," bias on weights: always uses a val-shaped bias","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::wt))),0,NULL,0},
  {&TA_float,NULL,"wt_gain"," gain multiplier (strength) of bias to apply for weights (gain 1 = .03 wt value)","CONDEDIT_OFF_wt:NO_WT DEF_1 ","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::wt_gain))),0,NULL,0},
  {&TA_float,NULL,"x_val"," X axis value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::x_val))),0,NULL,0},
  {&TA_float,NULL,"y_val"," Y axis value location (center of gaussian bump)","","",
    *((ta_memb_ptr*)&(TA_TwoDValBias_MbrOff=(int TwoDValBias::*)(&TwoDValBias::y_val))),0,NULL,0},
  NULL};
static int TwoDValLayerSpec::* TA_TwoDValLayerSpec_MbrOff;
static MemberDef_data TA_TwoDValLayerSpec_MemberDef[]={
  {&TA_TwoDValSpec,NULL,"twod"," specifies how values are represented in terms of distributed patterns of activation across the layer","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::twod))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"x_range"," range of values represented across the X (horizontal) axis; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::x_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"y_range"," range of values represented across the Y (vertical) axis; for GAUSSIAN, add extra values above and below true useful range to prevent edge effects.","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::y_range))),0,NULL,0},
  {&TA_TwoDValBias,NULL,"bias_val"," specifies bias values","","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::bias_val))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"x_val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::x_val_range))),0,NULL,0},
  {&TA_MinMaxRange,NULL,"y_val_range"," actual range of values (scalar.min/max taking into account un_range)","READ_ONLY NO_INHERIT ","",
    *((ta_memb_ptr*)&(TA_TwoDValLayerSpec_MbrOff=(int TwoDValLayerSpec::*)(&TwoDValLayerSpec::y_val_range))),0,NULL,0},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ClampValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_float,NULL,"rescale","1.0f"},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ReadValue_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ResetAfterClamp_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_HardClampExt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_LabelUnits_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_LabelUnits_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_LabelUnitsNet_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_WtBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"x_val",""},
  {&TA_float,NULL,"y_val",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_UnBias_Val_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_float,NULL,"x_val",""},
  {&TA_float,NULL,"y_val",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_BiasVal_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_Compute_dWtUgp_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TwoDValLayerSpec_ReConfig_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_units"," -1"},
  NULL};
static MethodDef_data TA_TwoDValLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TwoDValLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ClampValue"," clamp value in the first unit's ext field to the units in the group","","",
    0,3,2,0,NULL,cssElCFun_TwoDValLayerSpec_ClampValue_stub,TA_TwoDValLayerSpec_ClampValue_MethArgs},
  {&TA_void,NULL,"ReadValue"," read out current value represented by activations in layer","","",
    0,2,-1,0,NULL,cssElCFun_TwoDValLayerSpec_ReadValue_stub,TA_TwoDValLayerSpec_ReadValue_MethArgs},
  {&TA_void,NULL,"ResetAfterClamp"," reset activation of first unit(s) after hard clamping","","",
    0,2,-1,0,NULL,cssElCFun_TwoDValLayerSpec_ResetAfterClamp_stub,TA_TwoDValLayerSpec_ResetAfterClamp_MethArgs},
  {&TA_void,NULL,"HardClampExt"," hard clamp current ext values (on all units, after ClampValue called) to all the units","","",
    0,2,-1,0,NULL,cssElCFun_TwoDValLayerSpec_HardClampExt_stub,TA_TwoDValLayerSpec_HardClampExt_MethArgs},
  {&TA_void,NULL,"LabelUnits_impl"," label units with their underlying values","","",
    0,1,-1,0,NULL,cssElCFun_TwoDValLayerSpec_LabelUnits_impl_stub,TA_TwoDValLayerSpec_LabelUnits_impl_MethArgs},
  {&TA_void,NULL,"LabelUnits"," label units in given layer with their underlying values","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_TwoDValLayerSpec_LabelUnits_stub,TA_TwoDValLayerSpec_LabelUnits_MethArgs},
  {&TA_void,NULL,"LabelUnitsNet"," label all layers in given network using this spec","BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_TwoDValLayerSpec_LabelUnitsNet_stub,TA_TwoDValLayerSpec_LabelUnitsNet_MethArgs},
  {&TA_void,NULL,"Compute_WtBias_Val","","","",
    0,3,-1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_WtBias_Val_stub,TA_TwoDValLayerSpec_Compute_WtBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_UnBias_Val","","","",
    0,3,-1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_UnBias_Val_stub,TA_TwoDValLayerSpec_Compute_UnBias_Val_MethArgs},
  {&TA_void,NULL,"Compute_BiasVal"," initialize the bias value ","","",
    0,1,-1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_BiasVal_stub,TA_TwoDValLayerSpec_Compute_BiasVal_MethArgs},
  {&TA_void,NULL,"Compute_dWtUgp"," compute weight changes just for one unit group","","",
    0,3,-1,0,NULL,cssElCFun_TwoDValLayerSpec_Compute_dWtUgp_stub,TA_TwoDValLayerSpec_Compute_dWtUgp_MethArgs},
  {&TA_void,NULL,"ReConfig"," reconfigure layer and associated specs for current scalar.rep type; if n_units > 0, changes number of units in layer to specified value","BUTTON ","",
    0,2,1,0,NULL,cssElCFun_TwoDValLayerSpec_ReConfig_stub,TA_TwoDValLayerSpec_ReConfig_MethArgs},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Compute_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Send_Net_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_MarkerConSpec_UpdateWeights_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"na",""},
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_MarkerConSpec_MethodDef[]={
  {&TA_float,NULL,"Compute_Net"," compute net input for weights in this con group receiver-based net input ","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_Compute_Net_stub,TA_MarkerConSpec_Compute_Net_MethArgs},
  {&TA_void,NULL,"Send_Net"," sender-based net input for con group (send net input to receivers) sender-based net input computation","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_Send_Net_stub,TA_MarkerConSpec_Send_Net_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_Compute_dWt_stub,TA_MarkerConSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights (ie. add delta-wt to wt, zero delta-wt)","","",
    1,2,-1,0,NULL,cssElCFun_MarkerConSpec_UpdateWeights_stub,TA_MarkerConSpec_UpdateWeights_MethArgs},
  NULL};
static int DaModUnit::* TA_DaModUnit_MbrOff;
static MemberDef_data TA_DaModUnit_MemberDef[]={
  {&TA_float,NULL,"act_m2"," second minus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::act_m2))),0,NULL,0},
  {&TA_float,NULL,"act_p2"," second plus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::act_p2))),0,NULL,0},
  {&TA_float,NULL,"p_act_m"," previous minus phase activation ","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::p_act_m))),0,NULL,0},
  {&TA_float,NULL,"p_act_p"," previous plus phase activation","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::p_act_p))),0,NULL,0},
  {&TA_float,NULL,"dav"," modulatory dopamine value ","","",
    *((ta_memb_ptr*)&(TA_DaModUnit_MbrOff=(int DaModUnit::*)(&DaModUnit::dav))),0,NULL,0},
  NULL};
static EnumDef_data TA_DaModSpec_ModType[]={
  {"PLUS_CONT"," da modulates plus-phase activations (only) in a continuous manner","",0},
  {"PLUS_POST"," da modulates plus-phase activations (only), at the end of the plus phase","",1},
  {"NEG_DIP"," da dips provide a (decaying) negative (accomodation) current on a trial-wise basis","",2},
  NULL};
static int DaModSpec::* TA_DaModSpec_MbrOff;
static MemberDef_data TA_DaModSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to actually modulate activations by da values","","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::on))),0,NULL,0},
  {NULL,"::ModType","mod"," how to apply DA modulation","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::mod))),0,NULL,0},
  {&TA_float,NULL,"gain"," gain multiplier of da values","CONDEDIT_ON_on:true ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"neg_rec"," recovery time constant for NEG_DIP case (how much to decay negative current per trial)","CONDEDIT_ON_mod:NEG_DIP ","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::neg_rec))),0,NULL,0},
  {&TA_bool,NULL,"p_dwt"," whether units learn based on prior activation states, as in TD and other algorithms (not really to do with DA modulation; just stuck here.. affects Compute_dWt and UpdateWeights calls)","","",
    *((ta_memb_ptr*)&(TA_DaModSpec_MbrOff=(int DaModSpec::*)(&DaModSpec::p_dwt))),0,NULL,0},
  NULL};
static int DaModUnitSpec::* TA_DaModUnitSpec_MbrOff;
static MemberDef_data TA_DaModUnitSpec_MemberDef[]={
  {&TA_DaModSpec,NULL,"da_mod"," da modulation of activations (for da-based learning, and other effects)","","",
    *((ta_memb_ptr*)&(TA_DaModUnitSpec_MbrOff=(int DaModUnitSpec::*)(&DaModUnitSpec::da_mod))),0,NULL,0},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_InitState_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_Compute_dWt_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_UpdateWeights_MethArgs[]={
  {&TA_Unit_ptr,NULL,"u",""},
  NULL};
static MethodArgs_data TA_DaModUnitSpec_CheckConfig_MethArgs[]={
  {&TA_Unit_ptr,NULL,"un",""},
  {&TA_Layer_ptr,NULL,"lay",""},
  {&TA_TrialProcess_ptr,NULL,"tp",""},
  {&TA_bool,NULL,"quiet","false"},
  NULL};
static MethodDef_data TA_DaModUnitSpec_MethodDef[]={
  {&TA_void,NULL,"InitState"," initialize unit state variables","","",
    4,1,-1,0,NULL,cssElCFun_DaModUnitSpec_InitState_stub,TA_DaModUnitSpec_InitState_MethArgs},
  {&TA_void,NULL,"Compute_dWt"," compute change in weights","","",
    4,3,-1,0,NULL,cssElCFun_DaModUnitSpec_Compute_dWt_stub,TA_DaModUnitSpec_Compute_dWt_MethArgs},
  {&TA_void,NULL,"UpdateWeights"," update weights from deltas","","",
    1,1,-1,0,NULL,cssElCFun_DaModUnitSpec_UpdateWeights_stub,TA_DaModUnitSpec_UpdateWeights_MethArgs},
  {&TA_bool,NULL,"CheckConfig"," check for for misc configuration settings required by different algorithms, including settings on the processes","","",
    1,4,3,0,NULL,cssElCFun_DaModUnitSpec_CheckConfig_stub,TA_DaModUnitSpec_CheckConfig_MethArgs},
  NULL};
static int AvgExtRewSpec::* TA_AvgExtRewSpec_MbrOff;
static MemberDef_data TA_AvgExtRewSpec_MemberDef[]={
  {&TA_bool,NULL,"sub_avg"," subtract average reward value in computing rewards","DEF_false ","",
    *((ta_memb_ptr*)&(TA_AvgExtRewSpec_MbrOff=(int AvgExtRewSpec::*)(&AvgExtRewSpec::sub_avg))),0,NULL,0},
  {&TA_float,NULL,"avg_dt"," time constant for integrating average reward value","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_AvgExtRewSpec_MbrOff=(int AvgExtRewSpec::*)(&AvgExtRewSpec::avg_dt))),0,NULL,0},
  NULL};
static int OutErrSpec::* TA_OutErrSpec_MbrOff;
static MemberDef_data TA_OutErrSpec_MemberDef[]={
  {&TA_bool,NULL,"graded"," compute a graded reward signal as a function of number of correct output values","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::graded))),0,NULL,0},
  {&TA_bool,NULL,"no_off_err"," do not count a unit wrong if it is off but target says on -- only count wrong units that are on but should be off","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::no_off_err))),0,NULL,0},
  {&TA_bool,NULL,"seq_all_cor"," require that all RewTarg events in a sequence be correct before giving reward (on the last event in sequence); if graded is checked, this reward is a graded function of % correct","DEF_false ","",
    *((ta_memb_ptr*)&(TA_OutErrSpec_MbrOff=(int OutErrSpec::*)(&OutErrSpec::seq_all_cor))),0,NULL,0},
  NULL};
static int ExtRewSpec::* TA_ExtRewSpec_MbrOff;
static MemberDef_data TA_ExtRewSpec_MemberDef[]={
  {&TA_float,NULL,"err_val"," reward value for errors (when network does not respond correctly)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::err_val))),0,NULL,0},
  {&TA_float,NULL,"norew_val"," reward value when no feedback information is present","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::norew_val))),0,NULL,0},
  {&TA_float,NULL,"rew_val"," reward value for correct responses (positive rewards)","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ExtRewSpec_MbrOff=(int ExtRewSpec::*)(&ExtRewSpec::rew_val))),0,NULL,0},
  NULL};
static EnumDef_data TA_ExtRewLayerSpec_RewardType[]={
  {"OUT_ERR_REW"," get rewards as a function of errors on the output layer ONLY WHEN RewTarg layer act > .5 -- get from markerconspec from output layer(s)","",0},
  {"EXT_REW"," get rewards as external inputs marked as ext_flag = TARG to the first unit in the layer","",1},
  {"DA_REW"," get rewards from da values on first unit in layer","",2},
  NULL};
static int ExtRewLayerSpec::* TA_ExtRewLayerSpec_MbrOff;
static MemberDef_data TA_ExtRewLayerSpec_MemberDef[]={
  {NULL,"::RewardType","rew_type"," how do we get the reward values?","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::rew_type))),0,NULL,0},
  {&TA_AvgExtRewSpec,NULL,"avg_rew"," average reward computation specifications","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::avg_rew))),0,NULL,0},
  {&TA_OutErrSpec,NULL,"out_err"," how to compute external rewards based on output performance","CONDEDIT_ON_rew_type:OUT_ERR_REW ","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::out_err))),0,NULL,0},
  {&TA_ExtRewSpec,NULL,"rew"," misc reward computation specifications","","",
    *((ta_memb_ptr*)&(TA_ExtRewLayerSpec_MbrOff=(int ExtRewLayerSpec::*)(&ExtRewLayerSpec::rew))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_OutErrRewAvail_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_GetOutErrRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_OutErrRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_ExtRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_DaRew_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_UnitDa_MethArgs[]={
  {&TA_float,NULL,"er",""},
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_ExtRewLayerSpec_Compute_NoRewAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_ExtRewLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_ExtRewLayerSpec_HelpConfig_stub,NULL},
  {&TA_bool,NULL,"OutErrRewAvail"," figure out if reward is available on this trial (look if target signals are present)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_OutErrRewAvail_stub,TA_ExtRewLayerSpec_OutErrRewAvail_MethArgs},
  {&TA_float,NULL,"GetOutErrRew"," get reward value based on error at layer with MarkerConSpec connection: 1 = rew (correct), 0 = err, -1 = no info","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_GetOutErrRew_stub,TA_ExtRewLayerSpec_GetOutErrRew_MethArgs},
  {&TA_void,NULL,"Compute_OutErrRew"," get reward value based on external error (put in da val, clamp)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_OutErrRew_stub,TA_ExtRewLayerSpec_Compute_OutErrRew_MethArgs},
  {&TA_void,NULL,"Compute_ExtRew"," get external rewards from inputs (put in da val, clamp)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_ExtRew_stub,TA_ExtRewLayerSpec_Compute_ExtRew_MethArgs},
  {&TA_void,NULL,"Compute_DaRew"," clamp external rewards as da values (put in da val, clamp)","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_DaRew_stub,TA_ExtRewLayerSpec_Compute_DaRew_MethArgs},
  {&TA_void,NULL,"Compute_UnitDa"," actually compute the unit da value based on external reward value er","","",
    0,5,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_UnitDa_stub,TA_ExtRewLayerSpec_Compute_UnitDa_MethArgs},
  {&TA_void,NULL,"Compute_ZeroAct"," clamp zero activations, for minus phase","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_ZeroAct_stub,TA_ExtRewLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_NoRewAct"," clamp norew_val values for when no reward information is present","","",
    0,2,-1,0,NULL,cssElCFun_ExtRewLayerSpec_Compute_NoRewAct_stub,TA_ExtRewLayerSpec_Compute_NoRewAct_MethArgs},
  NULL};
static int ExtRew_Stat::* TA_ExtRew_Stat_MbrOff;
static MemberDef_data TA_ExtRew_Stat_MemberDef[]={
  {&TA_StatVal,NULL,"rew"," external reward value","","",
    *((ta_memb_ptr*)&(TA_ExtRew_Stat_MbrOff=(int ExtRew_Stat::*)(&ExtRew_Stat::rew))),0,NULL,0},
  NULL};
static MethodArgs_data TA_ExtRew_Stat_RecvCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodArgs_data TA_ExtRew_Stat_SendCon_Run_MethArgs[]={
  {&TA_Unit_ptr,NULL,"na",""},
  NULL};
static MethodDef_data TA_ExtRew_Stat_MethodDef[]={
  {&TA_void,NULL,"RecvCon_Run"," Compute over recv conns of a unit don't do these!","","",
    1,1,-1,0,NULL,cssElCFun_ExtRew_Stat_RecvCon_Run_stub,TA_ExtRew_Stat_RecvCon_Run_MethArgs},
  {&TA_void,NULL,"SendCon_Run"," Compute over send conns of a unit","","",
    1,1,-1,0,NULL,cssElCFun_ExtRew_Stat_SendCon_Run_stub,TA_ExtRew_Stat_SendCon_Run_MethArgs},
  NULL};
static MethodArgs_data TA_TDRewPredConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_TDRewPredConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_TDRewPredConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_TDRewPredConSpec_Compute_dWt_stub,TA_TDRewPredConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case this computes weight changes based on sender at time t-1","","",
    1,3,-1,0,NULL,cssElCFun_TDRewPredConSpec_C_Compute_Err_stub,TA_TDRewPredConSpec_C_Compute_Err_MethArgs},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_SavePred_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ClampPred_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ClampPrev_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TDRewPredLayerSpec_Compute_TdPlusPhase_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_TDRewPredLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_SavePred"," save current prediction to misc_1 for later clamping","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_SavePred_stub,TA_TDRewPredLayerSpec_Compute_SavePred_MethArgs},
  {&TA_void,NULL,"Compute_ClampPred"," clamp misc_1 to ext ","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ClampPred_stub,TA_TDRewPredLayerSpec_Compute_ClampPred_MethArgs},
  {&TA_void,NULL,"Compute_ClampPrev"," clamp minus phase to previous act value","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ClampPrev_stub,TA_TDRewPredLayerSpec_Compute_ClampPrev_MethArgs},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_ExtToPlus_stub,TA_TDRewPredLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_TdPlusPhase_impl","","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_stub,TA_TDRewPredLayerSpec_Compute_TdPlusPhase_impl_MethArgs},
  {&TA_void,NULL,"Compute_TdPlusPhase"," compute plus phase activations for learning including the td values","","",
    0,2,-1,0,NULL,cssElCFun_TDRewPredLayerSpec_Compute_TdPlusPhase_stub,TA_TDRewPredLayerSpec_Compute_TdPlusPhase_MethArgs},
  NULL};
static int TDRewIntegSpec::* TA_TDRewIntegSpec_MbrOff;
static MemberDef_data TA_TDRewIntegSpec_MemberDef[]={
  {&TA_float,NULL,"discount"," discount factor for V(t+1) from TDRewPredLayer","","",
    *((ta_memb_ptr*)&(TA_TDRewIntegSpec_MbrOff=(int TDRewIntegSpec::*)(&TDRewIntegSpec::discount))),0,NULL,0},
  NULL};
static int TDRewIntegLayerSpec::* TA_TDRewIntegLayerSpec_MbrOff;
static MemberDef_data TA_TDRewIntegLayerSpec_MemberDef[]={
  {&TA_TDRewIntegSpec,NULL,"rew_integ"," misc specs for TDRewIntegLayerSpec","","",
    *((ta_memb_ptr*)&(TA_TDRewIntegLayerSpec_MbrOff=(int TDRewIntegLayerSpec::*)(&TDRewIntegLayerSpec::rew_integ))),0,NULL,0},
  NULL};
static MethodDef_data TA_TDRewIntegLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TDRewIntegLayerSpec_HelpConfig_stub,NULL},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Compute_Td_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_TdLayerSpec_Send_Td_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_TdLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_TdLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_ZeroAct"," compute a zero td value: in minus phase","","",
    0,2,-1,0,NULL,cssElCFun_TdLayerSpec_Compute_ZeroAct_stub,TA_TdLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_Td"," compute the td value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,0,NULL,cssElCFun_TdLayerSpec_Compute_Td_stub,TA_TdLayerSpec_Compute_Td_MethArgs},
  {&TA_void,NULL,"Send_Td"," send the td value to sending projections: every cycle","","",
    0,2,-1,0,NULL,cssElCFun_TdLayerSpec_Send_Td_stub,TA_TdLayerSpec_Send_Td_MethArgs},
  NULL};
static MethodArgs_data TA_PVConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_PVConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_PVConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_PVConSpec_Compute_dWt_stub,TA_PVConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case this computes weight changes based on sender at time t-1","","",
    1,3,-1,0,NULL,cssElCFun_PVConSpec_C_Compute_Err_stub,TA_PVConSpec_C_Compute_Err_MethArgs},
  NULL};
static int PVDetectSpec::* TA_PVDetectSpec_MbrOff;
static MemberDef_data TA_PVDetectSpec_MemberDef[]={
  {&TA_float,NULL,"thr_min"," minimum threshold on PVe (ExtRew) or PVi, below which PV is considered present (i.e., punishment) (set to 0 if PVe.rew.norew_val = 0)","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_PVDetectSpec_MbrOff=(int PVDetectSpec::*)(&PVDetectSpec::thr_min))),0,NULL,0},
  {&TA_float,NULL,"thr_max"," maximum threshold on PVe (ExtRew) or PVi, above which PV is considered present (i.e., reward) (set to .4 if PVe.rew.norew_val = 0)","DEF_0.8 ","",
    *((ta_memb_ptr*)&(TA_PVDetectSpec_MbrOff=(int PVDetectSpec::*)(&PVDetectSpec::thr_max))),0,NULL,0},
  NULL};
static int PViLayerSpec::* TA_PViLayerSpec_MbrOff;
static MemberDef_data TA_PViLayerSpec_MemberDef[]={
  {&TA_PVDetectSpec,NULL,"pv_detect"," primary reward value detection spec: detect if a primary reward is present or expected","","",
    *((ta_memb_ptr*)&(TA_PViLayerSpec_MbrOff=(int PViLayerSpec::*)(&PViLayerSpec::pv_detect))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_PVe_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  {&TA_bool_ref,NULL,"actual_er_avail",""},
  {&TA_bool_ref,NULL,"pv_detected",""},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PViLayerSpec_Compute_PVPlusPhaseDwt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_PViLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_PViLayerSpec_HelpConfig_stub,NULL},
  {&TA_float,NULL,"Compute_PVe"," get excitatory primary reward value from PVe/ExtRew layer if it is available: actual_er_avail = internal flag from ExtRew layer (cheating), pv_detected = PVi layer's detection of primary reward presence or expectation based on PVi, PVe values (not cheating)","","",
    0,4,-1,0,NULL,cssElCFun_PViLayerSpec_Compute_PVe_stub,TA_PViLayerSpec_Compute_PVe_MethArgs},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,0,NULL,cssElCFun_PViLayerSpec_Compute_ExtToPlus_stub,TA_PViLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_PVPlusPhaseDwt"," compute plus phase activations as external rewards and change weights","","",
    0,2,-1,0,NULL,cssElCFun_PViLayerSpec_Compute_PVPlusPhaseDwt_stub,TA_PViLayerSpec_Compute_PVPlusPhaseDwt_MethArgs},
  NULL};
static MethodArgs_data TA_LVConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_LVConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraUnit_ptr,NULL,"ru",""},
  {&TA_LeabraUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_LVConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_LVConSpec_Compute_dWt_stub,TA_LVConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    1,3,-1,0,NULL,cssElCFun_LVConSpec_C_Compute_Err_stub,TA_LVConSpec_C_Compute_Err_MethArgs},
  NULL};
static int LVSpec::* TA_LVSpec_MbrOff;
static MemberDef_data TA_LVSpec_MemberDef[]={
  {&TA_float,NULL,"discount"," multiplicative discount factor for PVe/ExtRew/US training signal: plus phase clamp = (1-discount)*PVe","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::discount))),0,NULL,0},
  {&TA_bool,NULL,"use_actual_er"," use actual external reward presence to determine when to learn (cheating), otherwise use PVi's estimate of when primary value is avail (more realistic)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_LVSpec_MbrOff=(int LVSpec::*)(&LVSpec::use_actual_er))),0,NULL,0},
  NULL};
static int LVeLayerSpec::* TA_LVeLayerSpec_MbrOff;
static MemberDef_data TA_LVeLayerSpec_MemberDef[]={
  {&TA_LVSpec,NULL,"lv"," learned value specs","","",
    *((ta_memb_ptr*)&(TA_LVeLayerSpec_MbrOff=(int LVeLayerSpec::*)(&LVeLayerSpec::lv))),0,NULL,0},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_ExtToPlus_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_DepressWt_MethArgs[]={
  {&TA_Unit_Group_ptr,NULL,"ugp",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_LVeLayerSpec_Compute_LVPlusPhaseDwt_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_LVeLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_LVeLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_ExtToPlus"," copy ext values to act_p","","",
    0,2,-1,0,NULL,cssElCFun_LVeLayerSpec_Compute_ExtToPlus_stub,TA_LVeLayerSpec_Compute_ExtToPlus_MethArgs},
  {&TA_void,NULL,"Compute_DepressWt"," depress weights for units in unit group (only if not doing dwts!)","","",
    0,3,-1,0,NULL,cssElCFun_LVeLayerSpec_Compute_DepressWt_stub,TA_LVeLayerSpec_Compute_DepressWt_MethArgs},
  {&TA_void,NULL,"Compute_LVPlusPhaseDwt"," if primary value detected (present/expected), compute plus phase activations for learning, and actually change weights; otherwise just depress weights","","",
    0,2,-1,0,NULL,cssElCFun_LVeLayerSpec_Compute_LVPlusPhaseDwt_stub,TA_LVeLayerSpec_Compute_LVPlusPhaseDwt_MethArgs},
  NULL};
static EnumDef_data TA_PVLVDaSpec_DaMode[]={
  {"LV_PLUS_IF_PV"," da = (LVe - LVi) + [if (PV detected (present/expected), PVe - PVi]","",0},
  {"IF_PV_ELSE_LV"," if (PV detected (present/expected), da = PVe - PVi; else da = LVe - LVi","",1},
  {"PV_PLUS_LV"," da = (PVe - PVi) + (LVe - LVi)","",2},
  NULL};
static int PVLVDaSpec::* TA_PVLVDaSpec_MbrOff;
static MemberDef_data TA_PVLVDaSpec_MemberDef[]={
  {NULL,"::DaMode","mode"," how to compute DA as a function of PV and LV systems","DEF_LV_PLUS_IF_PV ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::mode))),0,NULL,0},
  {&TA_float,NULL,"tonic_da"," set a tonic 'dopamine' (DA) level (offset to add to da values)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::tonic_da))),0,NULL,0},
  {&TA_float,NULL,"min_lvi"," minimum LVi value, so that a low LVe value (~0) makes for negative DA: DA_lv = LVe - MAX(LVi, min_lvi)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::min_lvi))),0,NULL,0},
  {&TA_bool,NULL,"use_actual_er"," use actual external reward presence to determine when PV is detected (cheating), otherwise use PVi's estimate of when primary value is avail (more realistic)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PVLVDaSpec_MbrOff=(int PVLVDaSpec::*)(&PVLVDaSpec::use_actual_er))),0,NULL,0},
  NULL};
static int PVLVDaLayerSpec::* TA_PVLVDaLayerSpec_MbrOff;
static MemberDef_data TA_PVLVDaLayerSpec_MemberDef[]={
  {&TA_PVLVDaSpec,NULL,"da"," parameters for the lvpv da computation","","",
    *((ta_memb_ptr*)&(TA_PVLVDaLayerSpec_MbrOff=(int PVLVDaLayerSpec::*)(&PVLVDaLayerSpec::da))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_ZeroAct_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Compute_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PVLVDaLayerSpec_Send_Da_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_PVLVDaLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_ZeroAct"," compute a zero da value: in minus phase","","",
    0,2,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_ZeroAct_stub,TA_PVLVDaLayerSpec_Compute_ZeroAct_MethArgs},
  {&TA_void,NULL,"Compute_Da"," compute the da value based on recv projections: every cycle in 1+ phases","","",
    0,2,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_Compute_Da_stub,TA_PVLVDaLayerSpec_Compute_Da_MethArgs},
  {&TA_void,NULL,"Send_Da"," send the da value to sending projections: every cycle","","",
    0,2,-1,0,NULL,cssElCFun_PVLVDaLayerSpec_Send_Da_stub,TA_PVLVDaLayerSpec_Send_Da_MethArgs},
  NULL};
static EnumDef_data TA_SNcMiscSpec_PatchMode[]={
  {"NO_PATCH"," no patch at all","",0},
  {"PATCH"," use patch: Note currently not supported.","",1},
  NULL};
static int SNcMiscSpec::* TA_SNcMiscSpec_MbrOff;
static MemberDef_data TA_SNcMiscSpec_MemberDef[]={
  {NULL,"::PatchMode","patch_mode"," how to run the patch computation","DEF_NO_PATCH ","",
    *((ta_memb_ptr*)&(TA_SNcMiscSpec_MbrOff=(int SNcMiscSpec::*)(&SNcMiscSpec::patch_mode))),0,NULL,0},
  {&TA_float,NULL,"patch_gain"," proportion of patch (stripe-specific) da relative to global abl da","CONDEDIT_ON_patch_mode:PATCH DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_SNcMiscSpec_MbrOff=(int SNcMiscSpec::*)(&SNcMiscSpec::patch_gain))),0,NULL,0},
  NULL};
static int SNcLayerSpec::* TA_SNcLayerSpec_MbrOff;
static MemberDef_data TA_SNcLayerSpec_MemberDef[]={
  {&TA_SNcMiscSpec,NULL,"snc"," misc SNc specific parameters controlling influence of patch modulation","","",
    *((ta_memb_ptr*)&(TA_SNcLayerSpec_MbrOff=(int SNcLayerSpec::*)(&SNcLayerSpec::snc))),0,NULL,0},
  NULL};
static MethodDef_data TA_SNcLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_SNcLayerSpec_HelpConfig_stub,NULL},
  NULL};
static EnumDef_data TA_MatrixConSpec_LearnRule[]={
  {"MOTOR_DELTA"," delta rule for BG_motor: (bg+ - bg-) * s-","",0},
  {"MOTOR_CHL"," CHL rule for BG_motor: (bg+ * s+) - (bg- * s-)","",1},
  {"PFC"," PFC learning rule: (bg_p2 - bg_p) * s_p","",2},
  NULL};
static int MatrixConSpec::* TA_MatrixConSpec_MbrOff;
static MemberDef_data TA_MatrixConSpec_MemberDef[]={
  {NULL,"::LearnRule","learn_rule"," learning rule to use","","",
    *((ta_memb_ptr*)&(TA_MatrixConSpec_MbrOff=(int MatrixConSpec::*)(&MatrixConSpec::learn_rule))),0,NULL,0},
  {&TA_bool,NULL,"pfc_hebb_nego"," only allow negative dwts for pfc hebb learning","","",
    *((ta_memb_ptr*)&(TA_MatrixConSpec_MbrOff=(int MatrixConSpec::*)(&MatrixConSpec::pfc_hebb_nego))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixConSpec_Compute_dWt_MethArgs[]={
  {&TA_Con_Group_ptr,NULL,"cg",""},
  {&TA_Unit_ptr,NULL,"ru",""},
  NULL};
static MethodArgs_data TA_MatrixConSpec_C_Compute_Hebb_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_LeabraCon_Group_ptr,NULL,"cg",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodArgs_data TA_MatrixConSpec_C_Compute_Err_MethArgs[]={
  {&TA_LeabraCon_ptr,NULL,"cn",""},
  {&TA_DaModUnit_ptr,NULL,"ru",""},
  {&TA_DaModUnit_ptr,NULL,"su",""},
  NULL};
static MethodDef_data TA_MatrixConSpec_MethodDef[]={
  {&TA_void,NULL,"Compute_dWt"," compute the delta-weight change compute weight change: make new one of these for any C_ change above: hebb, err, dwt","","",
    1,2,-1,0,NULL,cssElCFun_MatrixConSpec_Compute_dWt_stub,TA_MatrixConSpec_Compute_dWt_MethArgs},
  {&TA_float,NULL,"C_Compute_Hebb"," compute Hebbian associative learning","","",
    1,4,-1,0,NULL,cssElCFun_MatrixConSpec_C_Compute_Hebb_stub,TA_MatrixConSpec_C_Compute_Hebb_MethArgs},
  {&TA_float,NULL,"C_Compute_Err"," compute generec error term, sigmoid case","","",
    1,3,-1,0,NULL,cssElCFun_MatrixConSpec_C_Compute_Err_stub,TA_MatrixConSpec_C_Compute_Err_MethArgs},
  NULL};
static EnumDef_data TA_MatrixBiasSpec_LearnRule[]={
  {"MOTOR_DELTA"," delta rule for BG_motor: (bg+ - bg-) * s-","",0},
  {"MOTOR_CHL"," CHL rule for BG_motor: (bg+ * s+) - (bg- * s-)","",1},
  {"PFC"," PFC: learn on 2p - p","",2},
  NULL};
static int MatrixBiasSpec::* TA_MatrixBiasSpec_MbrOff;
static MemberDef_data TA_MatrixBiasSpec_MemberDef[]={
  {NULL,"::LearnRule","learn_rule"," learning rule to use","","",
    *((ta_memb_ptr*)&(TA_MatrixBiasSpec_MbrOff=(int MatrixBiasSpec::*)(&MatrixBiasSpec::learn_rule))),0,NULL,0},
  NULL};
static int MatrixUnitSpec::* TA_MatrixUnitSpec_MbrOff;
static MemberDef_data TA_MatrixUnitSpec_MemberDef[]={
  {&TA_bool,NULL,"freeze_net"," freeze netinput (PFC in 2+ phase, MOTOR in 1+ phase) during learning modulation so that learning only reflects DA modulation and not other changes in netin","DEF_true ","",
    *((ta_memb_ptr*)&(TA_MatrixUnitSpec_MbrOff=(int MatrixUnitSpec::*)(&MatrixUnitSpec::freeze_net))),0,NULL,0},
  NULL};
static int ContrastSpec::* TA_ContrastSpec_MbrOff;
static MemberDef_data TA_ContrastSpec_MemberDef[]={
  {&TA_float,NULL,"gain"," overall gain for da modulation","DEF_1 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::gain))),0,NULL,0},
  {&TA_float,NULL,"go_p"," proportion of da * gate_act for DA+ on GO units: contrast enhancement","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::go_p))),0,NULL,0},
  {&TA_float,NULL,"go_n"," proportion of da * gate_act for DA- on GO units: contrast reduction","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::go_n))),0,NULL,0},
  {&TA_float,NULL,"nogo_p"," proportion of da * gate_act for DA+ on NOGO units: contrast enhancement","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::nogo_p))),0,NULL,0},
  {&TA_float,NULL,"nogo_n"," proportion of da * gate_act for DA- on NOGO units: contrast reduction","DEF_0.5 ","",
    *((ta_memb_ptr*)&(TA_ContrastSpec_MbrOff=(int ContrastSpec::*)(&ContrastSpec::nogo_n))),0,NULL,0},
  NULL};
static int MatrixRndGoSpec::* TA_MatrixRndGoSpec_MbrOff;
static MemberDef_data TA_MatrixRndGoSpec_MemberDef[]={
  {&TA_bool,NULL,"on"," whether to use random go firing function or not (if not, over max_mnt Go firing is still used)","DEF_true ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::on))),0,NULL,0},
  {&TA_float,NULL,"go_p"," probability of actually firing a random Go when all the conditions have been met","CONDEDIT_ON_on:true DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::go_p))),0,NULL,0},
  {&TA_float,NULL,"rgo_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) when max_mnt is up or a random Go is active (applied during learning, after Go/NoGo already computed)","CONDEDIT_ON_on:true DEF_20 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::rgo_da))),0,NULL,0},
  {&TA_float,NULL,"prf_go_p"," uniform random performance-only Go firing (not conditional on thresholds; happens randomly; does not cause learning)","CONDEDIT_ON_on:true DEF_1e-04 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::prf_go_p))),0,NULL,0},
  {&TA_float,NULL,"prf_rgo_da"," strength of DA for activating Go (gc.h) and inhibiting NoGo (gc.a) on a purely random basis (prf_go_p)","CONDEDIT_ON_on:true DEF_1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoSpec_MbrOff=(int MatrixRndGoSpec::*)(&MatrixRndGoSpec::prf_rgo_da))),0,NULL,0},
  NULL};
static int MatrixRndGoThrSpec::* TA_MatrixRndGoThrSpec_MbrOff;
static MemberDef_data TA_MatrixRndGoThrSpec_MemberDef[]={
  {&TA_float,NULL,"abs_thr"," absolute threshold on per stripe avg_go_da value (-1..1) for triggering random GO (if stripe_agd < abs_thr then Go p(go_p))","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::abs_thr))),0,NULL,0},
  {&TA_float,NULL,"abs_max"," absolute maximum on per stripe avg_go_da value (-1..1) above which no random GO can occur (if stripe_agd > abs_max then never Go)","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::abs_max))),0,NULL,0},
  {&TA_float,NULL,"rel"," relative threshold on per stripe avg_go_da value (-1..1) for triggering random GO (if (stripe_agd - avg_agd) < -agd_rel then Go p(go_p))","DEF_0.05 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::rel))),0,NULL,0},
  {&TA_int,NULL,"mnt"," minimum maintenance duration (trials of sustained maintenance/off) for a stripe before a random GO will fire","DEF_10 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::mnt))),0,NULL,0},
  {&TA_float,NULL,"avgrew"," threshold on global avg reward value (0..1) below which random GO can fire (uses ExtRew_Stat if avail, else avg value from ExtRewLayer)","DEF_0.9 ","",
    *((ta_memb_ptr*)&(TA_MatrixRndGoThrSpec_MbrOff=(int MatrixRndGoThrSpec::*)(&MatrixRndGoThrSpec::avgrew))),0,NULL,0},
  NULL};
static int MatrixMiscSpec::* TA_MatrixMiscSpec_MbrOff;
static MemberDef_data TA_MatrixMiscSpec_MemberDef[]={
  {&TA_float,NULL,"neg_da_bl"," negative da baseline in learning condition: this amount subtracted from all da values in learning phase (essentially reinforces nogo)","DEF_0.0002 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::neg_da_bl))),0,NULL,0},
  {&TA_float,NULL,"neg_gain"," gain for negative DA signals relative to positive ones: neg DA may need to be stronger!","DEF_1.5 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::neg_gain))),0,NULL,0},
  {&TA_float,NULL,"perf_gain"," performance effect da gain (in 2- phase for trans, 1+ for gogo)","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::perf_gain))),0,NULL,0},
  {&TA_int,NULL,"max_mnt"," maximum maintenance duration: if longer than this, NOGO is activated as per rnd_go","DEF_50 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::max_mnt))),0,NULL,0},
  {&TA_float,NULL,"avg_go_dt"," time constant for integrating the average DA value associated with Go firing for each stripe (stored in u->misc_1)","DEF_0.005 ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::avg_go_dt))),0,NULL,0},
  {&TA_bool,NULL,"no_snr_mod"," disable the Da learning modulation by SNrThal ativation (this is only to demonstrate how important it is)","DEF_false ","",
    *((ta_memb_ptr*)&(TA_MatrixMiscSpec_MbrOff=(int MatrixMiscSpec::*)(&MatrixMiscSpec::no_snr_mod))),0,NULL,0},
  NULL};
static EnumDef_data TA_MatrixLayerSpec_BGType[]={
  {"MOTOR"," matrix that gates motor cortex responses","",0},
  {"PFC"," matrix that gates pfc working memory updating","",1},
  NULL};
static int MatrixLayerSpec::* TA_MatrixLayerSpec_MbrOff;
static MemberDef_data TA_MatrixLayerSpec_MemberDef[]={
  {NULL,"::BGType","bg_type"," type of basal ganglia/frontal system: motor or pfc","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::bg_type))),0,NULL,0},
  {&TA_MatrixMiscSpec,NULL,"matrix"," misc parameters for the matrix layer","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::matrix))),0,NULL,0},
  {&TA_ContrastSpec,NULL,"contrast"," contrast enhancement effects of da/dopamine neuromodulation","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::contrast))),0,NULL,0},
  {&TA_MatrixRndGoSpec,NULL,"rnd_go"," matrix random GO firing to encourage exploration for non-productive stripes based on avg_go_da for that stripe (matrix_u->misc_1)","","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::rnd_go))),0,NULL,0},
  {&TA_MatrixRndGoThrSpec,NULL,"rnd_go_thr"," random Go firing thresholds: when to fire a random Go that drives learning","CONDEDIT_ON_rnd_go.on:true ","",
    *((ta_memb_ptr*)&(TA_MatrixLayerSpec_MbrOff=(int MatrixLayerSpec::*)(&MatrixLayerSpec::rnd_go_thr))),0,NULL,0},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_RndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_ClearRndGo_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaModUnit_NoContrast_MethArgs[]={
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"dav",""},
  {&TA_int,NULL,"go_no",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaModUnit_Contrast_MethArgs[]={
  {&TA_DaModUnit_ptr,NULL,"u",""},
  {&TA_float,NULL,"dav",""},
  {&TA_float,NULL,"gating_act",""},
  {&TA_int,NULL,"go_no",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaTonicMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaPerfMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_DaLearnMod_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraUnit_Group_ptr,NULL,"mugp",""},
  {&TA_LeabraInhib_ptr,NULL,"thr",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_MatrixLayerSpec_Compute_AvgGoDa_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_MatrixLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_MatrixLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_RndGo"," compute random GO signal for stripes that have been dormant a longish time","","",
    0,2,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_RndGo_stub,TA_MatrixLayerSpec_Compute_RndGo_MethArgs},
  {&TA_void,NULL,"Compute_ClearRndGo"," clear the rnd go signal","","",
    0,2,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_ClearRndGo_stub,TA_MatrixLayerSpec_Compute_ClearRndGo_MethArgs},
  {&TA_void,NULL,"Compute_DaModUnit_NoContrast"," apply given dopamine modulation value to the unit, based on whether it is a go (0) or nogo (1); no contrast enancement based on activation","","",
    0,3,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaModUnit_NoContrast_stub,TA_MatrixLayerSpec_Compute_DaModUnit_NoContrast_MethArgs},
  {&TA_void,NULL,"Compute_DaModUnit_Contrast"," apply given dopamine modulation value to the unit, based on whether it is a go (0) or nogo (1); contrast enhancement based on activation (gating_act)","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaModUnit_Contrast_stub,TA_MatrixLayerSpec_Compute_DaModUnit_Contrast_MethArgs},
  {&TA_void,NULL,"Compute_DaTonicMod"," compute tonic da modulation (for pfc gating units in first two phases)","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaTonicMod_stub,TA_MatrixLayerSpec_Compute_DaTonicMod_MethArgs},
  {&TA_void,NULL,"Compute_DaPerfMod"," compute dynamic da modulation; performance modulation, not learning (second minus phase)","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaPerfMod_stub,TA_MatrixLayerSpec_Compute_DaPerfMod_MethArgs},
  {&TA_void,NULL,"Compute_DaLearnMod"," compute dynamic da modulation: evaluation modulation, which is sensitive to GO/NOGO firing and activation in action phase","","",
    0,4,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_DaLearnMod_stub,TA_MatrixLayerSpec_Compute_DaLearnMod_MethArgs},
  {&TA_void,NULL,"Compute_AvgGoDa"," compute average da present when stripes fire a Go (stored in u->misc_1); used to modulate rnd_go firing","","",
    0,2,-1,0,NULL,cssElCFun_MatrixLayerSpec_Compute_AvgGoDa_stub,TA_MatrixLayerSpec_Compute_AvgGoDa_MethArgs},
  NULL};
static int SNrThalLayerSpec::* TA_SNrThalLayerSpec_MbrOff;
static MemberDef_data TA_SNrThalLayerSpec_MemberDef[]={
  {&TA_float,NULL,"avg_net_dt"," time-averaged netinput computation integration rate","","",
    *((ta_memb_ptr*)&(TA_SNrThalLayerSpec_MbrOff=(int SNrThalLayerSpec::*)(&SNrThalLayerSpec::avg_net_dt))),0,NULL,0},
  NULL};
static MethodArgs_data TA_SNrThalLayerSpec_Compute_GoNogoNet_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_SNrThalLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_SNrThalLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"Compute_GoNogoNet"," compute netinput as GO - NOGO on matrix layer","","",
    0,2,-1,0,NULL,cssElCFun_SNrThalLayerSpec_Compute_GoNogoNet_stub,TA_SNrThalLayerSpec_Compute_GoNogoNet_MethArgs},
  NULL};
static EnumDef_data TA_PFCGateSpec_GateSignal[]={
  {"GATE_GO"," gate GO unit fired ","",0},
  {"GATE_NOGO"," gate NOGO unit fired","",1},
  NULL};
static EnumDef_data TA_PFCGateSpec_GateState[]={
  {"EMPTY_GO"," stripe was empty, got a GO","",0},
  {"EMPTY_NOGO"," stripe was empty, got a NOGO","",1},
  {"LATCH_GO"," stripe was already latched, got a GO","",2},
  {"LATCH_NOGO"," stripe was already latched, got a NOGO","",3},
  {"LATCH_GOGO"," stripe was already latched, got a GO then another GO","",4},
  {"NO_GATE"," no gating took place","",5},
  {"RANDOM_GO"," matrix random-Go for stripes firing lots of NoGo (causes learning)","",6},
  {"PERF_RND_GO"," performance-only unconditional matrix random-Go ","",7},
  NULL};
static int PFCGateSpec::* TA_PFCGateSpec_MbrOff;
static MemberDef_data TA_PFCGateSpec_MemberDef[]={
  {&TA_float,NULL,"go_thr"," threshold in snrthal activation required to trigger a GO","DEF_0.1 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::go_thr))),0,NULL,0},
  {&TA_float,NULL,"off_accom"," how much of the maintenance current to apply to accommodation after turning a unit off","DEF_0 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::off_accom))),0,NULL,0},
  {&TA_bool,NULL,"updt_reset_sd"," reset synaptic depression when units are updated","DEF_true ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::updt_reset_sd))),0,NULL,0},
  {&TA_float,NULL,"snr_tie_thr"," how high does the average netinput need to be to detect a tie-deadlock among a set of snrthal units all sending equally strong GO signals, such that the net activation is < go_thr?","DEF_0.2 ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::snr_tie_thr))),0,NULL,0},
  {&TA_bool,NULL,"snr_tie_max"," choose the max active units to win in the case of a snrthal tie deadlock ","DEF_false ","",
    *((ta_memb_ptr*)&(TA_PFCGateSpec_MbrOff=(int PFCGateSpec::*)(&PFCGateSpec::snr_tie_max))),0,NULL,0},
  NULL};
static EnumDef_data TA_PFCLayerSpec_MaintUpdtAct[]={
  {"NO_UPDT"," no update action","",0},
  {"STORE"," store current activity state in maintenance currents","",1},
  {"CLEAR"," clear current activity state from maintenance currents","",2},
  {"RESTORE"," restore prior maintenance currents (after transient input activation)","",3},
  {"TMP_STORE"," temporary store of current activity state (for default maintenance of last state)","",4},
  {"TMP_CLEAR"," temporary clear of current maintenance state (for transient representation in second plus)","",5},
  NULL};
static int PFCLayerSpec::* TA_PFCLayerSpec_MbrOff;
static MemberDef_data TA_PFCLayerSpec_MemberDef[]={
  {&TA_PFCGateSpec,NULL,"gate"," parameters controlling the gating of pfc units","","",
    *((ta_memb_ptr*)&(TA_PFCLayerSpec_MbrOff=(int PFCLayerSpec::*)(&PFCLayerSpec::gate))),0,NULL,0},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_ResetSynDep_MethArgs[]={
  {&TA_LeabraUnit_ptr,NULL,"u",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_MaintUpdt_MethArgs[]={
  {&TA_LeabraUnit_Group_ptr,NULL,"ugp",""},
  {NULL,"::MaintUpdtAct","updt_act",""},
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_SendGateStates_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_TmpClear_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_GatingTrans_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodArgs_data TA_PFCLayerSpec_Compute_GatingGOGO_MethArgs[]={
  {&TA_LeabraLayer_ptr,NULL,"lay",""},
  {&TA_LeabraTrial_ptr,NULL,"trl",""},
  NULL};
static MethodDef_data TA_PFCLayerSpec_MethodDef[]={
  {&TA_void,NULL,"HelpConfig"," get help message for configuring this spec","BUTTON ","",
    0,0,-1,0,NULL,cssElCFun_PFCLayerSpec_HelpConfig_stub,NULL},
  {&TA_void,NULL,"ResetSynDep"," reset synaptic depression for sending cons from unit that was just toggled off in plus phase 1","","",
    0,3,-1,0,NULL,cssElCFun_PFCLayerSpec_ResetSynDep_stub,TA_PFCLayerSpec_ResetSynDep_MethArgs},
  {&TA_void,NULL,"Compute_MaintUpdt"," update maintenance state variables (gc.h, misc_1) based on given action","","",
    0,4,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_MaintUpdt_stub,TA_PFCLayerSpec_Compute_MaintUpdt_MethArgs},
  {&TA_void,NULL,"SendGateStates"," send misc_state gating state variables to the snrthal and matrix layers","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_SendGateStates_stub,TA_PFCLayerSpec_SendGateStates_MethArgs},
  {&TA_void,NULL,"Compute_TmpClear"," temporarily clear the maintenance of pfc units to prepare way for transient acts","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_TmpClear_stub,TA_PFCLayerSpec_Compute_TmpClear_MethArgs},
  {&TA_void,NULL,"Compute_GatingTrans"," compute the gating signal based on SNrThal layer: TRANS model","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_GatingTrans_stub,TA_PFCLayerSpec_Compute_GatingTrans_MethArgs},
  {&TA_void,NULL,"Compute_GatingGOGO"," compute the gating signal based on SNrThal layer: GOGO model","","",
    0,2,-1,0,NULL,cssElCFun_PFCLayerSpec_Compute_GatingGOGO_stub,TA_PFCLayerSpec_Compute_GatingGOGO_MethArgs},
  NULL};
static MethodArgs_data TA_LeabraWiz_StdNetwork_MethArgs[]={
  {&TA_Network_ptr,NULL,"net"," ((void *)0)"},
  NULL};
static MethodArgs_data TA_LeabraWiz_StdLayerSpecs_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraWiz_SRNContext_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  NULL};
static MethodArgs_data TA_LeabraWiz_UnitInhib_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_inhib_units","10"},
  NULL};
static MethodArgs_data TA_LeabraWiz_TD_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," false"},
  {&TA_bool,NULL,"td_mod_all"," false"},
  NULL};
static MethodArgs_data TA_LeabraWiz_PVLV_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," false"},
  {&TA_bool,NULL,"localist_val"," true"},
  {&TA_bool,NULL,"fm_hid_cons","true"},
  {&TA_bool,NULL,"fm_out_cons","false"},
  {&TA_bool,NULL,"da_mod_all"," false"},
  NULL};
static MethodArgs_data TA_LeabraWiz_BgPFC_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_bool,NULL,"bio_labels"," false"},
  {&TA_bool,NULL,"localist_val"," true"},
  {&TA_int,NULL,"n_stripes","4"},
  {&TA_bool,NULL,"fm_hid_cons","true"},
  {&TA_bool,NULL,"fm_out_cons","false"},
  {&TA_bool,NULL,"mat_fm_pfc_full"," false"},
  {&TA_bool,NULL,"make_patch","false"},
  {&TA_bool,NULL,"nolrn_pfc","false"},
  {&TA_bool,NULL,"da_mod_all"," false"},
  {&TA_bool,NULL,"lr_sched"," true"},
  NULL};
static MethodArgs_data TA_LeabraWiz_SetPFCStripes_MethArgs[]={
  {&TA_Network_ptr,NULL,"net",""},
  {&TA_int,NULL,"n_stripes",""},
  {&TA_int,NULL,"n_units","-1"},
  NULL};
static MethodDef_data TA_LeabraWiz_MethodDef[]={
  {&TA_void,NULL,"StdNetwork"," make a standard network according to the current settings (if net == NULL, new network is created)","MENU_BUTTON MENU_ON_Network NULL_OK ","",
    1,1,0,0,NULL,cssElCFun_LeabraWiz_StdNetwork_stub,TA_LeabraWiz_StdNetwork_MethArgs},
  {&TA_void,NULL,"StdLayerSpecs"," make standard layer specs for a basic Leabra network (KWTA_AVG 25% for hiddens, KWTA PAT_K for input/output)","MENU_BUTTON MENU_ON_Network MENU_SEP_BEFORE ","",
    0,1,-1,0,NULL,cssElCFun_LeabraWiz_StdLayerSpecs_stub,TA_LeabraWiz_StdLayerSpecs_MethArgs},
  {&TA_void,NULL,"SRNContext"," configure a simple-recurrent-network context layer in the network","MENU_BUTTON ","",
    0,1,-1,0,NULL,cssElCFun_LeabraWiz_SRNContext_stub,TA_LeabraWiz_SRNContext_MethArgs},
  {&TA_void,NULL,"UnitInhib"," configures unit-based inhibition for all layers in the network","MENU_BUTTON ","",
    0,2,1,0,NULL,cssElCFun_LeabraWiz_UnitInhib_stub,TA_LeabraWiz_UnitInhib_MethArgs},
  {&TA_void,NULL,"TD"," configure standard TD reinforcement learning layers; bio_labels = use biologically-based labels for layers, else functional; td_mod_all = have td value modulate all the regular units in the network","MENU_BUTTON MENU_SEP_BEFORE ","",
    0,3,1,0,NULL,cssElCFun_LeabraWiz_TD_stub,TA_LeabraWiz_TD_MethArgs},
  {&TA_void,NULL,"PVLV"," configure PVLV (pavlovian perceived value and local value) learning layers in a network; bio_labels = use biologically-based labels for layers, else functional; localist_val = use localist value representations for lvpv layers; da_mod_all = have da value modulate all the regular units in the network","MENU_BUTTON ","",
    0,6,1,0,NULL,cssElCFun_LeabraWiz_PVLV_stub,TA_LeabraWiz_PVLV_MethArgs},
  {&TA_void,NULL,"BgPFC"," configure all the layers and specs for doing basal-ganglia based gating of the pfc layer; bio_labels = label layers with biological, else functional, names; localist_val = use localist value representations for lvpv layers; fm_hid_cons = make cons to pfc/bg fm hidden layers; fm_out_cons = from output layers; mat_fm_pfc_full = make pfc -> matrix prjn full (else stripe-specific); patch per-stripe learning system optional; nolrn_pfc = pfc does not learn -- just copies input acts directly; da_mod_all = have da value modulate all the regular units in the network; lr_sched = make a learning rate schedule on BG learn cons","MENU_BUTTON MENU_SEP_BEFORE ","",
    0,11,1,0,NULL,cssElCFun_LeabraWiz_BgPFC_stub,TA_LeabraWiz_BgPFC_MethArgs},
  {&TA_void,NULL,"SetPFCStripes"," set number of 'stripes' (unit groups) throughout the entire set of pfc/bg layers (n_units = -1 = use current of units)","MENU_BUTTON  ","",
    0,3,2,0,NULL,cssElCFun_LeabraWiz_SetPFCStripes_stub,TA_LeabraWiz_SetPFCStripes_MethArgs},
  NULL};

// Init Function


static bool ta_Init_leabra_done = false;

void ta_Init_leabra() {
  TypeDef* sbt;

  if(ta_Init_leabra_done) return;
  ta_Init_leabra_done = true;

  ta_Init_ta();
  ta_Init_tamisc();
  ta_Init_pdp();

  taMisc::in_init = true;

  taMisc::types.Add(&TA_LeabraCon);
    TAI_LeabraCon = new LeabraCon;
    TA_LeabraCon.AddParFormal(&TA_class);
    TA_LeabraCon.AddParCache(&TA_taBase);
    TA_LeabraCon.AddClassPar(&TA_Connection,0);
    tac_AddMembers(TA_LeabraCon,TA_LeabraCon_MemberDef);
  taMisc::types.Add(&TA_LeabraConSpec);
    TAI_LeabraConSpec = new LeabraConSpec;
    TA_LeabraConSpec.AddParFormal(&TA_class);
    TA_LeabraConSpec.AddParCache(&TA_taBase);
    TA_LeabraConSpec.AddClassPar(&TA_ConSpec,0);
    tac_AddEnum(TA_LeabraConSpec, "LRSValue", " what value to drive the learning rate schedule with", "", "", "", TA_LeabraConSpec_LRSValue);
    tac_AddMembers(TA_LeabraConSpec,TA_LeabraConSpec_MemberDef);
    tac_AddMethods(TA_LeabraConSpec,TA_LeabraConSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraBiasSpec);
    TAI_LeabraBiasSpec = new LeabraBiasSpec;
    TA_LeabraBiasSpec.AddParFormal(&TA_class);
    TA_LeabraBiasSpec.AddParCache(&TA_taBase);
    TA_LeabraBiasSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_LeabraBiasSpec,TA_LeabraBiasSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraCon_Group);
    TAI_LeabraCon_Group = new LeabraCon_Group;
    TA_LeabraCon_Group.AddParFormal(&TA_class);
    TA_LeabraCon_Group.AddParCache(&TA_taBase);
    TA_LeabraCon_Group.AddClassPar(&TA_Con_Group,0);
    tac_AddMembers(TA_LeabraCon_Group,TA_LeabraCon_Group_MemberDef);
    tac_AddMethods(TA_LeabraCon_Group,TA_LeabraCon_Group_MethodDef);
  taMisc::types.Add(&TA_LeabraUnitSpec);
    TAI_LeabraUnitSpec = new LeabraUnitSpec;
    TA_LeabraUnitSpec.AddParFormal(&TA_class);
    TA_LeabraUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraUnitSpec.AddClassPar(&TA_UnitSpec,0);
    tac_AddEnum(TA_LeabraUnitSpec, "ActFun", "", "", "", "", TA_LeabraUnitSpec_ActFun);
    tac_AddEnum(TA_LeabraUnitSpec, "NoiseType", "", "", "", "", TA_LeabraUnitSpec_NoiseType);
    tac_AddMembers(TA_LeabraUnitSpec,TA_LeabraUnitSpec_MemberDef);
    tac_AddMethods(TA_LeabraUnitSpec,TA_LeabraUnitSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraUnit);
    TAI_LeabraUnit = new LeabraUnit;
    TA_LeabraUnit.AddParFormal(&TA_class);
    TA_LeabraUnit.AddParCache(&TA_taBase);
    TA_LeabraUnit.AddClassPar(&TA_Unit,0);
    tac_AddMembers(TA_LeabraUnit,TA_LeabraUnit_MemberDef);
    tac_AddMethods(TA_LeabraUnit,TA_LeabraUnit_MethodDef);
  taMisc::types.Add(&TA_LeabraInhib);
    TAI_LeabraInhib = new LeabraInhib;
    TA_LeabraInhib.AddParFormal(&TA_class);
    tac_AddMembers(TA_LeabraInhib,TA_LeabraInhib_MemberDef);
    tac_AddMethods(TA_LeabraInhib,TA_LeabraInhib_MethodDef);
  taMisc::types.Add(&TA_LeabraLayerSpec);
    TAI_LeabraLayerSpec = new LeabraLayerSpec;
    TA_LeabraLayerSpec.AddParFormal(&TA_class);
    TA_LeabraLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraLayerSpec.AddClassPar(&TA_LayerSpec,0);
    tac_AddEnum(TA_LeabraLayerSpec, "Compute_I", " how to compute the inhibition", "", "", "", TA_LeabraLayerSpec_Compute_I);
    tac_AddEnum(TA_LeabraLayerSpec, "InhibGroup", "", "", "", "", TA_LeabraLayerSpec_InhibGroup);
    tac_AddMembers(TA_LeabraLayerSpec,TA_LeabraLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraLayerSpec,TA_LeabraLayerSpec_MethodDef);
  taMisc::types.Add(&TA_LeabraUnit_Group);
    TAI_LeabraUnit_Group = new LeabraUnit_Group;
    TA_LeabraUnit_Group.AddParFormal(&TA_class);
    TA_LeabraUnit_Group.AddParCache(&TA_taBase);
    TA_LeabraUnit_Group.AddClassPar(&TA_Unit_Group,(int)((unsigned long)((Unit_Group*)TAI_LeabraUnit_Group)-(unsigned long)TAI_LeabraUnit_Group), &TA_LeabraInhib,(int)((unsigned long)((LeabraInhib*)TAI_LeabraUnit_Group)-(unsigned long)TAI_LeabraUnit_Group));
    tac_AddMembers(TA_LeabraUnit_Group,TA_LeabraUnit_Group_MemberDef);
    tac_AddMethods(TA_LeabraUnit_Group,TA_LeabraUnit_Group_MethodDef);
  taMisc::types.Add(&TA_LeabraLayer);
    TAI_LeabraLayer = new LeabraLayer;
    TA_LeabraLayer.AddParFormal(&TA_class);
    TA_LeabraLayer.AddParCache(&TA_taBase);
    TA_LeabraLayer.AddClassPar(&TA_Layer,(int)((unsigned long)((Layer*)TAI_LeabraLayer)-(unsigned long)TAI_LeabraLayer), &TA_LeabraInhib,(int)((unsigned long)((LeabraInhib*)TAI_LeabraLayer)-(unsigned long)TAI_LeabraLayer));
    tac_AddMembers(TA_LeabraLayer,TA_LeabraLayer_MemberDef);
    tac_AddMethods(TA_LeabraLayer,TA_LeabraLayer_MethodDef);
  taMisc::types.Add(&TA_LeabraCycle);
    TAI_LeabraCycle = new LeabraCycle;
    TA_LeabraCycle.AddParFormal(&TA_class);
    TA_LeabraCycle.AddParCache(&TA_taBase);
    TA_LeabraCycle.AddClassPar(&TA_CycleProcess,0);
    tac_AddMembers(TA_LeabraCycle,TA_LeabraCycle_MemberDef);
    tac_AddMethods(TA_LeabraCycle,TA_LeabraCycle_MethodDef);
  taMisc::types.Add(&TA_LeabraSettle);
    TAI_LeabraSettle = new LeabraSettle;
    TA_LeabraSettle.AddParFormal(&TA_class);
    TA_LeabraSettle.AddParCache(&TA_taBase);
    TA_LeabraSettle.AddClassPar(&TA_SettleProcess,0);
    tac_AddMembers(TA_LeabraSettle,TA_LeabraSettle_MemberDef);
    tac_AddMethods(TA_LeabraSettle,TA_LeabraSettle_MethodDef);
  taMisc::types.Add(&TA_LeabraTrial);
    TAI_LeabraTrial = new LeabraTrial;
    TA_LeabraTrial.AddParFormal(&TA_class);
    TA_LeabraTrial.AddParCache(&TA_taBase);
    TA_LeabraTrial.AddClassPar(&TA_TrialProcess,0);
    tac_AddEnum(TA_LeabraTrial, "StateInit", " ways of initializing the state of the network", "", "", "", TA_LeabraTrial_StateInit);
    tac_AddEnum(TA_LeabraTrial, "Phase", "", "", "", "", TA_LeabraTrial_Phase);
    tac_AddEnum(TA_LeabraTrial, "PhaseOrder", "", "", "", "", TA_LeabraTrial_PhaseOrder);
    tac_AddEnum(TA_LeabraTrial, "FirstPlusdWt", "", "", "", "", TA_LeabraTrial_FirstPlusdWt);
    tac_AddMembers(TA_LeabraTrial,TA_LeabraTrial_MemberDef);
    tac_AddMethods(TA_LeabraTrial,TA_LeabraTrial_MethodDef);
  taMisc::types.Add(&TA_LeabraMaxDa);
    TAI_LeabraMaxDa = new LeabraMaxDa;
    TA_LeabraMaxDa.AddParFormal(&TA_class);
    TA_LeabraMaxDa.AddParCache(&TA_taBase);
    TA_LeabraMaxDa.AddClassPar(&TA_Stat,0);
    tac_AddEnum(TA_LeabraMaxDa, "dAType", "", "", "", "", TA_LeabraMaxDa_dAType);
    tac_AddMembers(TA_LeabraMaxDa,TA_LeabraMaxDa_MemberDef);
    tac_AddMethods(TA_LeabraMaxDa,TA_LeabraMaxDa_MethodDef);
  taMisc::types.Add(&TA_const_LeabraCon);
    TA_const_LeabraCon.AddParents(&TA_const, &TA_LeabraCon);
  taMisc::types.Add(&TA_const_LeabraCon_ref);
    TA_const_LeabraCon_ref.AddParents(&TA_const_LeabraCon);
  taMisc::types.Add(&TA_WtScaleSpec);
    TAI_WtScaleSpec = new WtScaleSpec;
    TA_WtScaleSpec.AddParFormal(&TA_class);
    TA_WtScaleSpec.AddParCache(&TA_taBase);
    TA_WtScaleSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_WtScaleSpec,TA_WtScaleSpec_MemberDef);
    tac_AddMethods(TA_WtScaleSpec,TA_WtScaleSpec_MethodDef);
  taMisc::types.Add(&TA_const_WtScaleSpec);
    TA_const_WtScaleSpec.AddParents(&TA_const, &TA_WtScaleSpec);
  taMisc::types.Add(&TA_WtSigSpec);
    TAI_WtSigSpec = new WtSigSpec;
    TA_WtSigSpec.AddParFormal(&TA_class);
    TA_WtSigSpec.AddParCache(&TA_taBase);
    TA_WtSigSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_WtSigSpec,TA_WtSigSpec_MemberDef);
    tac_AddMethods(TA_WtSigSpec,TA_WtSigSpec_MethodDef);
  taMisc::types.Add(&TA_const_WtScaleSpec_ref);
    TA_const_WtScaleSpec_ref.AddParents(&TA_const_WtScaleSpec);
  taMisc::types.Add(&TA_const_WtSigSpec);
    TA_const_WtSigSpec.AddParents(&TA_const, &TA_WtSigSpec);
  taMisc::types.Add(&TA_const_WtSigSpec_ref);
    TA_const_WtSigSpec_ref.AddParents(&TA_const_WtSigSpec);
  taMisc::types.Add(&TA_LearnMixSpec);
    TAI_LearnMixSpec = new LearnMixSpec;
    TA_LearnMixSpec.AddParFormal(&TA_class);
    TA_LearnMixSpec.AddParCache(&TA_taBase);
    TA_LearnMixSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LearnMixSpec,TA_LearnMixSpec_MemberDef);
  taMisc::types.Add(&TA_const_LearnMixSpec);
    TA_const_LearnMixSpec.AddParents(&TA_const, &TA_LearnMixSpec);
  taMisc::types.Add(&TA_const_LearnMixSpec_ref);
    TA_const_LearnMixSpec_ref.AddParents(&TA_const_LearnMixSpec);
  taMisc::types.Add(&TA_SAvgCorSpec);
    TAI_SAvgCorSpec = new SAvgCorSpec;
    TA_SAvgCorSpec.AddParFormal(&TA_class);
    TA_SAvgCorSpec.AddParCache(&TA_taBase);
    TA_SAvgCorSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SAvgCorSpec,TA_SAvgCorSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraCon_Group_ptr);
    TA_LeabraCon_Group_ptr.AddParents(&TA_LeabraCon_Group);
  taMisc::types.Add(&TA_const_SAvgCorSpec);
    TA_const_SAvgCorSpec.AddParents(&TA_const, &TA_SAvgCorSpec);
  taMisc::types.Add(&TA_LeabraCon_ptr);
    TA_LeabraCon_ptr.AddParents(&TA_LeabraCon);
  taMisc::types.Add(&TA_const_SAvgCorSpec_ref);
    TA_const_SAvgCorSpec_ref.AddParents(&TA_const_SAvgCorSpec);
  taMisc::types.Add(&TA_LeabraUnit_ptr);
    TA_LeabraUnit_ptr.AddParents(&TA_LeabraUnit);
  taMisc::types.Add(&TA_LeabraUnitSpec_ptr);
    TA_LeabraUnitSpec_ptr.AddParents(&TA_LeabraUnitSpec);
  taMisc::types.Add(&TA_LeabraTrial_ptr);
    TA_LeabraTrial_ptr.AddParents(&TA_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraConSpec);
    TA_const_LeabraConSpec.AddParents(&TA_const, &TA_LeabraConSpec);
  taMisc::types.Add(&TA_const_LeabraConSpec_ref);
    TA_const_LeabraConSpec_ref.AddParents(&TA_const_LeabraConSpec);
  taMisc::types.Add(&TA_const_LeabraBiasSpec);
    TA_const_LeabraBiasSpec.AddParents(&TA_const, &TA_LeabraBiasSpec);
  taMisc::types.Add(&TA_const_LeabraBiasSpec_ref);
    TA_const_LeabraBiasSpec_ref.AddParents(&TA_const_LeabraBiasSpec);
  taMisc::types.Add(&TA_const_LeabraCon_Group);
    TA_const_LeabraCon_Group.AddParents(&TA_const, &TA_LeabraCon_Group);
  taMisc::types.Add(&TA_const_LeabraCon_Group_ref);
    TA_const_LeabraCon_Group_ref.AddParents(&TA_const_LeabraCon_Group);
  taMisc::types.Add(&TA_ActFunSpec);
    TAI_ActFunSpec = new ActFunSpec;
    TA_ActFunSpec.AddParFormal(&TA_class);
    TA_ActFunSpec.AddParCache(&TA_taBase);
    TA_ActFunSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ActFunSpec, "IThrFun", "", "", "", "", TA_ActFunSpec_IThrFun);
    tac_AddMembers(TA_ActFunSpec,TA_ActFunSpec_MemberDef);
  taMisc::types.Add(&TA_const_ActFunSpec);
    TA_const_ActFunSpec.AddParents(&TA_const, &TA_ActFunSpec);
  taMisc::types.Add(&TA_SpikeFunSpec);
    TAI_SpikeFunSpec = new SpikeFunSpec;
    TA_SpikeFunSpec.AddParFormal(&TA_class);
    TA_SpikeFunSpec.AddParCache(&TA_taBase);
    TA_SpikeFunSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SpikeFunSpec,TA_SpikeFunSpec_MemberDef);
  taMisc::types.Add(&TA_const_ActFunSpec_ref);
    TA_const_ActFunSpec_ref.AddParents(&TA_const_ActFunSpec);
  taMisc::types.Add(&TA_const_SpikeFunSpec);
    TA_const_SpikeFunSpec.AddParents(&TA_const, &TA_SpikeFunSpec);
  taMisc::types.Add(&TA_const_SpikeFunSpec_ref);
    TA_const_SpikeFunSpec_ref.AddParents(&TA_const_SpikeFunSpec);
  taMisc::types.Add(&TA_DepressSpec);
    TAI_DepressSpec = new DepressSpec;
    TA_DepressSpec.AddParFormal(&TA_class);
    TA_DepressSpec.AddParCache(&TA_taBase);
    TA_DepressSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_DepressSpec, "PSpike", "", "", "", "", TA_DepressSpec_PSpike);
    tac_AddMembers(TA_DepressSpec,TA_DepressSpec_MemberDef);
  taMisc::types.Add(&TA_const_DepressSpec);
    TA_const_DepressSpec.AddParents(&TA_const, &TA_DepressSpec);
  taMisc::types.Add(&TA_const_DepressSpec_ref);
    TA_const_DepressSpec_ref.AddParents(&TA_const_DepressSpec);
  taMisc::types.Add(&TA_OptThreshSpec);
    TAI_OptThreshSpec = new OptThreshSpec;
    TA_OptThreshSpec.AddParFormal(&TA_class);
    TA_OptThreshSpec.AddParCache(&TA_taBase);
    TA_OptThreshSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_OptThreshSpec,TA_OptThreshSpec_MemberDef);
  taMisc::types.Add(&TA_const_OptThreshSpec);
    TA_const_OptThreshSpec.AddParents(&TA_const, &TA_OptThreshSpec);
  taMisc::types.Add(&TA_const_OptThreshSpec_ref);
    TA_const_OptThreshSpec_ref.AddParents(&TA_const_OptThreshSpec);
  taMisc::types.Add(&TA_DtSpec);
    TAI_DtSpec = new DtSpec;
    TA_DtSpec.AddParFormal(&TA_class);
    TA_DtSpec.AddParCache(&TA_taBase);
    TA_DtSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DtSpec,TA_DtSpec_MemberDef);
  taMisc::types.Add(&TA_const_DtSpec);
    TA_const_DtSpec.AddParents(&TA_const, &TA_DtSpec);
  taMisc::types.Add(&TA_const_DtSpec_ref);
    TA_const_DtSpec_ref.AddParents(&TA_const_DtSpec);
  taMisc::types.Add(&TA_LeabraChannels);
    TAI_LeabraChannels = new LeabraChannels;
    TA_LeabraChannels.AddParFormal(&TA_class);
    TA_LeabraChannels.AddParCache(&TA_taBase);
    TA_LeabraChannels.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LeabraChannels,TA_LeabraChannels_MemberDef);
  taMisc::types.Add(&TA_const_LeabraChannels);
    TA_const_LeabraChannels.AddParents(&TA_const, &TA_LeabraChannels);
  taMisc::types.Add(&TA_const_LeabraChannels_ref);
    TA_const_LeabraChannels_ref.AddParents(&TA_const_LeabraChannels);
  taMisc::types.Add(&TA_VChanSpec);
    TAI_VChanSpec = new VChanSpec;
    TA_VChanSpec.AddParFormal(&TA_class);
    TA_VChanSpec.AddParCache(&TA_taBase);
    TA_VChanSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VChanSpec,TA_VChanSpec_MemberDef);
    tac_AddMethods(TA_VChanSpec,TA_VChanSpec_MethodDef);
  taMisc::types.Add(&TA_const_VChanSpec);
    TA_const_VChanSpec.AddParents(&TA_const, &TA_VChanSpec);
  taMisc::types.Add(&TA_ActRegSpec);
    TAI_ActRegSpec = new ActRegSpec;
    TA_ActRegSpec.AddParFormal(&TA_class);
    TA_ActRegSpec.AddParCache(&TA_taBase);
    TA_ActRegSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ActRegSpec,TA_ActRegSpec_MemberDef);
  taMisc::types.Add(&TA_const_VChanSpec_ref);
    TA_const_VChanSpec_ref.AddParents(&TA_const_VChanSpec);
  taMisc::types.Add(&TA_LeabraLayer_ptr);
    TA_LeabraLayer_ptr.AddParents(&TA_LeabraLayer);
  taMisc::types.Add(&TA_const_ActRegSpec);
    TA_const_ActRegSpec.AddParents(&TA_const, &TA_ActRegSpec);
  taMisc::types.Add(&TA_LeabraInhib_ptr);
    TA_LeabraInhib_ptr.AddParents(&TA_LeabraInhib);
  taMisc::types.Add(&TA_const_ActRegSpec_ref);
    TA_const_ActRegSpec_ref.AddParents(&TA_const_ActRegSpec);
  taMisc::types.Add(&TA_const_LeabraUnitSpec);
    TA_const_LeabraUnitSpec.AddParents(&TA_const, &TA_LeabraUnitSpec);
  taMisc::types.Add(&TA_const_LeabraUnitSpec_ref);
    TA_const_LeabraUnitSpec_ref.AddParents(&TA_const_LeabraUnitSpec);
  taMisc::types.Add(&TA_VChanBasis);
    TAI_VChanBasis = new VChanBasis;
    TA_VChanBasis.AddParFormal(&TA_class);
    TA_VChanBasis.AddParCache(&TA_taBase);
    TA_VChanBasis.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_VChanBasis,TA_VChanBasis_MemberDef);
  taMisc::types.Add(&TA_const_VChanBasis);
    TA_const_VChanBasis.AddParents(&TA_const, &TA_VChanBasis);
  taMisc::types.Add(&TA_LeabraUnitChans);
    TAI_LeabraUnitChans = new LeabraUnitChans;
    TA_LeabraUnitChans.AddParFormal(&TA_class);
    TA_LeabraUnitChans.AddParCache(&TA_taBase);
    TA_LeabraUnitChans.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LeabraUnitChans,TA_LeabraUnitChans_MemberDef);
  taMisc::types.Add(&TA_const_VChanBasis_ref);
    TA_const_VChanBasis_ref.AddParents(&TA_const_VChanBasis);
  taMisc::types.Add(&TA_const_LeabraUnit);
    TA_const_LeabraUnit.AddParents(&TA_const, &TA_LeabraUnit);
  taMisc::types.Add(&TA_const_LeabraUnitChans);
    TA_const_LeabraUnitChans.AddParents(&TA_const, &TA_LeabraUnitChans);
  taMisc::types.Add(&TA_const_LeabraUnit_ref);
    TA_const_LeabraUnit_ref.AddParents(&TA_const_LeabraUnit);
  taMisc::types.Add(&TA_const_LeabraUnitChans_ref);
    TA_const_LeabraUnitChans_ref.AddParents(&TA_const_LeabraUnitChans);
  taMisc::types.Add(&TA_taPtrList_LeabraUnit_);
    TAI_taPtrList_LeabraUnit_ = new taPtrList<LeabraUnit>;
    TA_taPtrList_LeabraUnit_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_taPtrList_LeabraUnit_.AddClassPar(&TA_taPtrList,0);
    sbt = new TypeDef("LeabraUnit_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LeabraUnit);
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    sbt = new TypeDef("const_LeabraUnit", 1, 0, 0);
    sbt->AddParents(&TA_const, &TA_LeabraUnit);
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    sbt = new TypeDef("const_LeabraUnit_ptr", 1, 1, 0);
    sbt->AddParents(TA_taPtrList_LeabraUnit_.sub_types.FindName("const_LeabraUnit"));
    TA_taPtrList_LeabraUnit_.sub_types.Add(sbt);
    tac_AddMethods(TA_taPtrList_LeabraUnit_,TA_taPtrList_LeabraUnit__MethodDef);
  taMisc::types.Add(&TA_LeabraSort);
    TAI_LeabraSort = new LeabraSort;
    TA_LeabraSort.AddParFormal(&TA_class);
    TA_LeabraSort.AddClassPar(&TA_taPtrList_LeabraUnit_,0);
    tac_AddMethods(TA_LeabraSort,TA_LeabraSort_MethodDef);
  taMisc::types.Add(&TA_KWTASpec);
    TAI_KWTASpec = new KWTASpec;
    TA_KWTASpec.AddParFormal(&TA_class);
    TA_KWTASpec.AddParCache(&TA_taBase);
    TA_KWTASpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_KWTASpec, "K_From", "", "", "", "", TA_KWTASpec_K_From);
    tac_AddMembers(TA_KWTASpec,TA_KWTASpec_MemberDef);
  taMisc::types.Add(&TA_const_KWTASpec);
    TA_const_KWTASpec.AddParents(&TA_const, &TA_KWTASpec);
  taMisc::types.Add(&TA_AdaptISpec);
    TAI_AdaptISpec = new AdaptISpec;
    TA_AdaptISpec.AddParFormal(&TA_class);
    TA_AdaptISpec.AddParCache(&TA_taBase);
    TA_AdaptISpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_AdaptISpec, "AdaptType", "", "", "", "", TA_AdaptISpec_AdaptType);
    tac_AddMembers(TA_AdaptISpec,TA_AdaptISpec_MemberDef);
  taMisc::types.Add(&TA_const_KWTASpec_ref);
    TA_const_KWTASpec_ref.AddParents(&TA_const_KWTASpec);
  taMisc::types.Add(&TA_const_AdaptISpec);
    TA_const_AdaptISpec.AddParents(&TA_const, &TA_AdaptISpec);
  taMisc::types.Add(&TA_const_AdaptISpec_ref);
    TA_const_AdaptISpec_ref.AddParents(&TA_const_AdaptISpec);
  taMisc::types.Add(&TA_ClampSpec);
    TAI_ClampSpec = new ClampSpec;
    TA_ClampSpec.AddParFormal(&TA_class);
    TA_ClampSpec.AddParCache(&TA_taBase);
    TA_ClampSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ClampSpec,TA_ClampSpec_MemberDef);
  taMisc::types.Add(&TA_const_ClampSpec);
    TA_const_ClampSpec.AddParents(&TA_const, &TA_ClampSpec);
  taMisc::types.Add(&TA_const_ClampSpec_ref);
    TA_const_ClampSpec_ref.AddParents(&TA_const_ClampSpec);
  taMisc::types.Add(&TA_DecaySpec);
    TAI_DecaySpec = new DecaySpec;
    TA_DecaySpec.AddParFormal(&TA_class);
    TA_DecaySpec.AddParCache(&TA_taBase);
    TA_DecaySpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_DecaySpec,TA_DecaySpec_MemberDef);
  taMisc::types.Add(&TA_const_DecaySpec);
    TA_const_DecaySpec.AddParents(&TA_const, &TA_DecaySpec);
  taMisc::types.Add(&TA_KWTASpec_ref);
    TA_KWTASpec_ref.AddParents(&TA_KWTASpec);
  taMisc::types.Add(&TA_const_DecaySpec_ref);
    TA_const_DecaySpec_ref.AddParents(&TA_const_DecaySpec);
  taMisc::types.Add(&TA_const_LeabraLayerSpec);
    TA_const_LeabraLayerSpec.AddParents(&TA_const, &TA_LeabraLayerSpec);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_ref);
    TA_const_LeabraLayerSpec_ref.AddParents(&TA_const_LeabraLayerSpec);
  taMisc::types.Add(&TA_SpecPtr_LeabraLayerSpec_);
    TAI_SpecPtr_LeabraLayerSpec_ = new SpecPtr<LeabraLayerSpec>;
    TA_SpecPtr_LeabraLayerSpec_.AddParFormal(&TA_class, &TA_templ_inst);
    TA_SpecPtr_LeabraLayerSpec_.AddParCache(&TA_taBase);
    TA_SpecPtr_LeabraLayerSpec_.AddClassPar(&TA_SpecPtr,0);
    sbt = new TypeDef("LeabraLayerSpec_ptr", 1, 1, 0);
    sbt->AddParents(&TA_LeabraLayerSpec);
    TA_SpecPtr_LeabraLayerSpec_.sub_types.Add(sbt);
    tac_AddEnum(TA_SpecPtr_LeabraLayerSpec_, "Orientation", " must be same values as Qt::Orientation", "", "", "", TA_SpecPtr_LeabraLayerSpec__Orientation);
    tac_AddMembers(TA_SpecPtr_LeabraLayerSpec_,TA_SpecPtr_LeabraLayerSpec__MemberDef);
    tac_AddMethods(TA_SpecPtr_LeabraLayerSpec_,TA_SpecPtr_LeabraLayerSpec__MethodDef);
  taMisc::types.Add(&TA_LeabraLayerSpec_SPtr);
    TAI_LeabraLayerSpec_SPtr = new LeabraLayerSpec_SPtr;
    TA_LeabraLayerSpec_SPtr.AddParFormal(&TA_class);
    TA_LeabraLayerSpec_SPtr.AddParCache(&TA_taBase);
    TA_LeabraLayerSpec_SPtr.AddClassPar(&TA_SpecPtr_LeabraLayerSpec_,0);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_SPtr);
    TA_const_LeabraLayerSpec_SPtr.AddParents(&TA_const, &TA_LeabraLayerSpec_SPtr);
  taMisc::types.Add(&TA_AvgMaxVals);
    TAI_AvgMaxVals = new AvgMaxVals;
    TA_AvgMaxVals.AddParFormal(&TA_class);
    TA_AvgMaxVals.AddParCache(&TA_taBase);
    TA_AvgMaxVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AvgMaxVals,TA_AvgMaxVals_MemberDef);
  taMisc::types.Add(&TA_const_LeabraLayerSpec_SPtr_ref);
    TA_const_LeabraLayerSpec_SPtr_ref.AddParents(&TA_const_LeabraLayerSpec_SPtr);
  taMisc::types.Add(&TA_const_AvgMaxVals);
    TA_const_AvgMaxVals.AddParents(&TA_const, &TA_AvgMaxVals);
  taMisc::types.Add(&TA_const_AvgMaxVals_ref);
    TA_const_AvgMaxVals_ref.AddParents(&TA_const_AvgMaxVals);
  taMisc::types.Add(&TA_KWTAVals);
    TAI_KWTAVals = new KWTAVals;
    TA_KWTAVals.AddParFormal(&TA_class);
    TA_KWTAVals.AddParCache(&TA_taBase);
    TA_KWTAVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_KWTAVals,TA_KWTAVals_MemberDef);
    tac_AddMethods(TA_KWTAVals,TA_KWTAVals_MethodDef);
  taMisc::types.Add(&TA_const_KWTAVals);
    TA_const_KWTAVals.AddParents(&TA_const, &TA_KWTAVals);
  taMisc::types.Add(&TA_const_KWTAVals_ref);
    TA_const_KWTAVals_ref.AddParents(&TA_const_KWTAVals);
  taMisc::types.Add(&TA_AdaptIVals);
    TAI_AdaptIVals = new AdaptIVals;
    TA_AdaptIVals.AddParFormal(&TA_class);
    TA_AdaptIVals.AddParCache(&TA_taBase);
    TA_AdaptIVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AdaptIVals,TA_AdaptIVals_MemberDef);
  taMisc::types.Add(&TA_const_AdaptIVals);
    TA_const_AdaptIVals.AddParents(&TA_const, &TA_AdaptIVals);
  taMisc::types.Add(&TA_const_AdaptIVals_ref);
    TA_const_AdaptIVals_ref.AddParents(&TA_const_AdaptIVals);
  taMisc::types.Add(&TA_InhibVals);
    TAI_InhibVals = new InhibVals;
    TA_InhibVals.AddParFormal(&TA_class);
    TA_InhibVals.AddParCache(&TA_taBase);
    TA_InhibVals.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_InhibVals,TA_InhibVals_MemberDef);
  taMisc::types.Add(&TA_LeabraLayerSpec_ptr);
    TA_LeabraLayerSpec_ptr.AddParents(&TA_LeabraLayerSpec);
  taMisc::types.Add(&TA_const_InhibVals);
    TA_const_InhibVals.AddParents(&TA_const, &TA_InhibVals);
  taMisc::types.Add(&TA_const_LeabraInhib);
    TA_const_LeabraInhib.AddParents(&TA_const, &TA_LeabraInhib);
  taMisc::types.Add(&TA_const_InhibVals_ref);
    TA_const_InhibVals_ref.AddParents(&TA_const_InhibVals);
  taMisc::types.Add(&TA_const_LeabraInhib_ref);
    TA_const_LeabraInhib_ref.AddParents(&TA_const_LeabraInhib);
  taMisc::types.Add(&TA_const_LeabraLayer);
    TA_const_LeabraLayer.AddParents(&TA_const, &TA_LeabraLayer);
  taMisc::types.Add(&TA_const_LeabraLayer_ref);
    TA_const_LeabraLayer_ref.AddParents(&TA_const_LeabraLayer);
  taMisc::types.Add(&TA_const_LeabraUnit_Group);
    TA_const_LeabraUnit_Group.AddParents(&TA_const, &TA_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_LeabraUnit_Group_ref);
    TA_const_LeabraUnit_Group_ref.AddParents(&TA_const_LeabraUnit_Group);
  taMisc::types.Add(&TA_LeabraSettle_ptr);
    TA_LeabraSettle_ptr.AddParents(&TA_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraCycle);
    TA_const_LeabraCycle.AddParents(&TA_const, &TA_LeabraCycle);
  taMisc::types.Add(&TA_const_LeabraCycle_ref);
    TA_const_LeabraCycle_ref.AddParents(&TA_const_LeabraCycle);
  taMisc::types.Add(&TA_const_LeabraSettle);
    TA_const_LeabraSettle.AddParents(&TA_const, &TA_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraSettle_ref);
    TA_const_LeabraSettle_ref.AddParents(&TA_const_LeabraSettle);
  taMisc::types.Add(&TA_const_LeabraTrial);
    TA_const_LeabraTrial.AddParents(&TA_const, &TA_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraTrial_ref);
    TA_const_LeabraTrial_ref.AddParents(&TA_const_LeabraTrial);
  taMisc::types.Add(&TA_const_LeabraMaxDa);
    TA_const_LeabraMaxDa.AddParents(&TA_const, &TA_LeabraMaxDa);
  taMisc::types.Add(&TA_const_LeabraMaxDa_ref);
    TA_const_LeabraMaxDa_ref.AddParents(&TA_const_LeabraMaxDa);
  taMisc::types.Add(&TA_LeabraSE_Stat);
    TAI_LeabraSE_Stat = new LeabraSE_Stat;
    TA_LeabraSE_Stat.AddParFormal(&TA_class);
    TA_LeabraSE_Stat.AddParCache(&TA_taBase);
    TA_LeabraSE_Stat.AddClassPar(&TA_SE_Stat,0);
    tac_AddMembers(TA_LeabraSE_Stat,TA_LeabraSE_Stat_MemberDef);
    tac_AddMethods(TA_LeabraSE_Stat,TA_LeabraSE_Stat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraSE_Stat);
    TA_const_LeabraSE_Stat.AddParents(&TA_const, &TA_LeabraSE_Stat);
  taMisc::types.Add(&TA_LeabraGoodStat);
    TAI_LeabraGoodStat = new LeabraGoodStat;
    TA_LeabraGoodStat.AddParFormal(&TA_class);
    TA_LeabraGoodStat.AddParCache(&TA_taBase);
    TA_LeabraGoodStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraGoodStat,TA_LeabraGoodStat_MemberDef);
    tac_AddMethods(TA_LeabraGoodStat,TA_LeabraGoodStat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraSE_Stat_ref);
    TA_const_LeabraSE_Stat_ref.AddParents(&TA_const_LeabraSE_Stat);
  taMisc::types.Add(&TA_const_LeabraGoodStat);
    TA_const_LeabraGoodStat.AddParents(&TA_const, &TA_LeabraGoodStat);
  taMisc::types.Add(&TA_const_LeabraGoodStat_ref);
    TA_const_LeabraGoodStat_ref.AddParents(&TA_const_LeabraGoodStat);
  taMisc::types.Add(&TA_LeabraSharpStat);
    TAI_LeabraSharpStat = new LeabraSharpStat;
    TA_LeabraSharpStat.AddParFormal(&TA_class);
    TA_LeabraSharpStat.AddParCache(&TA_taBase);
    TA_LeabraSharpStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraSharpStat,TA_LeabraSharpStat_MemberDef);
    tac_AddMethods(TA_LeabraSharpStat,TA_LeabraSharpStat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraSharpStat);
    TA_const_LeabraSharpStat.AddParents(&TA_const, &TA_LeabraSharpStat);
  taMisc::types.Add(&TA_const_LeabraSharpStat_ref);
    TA_const_LeabraSharpStat_ref.AddParents(&TA_const_LeabraSharpStat);
  taMisc::types.Add(&TA_WrongOnStat);
    TAI_WrongOnStat = new WrongOnStat;
    TA_WrongOnStat.AddParFormal(&TA_class);
    TA_WrongOnStat.AddParCache(&TA_taBase);
    TA_WrongOnStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_WrongOnStat,TA_WrongOnStat_MemberDef);
    tac_AddMethods(TA_WrongOnStat,TA_WrongOnStat_MethodDef);
  taMisc::types.Add(&TA_const_WrongOnStat);
    TA_const_WrongOnStat.AddParents(&TA_const, &TA_WrongOnStat);
  taMisc::types.Add(&TA_const_WrongOnStat_ref);
    TA_const_WrongOnStat_ref.AddParents(&TA_const_WrongOnStat);
  taMisc::types.Add(&TA_LeabraPrjnRelNetinStat);
    TAI_LeabraPrjnRelNetinStat = new LeabraPrjnRelNetinStat;
    TA_LeabraPrjnRelNetinStat.AddParFormal(&TA_class);
    TA_LeabraPrjnRelNetinStat.AddParCache(&TA_taBase);
    TA_LeabraPrjnRelNetinStat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_LeabraPrjnRelNetinStat,TA_LeabraPrjnRelNetinStat_MemberDef);
    tac_AddMethods(TA_LeabraPrjnRelNetinStat,TA_LeabraPrjnRelNetinStat_MethodDef);
  taMisc::types.Add(&TA_const_LeabraPrjnRelNetinStat);
    TA_const_LeabraPrjnRelNetinStat.AddParents(&TA_const, &TA_LeabraPrjnRelNetinStat);
  taMisc::types.Add(&TA_CtxtUpdateSpec);
    TAI_CtxtUpdateSpec = new CtxtUpdateSpec;
    TA_CtxtUpdateSpec.AddParFormal(&TA_class);
    TA_CtxtUpdateSpec.AddParCache(&TA_taBase);
    TA_CtxtUpdateSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_CtxtUpdateSpec,TA_CtxtUpdateSpec_MemberDef);
  taMisc::types.Add(&TA_const_LeabraPrjnRelNetinStat_ref);
    TA_const_LeabraPrjnRelNetinStat_ref.AddParents(&TA_const_LeabraPrjnRelNetinStat);
  taMisc::types.Add(&TA_const_CtxtUpdateSpec);
    TA_const_CtxtUpdateSpec.AddParents(&TA_const, &TA_CtxtUpdateSpec);
  taMisc::types.Add(&TA_const_CtxtUpdateSpec_ref);
    TA_const_CtxtUpdateSpec_ref.AddParents(&TA_const_CtxtUpdateSpec);
  taMisc::types.Add(&TA_LeabraContextLayerSpec);
    TAI_LeabraContextLayerSpec = new LeabraContextLayerSpec;
    TA_LeabraContextLayerSpec.AddParFormal(&TA_class);
    TA_LeabraContextLayerSpec.AddParCache(&TA_taBase);
    TA_LeabraContextLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_LeabraContextLayerSpec,TA_LeabraContextLayerSpec_MemberDef);
    tac_AddMethods(TA_LeabraContextLayerSpec,TA_LeabraContextLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LeabraContextLayerSpec);
    TA_const_LeabraContextLayerSpec.AddParents(&TA_const, &TA_LeabraContextLayerSpec);
  taMisc::types.Add(&TA_const_LeabraContextLayerSpec_ref);
    TA_const_LeabraContextLayerSpec_ref.AddParents(&TA_const_LeabraContextLayerSpec);
  taMisc::types.Add(&TA_PhaseOrderEventSpec);
    TAI_PhaseOrderEventSpec = new PhaseOrderEventSpec;
    TA_PhaseOrderEventSpec.AddParFormal(&TA_class);
    TA_PhaseOrderEventSpec.AddParCache(&TA_taBase);
    TA_PhaseOrderEventSpec.AddClassPar(&TA_EventSpec,0);
    tac_AddEnum(TA_PhaseOrderEventSpec, "PhaseOrder", "", "", "", "", TA_PhaseOrderEventSpec_PhaseOrder);
    tac_AddMembers(TA_PhaseOrderEventSpec,TA_PhaseOrderEventSpec_MemberDef);
  taMisc::types.Add(&TA_const_PhaseOrderEventSpec);
    TA_const_PhaseOrderEventSpec.AddParents(&TA_const, &TA_PhaseOrderEventSpec);
  taMisc::types.Add(&TA_const_PhaseOrderEventSpec_ref);
    TA_const_PhaseOrderEventSpec_ref.AddParents(&TA_const_PhaseOrderEventSpec);
  taMisc::types.Add(&TA_LeabraLinUnitSpec);
    TAI_LeabraLinUnitSpec = new LeabraLinUnitSpec;
    TA_LeabraLinUnitSpec.AddParFormal(&TA_class);
    TA_LeabraLinUnitSpec.AddParCache(&TA_taBase);
    TA_LeabraLinUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
  taMisc::types.Add(&TA_const_LeabraLinUnitSpec);
    TA_const_LeabraLinUnitSpec.AddParents(&TA_const, &TA_LeabraLinUnitSpec);
  taMisc::types.Add(&TA_const_LeabraLinUnitSpec_ref);
    TA_const_LeabraLinUnitSpec_ref.AddParents(&TA_const_LeabraLinUnitSpec);
  taMisc::types.Add(&TA_LeabraNegBiasSpec);
    TAI_LeabraNegBiasSpec = new LeabraNegBiasSpec;
    TA_LeabraNegBiasSpec.AddParFormal(&TA_class);
    TA_LeabraNegBiasSpec.AddParCache(&TA_taBase);
    TA_LeabraNegBiasSpec.AddClassPar(&TA_LeabraBiasSpec,0);
    tac_AddMembers(TA_LeabraNegBiasSpec,TA_LeabraNegBiasSpec_MemberDef);
  taMisc::types.Add(&TA_const_LeabraNegBiasSpec);
    TA_const_LeabraNegBiasSpec.AddParents(&TA_const, &TA_LeabraNegBiasSpec);
  taMisc::types.Add(&TA_const_LeabraNegBiasSpec_ref);
    TA_const_LeabraNegBiasSpec_ref.AddParents(&TA_const_LeabraNegBiasSpec);
  taMisc::types.Add(&TA_TrialSynDepCon);
    TAI_TrialSynDepCon = new TrialSynDepCon;
    TA_TrialSynDepCon.AddParFormal(&TA_class);
    TA_TrialSynDepCon.AddParCache(&TA_taBase);
    TA_TrialSynDepCon.AddClassPar(&TA_LeabraCon,0);
    tac_AddMembers(TA_TrialSynDepCon,TA_TrialSynDepCon_MemberDef);
  taMisc::types.Add(&TA_const_TrialSynDepCon);
    TA_const_TrialSynDepCon.AddParents(&TA_const, &TA_TrialSynDepCon);
  taMisc::types.Add(&TA_const_TrialSynDepCon_ref);
    TA_const_TrialSynDepCon_ref.AddParents(&TA_const_TrialSynDepCon);
  taMisc::types.Add(&TA_SynDepSpec);
    TAI_SynDepSpec = new SynDepSpec;
    TA_SynDepSpec.AddParFormal(&TA_class);
    TA_SynDepSpec.AddParCache(&TA_taBase);
    TA_SynDepSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_SynDepSpec,TA_SynDepSpec_MemberDef);
  taMisc::types.Add(&TA_TrialSynDepCon_ptr);
    TA_TrialSynDepCon_ptr.AddParents(&TA_TrialSynDepCon);
  taMisc::types.Add(&TA_const_SynDepSpec);
    TA_const_SynDepSpec.AddParents(&TA_const, &TA_SynDepSpec);
  taMisc::types.Add(&TA_const_SynDepSpec_ref);
    TA_const_SynDepSpec_ref.AddParents(&TA_const_SynDepSpec);
  taMisc::types.Add(&TA_TrialSynDepConSpec);
    TAI_TrialSynDepConSpec = new TrialSynDepConSpec;
    TA_TrialSynDepConSpec.AddParFormal(&TA_class);
    TA_TrialSynDepConSpec.AddParCache(&TA_taBase);
    TA_TrialSynDepConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_TrialSynDepConSpec,TA_TrialSynDepConSpec_MemberDef);
    tac_AddMethods(TA_TrialSynDepConSpec,TA_TrialSynDepConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TrialSynDepConSpec);
    TA_const_TrialSynDepConSpec.AddParents(&TA_const, &TA_TrialSynDepConSpec);
  taMisc::types.Add(&TA_const_TrialSynDepConSpec_ref);
    TA_const_TrialSynDepConSpec_ref.AddParents(&TA_const_TrialSynDepConSpec);
  taMisc::types.Add(&TA_FastWtCon);
    TAI_FastWtCon = new FastWtCon;
    TA_FastWtCon.AddParFormal(&TA_class);
    TA_FastWtCon.AddParCache(&TA_taBase);
    TA_FastWtCon.AddClassPar(&TA_LeabraCon,0);
    tac_AddMembers(TA_FastWtCon,TA_FastWtCon_MemberDef);
  taMisc::types.Add(&TA_const_FastWtCon);
    TA_const_FastWtCon.AddParents(&TA_const, &TA_FastWtCon);
  taMisc::types.Add(&TA_const_FastWtCon_ref);
    TA_const_FastWtCon_ref.AddParents(&TA_const_FastWtCon);
  taMisc::types.Add(&TA_FastWtSpec);
    TAI_FastWtSpec = new FastWtSpec;
    TA_FastWtSpec.AddParFormal(&TA_class);
    TA_FastWtSpec.AddParCache(&TA_taBase);
    TA_FastWtSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_FastWtSpec, "DecayMode", "", "", "", "", TA_FastWtSpec_DecayMode);
    tac_AddMembers(TA_FastWtSpec,TA_FastWtSpec_MemberDef);
  taMisc::types.Add(&TA_FastWtCon_ptr);
    TA_FastWtCon_ptr.AddParents(&TA_FastWtCon);
  taMisc::types.Add(&TA_const_FastWtSpec);
    TA_const_FastWtSpec.AddParents(&TA_const, &TA_FastWtSpec);
  taMisc::types.Add(&TA_const_FastWtSpec_ref);
    TA_const_FastWtSpec_ref.AddParents(&TA_const_FastWtSpec);
  taMisc::types.Add(&TA_FastWtConSpec);
    TAI_FastWtConSpec = new FastWtConSpec;
    TA_FastWtConSpec.AddParFormal(&TA_class);
    TA_FastWtConSpec.AddParCache(&TA_taBase);
    TA_FastWtConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMembers(TA_FastWtConSpec,TA_FastWtConSpec_MemberDef);
    tac_AddMethods(TA_FastWtConSpec,TA_FastWtConSpec_MethodDef);
  taMisc::types.Add(&TA_const_FastWtConSpec);
    TA_const_FastWtConSpec.AddParents(&TA_const, &TA_FastWtConSpec);
  taMisc::types.Add(&TA_const_FastWtConSpec_ref);
    TA_const_FastWtConSpec_ref.AddParents(&TA_const_FastWtConSpec);
  taMisc::types.Add(&TA_ScalarValSpec);
    TAI_ScalarValSpec = new ScalarValSpec;
    TA_ScalarValSpec.AddParFormal(&TA_class);
    TA_ScalarValSpec.AddParCache(&TA_taBase);
    TA_ScalarValSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ScalarValSpec, "RepType", "", "", "", "", TA_ScalarValSpec_RepType);
    tac_AddMembers(TA_ScalarValSpec,TA_ScalarValSpec_MemberDef);
    tac_AddMethods(TA_ScalarValSpec,TA_ScalarValSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValSpec);
    TA_const_ScalarValSpec.AddParents(&TA_const, &TA_ScalarValSpec);
  taMisc::types.Add(&TA_const_ScalarValSpec_ref);
    TA_const_ScalarValSpec_ref.AddParents(&TA_const_ScalarValSpec);
  taMisc::types.Add(&TA_ScalarValBias);
    TAI_ScalarValBias = new ScalarValBias;
    TA_ScalarValBias.AddParFormal(&TA_class);
    TA_ScalarValBias.AddParCache(&TA_taBase);
    TA_ScalarValBias.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_ScalarValBias, "UnitBias", " bias on individual units", "", "", "", TA_ScalarValBias_UnitBias);
    tac_AddEnum(TA_ScalarValBias, "BiasShape", " shape of the bias pattern", "", "", "", TA_ScalarValBias_BiasShape);
    tac_AddEnum(TA_ScalarValBias, "WeightBias", " bias on weights into units", "", "", "", TA_ScalarValBias_WeightBias);
    tac_AddMembers(TA_ScalarValBias,TA_ScalarValBias_MemberDef);
  taMisc::types.Add(&TA_const_ScalarValBias);
    TA_const_ScalarValBias.AddParents(&TA_const, &TA_ScalarValBias);
  taMisc::types.Add(&TA_const_ScalarValBias_ref);
    TA_const_ScalarValBias_ref.AddParents(&TA_const_ScalarValBias);
  taMisc::types.Add(&TA_ScalarValLayerSpec);
    TAI_ScalarValLayerSpec = new ScalarValLayerSpec;
    TA_ScalarValLayerSpec.AddParFormal(&TA_class);
    TA_ScalarValLayerSpec.AddParCache(&TA_taBase);
    TA_ScalarValLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_ScalarValLayerSpec,TA_ScalarValLayerSpec_MemberDef);
    tac_AddMethods(TA_ScalarValLayerSpec,TA_ScalarValLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValLayerSpec);
    TA_const_ScalarValLayerSpec.AddParents(&TA_const, &TA_ScalarValLayerSpec);
  taMisc::types.Add(&TA_const_ScalarValLayerSpec_ref);
    TA_const_ScalarValLayerSpec_ref.AddParents(&TA_const_ScalarValLayerSpec);
  taMisc::types.Add(&TA_ScalarValSelfPrjnSpec);
    TAI_ScalarValSelfPrjnSpec = new ScalarValSelfPrjnSpec;
    TA_ScalarValSelfPrjnSpec.AddParFormal(&TA_class);
    TA_ScalarValSelfPrjnSpec.AddParCache(&TA_taBase);
    TA_ScalarValSelfPrjnSpec.AddClassPar(&TA_ProjectionSpec,0);
    tac_AddMembers(TA_ScalarValSelfPrjnSpec,TA_ScalarValSelfPrjnSpec_MemberDef);
    tac_AddMethods(TA_ScalarValSelfPrjnSpec,TA_ScalarValSelfPrjnSpec_MethodDef);
  taMisc::types.Add(&TA_const_ScalarValSelfPrjnSpec);
    TA_const_ScalarValSelfPrjnSpec.AddParents(&TA_const, &TA_ScalarValSelfPrjnSpec);
  taMisc::types.Add(&TA_const_ScalarValSelfPrjnSpec_ref);
    TA_const_ScalarValSelfPrjnSpec_ref.AddParents(&TA_const_ScalarValSelfPrjnSpec);
  taMisc::types.Add(&TA_TwoDValSpec);
    TAI_TwoDValSpec = new TwoDValSpec;
    TA_TwoDValSpec.AddParFormal(&TA_class);
    TA_TwoDValSpec.AddParCache(&TA_taBase);
    TA_TwoDValSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_TwoDValSpec, "RepType", "", "", "", "", TA_TwoDValSpec_RepType);
    tac_AddMembers(TA_TwoDValSpec,TA_TwoDValSpec_MemberDef);
    tac_AddMethods(TA_TwoDValSpec,TA_TwoDValSpec_MethodDef);
  taMisc::types.Add(&TA_const_TwoDValSpec);
    TA_const_TwoDValSpec.AddParents(&TA_const, &TA_TwoDValSpec);
  taMisc::types.Add(&TA_const_TwoDValSpec_ref);
    TA_const_TwoDValSpec_ref.AddParents(&TA_const_TwoDValSpec);
  taMisc::types.Add(&TA_TwoDValBias);
    TAI_TwoDValBias = new TwoDValBias;
    TA_TwoDValBias.AddParFormal(&TA_class);
    TA_TwoDValBias.AddParCache(&TA_taBase);
    TA_TwoDValBias.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_TwoDValBias, "UnitBias", " bias on individual units", "", "", "", TA_TwoDValBias_UnitBias);
    tac_AddEnum(TA_TwoDValBias, "WeightBias", " bias on weights into units", "", "", "", TA_TwoDValBias_WeightBias);
    tac_AddMembers(TA_TwoDValBias,TA_TwoDValBias_MemberDef);
  taMisc::types.Add(&TA_const_TwoDValBias);
    TA_const_TwoDValBias.AddParents(&TA_const, &TA_TwoDValBias);
  taMisc::types.Add(&TA_const_TwoDValBias_ref);
    TA_const_TwoDValBias_ref.AddParents(&TA_const_TwoDValBias);
  taMisc::types.Add(&TA_TwoDValLayerSpec);
    TAI_TwoDValLayerSpec = new TwoDValLayerSpec;
    TA_TwoDValLayerSpec.AddParFormal(&TA_class);
    TA_TwoDValLayerSpec.AddParCache(&TA_taBase);
    TA_TwoDValLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_TwoDValLayerSpec,TA_TwoDValLayerSpec_MemberDef);
    tac_AddMethods(TA_TwoDValLayerSpec,TA_TwoDValLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TwoDValLayerSpec);
    TA_const_TwoDValLayerSpec.AddParents(&TA_const, &TA_TwoDValLayerSpec);
  taMisc::types.Add(&TA_const_TwoDValLayerSpec_ref);
    TA_const_TwoDValLayerSpec_ref.AddParents(&TA_const_TwoDValLayerSpec);
  taMisc::types.Add(&TA_MarkerConSpec);
    TAI_MarkerConSpec = new MarkerConSpec;
    TA_MarkerConSpec.AddParFormal(&TA_class);
    TA_MarkerConSpec.AddParCache(&TA_taBase);
    TA_MarkerConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_MarkerConSpec,TA_MarkerConSpec_MethodDef);
  taMisc::types.Add(&TA_const_MarkerConSpec);
    TA_const_MarkerConSpec.AddParents(&TA_const, &TA_MarkerConSpec);
  taMisc::types.Add(&TA_const_MarkerConSpec_ref);
    TA_const_MarkerConSpec_ref.AddParents(&TA_const_MarkerConSpec);
  taMisc::types.Add(&TA_DaModUnit);
    TAI_DaModUnit = new DaModUnit;
    TA_DaModUnit.AddParFormal(&TA_class);
    TA_DaModUnit.AddParCache(&TA_taBase);
    TA_DaModUnit.AddClassPar(&TA_LeabraUnit,0);
    tac_AddMembers(TA_DaModUnit,TA_DaModUnit_MemberDef);
  taMisc::types.Add(&TA_const_DaModUnit);
    TA_const_DaModUnit.AddParents(&TA_const, &TA_DaModUnit);
  taMisc::types.Add(&TA_const_DaModUnit_ref);
    TA_const_DaModUnit_ref.AddParents(&TA_const_DaModUnit);
  taMisc::types.Add(&TA_DaModSpec);
    TAI_DaModSpec = new DaModSpec;
    TA_DaModSpec.AddParFormal(&TA_class);
    TA_DaModSpec.AddParCache(&TA_taBase);
    TA_DaModSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_DaModSpec, "ModType", "", "", "", "", TA_DaModSpec_ModType);
    tac_AddMembers(TA_DaModSpec,TA_DaModSpec_MemberDef);
  taMisc::types.Add(&TA_const_DaModSpec);
    TA_const_DaModSpec.AddParents(&TA_const, &TA_DaModSpec);
  taMisc::types.Add(&TA_const_DaModSpec_ref);
    TA_const_DaModSpec_ref.AddParents(&TA_const_DaModSpec);
  taMisc::types.Add(&TA_DaModUnitSpec);
    TAI_DaModUnitSpec = new DaModUnitSpec;
    TA_DaModUnitSpec.AddParFormal(&TA_class);
    TA_DaModUnitSpec.AddParCache(&TA_taBase);
    TA_DaModUnitSpec.AddClassPar(&TA_LeabraUnitSpec,0);
    tac_AddMembers(TA_DaModUnitSpec,TA_DaModUnitSpec_MemberDef);
    tac_AddMethods(TA_DaModUnitSpec,TA_DaModUnitSpec_MethodDef);
  taMisc::types.Add(&TA_const_DaModUnitSpec);
    TA_const_DaModUnitSpec.AddParents(&TA_const, &TA_DaModUnitSpec);
  taMisc::types.Add(&TA_const_DaModUnitSpec_ref);
    TA_const_DaModUnitSpec_ref.AddParents(&TA_const_DaModUnitSpec);
  taMisc::types.Add(&TA_AvgExtRewSpec);
    TAI_AvgExtRewSpec = new AvgExtRewSpec;
    TA_AvgExtRewSpec.AddParFormal(&TA_class);
    TA_AvgExtRewSpec.AddParCache(&TA_taBase);
    TA_AvgExtRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_AvgExtRewSpec,TA_AvgExtRewSpec_MemberDef);
  taMisc::types.Add(&TA_const_AvgExtRewSpec);
    TA_const_AvgExtRewSpec.AddParents(&TA_const, &TA_AvgExtRewSpec);
  taMisc::types.Add(&TA_const_AvgExtRewSpec_ref);
    TA_const_AvgExtRewSpec_ref.AddParents(&TA_const_AvgExtRewSpec);
  taMisc::types.Add(&TA_OutErrSpec);
    TAI_OutErrSpec = new OutErrSpec;
    TA_OutErrSpec.AddParFormal(&TA_class);
    TA_OutErrSpec.AddParCache(&TA_taBase);
    TA_OutErrSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_OutErrSpec,TA_OutErrSpec_MemberDef);
  taMisc::types.Add(&TA_const_OutErrSpec);
    TA_const_OutErrSpec.AddParents(&TA_const, &TA_OutErrSpec);
  taMisc::types.Add(&TA_const_OutErrSpec_ref);
    TA_const_OutErrSpec_ref.AddParents(&TA_const_OutErrSpec);
  taMisc::types.Add(&TA_ExtRewSpec);
    TAI_ExtRewSpec = new ExtRewSpec;
    TA_ExtRewSpec.AddParFormal(&TA_class);
    TA_ExtRewSpec.AddParCache(&TA_taBase);
    TA_ExtRewSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ExtRewSpec,TA_ExtRewSpec_MemberDef);
  taMisc::types.Add(&TA_DaModUnit_ptr);
    TA_DaModUnit_ptr.AddParents(&TA_DaModUnit);
  taMisc::types.Add(&TA_const_ExtRewSpec);
    TA_const_ExtRewSpec.AddParents(&TA_const, &TA_ExtRewSpec);
  taMisc::types.Add(&TA_const_ExtRewSpec_ref);
    TA_const_ExtRewSpec_ref.AddParents(&TA_const_ExtRewSpec);
  taMisc::types.Add(&TA_ExtRewLayerSpec);
    TAI_ExtRewLayerSpec = new ExtRewLayerSpec;
    TA_ExtRewLayerSpec.AddParFormal(&TA_class);
    TA_ExtRewLayerSpec.AddParCache(&TA_taBase);
    TA_ExtRewLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddEnum(TA_ExtRewLayerSpec, "RewardType", " how do we get the reward values?", "", "", "", TA_ExtRewLayerSpec_RewardType);
    tac_AddMembers(TA_ExtRewLayerSpec,TA_ExtRewLayerSpec_MemberDef);
    tac_AddMethods(TA_ExtRewLayerSpec,TA_ExtRewLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_ExtRewLayerSpec);
    TA_const_ExtRewLayerSpec.AddParents(&TA_const, &TA_ExtRewLayerSpec);
  taMisc::types.Add(&TA_const_ExtRewLayerSpec_ref);
    TA_const_ExtRewLayerSpec_ref.AddParents(&TA_const_ExtRewLayerSpec);
  taMisc::types.Add(&TA_ExtRew_Stat);
    TAI_ExtRew_Stat = new ExtRew_Stat;
    TA_ExtRew_Stat.AddParFormal(&TA_class);
    TA_ExtRew_Stat.AddParCache(&TA_taBase);
    TA_ExtRew_Stat.AddClassPar(&TA_Stat,0);
    tac_AddMembers(TA_ExtRew_Stat,TA_ExtRew_Stat_MemberDef);
    tac_AddMethods(TA_ExtRew_Stat,TA_ExtRew_Stat_MethodDef);
  taMisc::types.Add(&TA_const_ExtRew_Stat);
    TA_const_ExtRew_Stat.AddParents(&TA_const, &TA_ExtRew_Stat);
  taMisc::types.Add(&TA_const_ExtRew_Stat_ref);
    TA_const_ExtRew_Stat_ref.AddParents(&TA_const_ExtRew_Stat);
  taMisc::types.Add(&TA_TDRewPredConSpec);
    TAI_TDRewPredConSpec = new TDRewPredConSpec;
    TA_TDRewPredConSpec.AddParFormal(&TA_class);
    TA_TDRewPredConSpec.AddParCache(&TA_taBase);
    TA_TDRewPredConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_TDRewPredConSpec,TA_TDRewPredConSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewPredConSpec);
    TA_const_TDRewPredConSpec.AddParents(&TA_const, &TA_TDRewPredConSpec);
  taMisc::types.Add(&TA_const_TDRewPredConSpec_ref);
    TA_const_TDRewPredConSpec_ref.AddParents(&TA_const_TDRewPredConSpec);
  taMisc::types.Add(&TA_TDRewPredLayerSpec);
    TAI_TDRewPredLayerSpec = new TDRewPredLayerSpec;
    TA_TDRewPredLayerSpec.AddParFormal(&TA_class);
    TA_TDRewPredLayerSpec.AddParCache(&TA_taBase);
    TA_TDRewPredLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMethods(TA_TDRewPredLayerSpec,TA_TDRewPredLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewPredLayerSpec);
    TA_const_TDRewPredLayerSpec.AddParents(&TA_const, &TA_TDRewPredLayerSpec);
  taMisc::types.Add(&TA_const_TDRewPredLayerSpec_ref);
    TA_const_TDRewPredLayerSpec_ref.AddParents(&TA_const_TDRewPredLayerSpec);
  taMisc::types.Add(&TA_TDRewIntegSpec);
    TAI_TDRewIntegSpec = new TDRewIntegSpec;
    TA_TDRewIntegSpec.AddParFormal(&TA_class);
    TA_TDRewIntegSpec.AddParCache(&TA_taBase);
    TA_TDRewIntegSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_TDRewIntegSpec,TA_TDRewIntegSpec_MemberDef);
  taMisc::types.Add(&TA_const_TDRewIntegSpec);
    TA_const_TDRewIntegSpec.AddParents(&TA_const, &TA_TDRewIntegSpec);
  taMisc::types.Add(&TA_const_TDRewIntegSpec_ref);
    TA_const_TDRewIntegSpec_ref.AddParents(&TA_const_TDRewIntegSpec);
  taMisc::types.Add(&TA_TDRewIntegLayerSpec);
    TAI_TDRewIntegLayerSpec = new TDRewIntegLayerSpec;
    TA_TDRewIntegLayerSpec.AddParFormal(&TA_class);
    TA_TDRewIntegLayerSpec.AddParCache(&TA_taBase);
    TA_TDRewIntegLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_TDRewIntegLayerSpec,TA_TDRewIntegLayerSpec_MemberDef);
    tac_AddMethods(TA_TDRewIntegLayerSpec,TA_TDRewIntegLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TDRewIntegLayerSpec);
    TA_const_TDRewIntegLayerSpec.AddParents(&TA_const, &TA_TDRewIntegLayerSpec);
  taMisc::types.Add(&TA_const_TDRewIntegLayerSpec_ref);
    TA_const_TDRewIntegLayerSpec_ref.AddParents(&TA_const_TDRewIntegLayerSpec);
  taMisc::types.Add(&TA_TdLayerSpec);
    TAI_TdLayerSpec = new TdLayerSpec;
    TA_TdLayerSpec.AddParFormal(&TA_class);
    TA_TdLayerSpec.AddParCache(&TA_taBase);
    TA_TdLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMethods(TA_TdLayerSpec,TA_TdLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_TdLayerSpec);
    TA_const_TdLayerSpec.AddParents(&TA_const, &TA_TdLayerSpec);
  taMisc::types.Add(&TA_const_TdLayerSpec_ref);
    TA_const_TdLayerSpec_ref.AddParents(&TA_const_TdLayerSpec);
  taMisc::types.Add(&TA_PVConSpec);
    TAI_PVConSpec = new PVConSpec;
    TA_PVConSpec.AddParFormal(&TA_class);
    TA_PVConSpec.AddParCache(&TA_taBase);
    TA_PVConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddMethods(TA_PVConSpec,TA_PVConSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVConSpec);
    TA_const_PVConSpec.AddParents(&TA_const, &TA_PVConSpec);
  taMisc::types.Add(&TA_const_PVConSpec_ref);
    TA_const_PVConSpec_ref.AddParents(&TA_const_PVConSpec);
  taMisc::types.Add(&TA_PVDetectSpec);
    TAI_PVDetectSpec = new PVDetectSpec;
    TA_PVDetectSpec.AddParFormal(&TA_class);
    TA_PVDetectSpec.AddParCache(&TA_taBase);
    TA_PVDetectSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_PVDetectSpec,TA_PVDetectSpec_MemberDef);
  taMisc::types.Add(&TA_const_PVDetectSpec);
    TA_const_PVDetectSpec.AddParents(&TA_const, &TA_PVDetectSpec);
  taMisc::types.Add(&TA_const_PVDetectSpec_ref);
    TA_const_PVDetectSpec_ref.AddParents(&TA_const_PVDetectSpec);
  taMisc::types.Add(&TA_PViLayerSpec);
    TAI_PViLayerSpec = new PViLayerSpec;
    TA_PViLayerSpec.AddParFormal(&TA_class);
    TA_PViLayerSpec.AddParCache(&TA_taBase);
    TA_PViLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_PViLayerSpec,TA_PViLayerSpec_MemberDef);
    tac_AddMethods(TA_PViLayerSpec,TA_PViLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PViLayerSpec);
    TA_const_PViLayerSpec.AddParents(&TA_const, &TA_PViLayerSpec);
  taMisc::types.Add(&TA_const_PViLayerSpec_ref);
    TA_const_PViLayerSpec_ref.AddParents(&TA_const_PViLayerSpec);
  taMisc::types.Add(&TA_LVConSpec);
    TAI_LVConSpec = new LVConSpec;
    TA_LVConSpec.AddParFormal(&TA_class);
    TA_LVConSpec.AddParCache(&TA_taBase);
    TA_LVConSpec.AddClassPar(&TA_TrialSynDepConSpec,0);
    tac_AddMethods(TA_LVConSpec,TA_LVConSpec_MethodDef);
  taMisc::types.Add(&TA_const_LVConSpec);
    TA_const_LVConSpec.AddParents(&TA_const, &TA_LVConSpec);
  taMisc::types.Add(&TA_const_LVConSpec_ref);
    TA_const_LVConSpec_ref.AddParents(&TA_const_LVConSpec);
  taMisc::types.Add(&TA_LVSpec);
    TAI_LVSpec = new LVSpec;
    TA_LVSpec.AddParFormal(&TA_class);
    TA_LVSpec.AddParCache(&TA_taBase);
    TA_LVSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_LVSpec,TA_LVSpec_MemberDef);
  taMisc::types.Add(&TA_const_LVSpec);
    TA_const_LVSpec.AddParents(&TA_const, &TA_LVSpec);
  taMisc::types.Add(&TA_const_LVSpec_ref);
    TA_const_LVSpec_ref.AddParents(&TA_const_LVSpec);
  taMisc::types.Add(&TA_LVeLayerSpec);
    TAI_LVeLayerSpec = new LVeLayerSpec;
    TA_LVeLayerSpec.AddParFormal(&TA_class);
    TA_LVeLayerSpec.AddParCache(&TA_taBase);
    TA_LVeLayerSpec.AddClassPar(&TA_ScalarValLayerSpec,0);
    tac_AddMembers(TA_LVeLayerSpec,TA_LVeLayerSpec_MemberDef);
    tac_AddMethods(TA_LVeLayerSpec,TA_LVeLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_LVeLayerSpec);
    TA_const_LVeLayerSpec.AddParents(&TA_const, &TA_LVeLayerSpec);
  taMisc::types.Add(&TA_const_LVeLayerSpec_ref);
    TA_const_LVeLayerSpec_ref.AddParents(&TA_const_LVeLayerSpec);
  taMisc::types.Add(&TA_LViLayerSpec);
    TAI_LViLayerSpec = new LViLayerSpec;
    TA_LViLayerSpec.AddParFormal(&TA_class);
    TA_LViLayerSpec.AddParCache(&TA_taBase);
    TA_LViLayerSpec.AddClassPar(&TA_LVeLayerSpec,0);
  taMisc::types.Add(&TA_const_LViLayerSpec);
    TA_const_LViLayerSpec.AddParents(&TA_const, &TA_LViLayerSpec);
  taMisc::types.Add(&TA_const_LViLayerSpec_ref);
    TA_const_LViLayerSpec_ref.AddParents(&TA_const_LViLayerSpec);
  taMisc::types.Add(&TA_PVLVDaSpec);
    TAI_PVLVDaSpec = new PVLVDaSpec;
    TA_PVLVDaSpec.AddParFormal(&TA_class);
    TA_PVLVDaSpec.AddParCache(&TA_taBase);
    TA_PVLVDaSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PVLVDaSpec, "DaMode", "", "", "", "", TA_PVLVDaSpec_DaMode);
    tac_AddMembers(TA_PVLVDaSpec,TA_PVLVDaSpec_MemberDef);
  taMisc::types.Add(&TA_const_PVLVDaSpec);
    TA_const_PVLVDaSpec.AddParents(&TA_const, &TA_PVLVDaSpec);
  taMisc::types.Add(&TA_const_PVLVDaSpec_ref);
    TA_const_PVLVDaSpec_ref.AddParents(&TA_const_PVLVDaSpec);
  taMisc::types.Add(&TA_PVLVDaLayerSpec);
    TAI_PVLVDaLayerSpec = new PVLVDaLayerSpec;
    TA_PVLVDaLayerSpec.AddParFormal(&TA_class);
    TA_PVLVDaLayerSpec.AddParCache(&TA_taBase);
    TA_PVLVDaLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_PVLVDaLayerSpec,TA_PVLVDaLayerSpec_MemberDef);
    tac_AddMethods(TA_PVLVDaLayerSpec,TA_PVLVDaLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PVLVDaLayerSpec);
    TA_const_PVLVDaLayerSpec.AddParents(&TA_const, &TA_PVLVDaLayerSpec);
  taMisc::types.Add(&TA_const_PVLVDaLayerSpec_ref);
    TA_const_PVLVDaLayerSpec_ref.AddParents(&TA_const_PVLVDaLayerSpec);
  taMisc::types.Add(&TA_PatchLayerSpec);
    TAI_PatchLayerSpec = new PatchLayerSpec;
    TA_PatchLayerSpec.AddParFormal(&TA_class);
    TA_PatchLayerSpec.AddParCache(&TA_taBase);
    TA_PatchLayerSpec.AddClassPar(&TA_LVeLayerSpec,0);
  taMisc::types.Add(&TA_const_PatchLayerSpec);
    TA_const_PatchLayerSpec.AddParents(&TA_const, &TA_PatchLayerSpec);
  taMisc::types.Add(&TA_const_PatchLayerSpec_ref);
    TA_const_PatchLayerSpec_ref.AddParents(&TA_const_PatchLayerSpec);
  taMisc::types.Add(&TA_SNcMiscSpec);
    TAI_SNcMiscSpec = new SNcMiscSpec;
    TA_SNcMiscSpec.AddParFormal(&TA_class);
    TA_SNcMiscSpec.AddParCache(&TA_taBase);
    TA_SNcMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_SNcMiscSpec, "PatchMode", "", "", "", "", TA_SNcMiscSpec_PatchMode);
    tac_AddMembers(TA_SNcMiscSpec,TA_SNcMiscSpec_MemberDef);
  taMisc::types.Add(&TA_const_SNcMiscSpec);
    TA_const_SNcMiscSpec.AddParents(&TA_const, &TA_SNcMiscSpec);
  taMisc::types.Add(&TA_const_SNcMiscSpec_ref);
    TA_const_SNcMiscSpec_ref.AddParents(&TA_const_SNcMiscSpec);
  taMisc::types.Add(&TA_SNcLayerSpec);
    TAI_SNcLayerSpec = new SNcLayerSpec;
    TA_SNcLayerSpec.AddParFormal(&TA_class);
    TA_SNcLayerSpec.AddParCache(&TA_taBase);
    TA_SNcLayerSpec.AddClassPar(&TA_PVLVDaLayerSpec,0);
    tac_AddMembers(TA_SNcLayerSpec,TA_SNcLayerSpec_MemberDef);
    tac_AddMethods(TA_SNcLayerSpec,TA_SNcLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_SNcLayerSpec);
    TA_const_SNcLayerSpec.AddParents(&TA_const, &TA_SNcLayerSpec);
  taMisc::types.Add(&TA_const_SNcLayerSpec_ref);
    TA_const_SNcLayerSpec_ref.AddParents(&TA_const_SNcLayerSpec);
  taMisc::types.Add(&TA_MatrixConSpec);
    TAI_MatrixConSpec = new MatrixConSpec;
    TA_MatrixConSpec.AddParFormal(&TA_class);
    TA_MatrixConSpec.AddParCache(&TA_taBase);
    TA_MatrixConSpec.AddClassPar(&TA_LeabraConSpec,0);
    tac_AddEnum(TA_MatrixConSpec, "LearnRule", "", "", "", "", TA_MatrixConSpec_LearnRule);
    tac_AddMembers(TA_MatrixConSpec,TA_MatrixConSpec_MemberDef);
    tac_AddMethods(TA_MatrixConSpec,TA_MatrixConSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixConSpec);
    TA_const_MatrixConSpec.AddParents(&TA_const, &TA_MatrixConSpec);
  taMisc::types.Add(&TA_const_MatrixConSpec_ref);
    TA_const_MatrixConSpec_ref.AddParents(&TA_const_MatrixConSpec);
  taMisc::types.Add(&TA_MatrixBiasSpec);
    TAI_MatrixBiasSpec = new MatrixBiasSpec;
    TA_MatrixBiasSpec.AddParFormal(&TA_class);
    TA_MatrixBiasSpec.AddParCache(&TA_taBase);
    TA_MatrixBiasSpec.AddClassPar(&TA_LeabraBiasSpec,0);
    tac_AddEnum(TA_MatrixBiasSpec, "LearnRule", "", "", "", "", TA_MatrixBiasSpec_LearnRule);
    tac_AddMembers(TA_MatrixBiasSpec,TA_MatrixBiasSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixBiasSpec);
    TA_const_MatrixBiasSpec.AddParents(&TA_const, &TA_MatrixBiasSpec);
  taMisc::types.Add(&TA_const_MatrixBiasSpec_ref);
    TA_const_MatrixBiasSpec_ref.AddParents(&TA_const_MatrixBiasSpec);
  taMisc::types.Add(&TA_MatrixUnitSpec);
    TAI_MatrixUnitSpec = new MatrixUnitSpec;
    TA_MatrixUnitSpec.AddParFormal(&TA_class);
    TA_MatrixUnitSpec.AddParCache(&TA_taBase);
    TA_MatrixUnitSpec.AddClassPar(&TA_DaModUnitSpec,0);
    tac_AddMembers(TA_MatrixUnitSpec,TA_MatrixUnitSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixUnitSpec);
    TA_const_MatrixUnitSpec.AddParents(&TA_const, &TA_MatrixUnitSpec);
  taMisc::types.Add(&TA_const_MatrixUnitSpec_ref);
    TA_const_MatrixUnitSpec_ref.AddParents(&TA_const_MatrixUnitSpec);
  taMisc::types.Add(&TA_ContrastSpec);
    TAI_ContrastSpec = new ContrastSpec;
    TA_ContrastSpec.AddParFormal(&TA_class);
    TA_ContrastSpec.AddParCache(&TA_taBase);
    TA_ContrastSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_ContrastSpec,TA_ContrastSpec_MemberDef);
  taMisc::types.Add(&TA_const_ContrastSpec);
    TA_const_ContrastSpec.AddParents(&TA_const, &TA_ContrastSpec);
  taMisc::types.Add(&TA_const_ContrastSpec_ref);
    TA_const_ContrastSpec_ref.AddParents(&TA_const_ContrastSpec);
  taMisc::types.Add(&TA_MatrixRndGoSpec);
    TAI_MatrixRndGoSpec = new MatrixRndGoSpec;
    TA_MatrixRndGoSpec.AddParFormal(&TA_class);
    TA_MatrixRndGoSpec.AddParCache(&TA_taBase);
    TA_MatrixRndGoSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixRndGoSpec,TA_MatrixRndGoSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixRndGoSpec);
    TA_const_MatrixRndGoSpec.AddParents(&TA_const, &TA_MatrixRndGoSpec);
  taMisc::types.Add(&TA_const_MatrixRndGoSpec_ref);
    TA_const_MatrixRndGoSpec_ref.AddParents(&TA_const_MatrixRndGoSpec);
  taMisc::types.Add(&TA_MatrixRndGoThrSpec);
    TAI_MatrixRndGoThrSpec = new MatrixRndGoThrSpec;
    TA_MatrixRndGoThrSpec.AddParFormal(&TA_class);
    TA_MatrixRndGoThrSpec.AddParCache(&TA_taBase);
    TA_MatrixRndGoThrSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixRndGoThrSpec,TA_MatrixRndGoThrSpec_MemberDef);
  taMisc::types.Add(&TA_const_MatrixRndGoThrSpec);
    TA_const_MatrixRndGoThrSpec.AddParents(&TA_const, &TA_MatrixRndGoThrSpec);
  taMisc::types.Add(&TA_const_MatrixRndGoThrSpec_ref);
    TA_const_MatrixRndGoThrSpec_ref.AddParents(&TA_const_MatrixRndGoThrSpec);
  taMisc::types.Add(&TA_MatrixMiscSpec);
    TAI_MatrixMiscSpec = new MatrixMiscSpec;
    TA_MatrixMiscSpec.AddParFormal(&TA_class);
    TA_MatrixMiscSpec.AddParCache(&TA_taBase);
    TA_MatrixMiscSpec.AddClassPar(&TA_taBase,0);
    tac_AddMembers(TA_MatrixMiscSpec,TA_MatrixMiscSpec_MemberDef);
  taMisc::types.Add(&TA_LeabraUnit_Group_ptr);
    TA_LeabraUnit_Group_ptr.AddParents(&TA_LeabraUnit_Group);
  taMisc::types.Add(&TA_const_MatrixMiscSpec);
    TA_const_MatrixMiscSpec.AddParents(&TA_const, &TA_MatrixMiscSpec);
  taMisc::types.Add(&TA_const_MatrixMiscSpec_ref);
    TA_const_MatrixMiscSpec_ref.AddParents(&TA_const_MatrixMiscSpec);
  taMisc::types.Add(&TA_MatrixLayerSpec);
    TAI_MatrixLayerSpec = new MatrixLayerSpec;
    TA_MatrixLayerSpec.AddParFormal(&TA_class);
    TA_MatrixLayerSpec.AddParCache(&TA_taBase);
    TA_MatrixLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_MatrixLayerSpec, "BGType", " which type of basal ganglia circuit is this?", "", "", "", TA_MatrixLayerSpec_BGType);
    tac_AddMembers(TA_MatrixLayerSpec,TA_MatrixLayerSpec_MemberDef);
    tac_AddMethods(TA_MatrixLayerSpec,TA_MatrixLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_MatrixLayerSpec);
    TA_const_MatrixLayerSpec.AddParents(&TA_const, &TA_MatrixLayerSpec);
  taMisc::types.Add(&TA_const_MatrixLayerSpec_ref);
    TA_const_MatrixLayerSpec_ref.AddParents(&TA_const_MatrixLayerSpec);
  taMisc::types.Add(&TA_SNrThalLayerSpec);
    TAI_SNrThalLayerSpec = new SNrThalLayerSpec;
    TA_SNrThalLayerSpec.AddParFormal(&TA_class);
    TA_SNrThalLayerSpec.AddParCache(&TA_taBase);
    TA_SNrThalLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddMembers(TA_SNrThalLayerSpec,TA_SNrThalLayerSpec_MemberDef);
    tac_AddMethods(TA_SNrThalLayerSpec,TA_SNrThalLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_SNrThalLayerSpec);
    TA_const_SNrThalLayerSpec.AddParents(&TA_const, &TA_SNrThalLayerSpec);
  taMisc::types.Add(&TA_const_SNrThalLayerSpec_ref);
    TA_const_SNrThalLayerSpec_ref.AddParents(&TA_const_SNrThalLayerSpec);
  taMisc::types.Add(&TA_PFCGateSpec);
    TAI_PFCGateSpec = new PFCGateSpec;
    TA_PFCGateSpec.AddParFormal(&TA_class);
    TA_PFCGateSpec.AddParCache(&TA_taBase);
    TA_PFCGateSpec.AddClassPar(&TA_taBase,0);
    tac_AddEnum(TA_PFCGateSpec, "GateSignal", "", "", "", "", TA_PFCGateSpec_GateSignal);
    tac_AddEnum(TA_PFCGateSpec, "GateState", " what happened on last gating action, stored in misc_state1 on unit group", "", "", "", TA_PFCGateSpec_GateState);
    tac_AddMembers(TA_PFCGateSpec,TA_PFCGateSpec_MemberDef);
  taMisc::types.Add(&TA_const_PFCGateSpec);
    TA_const_PFCGateSpec.AddParents(&TA_const, &TA_PFCGateSpec);
  taMisc::types.Add(&TA_const_PFCGateSpec_ref);
    TA_const_PFCGateSpec_ref.AddParents(&TA_const_PFCGateSpec);
  taMisc::types.Add(&TA_PFCLayerSpec);
    TAI_PFCLayerSpec = new PFCLayerSpec;
    TA_PFCLayerSpec.AddParFormal(&TA_class);
    TA_PFCLayerSpec.AddParCache(&TA_taBase);
    TA_PFCLayerSpec.AddClassPar(&TA_LeabraLayerSpec,0);
    tac_AddEnum(TA_PFCLayerSpec, "MaintUpdtAct", "", "", "", "", TA_PFCLayerSpec_MaintUpdtAct);
    tac_AddMembers(TA_PFCLayerSpec,TA_PFCLayerSpec_MemberDef);
    tac_AddMethods(TA_PFCLayerSpec,TA_PFCLayerSpec_MethodDef);
  taMisc::types.Add(&TA_const_PFCLayerSpec);
    TA_const_PFCLayerSpec.AddParents(&TA_const, &TA_PFCLayerSpec);
  taMisc::types.Add(&TA_const_PFCLayerSpec_ref);
    TA_const_PFCLayerSpec_ref.AddParents(&TA_const_PFCLayerSpec);
  taMisc::types.Add(&TA_LeabraWiz);
    TAI_LeabraWiz = new LeabraWiz;
    TA_LeabraWiz.AddParFormal(&TA_class);
    TA_LeabraWiz.AddParCache(&TA_taBase);
    TA_LeabraWiz.AddClassPar(&TA_Wizard,0);
    tac_AddMethods(TA_LeabraWiz,TA_LeabraWiz_MethodDef);
  taMisc::types.Add(&TA_const_LeabraWiz);
    TA_const_LeabraWiz.AddParents(&TA_const, &TA_LeabraWiz);
  taMisc::types.Add(&TA_const_LeabraWiz_ref);
    TA_const_LeabraWiz_ref.AddParents(&TA_const_LeabraWiz);


  taMisc::in_init = false;
} 

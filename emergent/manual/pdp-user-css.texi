@c uncomment the following two lines for 'update every node' command
@c @node  css
@c @chapter Guide to the Script Language (CSS)

CSS is the script language for the PDP++ software.  It is a
general-purpose language that allows one to do virtually anything that
could be done by writing programs in C or C++ and compiling them.  It
provides full access to all the types and objects defined in PDP++, and
allows you to call the "member functions" of these objects and set the
values of their members variables.

There are two principal uses for the script language in running
simulations.  One is to automate the procedure of setting up and running
a simulation.  In this role, the script replaces commands that would
otherwise be given through the graphical user interface (gui).  The
other is to extend the software without having to re-compile and
re-link.  Thus, one can write new kinds of procedures, statistics, etc.
that are particular to a given simulation in the script language, and
run them as if they were hard coded.  This gives the PDP++ software more 
flexibility.

@menu
* css-intro::                   Introduction to CSS
* css-tut::                     Tutorial Example of Using CSS
* css-from-c::                  CSS For C/C++ Programmers
* css-ref::                     CSS Reference Information
* css-errors::                  Common User Errors in CSS
* css-hard::                    Compiling CSS files as C++ Hard Code
@end menu


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node css-intro, css-tut, css, css
@section Introduction to CSS

CSS is a "C" language interpreter and script language (C Super-Script).
The name derives from the fact that the language is C, written in C, so
it is C to the C, or C^c, while at the same time being an excellent,
even superlative scripting language.  The actual syntax for CSS is
somewhere in between C and C++, and the language is written entirely in
C++.  The major differences between CSS and C++ are listed in
@ref{css-c++-diff}, and the few discrepancies between CSS and C are
noted in @ref{css-c-diff}.  Some of the convenient features of C++ that
are incorporated into CSS are enumerated in @ref{css-c++-intro}, for
those unfamiliar with C++.

Being an interpreter, CSS presents the user with a prompt: @code{css>}.
At this prompt, the user can enter any C expression, which will be
evaluated immediately upon pressing Return, or enter a command.  The
commands operate much like a debugger (e.g., gdb, dbx), and allow
control over the running, listing, and debugging of programs.  In
addition to the default "immediate mode" behavior of the system, it
can behave like a compiler.  For example, the command @code{define} will
cause the system to enter a compiling mode (the prompt changes to
@code{css\# }), where the C code that is subsequently entered is
compiled into an intermediate machine code, but not run directly.
Instead, it becomes a stored program that can be run many times.

Typically, one works with a program file (use the extension .css to
indicate a css file) that is loaded and then run, instead of manually
typing programs into the system using define mode.  The command
@code{load "filename.css"} will load a file and compile it, at which
point it can be run.  The command @code{run} will run the program from
the beginning.  @code{reload} will remove the existing compiled program
and load (and re-compile) the previously loaded one from the disk file,
which is handy when you are editing the program file and testing it out.

One can view the source code within CSS by using the @code{list}
command, which takes (optional) line number and length arguments.
Unlike C functions, which need to be called with the usual syntax of
parentheses around the arguments, which are themselves comma separated,
and the whole thing is terminated by a semi-colon, the arguments to
commands don't require the parentheses or the semi-colon, but do require
thte commas.

One of the principle uses of CSS is as an interface for hard-coded C/C++
programs.  There is a "TypeAccess" program that reads the header files
for a given application and generates type information that can be used
by CSS to automatically interface with the objects and types in the
hard-coded world.  CSS comes initially with some relevant hard-coded
types from the standard C/C++ library, including a String class and the
stream I/O classes, and various math and posix library functions.


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-tut, css-from-c, css-intro, css
@section Tutorial Example of Using CSS

This section provides a tutorial-style introduction to some of the
features of the CSS language environment.

@menu
* css-tut-run::                 Running an Example Program in CSS
* css-tut-debug::               Debugging an Example Program in CSS
* css-tut-access::              Accessing Hard-Coded Functions and Variables in CSS
@end menu


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-tut-run, css-tut-debug, css-tut, css-tut
@subsection Running an Example Program in CSS

The following example will be used to illustrate the use of the CSS
system:

@example

// a function that decodes the number
String Decode_Number(float number) @{
  String rval = "The number, " + number + " is: ";
  if(number < 0)
    rval += "negative";
  else if(number < .5)
    rval += "less than .5";
  else if(number < 1)
    rval += "less than 1";
  else
    rval += "greater than 1";
  return rval;
@}

// decodes n_numbers randomly generated numbers
void Decode_Random(int n_numbers) @{
  int i;
  for(i=0; i<n_numbers; i++) @{
    float number = 4.0 * (drand48()-.5);
    String decode = Decode_Number(number);  // call our decoding function
    cout << i << "\t" << decode << "\n";    // c++ style output
  @}
@}

@end example

You can enter this code using a text editor (e.g., emacs or vi), or use
the example code in @file{css_example.css} included with the PDP++
software in the @file{css/include} directory.  Then, run the PDP++
software.  At the prompt (which will vary depending on which executable
you run --- the example will use @code{css>}), type:

@example
css> load "css_example.css"
@end example

and the prompt should return.  If you made any typos, they might show up
as a Syntax Error, and should be corrected in the text file, which can
be re-loaded with:

@example
css> reload
@end example

Loading the text file translates it into an internal "machine code" that
actually implements CSS.  This is like compiling the code in traditional
C, but it does not write out an executable file.  Instead, it keeps the
machine code in memory, so that it can be run interactively by the user.

To ensure that CSS has loaded the text, you can list the program:

@example
css> list

Listing of Program: css_example.css
1
2       // a function that decodes the number
3       String Decode_Number(float number) @{
4         String rval = "The number, " + number + " is: ";
5         if(number < 0)
6           rval += "negative";
7         else if(number < .5)
8           rval += "less than .5";
9         else if(number < 1)
10          rval += "less than 1";
11        else
12          rval += "greater than 1";
13        return rval;
14      @}
15
16      // decodes n_numbers randomly generated numbers
17      void Decode_Random(int n_numbers) @{
18        int i;
19        for(i=0; i<n_numbers; i++) @{
20          float number = 4.0 * (drand48()-.5);
21          String decode = Decode_Number(number);  // call decoder
css> list

Listing of Program: css_example.css
21          String decode = Decode_Number(number);  // call decoder
22          cout << i << "\t" << decode << "\n";    // c++ style output
23        @}
24      @}
26      list

@end example

Note that you have to type @code{list} in twice in order to see the
whole program (by default, @code{list} only shows 20 lines of code).
Also, notice that the list command itself shows up at the end of the
program---this is because commands that are entered on the command line
are actually compiled, run, and then deleted from the end of the
program.  Because @code{list}, when run, shows the current state of the
code (i.e., before it has itself been deleted), it shows up at the
bottom of the listing.

Now, let's try running the example:

@example
css> run
css>
@end example

Nothing happens!  This is because the code as written only defines
functions, it does not actually call them.  The program would have to
have had some statements (i.e., function calls, etc) at the @emph{top
level} (i.e., not within the definition of a function) in order to do
something when the @code{run} command is issued.

However, we can call the functions directly:

@example
css> Decode_Random(5);
0       The number, -0.414141 is: negative
1       The number, 1.36194 is: greater than 1
2       The number, -0.586656 is: negative
3       The number, -0.213666 is: negative
4       The number, -0.725229 is: negative
css>
@end example

(of course, your output will vary depending on the random number
generator).  This illustrates the interactive nature of CSS --- you can
call any function with any argument, and it will execute it for you
right then and there.  This is especially useful for debugging functions
individually.  Thus, we can call the @code{Decode_Number} function
directly with different numbers to make sure it handles the cases
appropriately:

@example
css> Decode_Number(.25);
css>
@end example

Notice, however, that there was no output.  This is because the function
simply returns a string, but does not print it out.  There are several
ways to print out results, but the easiest is probably to use the
@code{print} command:

@example
css> print Decode_Number(.25);
(String)  = The number, 0.25 is: less than .5
@end example

@code{print} gives you the type name, the variable name (which is blank
in this case), and the value.  To illustrate this, you can just declare
a variable directly:

@example
css> String foo = "a string";
css> print foo
(String) foo = a string
@end example

Compare this with the print @emph{function} (not command) @code{printf}:

@example
css> printf(Decode_Number(.25));
The number, 0.25 is: less than .5css>
@end example

which just gives you the value of the string (and does not automatically
append a '\n' return at the end of the line).  Finally, we can use C++
stream-based printing, which directs the return value from the function
to print itself to the default current output @code{cout}:

@example
css> cout << Decode_Number(.75) << "\n";
The number, 0.75 is: less than 1
css>
@end example

Note also that you can put any expression in the arguments to the
function:

@example
css> print Decode_Number(exp(cos(tan(.2) + .5) * PI)/ 20);
(String)  = The number, 0.549689 is: less than 1
@end example

In order to actually be able to run a script, we can add the following
lines to the code by switching to @code{define} mode instead of the
default interactive mode:  

@example
css> define
css# cout << Decode_Number(.75) << "\n";
css# Decode_Random(5);
css# exit
@end example

Note that we use @code{exit} to exit the @code{define} mode.  You could
also use the @code{EOF} character (@kbd{ctrl-D} on most systems) to exit
this mode.  To see that we have added to the program, list it from line
20 onwards:

@example
css> list 20

Listing of Program: css_example.css
20          float number = 4.0 * (drand48()-.5);
21          String decode = Decode_Number(number);  // call decoder
22          cout << i << "\t" << decode << "\n";    // c++ style output
23        @}
24      @}
26      cout << Decode_Number(.75) << "\n";
27      Decode_Random(5);
28      exit
29      list 20
@end example

Now, when we @code{run} the program, we get:

@example
css> run
The number, 0.75 is: less than 1
0       The number, 1.54571 is: greater than 1
1       The number, -1.93767 is: negative
2       The number, 0.336361 is: less than .5
3       The number, -1.36253 is: negative
4       The number, -0.465137 is: negative
css>
@end example

All of the C language rules about declaring or defining functions before
they are called apply in CSS as well (in general, CSS obeys most of the
same rules as C), so we could not have put those two extra lines of code
in the example program before the functions themselves were defined.  In
general, this leads to a program layout consisting of various different
functions, followed at the very end by one or two lines of code at the
top-level which call the relevant function to start things off.  If you
are feeling traditional, you can call this function @code{main}, and it
will look like a regular C/C++ program, except for the last line which
calls the main function.


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-tut-debug, css-tut-access, css-tut-run, css-tut
@subsection Debugging an Example Program in CSS

This section illustrates the use of the debugging facilities within CSS.
We will use the example program from the previous section, with the
addition of the two extra lines of code that were added in @code{define}
mode.  It is important to note that some important aspects of debugging
like breakpoints can only be used when a program was started with the
@code{run} command.  Thus, do not set breakpoints if you are going to be
simply calling a function on the command line.

There are three primary debugging tools in CSS: @b{breakpoints},
@b{execution tracing}, and @b{single-stepping}.  Because CSS is
basically an interpreted system, all of the facilities for examining
variables, the stack, source code, etc. which must be added into a real
debugger come for "free" in CSS.

To illustrate, we will set a breakpoint in the @code{Decode_Number}
function (assuming you have loaded this code already):

@example
css> list Decode_Number
(String) Decode_Number((Real) number) @{
4         String rval = "The number, " + number + " is: ";
5         if(number < 0)
6           rval += "negative";
7         else if(number < .5)
8           rval += "less than .5";
9         else if(number < 1)
10          rval += "less than 1";
11        else
12          rval += "greater than 1";
13        return rval;
14      @}
css> setbp 5
css> showbp
Decode_Number   5         if(number < 0)
css>
@end example

Note that we first listed the function (referring to it by name), and
then set a breakpoint with the @code{setbp} command at line number 5.
We then confirmed this breakpoint with the @code{showbp} command.

Now, when we @code{run} the program, execution will stop at line 5, and
we will be returned to the @code{css>} prompt:

@example
css> run
2 css>
@end example

which has changed to @code{2 css>}, indicating that we are 2 levels deep
into the execution of the program.  To see where we are, @code{list} and
@code{status} can be used:

@example
2 css> list

Listing of Program: css_example.css
4         String rval = "The number, " + number + " is: ";
5         if(number < 0)
6           rval += "negative";
7         else if(number < .5)
8           rval += "less than .5";
9         else if(number < 1)
10          rval += "less than 1";
11        else
12          rval += "greater than 1";
13        return rval;
14      @}
28      list
2 css> status

        Status of Program: css_example.css
curnt:  Decode_Number   src_ln: 5       pc:     9
debug:  0       step:   0       depth:  2       conts:  2
lines:  29      list:   28
State: shell:   1   run: 0  cont:   0  defn:   0  runlast: 0
run status:     Waiting
shell cmd:      None
2 css>
@end example

The @code{src_ln} of the status output tells us which source-code line
we are at (and what function we are in).  Here, we can use the
interactive mode of css to determine the values of our variables:

@example
2 css> print number
(Real) number = 0.75
2 css> print rval
(String) rval = The number, 0.75 is:
@end example

The values of all of the variables for the current "frame" (there is one
frame for every call to a given function, or any expression appearing
between the curly-brackets) can be viewed at once with the @code{frame}
command:

@example
2 css> frame

Elements of Spaces For Program: Decode_Number (frame = 1)

Elements of Space: Autos (3)
(String) _retv_this =                   (Real) number = 0.75
(String) rval = The number, 0.75 is:

Elements of Space: Stack (0)


Elements of Space: css_example.css.Static (3)
(String) Decode_Number((Real) number)   (void) Decode_Random((Int) n_numbers)
(String) foo = a string
@end example

Included in the frame information are the "automatic" variables
(@code{Autos}), and the contents of the stack.  To get information on
previous frames in the execution sequence, use the command @code{trace},
which gives both a trace of processing and can give a dump of the entire
stack up to this point if given a higher "trace level", which is an
optional argument to the @code{trace} command.  The default trace level
of 0 just shows the frames, 1 also shows the stack, 2 also shows the
auto variables, and 3 shows all variables.  In addition, just the
contents of the current stack can be viewed with the @code{stack}
command (note that the saved stack is what is actually used by the
program during execution).

In addition to viewing variables, it is possible to change their
values:

@example
2 css> number = 200;
2 css> print number
(Real) number = 200
@end example

Finally, to continue the program from where it was stopped by the
breakpoint, use the @code{cont} command:

@example
2 css> cont
The number, 0.75 is: greater than 1
5 css> 
@end example

Since we changed the number after it was turned into a string for the
@code{rval}, but before the @code{if} statements, we got the
contradictory result printed above.  Also, because the breakpoint is
still in effect, the program has stopped due to the @code{Decode_Random}
function calling the @code{Decode_Number} function.  We can continue
again, or we can disable the breakpoint first, and then continue.  

@example
5 css> cont
0       The number, 0.764017 is: less than 1
5 css> unsetbp 5
5 css> showbp
5 css> cont
1       The number, -1.76456 is: negative
2       The number, 1.59942 is: greater than 1
3       The number, -1.34582 is: negative
4       The number, -1.36371 is: negative
css>
@end example

Note that the breakpoint is referred to by the source-code line number.

Another way to debug is to get a trace of the running program.  This can
be done by setting the @code{debug} level, which can have a value from 0
(normal, quiet operation) through 4, with higher levels giving more
detail than lower levels.  For most users, levels 0 and 1 are the only
ones needed, since the higher levels depend on understanding the guts of
the CSS machine code.  Debug level 1 shows the source-code line
corresponding to the currently-executing code:

@example
css> debug 1
css> run
31      run
3       String Decode_Number(float number) @{
17      void Decode_Random(int n_numbers) @{
26      cout << Decode_Number(.75) << "\n";
4         String rval = "The number, " + number + " is: ";
5         if(number < 0)
5         if(number < 0)
5         if(number < 0)
7         else if(number < .5)
7         else if(number < .5)
7         else if(number < .5)
9         else if(number < 1)
9         else if(number < 1)
9         else if(number < 1)
10          rval += "less than 1";
13        return rval;
26      cout << Decode_Number(.75) << "\n";
The number, 0.75 is: less than 1
27      Decode_Random(5);
18        int i;
19        for(i=0; i<n_numbers; i++) @{
.
.
.
@end example

Since running proceeds from the top to the bottom, the definitions of
the functions appear in the trace even though they do not really do
anything.  Also, some constructs like @code{if} and @code{for} result in
multiple copies of the same source-code line being printed.  This kind
of trace is useful for seeing what branches of the code are being taken,
etc.

The final kind of debugging is single-stepping, which is like having a
breakpoint after every line of source code.  Execution continues after
each point by simply entering a blank line:

@example
css> debug 0
31      debug 0
css> step 1
css> run
31      run
3       String Decode_Number(float number) @{
1 css>
17      void Decode_Random(int n_numbers) @{
1 css>
26      cout << Decode_Number(.75) << "\n";
4         String rval = "The number, " + number + " is: ";
2 css> print number
31      print number
(Real) number = 0.75
2 css> print rval
(String) rval = The number, 0.75 is:
5         if(number < 0)
3 css>
7         else if(number < .5)
4 css>
9         else if(number < 1)
5 css>
10          rval += "less than 1";
4 css>
13        return rval;
26      cout << Decode_Number(.75) << "\n";
The number, 0.75 is: less than 1
1 css>
27      Decode_Random(5);
18        int i;
2 css>
19        for(i=0; i<n_numbers; i++) @{
19        for(i=0; i<n_numbers; i++) @{
20          float number = 4.0 * (drand48()-.5);
4 css>
@end example

(note that we turned debugging off, since it is redundant with
single-stepping).  The @code{step} command takes an argument, which is
the number of lines to step over (typically 1). Then, when we @code{run}
the program again, it stops after every line.  If you simply want to
continue running, you can just hit return and it will continue to the
next line.

If at any point during debugging you want to stop the execution of the
program and return to the top-level (i.e., get rid of that number in
front of the prompt), use the @code{restart} command.

@example
4 css> restart
34      restart
css>
@end example

Be sure not to confuse @code{restart} with @code{reset}, as the latter
will erase the current program from memory (you can just reload it with
@code{reload}, so its not so bad if you do).

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-tut-access,  , css-tut-debug, css-tut
@subsection Accessing Hard-Coded Objects in CSS

In general, hard-coded objects (and their members and member functions)
are treated just as they would be in C or C++.  Objects that have been
created (i.e., Networks, Units, etc) can be referred to by their
@emph{path} names, which start with the @emph{root} object (PDPRoot).
While you could type @code{root.projects[0]}, for example, to refer to
the first project, it is easier to use the abbreviation of a preceding
period to stand for @code{root}, resulting in: @code{.projects[0]}.

The following examples were performed on the XOR example project in
Bp++. In order to examine the project in CSS, one could simply use the
@code{print} command on the path of this object:

@example
bp++> print .projects[0]
.projects[0] Proj (refn=1) @{
  ta_Base*        owner           = .projects;
  String          name            = Proj;
  WinBase*        win_owner       = root;
  WinGeometry     win_pos         = @{lft=4: bot=74: wd=535: ht=24: @};
  WinGeometry     root_win_pos    = @{lft=9: bot=79: wd=161: ht=23: @};
  TypeDefault_MGroup   defaults           =  Size: 5 (TypeDefault);
  BaseSpec_MGroup   specs         =  Size: 3 (BaseSpec);
  Network_MGroup   networks       =  Size: 1 (Network);
  Environment_MGroup   environments       =  Size: 1 (Environment);
  Process_MGroup   processes      =  Size: 5 (SchedProcess);
  PDPLog_MGroup   logs            =  Size: 2 (TextLog);
  Script_MGroup   scripts         =  Size: 1 (Script);
@}
@end example

The first network within this project would then be referred to as
@code{.projects[0].networks[0]}:

@example
bp++> print .projects[0].networks[0]
.projects[0].networks[0] XOR (refn=15) @{
  ta_Base*        owner           = .projects[0].networks;
  String          name            = XOR;
  WinBase*        win_owner       = .projects[0];
  WinGeometry     win_pos         = @{lft=4: bot=3: wd=536: ht=390: @};
  WinView_MGroup   views          =  Size: 1 (NetView);
  Layer_MGroup    layers          =  Size: 3 (Layer);
  Project*        proj            = .projects[0];
  TDGeometry      pos             = @{x=0: y=0: z=0: @};
  TDGeometry      max_size        = @{x=2: y=2: z=3: @};
  int             epoch           = 0;
  Network::Layer_Layout   lay_layout      = THREE_D;
@}
@end example

You can also use a shortcut by just typing @code{.networks[0]}, which
finds the first member with the name @code{networks} in a search
starting at the root object and scanning down the @emph{first branch} of
the tree of objects (i.e., looking in the first element of every group
along the way).

Scoped types such as @code{Network::Layer_Layout} which appear in the
above class are referred to just as they would be in C++:

@example
bp++> .networks[0].lay_layout = Network::TWO_D;
@end example

As you can see, setting the values of hard-coded object variables simply
amounts to typing in the appropriate C/C++ statement.

Type information (obtained via the TypeAccess system) about hard-coded
objects can be obtained with the @code{type} command:

@example
bp++> type Network
class Network : PDPWinMgr : WinMgr : WinBase : ta_NBase : ta_Base @{
// The Network 

  // sub-types
  enum Layer_Layout @{   // Visual mode of layer position/view
    TWO_D            = 0;       // all z = 0, no skew
    THREE_D          = 1;       // z = layer index, default skew
  @}

  // members
  ta_Base*        owner;          //   pointer to owner
  String          name;           //   name of the object
  .
  .
  TDGeometry      max_size;       //   max size in each dim
  int             epoch;          //   epoch counter
  Network::Layer_Layout   lay_layout;     // Visual mode of layer 

  // functions
  void            UnSafeCopy(ta_Base* na);
  ta_Base*        GetOwner(TypeDef* tp);
  .
  .
  .
  void            InitWtState();        // Initialize the weights
  .
  .
  void            Compute_dWt();        // update weights for whole net
  void            Copy_Weights(const Network* src);  
  void            Enforce_Layout(Network::Layer_Layout layout_type);
@}
@end example

This shows the inheritance of this object, any sub-types that are
defined within it, and all of its members and functions (including those
it inherits from other classes).

In addition, there is Tab-completion for path names and types in the CSS
prompt-level script interface.  Thus, as you are typing a path, if you
hit the Tab key, it will try to complete the path.  If there are
multiple completions, hitting Tab twice will display them.

In order to call member functions of hard-coded classes, simply give the
path to the object, followed by the member function, with any arguments
that it might require (or none).

@example
bp++> .networks[0].InitWtState();
bp++> 
@end example

It is possible to create pointers to hard-coded objects.  Simply declare
a pointer variable with the appropriate type, and assign it to the given
object by referring to its path:

@example
bp++> Unit* un;
bp++> un = .networks[0].layers[1].units[0];
bp++> print un
.projects[0].networks[0].layers[1].units[0] hid_1 (refn=6) @{
  ta_Base*        owner           = .projects[0].networks[0].layers[1].units;
  String          name            = hid_1;
  UnitSpec_SPtr   spec            = @{type=BpUnitSpec: spec=.specs[0]: @};
  TDGeometry      pos             = @{x=0: y=0: z=0: @};
  Unit::ExtType   ext_flag        = NO_EXTERNAL;
  float           targ            = 0;
  float           ext             = 0;
  float           act             = 0;
  float           net             = 0;
  Con_Group       recv            =  Size: 0.1.2 (BpCon);
  Con_Group       send            =  Size: 0.1.1 (BpCon);
  BpCon           bias            = BpCon;
  float           err             = 0;
  float           dEdA            = 0;
  float           dEdNet          = 0;
@}
@end example

There are two ways to create new hard-coded objects.  The preferred way
is to call one of the @code{New} functions on the group-like objects
(@code{List} or @code{Group}, see @ref{obj-group}), which will create
the object and add it to the group, so that it can be referred to by its
path as just described.

@example
bp++> .layers[1].units.List();

Elements of List:  (2)
hid_1   hid_2 
bp++> .layers[1].units.New(1);
bp++> .layers[1].units.List();

Elements of List:  (3)
hid_1   hid_2    
bp++> .layers[1].units[2].name = "new_guy";
bp++> .layers[1].units.List();

Elements of List:  (3)
hid_1   hid_2   new_guy 
@end example

Finally, it is possible to create new instances of hard-coded object
types through the C++ @code{new} operator, which is especially useful in
order to take advantage of some of the handy built-in types like arrays
(@pxref{obj-array}):

@example
bp++> float_RArray* ar = new float_RArray;
bp++> print ar
[0];

bp++> ar.Add(.25);
bp++> ar.Add(.55);
bp++> ar.Add(.11);
bp++> print ar
[3] 0.25 0.55 0.11;

bp++> print ar.Mean();
(Real)  = 0.303333
bp++> print ar.Var();
(Real)  = 0.101067
bp++> ar.Sort();
bp++> print ar
[3] 0.11 0.25 0.55;
@end example

Remember to @code{delete} those objects which you have created in this
fashion:

@example
bp++> delete ar;
bp++> print ar
(float_RArray) ar = 0
@end example

(the @code{ar = 0} means that it is a null pointer).  Be sure @emph{not}
to use the @code{delete} operator on those objects which were created
with the group's @code{New} function, which should be @code{Remove}d
from the group, not deleted directly (@pxref{obj-group}).

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-from-c, css-ref, css-tut, css
@section CSS For C/C++ Programmers

This section outlines the ways in which CSS differs from C and C++.
These differences have been kept as small as possible, but nonetheless
the fact that CSS is an interactive scripting language means that it
will inevitably differ from compiled versions of the language in some
respects. 

Note that this manual does not contain an exhaustive description of the
CSS language --- only differences from standard C/C++.  Thus, it is
expected that the user who is unfamiliar with these languages will
purchase one of the hundreds of books on these languages, and then
consult this section to find out where CSS differs.

@menu
* css-c++-diff::                Differences Between CSS and C++
* css-c-diff::                  Differences Between CSS and ANSI C
* css-extend::                  Extensions Available in CSS
* css-c++-intro::               Features of C++ for C Programmers
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-c++-diff, css-c-diff, css-from-c, css-from-c
@subsection Differences Between CSS and C++

The primary difference between CSS and C++ is that CSS does not support
the complex set of rules which determine which of a set of functions
with the same name should be called given a particular set of arguments.
Thus, CSS does not allow multiple functions with the same name.  By
avoiding the function-call resolution problems, CSS is much faster and
smaller than it otherwise would be.

One consequence of the lack of name resolution is that only default (no
argument) constructors can be defined.  This also obviates the need for
the special parent-constructor calling syntax.

Also, at the present time, CSS does not support the definition of
@code{operator} member functions that redefine the operation of the
various arithmetic operators.  Further, it does not provide access
control via the @code{private}, @code{public}, and @code{protected}
keywords, or the @code{const} type control, though these are parsed (and
ignored).  Thus, it also does not deal with the @code{friend} constructs
either.  While these language features could be added, they do not make
a great deal of sense for the interactive script-level programming that
CSS is designed to handle.

CSS @emph{does} support multiple inheritance, and the overloading of
derived member functions.  It does not support the inlining of
functions, which is a compiler-level optimization anyway.  The keyword
@code{inline} will be parsed, but ignored.

Also, note that CSS gives one access to hard-coded classes and types
(via TypeAccess), in addition to those defined in the script.

Templates are not supported for script-based classes, but are supported
in hard-coded classes (via TypeAccess).

Exception handling is not supported, and probably will not be.

Since the primary use of CSS is for relatively simple pieces of code
that glue together more complex hard-coded objects, and not implementing
large programs, the present limitations of CSS will probably not affect
most users.


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-c-diff, css-extend, css-c++-diff, css-from-c
@subsection Differences Between CSS and ANSI C

The design specification for CSS should be the same as ANSI C. However,
at the present time, some features have not been implemented, including:

The full functionality of @code{#define} pre-processor macros is not
supported.  At this point, things are either defined or undefined and
the @code{#ifdef} and @code{#ifndef} functions can be used to
selectively include or not different parts of code.

The promotion of types in arithmetic expressions is not standard.  In
CSS, the result of an expression is determined by the left-most (first)
value in the expression.  Thus, @code{20 / 3.0} would result in an
integer value of 6, whereas @code{20.0 / 3} gives a real value of
6.6667. 

The guarantee that only as much of a logical expression will be
evaluated as is necessary is not implemented in CSS.  Thus, something
like @samp{if((a == NULL) || (a->memb == "whatever"))} will
(unfortunately) not work as it would in C, since the second expression
will be evaluated even when @code{a} is @code{NULL}.

Initialization of multiple variables of the same type in the same
statement, is not supported, for example:
@example
  int var1 = 20, var2 = 10, var3 = 15;
@end example
and initialization of an array must occur after it has been declared
(see example below).

There are a limited number of primitive types in CSS, with the others
defined in C being equivalent to one of these basic CSS types (see
@ref{css-types}).  This is because everything in CSS is actually
represented by an object, so the storage-level differences between
many different C types are irrelevant in the script language.

Pointers in CSS are restricted to point to an object which lies in an
array somewhere, or is a single entity.  The pointer is "smart", and it
is impossible to increment a pointer that points to a single entity,
which makes all pointer arithmatic safe:

@example
css> int xxx;
css> int* xp = &xxx;
css> print xp
(Int)* xp --> (Int) xxx = 0
css> xp++;
Cannot modify a NULL or non-array pointer value
>1      xp++;
css> print *(xp +1);
Cannot modify a NULL or non-array pointer value
>1      print *(xp +1);
@end example

but it is possible to increment and perform arithmetic on a pointer
when it points to an array:

@example
css> int xar[10];
css> xp = xar;
css> xar = @{0,1,2,3,4,5,6,7,8,9@};
css> print xar
(Int) xar[10] @{
0       1       2       3       4       5       6       7       8       9 
@}
css> print xp
(Int)* xp --> (Int) xar[10] @{
0       1       2       3       4       5       6       7       8       9 
@}
css> print *(xp+2);
(Int)  = 2
css> print *(xp+3);
(Int)  = 3
css> xp++;
css> print *(xp+3);
(Int)  = 4
css> print *(xp+9);
Array bounds exceeded
>1      p *(xp+9);
(void) Void
css> print *(xp+8);
(Int)  = 9
@end example

The error that occurred when the @code{print *(xp+9)} command was issued
(after @code{xp} already points to @code{xar[1]}), illustrates the kind
of "smart pointers" that are built into CSS, which prevent crashes by
preventing access to the wrong memory areas.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-extend, css-c++-intro, css-c-diff, css-from-c
@subsection Extensions Available in CSS

There are several "extensions" of the C/C++ language available in CSS.
The most obvious one is the ability to shorten the path to refer to a
particular hard-coded object by skipping those elements that are the
first of a given group.  Thus, if referring to a unit in the first layer
of a network, in the first project, one can say: @code{.units[x]}
instead of @code{.projects[0].networks[0].layers[0].units[x]}.

Also, one can often avoid the use of a type specifier when initializing
a new variable, because CSS can figure out the type of the variable from
the type of the initializing expression:

@example
  var1 = "a string initializer";          // type is inferred from initializer
  //        instead of
  String var2 = "a string initializer";   // instead of explicitly declared  
@end example

When referring to a hard-coded type, CSS will automatically use the
actual type of the object if the object derives from the @code{ta_Base}
class which is aware of its own type information.

CSS does not pay attention to the distinction between @code{ptr->mbr}
and @code{obj.mbr}.  It knows if the object in question is an object
itself or a pointer to an object, and can figure out how to access the
members appropriately.

All of the basic CSS types (see @ref{css-types}) know how to convert
themselves into the other types automatically, without even casting
them.  However, you can use an explicit cast if you want the code to
compile properly in standard C/C++.

Also, all script variables for hard-coded objects are implicitly
pointers, even if not declared as such.  This is because script objects
are not the same thing as hard-coded ones, and can only act at best as
reference variables for them (i.e., essentially as pointers, but you can
use the @code{obj.mbr} notation, see previous paragraph).  Thus, while
you can write CSS code that would also compile as C++ code by using
@code{ptr->mbr} notation to refer to hard-coded objects, you can also
cheat and use the simpler @code{obj.mbr} notation even when @code{obj}
is a pointer.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-c++-intro,  , css-extend, css-from-c
@subsection Features of C++ for C Programmers
@cindex C++
@cindex OOP, C++
@cindex Object Oriented Programming, C++
@cindex Objects, C++
@cindex Classes, C++
@cindex Methods, C++
@cindex Members, C++
@cindex Member Functions, C++
@cindex Inheritance, of Objects, C++
@cindex Class Inheritance, C++

Since more users are likely to be familiar with C than C++, this section
provides a very brief introduction to the essentials of C++.

The central feature of C++ is that it extends the @code{struct}
construct of C into a full-fledged object oriented programming (OOP)
language based around a @code{class}.  Thus, a class or object has data
members, like a @code{struct} in C, but it also has functions associated
with it.  These @emph{member functions} or @emph{methods} perform
various functions associated with the data members, and together the
whole thing ends up encapsulating a set of related tasks or operations
together in a single entity.

The object-oriented notion is very intuitive for neural-network entities
like units:

@example
class Unit @{    // this defines an object of type Unit
public:         // public means that any other object can access the following

  // these are the data members, they are stored on the object  
  float         net_input;      // this gets computed by the weights, etc.
  float         activation;     // this is computed by the function below
  float         target;         // this is set by the environment before hand
  float         error;          // this gets computed by the function below

  // these are the member functions, they can easily access the data members
  // associated with this object 
  virtual void  Compute_Activation()
  @{ activation = 1.0 / (1.0 + exp(net_input)); @}
  virtual void  Compute_Error()
  @{ error = target - activation; error *= error; @}
@};
@end example

The member functions encapsulate some of the functionality of the unit
by allowing the unit to update itself by calling its various member
functions.  This is convenient because different types of units might
have different @emph{definitions} of these functions, but they all would
have a @code{Compute_Activation()} function that would perform this same
basic operation.  Thus, if you have an object which is an instance or
token of the type @code{Unit}, you can set its data members and call its
member functions as follows:

@example
Unit un;
un.net_input = 2.5;
un.target = 1.0;
un.Compute_Activation();
un.Compute_Error();
@end example

Thus, you use the same basic notation to access data members as member
functions (i.e., the @code{obj.mbr} syntax).  To illustrate why this
encapsulation of functions with objects is useful, we can imagine
defining a new object type that is just like a unit but has a different
activation function.

@example
class TanhUnit : public Unit @{          // we're going to inherit from a Unit
public:
  void          Compute_Activation()    @{ activation = tanh(net_input); @}
@};
@end example

This notation means that the new type, @code{TanhUnit}, is just like a
@code{Unit}, except that it has a different version of the
@code{Compute_Activation()} function.  This is an example of
@emph{inheritance}, which is central to C++ and OOP in general.  Thus,
if we have something which we know to be a unit of some type (either a
@code{Unit} or a @code{TanhUnit}, or maybe something else derived from a
@code{Unit}), we can still call the @code{Compute_Activation()} function
and expect it to do the right thing:

@example
Unit* un;
un->Compute_Activation();
@end example

This is an example of a @emph{virtual member function}, because the
actual function called depends on what actual type of unit you have.
This is why the original definition of the @code{Compute_Activation()}
function has the @code{virtual} keyword in front of it.  Virtual
functions are an essential part of C++, as they make it possible to have
many different definitions or "flavors" of a given operation.  Since
these differences are all encapsulated within a standard set of virtual
functions, other objects do not need to have special-case code to deal
with these differences.  Thus, a very general purpose routine can be
written which calls all of the @code{Compute_Activation()} functions on
all of the units in a network, and this code will work regardless of
what actual type of units are in the network, as long as they derive
from the @emph{base type} of @code{Unit}.

While there are a number of other features of C++, the PDP++ software
mainly makes use of the basics just described.  There are a couple of
basic object types that are used in the software for doing file
input/output, and for representing character-string values.

The C++ way of doing file input/output is via the @emph{stream} concept.
There is an object that represents the file, called a stream object.
There are different flavors of stream objects depending on whether you
are doing input (@code{istream}), output (@code{ostream}) or both
(@code{iostream}).  To actually open and close a file on a disk, there
is a version of the @code{iostream} called an @code{fstream} that has
functions allowing you to open and close files.  To send stuff to or
read stuff from a file, you use something like the "pipe" or i/o
redirection concept from the standard Unix shells.  The following
example illustrates these concepts:

@example
fstream fstrm;     // fstrm is a file stream, which can do input or output

// we are opening the file by calling a member function on the
// fstream object. the enumerated type ios::out means 'output'
// also available are ios::in, ios::app, etc.

fstrm.open("file.name", ios::out);  

// we "pipe" stuff to the fstrm with the << operator, which can deal
// with all different types of things (ints, floats, strings, etc.)

fstrm << "this is some text " << 10 << 3.1415 << "\n";

fstrm.close();     // again, the file is closed with a member fun
@end example

The mode in which the file is opened is specified by an @emph{enumerated
type} or an @code{enum}.  This provides a way of giving a descriptive
name to particular integer values, and it replaces the use of
string-valued arguments like "r" and "w" that were used in the
@code{open()} function of the standard C library.  The base class of all
the stream types is something called @code{ios}, and the enum for the
different modes a file can be opened in are defined in that type, which
is why they are @emph{scoped} to the @code{ios} class by the
@code{ios::} syntax.  The definition of this enum in ios is as follows:

@example
  enum open_mode  @{ in=1, out=2, ate=4, app=010, trunc=020,
                        nocreate=040, noreplace=0100 @};
@end example

which shows that each enum value defines a bit which can be combined
with others to affect how the file is opened.

The following example illustrates how file input works with streams.
One simply uses the @code{>>} operator instead of @code{<<}.  Note that
the fstream has to be opened in @code{ios::in} mode as well:

@example
fstream fstrm;     // fstrm is a file stream, input or output

// we are opening the file by calling a member function on the
// fstream object. the enumerated type ios::out means 'output'
// also available are ios::in, ios::app, etc.

fstrm.open("file.name", ios::in);

// these variables will hold stuff that is sucked in from the stream
String words[4];
int number;
float pi;
// this assumes that the stream was written by the output example
// given previously
fstrm >> words[0] >> words[1] >> words[2] >> words[3] >> number >> pi;

fstrm.close();     // again, the file is closed with a member fun
@end example

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-ref, css-errors, css-from-c, css
@section CSS Reference Information

This section of the manual contains reference material on many aspects
of CSS (excluding the basic C/C++ language itself, for which many
excellent reference sources exist).

@menu
* css-spaces::                  Name and Storage Spaces in CSS
* css-gui::                     Graphical Editing of CSS Classes
* css-startup::                 CSS Startup options
* css-shell::                   The CSS Command Shell
* css-types::                   Basic Types in CSS
* css-commands::                CSS Commands
* css-functions::               CSS Functions
* css-settings::                Parameters Affecting CSS Behavior
@end menu


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-spaces, css-gui, css-ref, css-ref
@subsection Name and Storage Spaces in CSS

Like C and C++, CSS has several different places that it can put
variables and functions.  Some of these amount to ways of organizing
things that have a similar role in the same list, so that they can all
be viewed together.  These are essentially transparent to the user, and
are described in the context of the various commands that print out
lists of various types of functions and variables.  The remaining
distinctions have consequences for the programmer, and are described
below.

The initial program space in CSS is different than that of C or C++,
since it can actually contain executable code, whereas the compiled
languages restrict the basic top-level space to consist of definitions
only.  Any definitions or variables declared in the top-level space are
by default considered to be @code{static}, which means that they are
visible only to other things within that program space.  Other program
spaces (such as those in a @code{Script} object or a
@code{ScriptProcess}, @code{ScriptEnv}, etc.) do not have access to
these variables or functions.  However, the @code{extern} declaration
will make a variable or function visible across any other program
spaces.

Within a function, all variables declared as arguments and local
variables are known as "autos", as they are automatically-allocated.
These are stored locally on a kind of stack within the same object that
holds the code for the function, and a new set of them are allocated for
each invocation of the function.  The exception is for variables
declared @code{static}, which are also stored on the function object,
but the same one is used for all invocations of the function.

All new types that are declared (including enums and classes) are put in
the global typespace, which is available to all program spaces.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-gui, css-startup, css-spaces, css-ref
@subsection Graphical Editing of CSS Classes
@cindex Edit Dialogs

A class object defined within CSS can be edited using the @code{edit}
command or the @code{EditObj} function (described below).  Classes offer
the ability to customize the edit dialog through the use of comment
directives, which are the same as those used in the hard-coded C++
classes with the TypeAccess system.  These allow class member functions
to be associated with a button (using the #BUTTON directive) which, when
pressed, calls the member function.  By default functions are added to
an "Actions" menu, but the #MENU_ON_menuname directive puts that
function on a menu named "menuname".  The full list of directives is
given in @ref{prog-comdir}.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-startup, css-shell, css-gui, css-ref
@subsection CSS Startup options
@cindex Startup Options, CSS

The following startup arguments are interpreted by CSS:

@table @code
@item [-f|-file] <file>
@findex file argument in CSS
Compile and execute the given file upon startup. The default is to then
exit after execution, but this can be overridden by the @code{-i} flag.
@item [-e|-exec] <code>
@findex exec argument in CSS
Compile and execute the given code upon startup.  The code is passed as a
single string argument, and should contain CSS code separated by
semicolons.  The default is to then
exit after execution, but this can be overridden by the @code{-i} flag.
@item [-i|-interactive] 
@findex interactive argument in CSS
If using @code{-f} or @code{-e}, CSS will go into interactive (prompt)
mode after startup execution.
@item -v[<number>]
@findex verbose argument in CSS
Run CSS with the initial debug level set to given number (default 1)
@item [-b|-bp] <line>
@findex breakpoint argument in CSS
Set an initial breakpoint at the given line of code (only if using
@code{-f}).
@item [-gui]
@findex gui argument in CSS
Enable the graphical-user-interface to CSS class objects.  This is not
activated by default, since most uses of CSS don't involve the gui.
@end table

Any other arguments can be accessed by user script programs by the global
variables @code{argv} (an array of strings) and @code{argc} (an int).

Note that it is possible to make a self-executing css program by putting
the following on the very first line of the file:
@example
#!/usr/local/pdp++/bin/SUN4/css -f 
@end example

@cindex Init Files
@cindex .cssinitrc
In addition to these arguments, CSS looks for a file named
@file{.cssinitrc} in the user's home directory, which contains CSS code
that is run when CSS is started.  This is useful for setting various
command @code{alias}es, and defining commonly-used @code{extern}
functions.  An example @file{.cssinitrc} file is located in
@file{config/std.cssinitrc}.


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-shell, css-types, css-startup, css-ref
@subsection The CSS Command Shell
@cindex Shell, CSS
@cindex CSS Shell

The primary interface to CSS is via the command shell, which provides a
prompt and allows the user to enter commands, etc.  This shell has some
useful features, including @emph{editing}, @emph{history}, and
@emph{completion}, all of which are provided by the GNU readline
library.

The current line can be edited using a subset of the emacs editing
commands, including Ctrl-f, Ctrl-b, Ctrl-a, Ctrl-e, etc.

A running history of everything that has been entered is kept, and can
be accessed by using the Ctrl-p and Ctrl-n commands (previous and next,
respectively).  This makes it easy to repeat previous commands,
especially when combined with the editing facility.

Completion occurs when the TAB key is pressed after some
partially-entered expression, causing the shell to suggest a completion
to the expression based on the part that has already been entered.  If
there is more than one possible completion, then the shell will beep,
and pressing TAB a second time will produce a list of all of the
possible completions.  Completion is based on all of the keywords
currently defined (including types, commands, functions, user-defined
variables and functions, etc), except in the following two cases: If the
expression starts with a ".", it is interpreted as a path, and the next
segment of the path to either an object or a member function of an
object is suggested by the shell.  If the expression contains a scoping
operator "::", then the completion will interpret whatever is in front
of the scoping operator as a type name, and will suggest the possible
members, subtypes, etc. of that type as completions.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-types, css-commands, css-shell, css-ref
@subsection Basic Types in CSS
@cindex CSS Types

There are six basic "primitive" types in CSS: @code{Int}, @code{Real},
@code{char}, @code{String}, @code{bool}, and @code{enum}.  An @code{Int}
is essentially an @code{int}, a @code{Real} is essentially a
@code{double}, and a @code{String} is a C++, dynamically-allocating
string object.  A @code{char} is just an int object that will convert
into its equivalen ASCII character instead of its numerical value when
converted into a String.  A @code{bool} has two values: @code{true} and
@code{false}.  An @code{enum} has defined enumeration values, and will
convert a string representation of one of those values into the
corresponding symbolic/numeric value.

All of the other flavors of @code{int} in C, including @code{short},
@code{long}, @code{unsigned}, etc, are all just defined to be the same
as an @code{Int}.  Similarly, a @code{float} and @code{double} are
defined to be the same as a @code{Real}.  The @code{String} object is
the same as the one that comes with the GNU libg++ library (slightly
modified), which provides all of the common string manipulation
functions as member functions of the @code{String} object, and handles
the allocation of memory for the string dynamically, etc.

In addition to the primitive types, there are reference, pointer, and
array types.  Also, there are both script-defined and TypeAccess-derived
hard-coded @code{class} objects.  Finally, there are types that point to
hard-coded members of class objects, which correspond to all of the
basic C types, and, unlike the basic script types, are sensitive to the
actual size of a @code{short} vs a @code{long}, etc.

Finally there is a special @code{SubShell} type, which allows one to
have multiple compile spaces (cssProgSpace's) within css.  Thus, one
could @code{load} one program into the current shell, and use a SubShell
to load another one without getting rid of the first.  The two shells
can communicate via @code{extern} objects, and they share the same type
space.  Typical usage is:

@example
css> extern SubShell sub_shell;
css> chsh sub_shell
@end example

The first line defines the object (@code{extern} is recommended else it
will be removed when the parent shell is recompiled), and the second
switches to it.  To exit from the sub shell, just use @code{exit} or
@kbd{ctrl-D} (and have faith that when you answer 'y' you will be
returned to the parent shell).

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-commands, css-functions, css-types, css-ref
@subsection CSS Commands
@cindex CSS Commands

The following are the commands available in CSS.  Commands are a little
bit "special" in that they are typically executed immediately, they can
be called with arguments without using the parentheses required in
normal C functions (though they can be used if desired), and they do not
need to be terminated with a semicolon (note that this also means that
commands cannot extend across more than one line).  Also, they do not
generate return values.  In general, commands provide debugging and
program management (loading, listing, etc) kinds of facilities.

@table @code
@item alias <cmd> <new_nm>
@findex alias in CSS
Gives a new name to an existing command.  This is useful for defining
shortcuts (e.g., @code{alias list ls}), but does not allow more complex
functionality.  For that, either define a new function, or use a
pre-processor @code{#define} macro.
@item chsh <script_path>
@findex chsh in CSS
Switches the CSS interface to access the CSS script object pointed to by
the given path.  This is for hard-coded objects that have CSS script
objects in them (of type @code{cssProgSpace}).
@item clearall
@findex clearall in CSS
Clears out everything from the current program space.  This is like
restarting the CSS shell, compared to @code{reset} which does not remove
any variables defined at the top-level.
@item commands
@findex commands in CSS
Shows a list of the currently available commands (including any aliases
that have been defined, which will appear at the end of the list).
@item constants
@findex constants in CSS
Shows a list of the pre-defined constants that have been defined in CSS.
These are just like globally-defined @code{Int} and @code{Real} values,
and thus they can be assigned to different values (though this is
obviously not recommended).
@item cont 
@findex cont in CSS
Continues the execution of a program that was stopped either by a
breakpoint or by single-stepping.  To continue at a particular line in
the code, use the @code{goto} command.
@item debug <level>
@findex debug in CSS
Sets the debug level.  Level 1 provides a trace of the source lines
executed.  Level 2 provides a more detailed, machine-level trace, and
causes @code{list} to show the program at the machine level instead of
at the usual source level. Levels greater than 2 provide increasing
amounts of detail about the inner workings of CSS, which should not be
relevant to most users.
@item define
@findex define in CSS
Toggles the mode where statements that are typed in become part of the
current program to be executed later (define mode), as opposed the
default (run mode) where statements are executed immediately after entering
them.
@item defines
@findex defines in CSS
Shows a list of all of the current @code{#define} pre-processor macros.
@item edit <object> [<wait>]
@findex edit in CSS
If the GUI (graphical user interface) is active (i.e., by using
@code{-gui} to start up CSS), @code{edit} will bring up a graphical edit
dialog for the given object, which must be either a script-defined or
hard-coded @code{class} object.  The optional second argument, if
@code{true}, will cause the system to wait for the user to close the
edit dialog before continuing execution of the script.
@item enums
@findex enums in CSS
Shows a list of all the current @code{enum} types.  Note that most
@code{enum} types are defined within a @code{class} scope, and can be
found there by using the @code{type} command on the class type.
@item exit
@findex exit in CSS
Exits from the program (CSS), or from another program space if
@code{chsh} (or its GUI equivalent) was called.
@item frame [<back>]
@findex frame in CSS
Shows the variables and their values associated with the current block
or frame of processing.  The optional argument gives the number of
frames back from the current one to display.  This is most relevant for
debugging at a breakpoint, since otherwise there will only be a single,
top-level frame to display.
@item functions
@findex functions in CSS
Shows a list of all of the currently defined functions.
@item globals
@findex globals in CSS
Shows a list of all of the currently defined global variables, including
those in the script and hard-coded ones.
@item goto <src_ln>
@findex goto in CSS
Continues execution at the given source line.  
@item help [<expr>]
@findex help in CSS
Shows a short help message, including lists of commands and functions
available.  When passed argument (command, function, class, etc),
provides help information for it.
@item inherit <object_type>
@findex inherit in CSS
Shows the inheritance path for the given object type.
@item list [<start_ln> [<n_lns>]] [<function>]
@findex list in CSS
Lists the program source (or machine code, if @code{debug} is 2 or
greater), optionally starting at the given source line number, and
continuing for either 20 lines (the initial default) or the number given
by the second argument (which then becomes the new default).
Alternatively, a function name can be given, which will start the
listing at the beginning of that function (even if the function is
@code{extern}al and does not appear in a line-number based list).
@code{list} with no arguments will resume where the last one left off.
@item load <program_file>
@findex load in CSS
Loads and compiles a new program from the given file.
@item mallinfo
@findex mallinfo in CSS
Generates a listing of the current @code{malloc} memory allocation
statistics, including changes from the last time the command was called.
@item print <expr>
@findex print in CSS
Prints the results of the given expression (which can be any valid CSS
expression), giving some type information and following with a new line
(@code{\n}).  This is useful for debugging, but not for printing values
as part of an executing program.
@item printr <object>
@findex printr in CSS
Prints an object and any of its sub-objects in a indented style
output.  This can be very long for objects near the top of the object
hierarchy (i.e., the root object), so be careful!
@item reload
@findex reload in CSS
Reloads the current program from the last file that was @code{load}ed.
This is useful because you do not have to specify the program file when
making a series of changes to a program.
@item remove <var_name>
@findex remove in CSS
Removes given variable from whatever space it was defined in.  This can
be useful if a variable was defined accidentally or given the wrong name
during interactive use.
@item reset
@findex reset in CSS
Reset is like @code{clearall}, except that it does not remove any
top-level variables that might have been defined.  Neither of these
commands will remove anything declared @code{extern}.
@item restart
@findex restart in CSS
Resets the script to start at the beginning.  This is useful if you want
to stop execution of the program after a break point.
@item run
@findex run in CSS
Runs the script from the start (as opposed to @code{cont} which
continues execution from the current location).
@item setbp <src_ln>
@findex setbp in CSS
Sets a breakpoint at the given source-code line.  Execution of the
program will break when it gets to that line, and you will be able to
examine variables, etc.
@item setout <ostream>
@findex setout in CSS
Sets the default output of CSS commands to the given stream.  This can
be used to redirect listings or program tracing output to a file.
@item settings
@findex settings in CSS
Shows the current values of various system-level settings or parameters.
These settings are all static members of the class @code{ta_Misc}, and
can be set by using the scoped member name, for example:
@code{ta_Misc::display_width = 90;}
@item shell <"shell_cmd">
@findex shell in CSS
Executes the given Unix shell command (i.e., @code{shell "ls -lt"}).
@item showbp
@findex showbp in CSS
Shows a list of all currently defined breakpoints, and the source code
line they point to.
@item source <cmd_file>
@findex source in CSS
Loads a file which contains a series of commands or statements, which
are executed exactly as if they were entered from the keyboard.  Note
that this is different than @code{load}ing a program, which merely
compiles the program but does not execute it immediately thereafter.
@code{source} uses run mode, while @code{load} uses define mode.
@item stack
@findex stack in CSS
Displays the current contents of the stack.  This can be useful for
debugging.
@item status
@findex status in CSS
Displays a brief listing of various status parameters, such as current
source line, depth, etc.
@item step <step_n>
@findex step in CSS
Sets the single-step mode for program execution.  The parameter is the
number of lines to step through before pausing.  A value of 0 turns off
single stepping.
@item tokens <obj_type>
@findex tokens in CSS
Lists the instances of the given object type which are known to have
been created.  Many object types do not register tokens, which will be
indicated in the results of this command if applicable.  It is possible
to refer to the objects by their position in this list with the
@code{Token} function, which can be a useful shortcut to using the
object's path.
@item trace [<level>]
@findex trace in CSS
Displays a trace of the functions called up to the current one (i.e., as
called from within a breakpoint). A trace level of 0 (the default) just
gives function names, line numbers, and the source code for the
function call, while level 1 adds stack information, level 2 adds
stack and auto variable state information, and level 3 gives a complete
dump of all available information.
@item type <type_name>
@findex type in CSS
Gives type information about the given type.  This includes full
information about classes (both hard-coded and script-defined),
including members, functions, scoped types (enums), etc.
@item undo
@findex undo in CSS
This undoes the previous statement, when in @code{define} mode.
@item unsetbp <src_ln>
@findex unsetbp in CSS
Removes a breakpoint associated with the given source-code line number.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-functions, css-settings, css-commands, css-ref
@subsection CSS Functions
@cindex CSS Functions

The following functions are built into CSS, and provide some of the
basic functionality found in the standard C library.  Note that the
@code{String} and @code{stream} objects encapsulate many commonly-used C
library functions, which have not in general been reproduced in CSS
(with the exception of some of the file functions).

@table @code
@item Int access(String fname, int ac_type)
@findex access in CSS
This POSIX command determines if the given file name is accessible
according to the ac_type argument, which should be some bitwise OR of
the enums @code{R_OK W_OK X_OK F_OK}.  Returns success and sets errno
flag on failure.
@item Real acos(Real x)
@findex acos in CSS
The arc-cosine (inverse cosine) -- takes an X coordinate and returns the
angle (in radians) such that cos(angle)=X.
@item Real acosh(Real x)
@findex acosh in CSS
The hyperbolic arc-cosine.
@item Int alarm(int seconds)
@findex alarm in CSS
Generate an alarm signal in the given number of seconds.  Returns
success and sets errno flag on failure.
@item Real asin(Real x)
@findex asin in CSS
The arc-sine (inverse sine) -- takes a Y coordinate and returns the
angle (in radians) such that sin(angle)=Y. 
@item Real asinh(Real x)
@findex asinh in CSS
The hyperbolic arc-sine.
@item Real atan(Real x)
@findex atan in CSS
The arc-tangent (inverse tangent) -- takes a Y/X slope and returns angle
(in radians) such that tan(angle)=Y/X.
@item Real atan2(Real y, Real x)
@findex atan2 in CSS
The arc-tangent (inverse tangent) -- takes a Y/X slope and returns angle
(in radians) such that tan(angle)=Y/X.
@item Real atanh(Real x)
@findex atanh in CSS
The hyperbolic arc-tangent.
@item Real beta(Real z, Real w)
@findex beta in CSS
The Beta function.
@item Real beta_i(Real a, Real b, Real x)
@findex beta_i in CSS
The incomplete Beta function.
@item Real bico_ln(Int n, Int j)
@findex bico_ln in CSS
The natural logarithm of the binomial coefficient "n choose j".  The
number of ways of choosing j items out of a set containing n
elements:
@example
  / n \        n! 
  |   |  = ------------
  \ j /      k! (n-k)!
@end example
@item Real binom_cum(Int n, Int j, Int p)
@findex binom_cum in CSS
The cumulative binomial probability of getting j @emph{or more} in n
trials of probability p.
@item Real binom_den(Int n, Int j, Real p)
@findex binom_den in CSS
The binomial probability density function for j "successes" in n trials,
each with probability p of success.
@example
               / n \   j      (n-j)
  P(n,j,p) =   |   |  p  (1-p) 
               \ j /  
@end example
@item Real binom_dev(Int n, Real p)
@findex binom_dev in CSS
The binomial random deviate: produces an integer number of successes for
a binomial distribution with p probability over n trials.
@item Int CancelEditObj(obj)
@findex CancelEditObj in CSS
Cancels the edit dialog for the given object that would have been opened
by @code{EditObj}.
@item Real ceil(Real x)
@findex ceil in CSS
Rounds up the value to the next-highest integral value.
@item int chdir(String dir_name)
@findex chdir in CSS
Change the current directory to given argument.  Returns success and
sets errno flag on failure.
@item Real chisq_p(Real X, Real v)
@findex chisq_p in CSS
Gives the chi-squared statistic P(X^2 | v).
@item Real chisq_q(Real X, Real v)
@findex chisq_q in CSS
Gives the complement of the chi-squared statistic Q(X^2 | v).
@item Int chown(String fname, int user, int group)
@findex chown in CSS
Changes the ownership of the given file to the given user and group
numbers.  Returns success and sets errno flag on failure.
@item Real clock()
@findex clock in CSS
Returns processor time used by current process in seconds (with
fractions expressed in decimals).
@item Real cos(Real x)
@findex cos in CSS
The cosine of angle x (given in radians).  Use @code{cos(x / DEG)} if x
is in degrees.
@item Real cosh(Real x)
@findex cosh in CSS
The hyperbolic cosine of angle x.
@item String ctermid()
@findex ctermid in CSS
Returns the character-id of the current terminal.
@item String cuserid()
@findex cuserid in CSS
Returns the character-id of the current user.
@item String_Array& Dir([String& dir_nm])
@findex Dir in CSS
Fills an array with the names of all the files in the given directory
(defaults to "." if no directory name is passed).  The user should copy
the array if they want to keep it around, since the one returned is
just a pointer to an internal array object.
@item Real drand48()
@findex drand48 in CSS
Returns a uniformly-distributed random number between 0 and 1.
@item Int EditObj(<object>, [Int wait])
@findex EditObj in CSS
This is the function version of the @code{edit} command.  If the GUI
(graphical user interface) is active (i.e., by using @code{-gui} to
start up CSS), edit will bring up a graphical edit dialog for the given
object, which must be either a script-defined or hard-coded @code{class}
object.  The optional second argument, if TRUE, will cause the system to
wait for the user to close the edit dialog before continuing execution
of the script.
@item Real erf(Real x)
@findex erf in CSS
The error function, which provides an approximation to the integral of
the normal distribution.
@item Real erf_c(Real x)
@findex erf_c in CSS
The complement of the error function.
@item Real exp(Real x)
@findex exp in CSS
The natural exponential (e to the power x).
@item css* Extern(String& name)
@findex Extern in CSS
Returns the object with the given name on the 'extern' variable list.
This provides a mechanism for passing arbitrary (i.e., class objects)
data across different name spaces (i.e., across different instances of
the css program space), since you can pass the name of the extern class
object that contains data relevant to another script, and use this
function to get that object from its name.
@item Real fabs(Real x)
@findex fabs in CSS
The absolute value of x.
@item Real fact_ln(Int x)
@findex fact_ln in CSS
The natural logarithm of the factorial of x (x!).
@item void fclose(FILE fh)
@findex fclose in CSS
Closes the file, which was opened by @code{fopen}.  The FILE type is not
actually a standard C FILE, but actually a @code{fstream} type, so
stream operations can be performed on it.
@item Real floor(Real x)
@findex floor in CSS
Rounds the value down to the next lowest integral value.
@item Real fmod(Real x, Real y)
@findex fmod in CSS
Returns the value of x modulo y (i.e., @code{x % y}) for floating-point
values.
@item FILE fopen(String& file_nm, String& mode)
@findex fopen in CSS
Opens given file name in the given mode, where the modes are "r", "w",
and "a" for read, write and append. The FILE type is not actually a
standard C FILE, but actually a @code{fstream} type, so stream
operations can be performed on it.
@item void fprintf(FILE strm, v1 [,v2...])
@findex fprintf in CSS
Prints the given arguments (which must be comma separated) to the
stream.  Values to be printed can be of any type, and are actually
printed with the @code{<<} operator of the stream classes.  Unlike the
standard C function, there is no provision for specifying formatting
information.  Instead, the formatting must be specified by changing the
parameters of the stream object.  The FILE type is not actually a
standard C FILE, but actually a @code{fstream} type, so stream
operations can be performed on it.
@item Real Ftest_q(Real F, Real v1, Real v2)
@findex Ftest_q in CSS
Gives the F probability distribution for P(F | (v1 < v2)).  Useful for
performing statistical significance tests.  The _q suffix means that
this is the complement distribution.
@item Real gamma_cum(Int i, Real l, Real t)
@findex gamma_cum in CSS
The cumulative gamma distribution for event i with parameters l=lambda
and t=time, which is the same as @code{gamma_p(j, l * t)}.
@item Real gamma_den(Int j, Real l, Real t)
@findex gamma_den in CSS
The gamma probability density function for j events, l=lambda, and
t=time.
@example
                 j  (j-1)
                l  t         -lt 
  P(j,l,t)  =  -----------  e           (t > 0)
                    j!
@end example
@item Real gamma_dev(Int j)
@findex gamma_dev in CSS
A random gamma deviate: how long it takes to wait until j events occur
with a unit lambda (l=1).
@item Real gamma_ln(Real z)
@findex gamma_ln in CSS
The natural logarithm of the gamma function, which is a generalization
of (n-1)! to real-valued arguments. Note that this is not the
gamma probability distribution.
@example
                x
              /   z-1  -t
  Gamma(z) =  |  t    e   dt 
              /
               0             
@end example
@item Real gamma_p(Real a, Real x)
@findex gamma_p in CSS
The incomplete gamma function:
@example
                          x            
                1       /   a-1  -t    
  P(a,x) =  --------    |  t    e   dt          (a > 0)
            Gamma(a)    /              
                         0             
@end example
@item Real gamma_q(Real a, Real x)
@findex gamma_q in CSS
The incomplete gamma function as the complement of @code{gamma_p}
@example
                         inf            
                1       /   a-1  -t    
  P(a,x) =  --------    |  t    e   dt          (a > 0)
            Gamma(a)    /              
                         x             
@end example
@item Real gauss_cum(Real x)
@findex gauss_cum in CSS
The cumulative of the Gaussian or normal distribution up to given x
(sigma = 1, mean = 0).
@item Real gauss_den(Real x)
@findex gauss_den in CSS
The Gaussian or normal probability density function at x with sigma = 1
and mean = 0.
@item Real gauss_inv(Real p)
@findex gauss_inv in CSS
Inverse of the cumulative for p: returns z value for given p.
@item Real gauss_dev()
@findex gauss_dev in CSS
Returns a Gaussian random deviate with unit variance and 0 mean.
@item String getcwd()
@findex getcwd in CSS
Returns the current working directory path.
@item String getenv(String var)
@findex getenv in CSS
Returns the environment variable definition for varable var.
@item Int getegid()
@findex getegid in CSS
Returns the current effective group id number for this process.
@item Int geteuid()
@findex geteuid in CSS
Returns the current effective user id number for this process.
@item Int getgid()
@findex getgid in CSS
Returns the current group id number for this process.
@item Int getuid()
@findex getuid in CSS
Returns the current user id number for this process.
@item String getlogin()
@findex getlogin in CSS
Returns the name the current user logged in as.
@item Int getpgrp()
@findex getpgrp in CSS
Returns the process group id for current process.
@item Int getpid()
@findex getpid in CSS
Returns the process id for current process.
@item Int getppid()
@findex getppid in CSS
Returns the parent process id for current process.
@item Int gettimesec()
@findex gettimesec in CSS
Returns current time of day in seconds.
@item Int gettimmesec()
@findex gettimemsec in CSS
Returns current time of day in microseconds.
@item Real hyperg(Int j, Int s, Int t, Int n)
@findex hyperg in CSS
The hypergeometric probability function for getting j number of the
"target" items in an environment of size "n", where there are "t"
targets and a sample (without replacement) of this environment of size
"s" is taken.
@item Int isatty()
@findex isatty in CSS
Returns true if the current input terminal is a tty (as opposed to a
file or a pipe or something else).
@item Int link(String from, String to)
@findex link in CSS
Creates a hard link from given file to other file.  (see also symlink).
Returns success and sets errno flag on failure.
@item Real log(Real x)
@findex log in CSS
The natural logarithm of x.
@item Real log10(Real x)
@findex log10 in CSS
The logarithm base 10 of x.
@item Int lrand48()
@findex lrand48 in CSS
Returns a uniformly-distributed random number on the range of the
integers.
@item MAX(<v1>, <v2>) or max(<v1>, <v2>)
@findex MAX in CSS
@findex max in CSS
Works like the commonly-used @code{#define} macro that gives the maximum
of the two given arguments.  The return type is that of the
maximum-valued argument.
@item MIN(<v1>, <v2>) or min(<vi>, <v2>)
@findex MIN in CSS
@findex min in CSS
Just like @code{MAX}, except it returns the minimum of the two given
arguments.
@item Int pause()
@findex pause in CSS
Pause (wait) until an alarm or other signal is received.  Returns
success and sets errno flag on failure.
@item void perror(String prompt)
@findex perror in CSS
Prints out the current error message to stderr (cerr).  The prompt
argument is printed before the error message.  Also, the global variable
@code{errno} can be checked.  Further, there is an include file in
css/include called errno.css that defines an enumerated type for the
defined values of errno.
@item Real poisson_cum(Int j, Real l)
@findex poisson_cum in CSS
The cumulative Poisson distribution for getting 0 to j-1 events with an
exected number of events of l (lambda).
@item Real poisson_den(Int j, Real l)
@findex poisson_den in CSS
The Poisson probability density function for j events given an expected
number of events of l (lambda).
@example
               j
              l    -l
  P(j, l) =  ---- e
              j!
@end example
@item Real poisson_dev(Real l)
@findex poisson_dev in CSS
A random Poisson deviate with a mean of l (lambda).
@item Real pow(Real x, Real y)
@findex pow in CSS
Returns x to the y power.  This can also be expressed in CSS as x ^ y.
@item void PrintR(<object>)
@findex PrintR in CSS
This is the function version of the @code{printr} command.  Prints an
object and any of its sub-objects in a indented style output.  This can
be very long for objects near the top of the object hierarchy (i.e., the
root object), so be careful!
@item void printf(v1 [,v2...])
@findex printf in CSS
Prints the given arguments (which must be comma separated) to the
standard output stream.  Values to be printed can be of any type, and
are actually printed with the @code{<<} operator of the stream classes.
Unlike the standard C function, there is no provision for specifying
formatting information.  Instead, the formatting must be specified by
changing the parameters of the standard stream output object,
@code{cout}.  The FILE type is not actually a standard C FILE, but
actually a @code{fstream} type, so stream operations can be performed on
it.
@item Int putenv(String env_val)
@findex putenv in CSS
Put the environment value into the list of environment values (avail
through getenv).
@item Int random()
@findex random in CSS
Returns a uniformly-distributed random number on the range of the
integers.  CSS actually uses the @code{lrand48} function to generate the
number given the limitations of the standard @code{random} generator.
@item String_Array& ReadLine(istream& strm)
@findex ReadLine in CSS
Reads a line of data from the given stream, and returns a reference to
an internal array (which is reused upon a subsequent call to ReadLine)
of strings with elements containing the whitespace-delimited columns of
the line.  The size of the array gives the number of columns, etc.  This
allows one to easily implement much of the functionality of awk.  See
the file @file{css_awk.css} in @file{css/include} for an example.
@item Int rename(String from, String to)
@findex rename in CSS
Renames given file.  Returns success and sets errno flag on failure.
@item Int rmdir(String dir_name)
@findex rmdir in CSS
Removes given directory.  Returns success and sets errno flag on
failure.
@item Int setgid(Int id)
@findex setgid in CSS
Sets group id for given process to that given.  Note that only the
super-user can in general do this.  Returns success and sets errno flag
on failure.
@item Int setpgid(Int id)
@findex setpgid in CSS
Sets process group id for given process to that given.  Note that only
the super-user can in general do this.  Returns success and sets errno
flag on failure.
@item Int setuid(Int id)
@findex setuid in CSS
Sets user id for given process to that given.  Note that only the
super-user can in general do this.  Returns success and sets errno flag
on failure.
@item Real sin(Real x)
@findex sin in CSS
The sine of angle x (given in radians).  Use @code{sin(x / DEG)} if x is
in degrees.
@item Real sinh(Real x)
@findex sinh in CSS
The hyperbolic sine of x.
@item Real sqrt(Real x)
@findex sqrt in CSS
The square-root of x.
@item void srand48(Int seed)
@findex srand48 in CSS
Provides a new random seed for the random number generator.
@item Int sleep(Int seconds)
@findex sleep in CSS
Causes the process to wait for given number of seconds.  Returns success
and sets errno flag on failure.
@item Real students_cum(Real t, Real v)
@findex students_cum in CSS
Gives the cumulative Student's distribution for v degrees of freedom t test.
@item Real students_den(Real t, Real v)
@findex students_den in CSS
Gives the Student's distribution density function for v degrees of freedom t test.
@item Int symlink(String from, String to)
@findex symlink in CSS
Creates a symbolic link from given file to other file.  (see also link).
Returns success and sets errno flag on failure.
@item void system(String& cmd)
@findex system in CSS
Executes the given command in the Unix shell.
@item Real tan(Real x)
@findex tan in CSS
The tangent of angle x (given in radians).  Use @code{tan(x / DEG)} if x
is in degrees.
@item Real tanh(Real x)
@findex tanh in CSS
The hyperbolic tangent of x.
@item Int tcgetpgrp(Int file_no)
@findex tcgetpgrp in CSS
Gets the process group associated with the given file descriptor.
Returns success and sets errno flag on failure.
@item Int tcsetpgrp(Int file_no)
@findex tcsetpgrp in CSS
Sets the process group associated with the given file descriptor.
Returns success and sets errno flag on failure.
@item String ttyname(Int file_no)
@findex ttyname in CSS
Returns the terminal name associated with the given file descriptor.
@item Token(<obj_type>, Int tok_no)
@findex Token in CSS
Returns the token of the given type of object at index @code{tok_no} in
the list of tokens.  Use the @code{tokens} command to obtain a listing
of the tokens of a given type of object.
@item TypeDef Type(String& typ_nm | <obj_type>)
@findex Type in CSS
Returns a type descriptor object (generated by TypeAccess), for the
given type name or type object (the type object can be used directly in
some situations, but not all).
@item Int unlink(String fname)
@findex unlink in CSS
Unlinks (removes) the given file name.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-settings,  , css-functions, css-ref
@subsection Parameters affecting CSS Behavior

All of the settings that control the behavior of CSS are contained in
the global object called @code{cssSettings}.  This is actually just a
reference to the @code{taMisc} class, which is part of the TypeAccess
system.  The members of this class that can be set by the user are
listed below (see also @pxref{gui-settings}): 

@table @code
@item int display_width
@vindex display_width of taMisc 
Width of the shell display in characters.
@item int sep_tabs
@vindex sep_tabs of taMisc
Number of tabs to separate items by in listings.
@item int search_depth
@vindex search_depth of taMisc
The recursive depth at which css stops searching for an object's path.
@item TypeInfo type_info
@vindex type_info of taMisc
The amount of information about a class type that is reported when
the "type" command is used in CSS.
@sp 1
Type_info has one of the following values:
@sp 1
@sp 1
@itemize @asis
@item
@code{MEMB_OFFSETS}       shows the byte offset of members
@item
@code{All_INFO}          shows all type info except memb_offsets
@item
@code{NO_OPTIONS}        shows all info except type options
@item
@code{NO_LISTS}          shows all info but lists
@item
@code{NO_OPTIONS_LISTS}  shows all info but options and lists
@end itemize
@sp 1
The default is @code{NO_OPTIONS_LISTS}
@sp 1
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-errors, css-hard, css-ref, css
@section Common User Errors
@cindex Errors, CSS
@cindex CSS Errors

The following are common user errors, which you can anticipate and avoid
by reading about them in advance.

@strong{Forgetting the semicolon:} CSS, being essentially like C or C++,
requires most statements to end with a semicolon (;). This allows one to
spread statements over multiple lines, since the semicolon and not the
newline indicates the end of a statement.  However, it is easy to forget
it when typing stuff in interactively.  The consequences of this are
that the following command or statement will be treated as if it was
part of the one where the semicolon was forgotten, usually resulting in
a @code{Syntax Error}.  Note that commands are exempt from the semicolon
requirement, and, as a corollary, can not be extened across multiple
lines. 

@strong{Delayed impact of syntax error:}  This happens when the user types
in something erroneous (i.e., something that will result in a Syntax
Error), without following it with a semicolon (usually because it was
supposed to be a command, which does not require a semicolon).
However, because the entry was neither a command nor followed by a
semicolon, it treats the following material as being on the same line,
so that only after the second line has been entered (typically), is the
first syntax error caught.  The solution is to simply press enter a
couple of times (or hit the semicolon and press enter), which will clear
out the preceding line and let you continue on.

@strong{Trying to @code{print} or do something else with a @code{void}:} If
an expression cannot be evaluated (resulting in a @code{void} value), or
a function is called which returns a type of @code{void} (i.e., nothing
is returned), and the result of this expression is then printed or
passed to some other function, the following error will result:
@code{Incomplete argument list for: <function_name>, Should have: 1 Got:
0}.  Since the void does not get passed to the function or command which
is expecting an argument, the function/command (typically @code{print})
complains with the above error.

 
@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  css-hard,  , css-errors, css
@section Compiling CSS files as C++ Hard Code
@cindex Compiling CSS
@cindex CSS, Compiling

Because they use the standard C++ syntax, CSS script files can be
compiled into "hard" code that runs (fast) as a stand-alone application.
Of course, the files must not use any of the CSS shortcuts, and must
otherwise be standard C++ code (i.e., no executable code outside of
functions, using the correct @code{.} or @code{->} operator, etc).

There are three main steps that are needed to compile your CSS code.
The first, which need only be done once, is the creation of the
appropriate libraries that will be linked with the C++ compiled code to
produce an executable.  The second is formatting your file so that it
can be both run by CSS and compiled by C++.  The third is creating a
Makefile which will allow C++ to compile your file.  An example of this
is provided in the directory @file{demo/css}.

There are two special libraries that are linked into your C++
executable, one in the @file{src/ta} directory, and one in the
@file{src/css} directory.  Both can be made using top-level Makefile
commands, or by going into the directories separately.  @samp{make
LibMin} makes a library which contains the minimal type-access stuff
from the @file{src/ta} directory of the distribution, and it makes the
@file{libtypea_min} library.  @samp{make hard_css} makes a library of
special functions in @file{src/css} (e.g., the "special math" functions
which have been added into CSS and are not part of the standard C
library, and the Dir and ReadLine functions).  This library is
@file{libhard_css}.  Both of these libraries will be visible to the C++
compiler using the makefiles as described below.

The CSS file needs to have a couple of conditially-included elements
that resolve the basic differences between CSS and C++.  Basically, this
amounts to including a header file that estabilshes some defines and
includes some commonly-used standard library headers, which are
automatically present in CSS.  This is the @file{css/hard_of_css.h}
file.  It is only included when compiling by making it conditional on
the pre-processor define @code{__CSS__}, which is automatically defined
by CSS.  Also, @file{hard_of_css.h} defines a @code{main} function which
calls a function called @code{s_main}, which is the actual main function
that should be defined in your script.

The following example illustrates these elements, and can be used as a
template for making your own CSS files compilable (see @file{demo/css}
for a larger example):

@example
#ifndef __CSS__
#include <css/hard_of_css.h>
#endif

void s_main(int ac, String* av) @{
  // do stuff here..
@}

// in css, call our main function as the thing we actually run..
#ifdef __CSS__
s_main(argc, argv);
#endif
@end example

In order to make the C++ compiling environment as similar to CSS as
possible, a variant of the same Makefile can be used.  This assumes that
the makefiles for your CPU type are correct (i.e., those used in
installing the PDP++/CSS source-code distribution (@pxref{inst},
@ref{inst-prog})).  The following steps will result in a Makefile that
will enable you to compile your CSS code.

1) Copy the sample makefile in @file{config/Makefile.hard_of_css} into
the directory where your CSS file is to be compiled, and name it
@file{Makefile.in}.

2) Edit this file and ensure that the PDPDIR path is pointing to the
installed pdp++ distribution.

3) Then, do a @code{make -f Makefile.in InitMakefile}, which will make a
@file{Makefile} in the current directory that can be used to compile
your file.

4) To compile, just type @code{make <filenm>}, where @code{<filenm>} is
the CSS file without any extension (i.e., the name of the executable
that will be produced.  Some C++ compilers will complain if the file
does not end in a "standard" C++ extension like .cc or .C, so you may
have to rename it or create a symbolic link from your .css file (CSS
does not care about using a non .css extension, as long as you specify
the entire file name).


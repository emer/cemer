@c uncomment the following two lines for 'update every node' command
@c @node  env
@c @chapter Environments, Events, and Patterns

@cindex Environment
@tindex Environment

Conceptually, a network always acts in an environment of some kind. For
example, back propagation and pattern associator networks act in an
environment of input-output patterns. An unsupervised learning network
operates in an environment consisting of input patterns.

In PDP++, the object of type @b{Environment} contains all the
information that specifies the kinds of stimuli or patterns that the
network will be tested or trained on.  The role of the environment is to
represent all of the data, structured so that the data can be
interpreted by the processes and presented to the network appropriately.
Thus, it is like a database or a library.  The environment does not
specify things like the @emph{order} with which events will be presented
to the network--this is the job of the processes, which, to continue the
metaphor, act like librarians in providing the interface between the
data (the environment) and the consumer (the network).

There is a special relationship between the @b{EventSpec}, which
specifies properties of events, and the @b{Event} objects themselves.
Any changes made to the event spec (or its pattern specs), for example
in the number of patterns per event or size of one of the patterns, are
automatically propagated to all of the events that use the event spec.
Thus, the @b{EventSpec} acts much like a dynamic template for events,
which is a different role for a spec object.  This design makes it very
easy to modify environments once they've been created.

The @b{EnviroView} enables you to interactively configure the event
specs for the events, much in the same way the net view allows one to
configure networks.  In the standard color scheme, environment objects
are colored green (like the great outdoors!).

@menu
* env-env::                     Environment
* env-event::                   Events, Patterns, and their Specs
* env-seq::                     Representing Sequences of Events
* env-view::                    The EnviroView
* env-import::                  Importing Environments from Text Files
* env-gen::                     Environment Generation Functions
* env-analyze::                 Environment Analysis Functions
* env-freq::                    Frequency Environments and Events
* env-other::                   Other Environment Types
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node env-env, env-event, env, env
@section Environments

The @b{Environment} is used by the processes to present inputs to the
@b{Network}, and to provide training values for the network as well.  At
appropriate intervals, the processes will ask the environment for an
@b{Event}. The event is a snapshot or instance of the environment at a
given time. It is up to the environment to generate the appropriate
event given an index presented by the processes. Typically, these
events are precomputed and the environment simply iterates over the a
list of events. Optionally, an environment can perform more complicated
event choosing operations and can even modify or generate events on the
fly if so desired (supported by the @b{InteractiveScriptEnv},
@ref{env-other}). 

Sometimes the events may need to be further organized into subgroups of
events in order to represent groups of events that belong in a
particular sequence (@pxref{env-seq}). Specialized processes like the
@b{SequenceEpoch} and the @b{SequenceProcess} interact with the
Environment by asking it for one of these subgroups of Events. The
Sequence Epoch allows updating of weights and other operations to occur
after the entire "batch" of events in the Event SubGroup has been
presented (@pxref{proc-special-seq}).

In summary, there are three different interfaces to the environment:

@table @b
@item 1.
A flat list of events accessed by event index (supported by the standard
@b{EpochProcess}).  @code{InitEvents()} is called at the start, and a
@b{ScriptEnv} can render a batch of events for each epoch.
@item 2.
Groups of events accessed first by group index, then by index of event
within group (supported by @b{SequenceEpoch} and @b{SequenceProcess},
@ref{proc-special-seq}).  This allows for subsets of events to be
grouped together as a sequence.  Again, @code{InitEvents()} is called
at the start of the entire epoch.
@item 3.
An 'interactive' model that doesn't depend on indicies at all,
supported by @b{InteractiveEpoch} (@pxref{proc-special-inter}).  This
allows for events to depend on what has just happened in the network.
@code{InitEvents()} is called at the start of an epoch, and
@code{GetNextEvent()} is called for each new event until it returns a
NULL.  In a @b{IneractiveScriptEnv}, @code{GetNextEvent()} calls the
script, and returns the event in the @code{next_event} pointer (which
needs to be set by the script) -- see @ref{env-other} for details.
@end table

In the generic @b{Environment} class there are two groups:

@table @code
@item Event_Group events
@vindex events of Environment
This is where the events are stored.
@item BaseSpec_Group event_specs
@vindex event_specs of Environment
This is where the @b{EventSpec} objects are stored.  Note that event
specs, unlike other specs, reside in the environment, and not in the
@b{Project} @code{.specs} group.  This makes environments self-contained
so that they can be loaded and saved independent of the project.
@end table

The following functions are defined on the @b{Environment} object.  Note
that a given process will either use the Group model or the Event model
of the environment.  The group model is for sequences, which are stored
in subgroups, and the event model treats the environment just like a
flat list of events.  These functions are on the @i{Actions} menu:

@table @code
@item InitEvents()
@findex InitEvents on Environment
Initializes events for an epoch. Used for algorithmically generated
events which are generated at the start of each epoch.  This does
nothing in the base class, but in a @code{ScriptEnv} it calls the
script, which can then generate events.
@item UpdateAllEvents()
@findex UpdateAllEvents on Environment
Updates all events in accordance with their corresponding event
specs.  This should happen automatically but things can get out of
whack and this should clean everything up.
@item UpdateAllEventSpecs()
@findex UpdateAllEventSpecs on Environment
Updates all events in accordance with their corresponding event
specs.  This should happen automatically but things can get out of
whack and this should clean everything up.
@item EventCount()
@findex EventCount on Environment
Returns the number of events in the Environment.  This is used by the
processes to determine how long an epoch should be.
@item GroupCount()
@findex GroupCount on Environment
Returns the number of event groups in the Environment, for
sequence-based processing.  This determines how many sequences go in an
epoch. 
@item GetNextEvent()
@findex GetNextEvent on Environment
Returns the next event for processing (or NULL to signal the end of
the epoch).  This is the interface for the interactive environment
model (hook for generating new event based on current state).
@item UnitNamesToNet(EventSpec* event_spec_with_names, Network* network)
@findex UnitNamesToNet on Environment
Copies names from pattern spec @code{value_names} to corresponding units
in the network.  Uses default event spec and network if NULL.  This is
a convenient way to name units in the network -- these names are
otherwise lost when the network is rebuilt.
@item AutoNameAllEvents(float act_thresh, int max_pat_nm, int max_val_nm)
@findex AutoNameAllEvents on Environment
Automatically name all events based on the pattern names and value
(unit) names for those units with activations above act_thresh, e.g.,
@code{Inp:vl1_vl2,Out:vl1_vl2}.  There are also versions of this
functionality in Events and Event specs.
@end table

The following functions are defined in the @i{Object} menu and provide
additional input/output functionality:

@table @code
@item ReadText(ostream& strm, EventSpec* espec, TextFmt fmt)
@findex ReadText on Environment
Reads in an Environment from a text file which is in the format from
the old PDP software, or other formats based on the fmt parameter.
This uses the given event spec which must correspond to the pattern
file being read in.  See @ref{env-import}.
@item WriteText(istream& strm, int pat_no, TextFmt fmt)
@findex WriteText on Environment
Writes an Environment to a text file in the format from the old PDP
software, or other formats.  See @ref{env-import}.
@item ReadBinary(ostream& strm, EventSpec* espec)
@findex ReadBinary on Environment
Reads in an Environment from a binary file, which must be just a
continuous stream of floating point numbers that are applied in
sequence to the patterns and events of the environment.  See @ref{env-import}.
@item WriteBinary(istreamm& strm, int pat_no=-1, TextFmt fmt = NAME_FIRST)
@findex WriteBinary on Environment
Writes an Environment to a binary file as a continuous stream of
floating point numbers.  See @ref{env-import}.
@end table

The following are function interfaces used by processes to access events:

@table @code
@item GetEvent(int event_number)
@findex GetEvent on Environment
Returns a pointer to the Event corresponding to @code{event_number}.
The event number should be between 0 and @code{EventCount()}.
@item GetGroup(int group_number)
@findex GetGroup on Environment
Returns a pointer to the Event group corresponding to
@code{group_number}, which should be between 0 and @code{GroupCount()}.
@end table



@c ======================================
@c    <node>, <next>, <prev>, <up>
@node env-event, env-seq, env-env, env
@section Events, Patterns and their Specs
@tindex Event
@tindex EventSpec
@tindex Pattern
@tindex PatternSpec
@cindex Event
@cindex Pattern

Events are the snapshots of the Environment presented to the Network.
They represent a single coherent set of stimuli drawn from the
environment.  They are comprised of a set of patterns, which hold the
information affecting the network on a layer by layer basis.

@vindex spec of Event
The structure of an event is determined by its corresponding
@b{EventSpec}.  Any changes made in the event spec are automatically
made to all of the events that use that event spec.  Thus, there must be
one event spec for each different type of event created.  Event specs
reside in the environment itself, and not in the Project like other
specs.  The @b{Event} has a pointer to its spec, called @code{spec}.
This works just like other spec pointers (@pxref{obj-spec}).

@vindex patterns of Event
@vindex patterns of EventSpec
Both the @b{Event} and @b{EventSpec} objects are essentially just
containers for their constituent @b{Pattern} and @b{PatternSpec}
objects, which are also kept in one-to-one correspondence.  Thus, any
new pattern specs added in the @code{pattern} group in an event spec
will result in corresponding patterns in the @code{pattern} group on the
event.  Different varieties of events will add event-level parameters
like frequency and time (@pxref{env-freq}, @ref{env-other}).

@vindex value of Pattern
@vindex flag of Pattern
A @b{Pattern} is simply a list of real numbers, which are kept in a
floating-point @b{Array} object called @code{value}. It can be "applied"
to a specified layer in the network.  Each element of the value array in
the Pattern corresponds to a Unit in the Layer.  In addition, one can
assign a flag to each value, which will alter how this value is applied
to the units in the network.  The @code{flag} member of a Pattern holds
the flags, which are only present if the @code{use_flags} field in the
corresponding pattern spec is set to @code{USE_PATTERN_FLAGS} or
@code{USE_PAT_THEN_GLOBAL_FLAGS}. All of the flags are independent of
each other and be either on or off. The meaning of the flag values are
given in the @code{PatFlags} enumerated type in the @b{PatternSpec} and
listed below.

@table @code
@item TARG_FLAG
unit's TARG flag is set
@item EXT_FLAG
unit's EXT flag is set
@item COMP_FLAG
unit's COMP flag is set
@item TARG_VALUE
pattern value goes to the unit targ field
@item EXT_VALUE
pattern value goes to the unit ext field
@item NO_UNIT_FLAG
no unit flags are set, but value is set as normal
@item NO_UNIT_VALUE
don't set the unit's value, but flag as normal
@item NO_APPLY
don't apply this value to unit (no flags either)
@end table

The options include the ability to control how the unit's external input
will be flagged, and where the value will be copied on the Unit (i.e.,
to its @code{targ} or @code{ext} field).  This gives the user complete
control over how the pattern value is presented.

Note that the @code{value} field is an @code{float_RArray} type, which
has a range associated with it (hence the RArray), and it also has a
number of other useful functions that enable the distance between two
arrays to be computed, or various statistics like the mean, variance,
etc. to be computed on a given array.  These functions may be useful in
creating and analyzing patterns.

The @b{PatternSpec} has several fields which determine where its
corresponding pattern is presented, and what meaning it has to the
network:
@table @code
@item PatType type
@vindex type of PatternSpec
The type of the pattern, which determines how the network will interpret
its values.  This can be one of the following values:
@table @code
@item INACTIVE:
The corresponding pattern is not presented to the network.
@item INPUT:
The corresponding pattern is presented to the network as external input
activation: the value is copied to the @code{ext} variable of the
corresponding Unit, and the @code{EXT} flag is set on the
@code{ext_flags} of the unit (and the layer the unit is in).
@item TARGET:
The corresponding pattern is presented to the network as target
activation: the value is copied to the @code{targ} variable of the
corresponding Unit, and the @code{TARG} flag is set on the
@code{ext_flags} of the unit (and the layer the unit is in).
@item COMPARE:
The corresponding pattern is presented to the network as comparison
pattern, which does not affect activation states or learning, but can be
used to compare output values to expected ones via error statistics
(e.g., the @b{SE_Stat}). The value is copied to the @code{targ} variable
of the corresponding Unit, and the @code{COMP} flag is set on the
@code{ext_flags} of the unit (and the layer the unit is in).
@end table
@sp 1
@item PatLayer to_layer
@vindex to_layer of PatternSpec
The network layer to present the Pattern to. This can be one of the
following values:
@table @code
@item FIRST:
Apply to the first layer in the network.
@item LAST:
Apply to the last layer in the network.
@item LAY_NAME:
Specify the Layer to apply to by name. The name should be set in the
variable @code{layer_name}.
@item LAY_NUM:
Specify the Layer to apply to by layer number. The number should be set
in the variable @code{layer_num}.
@end table
@sp 1
@item  String layer_name
@vindex layer_name of PatternSpec
Contains the name of the layer to apply to (used if @code{to_layer} is
set to @code{LAY_NAME}).
@item Int layer_num
@vindex layer_num of PatternSpec
Contains the number of the layer to apply to (used if @code{to_layer} is
set to @code{LAY_NUM}).
@item TypeDef* pattern_type
@vindex pattern_type of PatternSpec
Determines the type of @b{Pattern} object that is created in events
that use this pattern spec.  Changing this after events have already
been created will @emph{not} cause them to change pattern types.  You
have to remove the Events and start over if you want to change the types
of patterns that are used.
@item LayerFlags layer_flags
@vindex layer_flags of PatternSpec
Determines how the layer's @code{ext_flags} will be set.  The
@code{DEFAULT} is to set them according to the pattern @code{type} as
described above, but they can be set to any of the possible combinations
of flags (@code{TARG, EXT, COMP}), or to @code{NO_LAYER_FLAGS} at all.
This can be useful if you have an pattern which uses flags for different
values (see @code{use_flags}) so the layer actually receives multiple
different kinds of external input.
@item PatUseFlags use_flags
@vindex use_flags of PatternSpec
Determines how the @code{flag} field of the Pattern and the
@code{global_flags} of this PatternSpec will be used when applying the
Pattern to the network.  This can be one of the following values:
@table @code
@item USE_NO_FLAGS:
Both pattern flags and global flags are ignored
@item USE_PATTERN_FLAGS:
Patterns flags are applied, global flags are ignored
@item USE_GLOBAL_FLAGS:
Global flags are applied, individual pattern flags are ignored
@item USE_PAT_THEN_GLOBAL_FLAGS:
If any flags are set on the pattern then use all the pattern's flag
settings, otherwise apply the global flags for that pattern. Note that
the choice of global versus pattern flags is not done individually by
each flag on the pattern but rather as an all or nothing check on each
pattern to determine if any of its flags are set.
@end table
@sp 1 
@item int n_vals
@vindex n_vals of PatternSpec
The number of values to create in the corresponding pattern.  It
should be equivalent to the number of units in the corresponding layer.
If this value is set to 0, it will be filled in with the number of units
on the corresponding layer of the default network in the current
project, if the layer can be found.
@item PosTDCoord geom
@vindex geom of PatternSpec
Determines the shape of the values as displayed in the
@b{EnviroView}.  It should correspond to the geom of the
corresponding layer, and is initialized as such if possible.
@item PosTDCoord pos
@vindex pos of PatternSpec
The position of the start of the event in the @b{EnviroView}.
Any overlap of displayed patterns is detected automatically, and the
@code{LinearLayout} action on the EventSpec can be called to arrange the
events linearly across or down the display.
@item float initial_val
@vindex initial_val of PatternSpec
The initial value that will be placed in newly created pattern
@code{value} arrays.
@item Random noise
@vindex noise of PatternSpec
This adds random noise of the given specification as the pattern is
applied to the network.
@item String_Array value_names
@vindex value_names of PatternSpec
The elements in this array are in one-to-one correspondence with the
values in the pattern, and can be used to label the patterns in the
@b{EnviroView} (@pxref{env-view}).  This is very useful 
@item int_Array global_flags
@vindex global_flags of PatternSpec
This contains flags that can apply (depending on @code{use_flags}) to
all of the patterns, determining how they are presented.
@end table

Note: the following information should be useful to those who wish to
program in PDP++, but is not necessary for the average user to
understand.

@menu
* env-event-impl::               Implementational Details of Events and Patterns
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  env-event-impl,  , env-event, env-event
@subsection Implementational Details of Events and Patterns

Note that layer pointer in a pattern spec depends on which network the
environment is being applied to.  Thus, there is some checking that
takes place when an event is being applied to the network to make sure
that the layer pointers are up-to-date.  Along these same lines, any
time the events or patterns are edited, the layer pointers are reset,
with the idea being that they might have changed where the patterns are
being applied to.

The basic set of functions can be found in the @file{src/pdp/enviro.h}
file.  They are fairly straightforward.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  env-seq, env-view, env-event, env
@section Representing Sequences of Events

Sequences of events are represented in PDP++ by creating subgroups
within the main @code{.events} group of an environment.  Each sub group
should contain a set of events that define one discrete sequence of
related events.  If the appropriate @b{SequenceEpoch} and @b{Sequence}
processes are used, they will access the @code{GroupCount} and
@code{GetGroup} functions on the environment (@pxref{env-env}), which
will allow the epoch-level process to iterate over the groups
(sequences) in the environment, while the sequence process iterates over
the events within each group.  The sequence-based processes are
discussed in @ref{proc-special-seq}.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node env-view, env-import, env-seq, env
@section The EnviroView
@tindex EnviroView

The EnviroView provides a graphical representation of the Environment,
allowing the user to view, create, and edit Events and Patterns and
their corresponding specs.  In addition the EnviroView can be used to
track the current Event presented to the network by setting its updaters
(@pxref{gui-win-view}).

There are two basic modes to the enviro view --- initially, it is in
Edit Events mode, where the Events and Patterns are displayed and can be
edited.  By hitting the @i{Edit Specs} button at the top of the
left-hand set of buttons, the display changes to editing the EventSpecs
and PatternSpecs.

@menu
* env-view-events::             Edit Events Mode
* env-view-specs::              Edit Specs Mode
@end menu
 
@c ======================================
@c    <node>, <next>, <prev>, <up>
@node env-view-events, env-view-specs, , env-view
@section Edit Events in the EnviroView

@ifset html
@ifhtml
<IMG SRC="pics/xor.enviroview.gif" ALIGN="MIDDLE" ALT="The Environment Viewer -- Events">
<P>
<B> Figure: </B> The Environment Viewer -- Events
<P>
@end ifhtml
@end ifset
@iftex
@tex
\medskip
\global\advance\texfigno by 1
\input epsf
\epsfysize=3.0in
\centerline{\epsfbox{/usr/local/pdp++/manual/pics/xor.enviroview.epsi}}
\noindent {\bf Figure: \number\texfigno} The Environment Viewer -- Events
@end tex
@end iftex
@ifinfo
Figure of: <The Environment Viewer -- Events> here
@end ifinfo

Non-obvious actions you can perform on objects in the EnviroView
@table @b
@item Single-click with left-mouse-button (LMB) on Event Button
Will select event for display in the view area to the right.
@item Single-click with right-mouse-button (RMB) on Event Button
Will bring up the edit dialog for the Event.
@item Shift-LMB or middle-mouse-button (MMB) on Event Button
Extends the selection to include multiple events, and can remove an
event from the display if performed on an already-selected event.
@item Click on alreadly selected Event Group Button
Will select all the events within the group, and deselect the group
button.
@item LMB on a pattern element of displayed event
Will set the value of that pattern element according to highlighted
drawing color (in color palette at bottom of display).
@item MMB on a pattern element of displayed event
Will set the value of that pattern element to 0.
@item RMB on a label on the displayed event
Will allow you to edit the value (e.g., change the event name, or its
frequency if that is what is displayed).
@item Turning off the Disp checkbox at top prevents display of events
This can be useful for manipulating large numbers of events using the 
event buttons -- just turn off the Disp and then you can select all the
events for setting specs or changing types, etc.
@end table

All of the events in the Environment are listed sequentially from top to
bottom in a scrollable vertical list on the left side of the EnviroView.
The index number of the event is shown on the left-hand side of the
label, and the first four characters of the sub-group name if the event
is in a sub-group.  Sub-groups have their own button that preceeds the
events that are within them, and are indicated by the @code{>>} symbol
on the left of the button.  Selecting these group buttons twice (double
clicking) will select all the events within them.

The following action buttons appear in the upper left of the EnviroView:
@table @code
@item New Evt/Gp
@findex New Evt/Gp of EnviroView
This button provides a convenient method for creating events or
sub-groups in the Environment. Pressing the New Evt/Gp button creates a
"New" dialog which prompts the user for the number and type of events or
groups to create. Each new event is modeled after the default (usually
the first) EventSpec in the Environment. If there are no EventSpecs, a
default EventSpec consisting of an input pattern for the @code{FIRST}
layer and a target output pattern for the @code{LAST} layer is created
for the new events.  If there are currently no events, the button will
appear hi-lighted indicating that it is the suggested course of action.
If there is one sub-group selected, then this button will create events
within that selected subgroup.
@item Delete
@findex Delete of EnviroView
The Delete button removes the currently selected Events or groups from
the Environment.
@item Xfer/Dupe, Xfer Event, Dupe Event, Dupe Group
@findex Xfer/Dupe, Xfer Event, Dupe Event, Dupe Group of EnviroView
If event(s) are selected, Dupe Event will duplicate them.  If
sub-group(s) are selected, Dupe Group will duplicate them (and their
associated sub-events).  If a group and some events are selected, then
Xfer Event will transfer the events into the selected group.
@item Set Spec/Type, Change Type
@findex Set Spec/Type, Change Type of EnviroView
If event(s) are selected, Set Spec/Type will bring up a choice of either
setting the spec for these events, or changing their type.  If
sub-group(s) are selected, Change Type will change their type.
@item Apply
@findex Apply on EnviroView
The Apply button saves the changes made to the Patterns. It will appear
hi-lighted if there are potentially changes which have not been saved.
@item Init/Revert
@findex Init/Revert on EnviroView
The Init button refreshes the EnviroView to reflect the stored values
of the currently displayed Events. @i{Any un-applied changes to the
patterns will be lost.}
@end table

At the bottom of the EnviroView is a painting ColorBar. This colorbar
differs from the colorbar in the scale region of the NetView in that the
different shades of color are selectable for use in "painting" values
into the patterns of the Events. In addition, four custom value pads are
provided for entering specific values. The color corresponding to the
value of the pad appears next to the value and is selectable for use in
painting just like to shades of the colorbar. These pads appear above
the ColorBar and have default values of (-1.0, 0.0, 0.5, 1.0), which can
be changed just by typing in a new value. The minimum and maximum of the
range of the ColorBar may be independently specified or automatically
scaled to the minimum and maximum value of the currently displayed
events if the "Auto Range" toggle in the upper left corner of the
EnviroView is selected.

When an Event is selected for viewing, it appears in the EnviroView as
as set of name labels and colored blocks. The labels and blocks are
positioned according to @code{pos} and @code{geom} values of the
PatternSpecs for each Pattern in the Event (see @ref{env-view-specs} for
how to configure this interactively). The color of the blocks
corresponds to its value in the ColorBar at the bottom of the
EnviroView. If a pad or shade value is selected in the ColorBar, the
user may change the values of the Patterns by clicking or dragging on
the colored blocks. Pressing the left mouse button changes the value of
the block under the mouse pointer to be the selected value in the
ColorBar. Pressing the middle mouse button changes the block's value to
it previous value.

In the upper left area of the EnviroView are several menus which
control certain features of each event which is displayed.  The first
menu called @i{Val Txt} determines what kind of textual information is
rendered along with the pattern values (could be @code{VALUES} or
@code{NAMES} (for the value_names) aor @code{BOTH}).  The @i{Disp Md:}
menu selects the way in which the values are rendered -- @code{COLOR},
@code{AREA}, or @code{LINEAR}, just as in the NetView
(@pxref{net-view}).

The next two menus control what kinds of labels are shown along with
each event and each pattern.  @i{Evt Label} controls which propery of
the Event is shown in the Event Label region (bottom) of the displayed
events. Likewise, the @i{Pat Label} menu contols what pattern properties
are shown in the formatted pattern label section of the displayed events
(at the top of each pattern). If the displayed event and/pr pattern does
not have the propery which is selected, a "n/a" will be displayed.

The @i{Pat Block} menu controls which property of the pattern is being
displayed and edited when the user clicks on the pattern blocks
described above. By default this menu is set to "Pattern Values"
indicating that changes in the blocks colors reflect changes in the
actual values of the patterns. More complicated patterns which behave in
specialized ways can be created by changing the the "Pat Block" menu to
one of the other selections and editing a pattern's flags
(@pxref{env-event}.) When editing pattern values a color value greater
than zero sets the flag on, and a colorvalue less than or equal to zero
sets the flag off. The user may also choose to edit the global
PatternSpec flags from this menu. In this case the global flags on the
displayed pattern's PatternSpec will be displayed and changed when the
"Apply" button is pressed. Note that if multiple Events are being edited
and more than one of those Events shares the same EventSpec then the
last selected Event's values will be applied when the "Apply" button is
pressed.

The EnviroView provides the following variables for customizing the
display:
@table @code
@item EventLayout event_layout
@vindex event_layout of EnviroView
Controls whether events are arranged @code{VERTICALLY} or
@code{HORIZONTALLY} when multiple events are selected for viewing.
@item bool auto_scale
@vindex auto_scale of EnviroView
Controls whether or not the ColorBar at the bottom off the
EnviroView is automatically scaled to reflect the minimum and maximum
pattern values of the Events currently displayed in the EnviroView.
@item ValDispMode val_disp_mode
@vindex val_disp_mode of EnviroView
Controls how the values of the Patterns are displayed in
the blocks. The @code{COLOR} setting fills the blocks with the colors
from the colorbar, while the @code{AREA}, and @code{LINEAR} settings draw
size varying spirals in the blocks. The spirals are similar to
the spirals available for viewing in the NetView and a described in more
detail in that section. (@pxref{net-view}).
@item ColorScale* colorspec
The colorscale to use for the ColorBar at the bottom of the
EnviroView (@pxref{gui-colors}).
@item ValTextMode val_text
Can be @code{VALUES} or @code{LABELS} or @code{BOTH} (same as @i{Val
Txt} menu) -- controls whether or not the names stored in PatternSpecs'
@code{value_names} array are displayed on top of the blocks (LABELS),
and/or the numerical value of the pattern is displayed (VALUES).
@item bool no_border
@vindex no_border of EnviroView
If selected, this eliminates the black border around the pattern
values.  This is useful for displaying picture-like stimuli.
@item FontSpec view_font
@vindex view_font of EnviroView
The X11 specification for the font to use in drawing all of the basic
text in the view.
@item FontSpec value_font
@vindex value_font of EnviroView
The X11 specification for the font to use in drawing the
pattern labels and values in the View Region (might want it smaller).
@end table

In addition, the EnviroView provides the following functions:
@table @code
@item SelectEvents(int start=0, int n_events=-1)
@findex SelectEvents on EnviroView
This will automatically select a range of events for display in the view
-- saves on clicking.  start is the index of the event to start
displaying, and n_events is the number to display (-1 = all).
@item DeselectEvents(int start=0, int n_events=-1)
@findex DeselectEvents on EnviroView
This is the de-selecting complement to SelectEvents.
@item SetEventSpec(EventSpec* es)
@findex SetEventSpec on EnviroView
Changes the EventSpec of all the currently displayed Events to @code{es}
@item ChangeEventType(TypeDef* new_type)
@findex ChangeEventType on EnviroView
Change event types for selected events
@item ChangeEventGpType(TypeDef* new_type)
@findex ChangeEventGpType on EnviroView
Change event group types for selected event groups
@item DuplicateEvents()
@findex DuplicateEvents on EnviroView
Duplicate selected events
@item DuplicateEventGps()
@findex DuplicateEventGps on EnviroView
Duplicate selected event groups
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node env-view-specs, , env-view-events, env-view
@section Edit Specs in the EnviroView

@ifset html
@ifhtml
<IMG SRC="pics/xor.enviroview.specs.gif" ALIGN="MIDDLE" ALT="The Environment Viewer -- Specs">
<P>
<B> Figure: </B> The Environment Viewer -- Specs
<P>
@end ifhtml
@end ifset
@iftex
@tex
\medskip
\global\advance\texfigno by 1
\input epsf
\epsfysize=3.0in
\centerline{\epsfbox{/usr/local/pdp++/manual/pics/xor.enviroview.specs.epsi}}
\noindent {\bf Figure: \number\texfigno} The Environment Viewer -- Specs
@end tex
@end iftex
@ifinfo
Figure of: <The Environment Viewer -- Specs> here
@end ifinfo

Non-obvious actions you can perform on objects in the EnviroView in this
mode are:
@table @b
@item Single-click with left-mouse-button (LMB) on EventSpec Button
Will select event spec for display in the view area to the right.
@item Single-click with right-mouse-button (RMB) on EventSpec Button
Will bring up the edit dialog for the EventSpec.
@item Shift-LMB or middle-mouse-button (MMB) on EventSpec Button
Extends the selection to include multiple event specs, and can remove an
event spec from the display if performed on an already-selected event
spec.
@item RMB on text in the view area
Will bring up an edit dialog for that text.
@end table

As in the "Edit Events" mode, the "Edit Specs" mode displays event specs
in a scroll box along the bottom left-hand side of the window.  It
differs in having a variety of different action buttons above that, and
in the way that the event specs and pattern specs are displayed.

When you click on an event spec, the event spec is displayed in
"skeleton" format in the viewer area.  By default, if there is only one
event spec, it is automatically selected.  The overall event spec is
represented by a box, within which there are one or more pattern specs,
represented by a grid of pattern elements.  At the lower-left of the
pattern spec is a display of four critical pieces of information about
how that pattern is to be presented to the network (type, to_layer,
layer_name, and layer_num, see @pxref{env-event} for details).  The
total number of values in a pattern is indicated by a grey square with
the "n_vals" label on it and a number indicating the number of values.
This can be moved to change the total number of values within the
constraints of the overall pattern geometry.

There are four mutually-exclusive tool selection buttons at the top of
the action area, which operate much like their counterparts in the
NetView:

@table @code
@item Select
@findex Select of EnviroView
Select mode makes clicking in the view area act to select items.  In
select mode, the entire event spec is selected upon the first click, and
then the patternspec under the mouse is selected on the next click, and
then any further sub-level of text is after that.   Some of the other
action buttons will update based on what is currently selected.
@item Move
@findex Move of EnviroView
Move mode enables moving of PatternSpecs within the event.  The patterns
will be directly selected upon first mouse click, so just click and
drag.  You can also determine the total number of values in an event
by moving the grey square that has the "n_vals" label on it, which
typically is located in the upper-right corner of each pattern spec.
You can also move the entire display by clicking on the background and
dragging it around.
@item ReShape
@findex ReShape of EnviroView
This allows you to reshape the geometry of the PatternSpecs.  Simply
click and drag to reshape the patternspec geometry.
@item ReScale
@findex ReScale of EnviroView
This only works on the background, and serves to rescale the size of the
entire display. 
@end table

Below that are four buttons that change character depending on what is
selected:

@table @code
@item New Spec, New Pattern, Set To Layer 
@findex New Spec, New Pattern, Set To Layer of EnviroView
If nothing is selected, New Spec will allow you to create a new Event
Spec (if one is selected, use Dupe Spec to get a new one).  If an
EventSpec is selected, New Pattern will allow you to create a new
PatternSpec within that EventSpec.  If a PatternSpec is selected, Set To
Layer will prompt you for the name of a network Layer, and will
configure the pattern to fit the geometry, etc of this layer (it will
ensure that this pattern fits that layer and will be send to that layer
when presented).  @b{Set To Layer is the easiest and safest way to
configure a pattern for a given network layer (see also Updt Fm
Events)!}.
@item Rmv Spec(s), Pat(s)
@findex Rmv Spec(s), Pat(s) of EnviroView
Will remove (delete) selected EventSpecs or PatternSpecs.
@item New Child, Edit Names
@findex New Child, Edit Names of EnviroView
New Child makes a child spec of selected EventSpec -- a child spec
inherits all the properties of the parent, except those checked as
being unique.  The only way to mark features as unique is to edit the
pattern spec.  Edit Names of a selected Pattern Spec will pull up an
editor for the @code{value_names} that label values with names.
@item Layout/Updt
@findex Layout/Updt of EnviroView
Pops up a dialog for selecting one of two actions: @b{Linear Layout}
will arrange patterns in a line with a single space between them --
useful for quickly arranging patterns that might be spread out.  @b{Updt
Fm Layers} will go through each pattern and perform Set To Layer on that
pattern, based on the current layer that each pattern is associated
with.  This is a quick way to update the environment to any changes you
have made to your network.
@item Copy Fm Spec
@findex Copy Fm Spec of EnviroView
Allows you to copy parameters from another event spec to selected one.
@item Dupe Spec
@findex Dupe Spec of EnviroView
Duplicates currently selected event spec.
@item Edit Spec(s), Pat(s)
@findex Edit Spec(s), Pat(s) of EnviroView
Will bring up an edit dialog for selected objects (note: can also use RMB).
@item Init
@findex Init of EnviroView
Rebuilds the display -- should not generally be necessary but use if you
suspect display is not up-to-date.
@end table

So, a typical session starting from scratch would be to do New Spec,
then click on each pattern spec in turn and do Set To Layer and select
the layer these patterns will go to.  Then, the patterns may have to be
moved around a bit, or new patterns created if there are more than two
that receive environmental input (or one removed, etc).  In general,
everything should be managable within the interface.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node env-import, env-gen, env-view, env
@section Importing Environments from Text Files
@cindex Patterns, Importing/Exporting
@cindex Importing Patterns
@cindex Exporting Patterns

To aid in the conversion of environments from the old PDP software to
the format used in PDP++ (@file{.pat} files), and for generally
importing training and testing data represented in plain text files, we
have provided functions on the Environment that read and write text
files.  These functions are called @code{ReadText} and @code{WriteText}.

There is also a @b{FromFileEnv} that reads event patterns from files
incrementally during processing (@pxref{env-other}).

The format that these functions read and write is very simple,
consisting of a sequence of numbers, with an (optional) event name at
the beginning or end of the line.  Note, you must specify using the fmt
parameter whether there will be a name associated with the events or
not.  @b{Important: the name must be a contiguous string, without any
whitespace -- it can however be a number or have any other ASCII
characters in it.}  When reading in a file, ReadText simply reads in
numbers sequentially for each pattern in each event, so the layout of
the numbers is not critical.  If the optional name is to be used, it
must appear at the beginning of the line that starts a new event.

For example, in the old PDP software, the "xor.pat" file for the XOR
example looks like this:

@example
p00 0 0 0
p01 0 1 1
p10 1 0 1
p11 1 1 0
@end example 

It is critical that the @b{EventSpec} and its constitutent
@b{PatternSpecs} (@pxref{env-event}) are configured in advance for the
correct number of values in the pattern file.  The event spec for the
above example would contain two PatternSpecs.  The PatternSpecs would
look like:
@example
PatternSpec[0] @{
   type = INPUT;
   to_layer = FIRST;
   n_vals = 2;
@};

PatternSpec[0] @{
   type = TARGET;
   to_layer = LAST;
   n_vals = 1;
@};
@end example

So that the first two values (n_vals = 2) will be read into the first
(input) pattern, and the third value (n_vals = 1) will be read into the
last (output) pattern.

The @code{ReadText} function also allows comments in the .pat
files, as it skips over lines beginning with @t{#} or @t{//}.  Further,
@code{ReadText} allows input to be split on different lines, since it
will read numbers until it gets the right number for each pattern.

There is a special comment you can use to control the creation and
organization of subgroups of events.  To start a new subgroup, put the
comment @code{# startgroup} before the pattern lines for the events in
your subgroup (note that the @code{# endgroup} comments from earlier
versions are no longer neccessary, as they are redundant with the
startgroup comments -- they will be ignored).  For example, if you
wanted 2 groups of 3 events you might have a file that looked like this:

@example
# startgroup
p01 0 0 0
p02 0 1 1
p03 0 1 0
# startgroup
p11 1 0 1
p12 1 1 0
p13 1 1 1
@end example 


@cindex Environments, Converting

@code{WriteText} simply produces a file in the above format for all of
the events in the environment on which it is called.  This can be useful
for exporting to other programs, or for converting patterns into a
different type of environment, one which cannot be used with the CopyTo
or CopyFrom commands.  For example if events were created originally in
a TimeEnv environment, but you now want to use them in a FreqEnv
frequency environment, then you can use WriteText to save the 
events to a file, and then use ReadText to read them into a
@code{FreqEnv} which will enable a frequency to be attached to them.

For Environments that are more complicated than a simple list of events,
it is possible to use CSS to import text files of these events.  Example
code for reading events structured into subgroups is included in the
distribution as @file{css/include/read_event_gps.css}, and can be used
as a starting point for reading various kinds of different formats.  The
key function which makes writing these kinds of functions in CSS easy is
@code{ReadLine}, which reads one line of data from a file and puts it
into an array of strings, which can then be manipulated, converted into
numbers, etc.  This is much like the @file{awk} utility.

The @code{read_event_gps.css} example assumes that it will be read into
a @code{Script} object in a project, with three @code{s_args} values that
control the parameters of the expected format.  Note that these
parameters could instead be put in the top of the data file, and read in
from there at the start.

The binary read/write functions (@code{ReadBinary},
@code{WriteBinary}) simply read and write a stream of floating point
numbers in native binary format.  These files are not necessarily
portable, but are much more compact for large data sets.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  env-gen, env-analyze, env-import, env
@section Environment Generation Functions
@cindex Environment, Generation

The following functions are available on the @b{Environment} object (in
the @i{Generate} menu) for algorithmically creating events.  See
@file{demo/bp_misc/gen_rnd_prototypes.css} for a CSS script that creates
prototypes and random exemplars based on these prototypes using some of
the following functions.

@table @code
@item ReplicateEvents(int n_replicas, bool make_groups)
@findex ReplicateEvents on Environment
This will create n_replicas of all of the existing events in the
environment.  If make_groups is set, then all events which are replicas
of a given one will be placed into the same sub-group.   Otherwise, the
replicas appear right after the event they are replicas of.  This can
be used to replicate a set of prototype events, and noise can be added
(AddNoise, FlipBits) to create random distortions of these prototypes.
@item PermutedBinary(int pat_no, int n_on)
@findex PermutedBinary on Environment
This produces random (permuted) binary patterns of 1's and 0's over the
existing events in the environment.  @code{pat_no} determines which
pattern to use, and @code{n_on} specifies the number of 1's in each
random pattern.
@item PermutedBinary_MinDist(int pat_no, int n_on, float dist, bool max_correl)
@findex PermutedBinary_MinDist on Environment
This is like PermutedBinary, but it ensures that the hamming distance
between any two patterns is at least @code{dist} (i.e., all patterns are
separated by at least this minimum distance).  If max_correl is set,
this ensures that the maximum correlation between patterns is below the
@code{dist} value.
@item FlipBits(int pat_no, int n_off, int n_on)
@findex FlipBits on Environment
This switches exactly @code{n_off} values of a pattern from 1 to 0, and
@code{n_on} from 0 to 1.  In other words, some values that were 1 will
now be 0, and some values that were 0 will now be 1.  This is a useful
way of creating random distortions of prototypical patterns.
@item FlipBits_MinMax(int pat_no, int n_off, int n_on, float min_dist, float max_dist, metric, norm, tol)
@findex FlipBits_MinMax on Environment
This does FlipBits, but if the new event that was just flipped is
outside the distance limits set by min_ and max_dist, according to the
metric supplied, then another pattern is tried.  There is a timeout and
an error message will be reported if it takes too many retries to fit
these criteria.
@item Clear(int pat_no)
@findex Clear on Environment
Simply clears out the pattern values to a specified value (e.g., zero).
@item AddNoise(int pat_no, Random rnd_spec)
@findex AddNoise on Environment
This will add noise of the given specification to all events in pattern
@code{pat_no}.
@item TransformPats(int pat_no, PreProcessVals trans)
@findex TransformPats on Environment
This will apply given transformation (simple math) operation to all
events in pattern @code{pat_no}.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  env-analyze, env-freq, env-gen, env
@section Environment Analysis Functions
@cindex Environment, Analysis

The following functions are available on the @b{Environment} object
(in the @i{Analyze} menu) for analyzing the patterns in the
environment.  Some of these functions can also be called from the
@b{Log} objects in their own @i{Analyze} menu
(@pxref{log-views-logview}), and by the @b{DispDataEnvProc} process
that automatically analyzes data collected in an environment from a
statistic (@pxref{proc-special-misc}).

@table @code
@item DistMatrix(ostream& strm, int pat_no, metric, norm, tol, format, precision)
@findex DistMatrix on Environment
This produces a distance matrix between all events for given pattern to
a file specified by strm.  The metric and associated parameters
determine how distance is computed.  Norm is whether to normalize entire
distance, and tol is a unit-wise tolerance, below which dist = 0.  The
output format can be varied according to the format and precision
parameters.
@item DistMatrixGrid(GridLog* disp_log, metric, norm, tol)
@findex DistMatrixGrid on Environment
This produces a distance matrix between all events for given pattern,
and sends it to the given GridLog for immediate display (if NULL, a new
GridLog is created).  
@item CmpDistMatrix(ostream& strm, int pat_no, Environment* cmp_env, int cmp_pat_no, metric, norm, tol, format)
@findex CmpDistMatrix on Environment
This produces a distance matrix between all events across two different
environments, for given pattern on each.
@item CmpDistMatrixGrid(ostream& strm, int pat_no, Environment* cmp_env, int cmp_pat_no, metric, norm, tol, format)
@findex CmpDistMatrixGrid on Environment
This produces a distance matrix between all events across two different
environments, for given pattern on each, and displays the results in a
grid log.
@item ClusterPlot(GraphLog* disp_log, int pat_no, metric, norm, tol)
@findex ClusterPlot on Environment
This produces a cluster plot of the distance matrix between all events
for given pattern, and sends it to the given GraphLog for immediate
display.  The clusterplot recursively groups the most similar items
together, and uses the average of the individual cluster element
distances to compute the distance to a cluster, instead of computing
an average vector for a cluster and using that to compute distances.
This makes the algorithm somewhat more computationally intensive, but
also produces nicer results (the distance metric is cached so
distances are only computed once, so it should handle relatively large
numbers of events).
@item CorrelMatrixGrid(GridLog* disp_log, int pat_no)
@findex CorrelMatrixGrid on Environment
Generates a correlation matrix for all patterns in @code{pat_no} in
the environment and plots the result in grid log (NULL = new log).
The correlation matrix is defined by taking a vector of each pattern
value (e.g., the first element in the pattern) across all events, and
computing the correlation of this vector of values with those of all
the other such value vectors.  As such, it measures the degree to
which the variation of one pattern value (across events) correlates
with the variation of another pattern value (across events).
@item PCAEigenGrid(GridLog* disp_log, int pat_no, bool print_eigen_vals)
@findex PCAEigenGrid on Environment
Performs principal components analysis (PCA) of the correlations of
patterns in @code{pat_no} across events, plotting all eigenvectors in the
grid log (NULL = new log).  The eigenvectors are the orthogonal
components of the correlations ordered in terms of how much
variability they account for.  The first principal component
(eigenvector) accounts for the greatest amount of variability in the
correlation matrix, etc.  Note that the eigenvectors are arranged from
left-to-right, bottom-to-top, such that the first component is at the
bottom-left.
@item PCAPrjnPlot(GraphLog* disp_log, int pat_no, int x_axis_component, int y_axis_component, bool print_eigen_vals)
@findex PCAPrjnPlot on Environment
Performs principal components analysis of the correlations of patterns
in @code{pat_no} across events, and then plots projections of all the
patterns onto two of the principal components in the graph log (NULL =
new log).  This provides a means of representing the similarities of
the different patterns with each other in a two-dimensional space.
The X-axis of the graph represents how similar the patterns are along
the first selected component, and the Y-axis represents how similar
they are along the second selected component.
@item MDSPrjnPlot(GraphLog* disp_log, int pat_no, int x_axis_component, int y_axis_component, metric, norm, tol, bool print_eigen_vals)
@findex MDSPrjnPlot on Environment
Performs multidimensional scaling (MDS) on the distance matrix
(computed according to metric, norm, tol parameters) of patterns in
pat_no across events in the graph log (NULL = new log).
Multidimensional scaling takes a set of dissimilarities and returns a
set of points such that the distances between the points are
approximately equal to the dissimilarities.  The results of this are
typically very similar to PCA, even though the method is somewhat
different, operating on the distance matrix instead of the correlation
matrix.  The classical (metric) form of MDS is used, computed
according to the algorithm developed by Torgerson, W. S. (1958).
@i{Theory and Methods of Scaling}. New York: Wiley, as extracted from
the @file{cmdscale.R} function from the @b{R} statistical program.
@item EventPrjnPlot(Event* x_axis_event, Event* y_axis_event, int pat_no, GraphLog* disp_log, metric, norm, tol)
@findex EventPrjnPlot on Environment
Projects all events according to their smiliarity to the two specified
events using given distance metrics.  This allows one to obtain a 2-d
plot of the similarity of all events to two selected events.
@item EnvToGrid(GridLog* disp_log, int pat_no, ev_x, y, pt_x, y)
@findex EnvToGrid on Environment
This dumps the entire set of events worth of a given pattern into a grid
log for more efficient viewing and for more control over the display
layout.  The ev_x, ev_y parameters control the geometry of the events,
and the pt_x, pt_y control the geometry of the pattern values within
each event.
@item PatFreqText(float act_thresh, bool proportion, ostream& strm)
@findex PatFreqText on Environment
Reports frequency (proportion) of pattern values greater than
act_thresh across events, to a text output (this is most useful if
pattern values are named in value_names).  This can be useful for
verifying that an environment has expected probabilities of different
inputs. 
@item PatFreqGrid(GridLog* disp_log, float act_thresh, bool proportion)
@findex PatFreqGrid on Environment
Reports frequency (proportion) of pattern values greater than
act_thresh across events, to a grid log (if NULL, new log is made).
@item PatAggText(Aggregate& agg, ostream& strm)
@findex PatAggText on Environment
Reports aggregate (SUM, AVG, etc) of pattern values across events, to
a text output (this is most useful if pattern values are named in
value_names).  This can be useful for identifying the overall
properties of events.
@item PatAggGrid(GridLog* disp_log, float act_thresh, bool proportion)
@findex PatAggGrid on Environment
Reports aggregate (SUM, AVG, etc) of pattern values across events, to
a grid log (NULL = make a new log).  This can be useful for
identifying the overall properties of events.
@item EventFreqText(bool proportion, ostream& strm)
@findex EventFreqText on Environment
Reports frequency (proportion) of event names in the environment.
Also useful for validating that the environment contains what you
think it should.
@end table


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  env-freq, env-other, env-analyze, env
@section Frequency Environments and Events
@cindex Frequency, of Events
@cindex Events, Frequency of
@tindex FreqEvent_MGroup
@tindex FreqEvent
@tindex FreqEnv

In the basic model of the environment, all events are equally likely to
be presented to the network.  However, this is often not the case in the
real world.  Thus, PDP++ provides a set of environmental types that
implement frequency-based presentation of events.  These are the
@b{FreqEvent}, the @b{FreqEvent_MGroup}, and the @b{FreqEnv} types.  As
discussed above (@pxref{env-seq}, @ref{env-env}), processes can ask the
Environment for a single Event or a Group of Events. The FreqEvent is an
individual event with its own frequency, and the FreqEvent_MGroup is a
group of events with an associated frequency.

@vindex frequency of FreqEvent
@vindex frequency of Freq_MGroup
The frequency model supported by these types has a number between zero
and 1 associated with each event or event group.  This @code{frequency}
value is essentially a probability with which the event should be
presented.  

@vindex sample_type of FreqEnv
A @b{FreqEnv} environment type must be used in order for the frequency
variable associated with events or groups to be used.  This type of
environment uses the @code{InitEvents} function to create the list of
events or groups that will be presented for the current epoch.  There
are two modes of selecting these events according to their frequency.
Setting @code{sample_type} to @code{RANDOM} results in a random sample
of events to be presented for each epoch, with the probability of an
event's inclusion proportional to its frequency value.  The
@code{PERMUTED} option instead adds a fixed number of a given event
which is equal to the frequency of that event times the @code{n_sample}
parameter.

The @b{FreqEnv} class also has the following variables which affect this
sampling process:

@table @code
@item int n_sample;
@vindex n_sample of FreqEnv
The number of samples of the Events or EventGroups to make per epoch.
In the @code{RANDOM} case, this is the number of times to "roll the
dice" to determine if a given event gets into the epoch.  An event or
group with a frequency of 1 will appear exactly @code{n_sample} times in
a given epoch.  Events with lower frequency will occur less often and
with lower probability.  In the @code{PERMUTED} case, this number is
multiplied times the frequency to determine how many copies of an event
or group appear in a given epoch.
@item FreqLevel freq_level
@vindex freq_level of FreqEnv
Has the values @code{NO_FREQ}, @code{EVENT}, or @code{GROUP}. It
controls the level at which the frequency sampling occurs.  If
@code{NO_FREQ} is selected, frequency is ignored and the environment is
just like the basic one. The other two options should be selected
depending on the type of process that is being used--use @code{GROUP}
for sequence-based processes (@pxref{env-seq}), and otherwise use
@code{EVENT}.
@end table

Note that there is also a @b{FreqTimeEvent}, @b{FreqTimeEvent_MGroup},
and @b{FreqTimeEnv}, which are frequency versions of the time-based
environments described below.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  env-other,  , env-freq, env
@section Other Environment Types

There are a couple of other types of environments that embelish the
basic model described above.  Two of these are particularly appropriate
for specific algorithms, and are therefore described in the context of
these algorithms.  Thus, for information on the environment types that
associate a particular time with each event (@b{TimeEnvironment},
@b{TimeEvent_MGroup}, and @b{TimeEvent}), see the recurrent
backpropagation part of the manual: @ref{rbp-seq}.  However, note that
the @b{CsSettle} process (@pxref{cs-proc}) will use the @code{time}
value for determining how long to settle, which is different from the
way this variable is used in RBp.  For information about the environment
types that allow individual patterns within an event to be chosen
probabilistically (@b{ProbEventSpec}, @b{ProbPatternSpec_Group},
@b{PropPattern}), see the constraint satisfaction part of the manual:
@ref{cs-prob-env}.

@tindex XYPattern
The @b{XYPattern} and @b{XYPatternSpec} provide a mechanism for applying
patterns that move around on a larger input layer.  The offset of a
pattern is specified by the @code{offset} member of the pattern, which
can be updated (e.g., by a script) to move the pattern around on
subsequent pattern presentations.  The pattern spec provides options to
determine the way in which the pattern is applied to a network layer:

@tindex XYPatternSpec
@table @code
@item bool wrap
@vindex wrap of XYPatternSpec
This controls whether to wrap the pattern around the network layer if it
should extend beyond the maximum coordinate for the layer in either the
x or y dimension.  The alternative is that it is "clipped" at the
maximum, and that portion of the pattern is simply not presented.
@item bool apply_background
@vindex apply_background of XYPatternSpec
The portions of the network layer which do not receive input from the
pattern can optionally be set to a particular "background" level, by
setting this flag.
@item float background_value
@vindex background_value of XYPatternSpec
This is the value to set the background units to, if applicable.
@end table

@tindex ScriptEnv
The @b{ScriptEnv} is an environment with a script associated with it.
The script is called at the beginning of the epoch, when the
@b{EpochProcess} calls the @code{InitEvents} function on the
environment.  The @b{ScriptEnv} defines this function to run its
script, which can contain code to build an entire epoch's worth of
events dynamically (i.e., as the epoch is starting).  This is useful
for environments which have a probabalistic character which is more
complicated than simple frequency sampling.  An example of a
@b{ScriptEnv} is provided in the demo of a simple recurrent network,
which learns to perform like a finite state automaton.  The training
events are generated probabalistically at run-time using a
@b{ScriptEnv} from a script version of the automaton.  This demo can
be found in the @file{demo/bp_srn} directory.

@vindex s_args on ScriptEnv
Note that the @b{ScriptEnv}, like other script-based objects, provides
an array of script args called @code{s_args} that can be used to control
the behavior of the script and customize it for particular cases.  The
meaning of these arguments depends of course on the script that is being
used, but they should be documented near the top of the script code.

@cindex Interactive Environments
@cindex Environments, Interactive
@tindex InteractiveScriptEnv
The @b{InteractiveScriptEnv} is a script environment that works with
the interactive model of event construction (See
@ref{env-env} and @ref{proc-special-inter}).  The script is called
when the @b{InteractiveEpoch} calls @code{GetNextEvent} on the
environment, at the start of each trial.  At this point, the script
should generate a new event (based on the network's output to the
prior event, for example), and set the @code{next_event} pointer to
point to this event.  If the epoch is over, then next_event should be
set to NULL.  The script can examine the @code{event_ctr} variable on
the environment to determine where it is within the epoch -- this
value is reset to 0 at the start of the epoch.

For a working example of this technology, see
@file{demo/leabra/nav.proj.gz} and its associated @file{nav_env.css}
script which is attached to an InteractiveScriptEnv.

@cindex Patterns, from a file
@cindex Events, from a file
@cindex File, reading events from
@tindex FromFileEnv
The @b{FromFileEnv} environment reads events one epoch of
@code{events_per_epc} events (@code{read_mode = ONE_EPOCH}) or one
single event (@code{ONE_EVENT}) at a time from a file (either text or
binary format) for presentation to the network.  This should be useful
for very large environments or very large patterns, or both.  Note
that events_per_epc events will be loaded into RAM at a time from the
file, so this number should not be set too large relative to available
memory, etc.  Reading one event at a time (ONE_EVENT -- only one event
in RAM at any time) uses the ``interactive'' interface to the
environment (GetNextEvent) meaning that the @b{InteractiveEpoch} epoch
process (@pxref{proc-special-inter}) must be used.

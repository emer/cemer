// ta_Dump File v2.0
LeabraProject .projects[1] { 
  Doc_Group @.docs = [7] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
    taDoc @[3] { };
    taDoc @[4] { };
    taDoc @[5] { };
    taDoc @[6] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { };
    taDataAnal @[1] { };
    taDataGen @[2] { };
    taImageProc @[3] { };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { };
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [1] {
	    T3DataViewFrame @[0] { };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { };
      };
    };
  };
};
LeabraProject .projects[1] {
 name="Project_0";
 desc=;
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   auto_open=1;
   text="<html>
<head></head>
<body>

= Building a Complete Model =

This project provides step-by-step directions for constructing a working neural network simulation from the ground up, including programming a simple psychological task (target detection), which we extend through several stages to ultimately simulate the more complex CPT-AX task used in working memory studies.

 '''To return to this document''' at any time, just hit the <code>ProjectDocs</code> tab at the top of this middle panel where you are now reading.

Some basic terminology:
* '''Left browser panel''' is the left portion of the window with a \"tree\" of objects in the simulation (inlcuding the netowrk, and the input/output data, etc).
* '''Middle edit panel''' is where you are currently reading -- it can display different things depending on the selected tabs at the top, and what is currently selected in the left browser panel.  The left-most tab usually shows what is selected in the browser, and the other tabs with \"pins\" down are locked in place and contain this document and the Wizard, which we will be making heavy use of.  The right-most tab represents the configuration information for the 3D display shown in the right-most view panel (which is now called \"Frame1\" and is empty).
* '''Right view panel''' shows 3d displays of various simulation objects, incuding the network, input/output patterns, and graphs of results, etc.

== Basic Task: Target Detection ==

The basic task we'll simulate involves presenting letters one at at a time to the network, and having it identify \"targets\" from \"non-targets\".  The targets are the letters 'A' and 'X', and the non-targets are 'B', 'C', 'Y', and 'Z'.

The network will have 6 input units representing each of these letters, and two output units, one for \"target\" and the other for \"non-target\".  It will have a hidden layer to learn the mapping (though this task is initially so trivial that it doesn't even require a hidden layer -- we'll make it harder later).

== Chapters ==

Here are the steps we'll go through, organized as separate document chapters (which live under the <code>docs</code> section of the browser, as does this document):
# [[.docs.BuildNet]] -- building the network
# [[.docs.InputData]] -- make basic input patterns (data) to present to the network
# [[.docs.Programs]] -- creating and controlling the programs that perform the simulation
# [[.docs.OuptutData]] -- monitoring and analyzing the peformance of the model<br>
# [[.docs.TaskProgram]] -- writing a program to construct the task input patterns, including more complex tasks.
# [[.docs.PfcBg]] -- adding a prefrontal cortex/basal ganglia to the model to handle the full CPT-AX task.

</body>
</html>
";
  };
  taDoc @[1] {
   name="BuildNet";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Building a Network =

The Wizard makes it easy to get started making a network.  It is located in the <code>wizards</code> section of the browser, and can always be found in the <code>LeabraWizard_0</code> tab at the top of this middle panel.  This link: [[.PanelTab.LeabraWizard_0]] will take you there (return to these docs by pressing the BuildNet tab).

You will see that it is currently configured for 3 layers, which is fine for our purposes.  But how do we tell it how big to make these layers?  The wizard has some layer configuration information tucked inside of it -- to access it, you need to open up the wizard object in the browser (as is true of most things in this simulator).  This link: [[.wizards.LeabraWizard_0.layer_cfg.Input]] will take you directly to the configuration information for the Input layer.  You can see the browser expanding to reveal the other layer configuration information as well.

Enter 6 for <code>n_units</code> in the Input layer.  Then select the Hidden layer and enter 16 units, and 2 for the Output layer.  Note that the system automatically applies changes when you move from one selection to the next.

Next, return to the [[.PanelTab.LeabraWizard_0]] tab, and at the bottom, click the <code>Network</code> 
menu button, and choose the <code>Std Network</code> option.  This pops up a confirmation dialog explaining that it will create a new network according to your current specifications.  Hit OK.

You will see a network appear in the right view panel, and the left browser will expand to reveal all of the objects created (e.g., layers and specifications).  Feel free to click around on these objects now to see what they have in them -- we will just use the defaults so there is no need to change anything.

Now we'll move on to making the [[.docs.InputData]] for the simple target detection task.  Here are a few optional topics that you can explore if you wish:

== Manipulating the 3d View ==

== Configuring the Network View ==

== Changing the Network Configuration ==

</body>
</html>
";
  };
  taDoc @[2] {
   name="InputData";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Input Data  (Pattenrs to Present to the Network) =

(Note -- to return to this document, click on docs/InputData in the left browser window).

We return to the [[.PanelTab.LeabraWizard_0]] wizard tab, and move across to the next menu button on the bottom labeled <code>Data</code>, and select the <code>Std Data</code> option.  This will bring up a dialog with mostly default information already filled in (and not modifyiable because there are no other options), but there is one parameter we need to specify: <code>n_patterns</code>.  Enter 6 -- one for each of the different input letters.

This will construct a \"data table\" object (much like a spreadsheet or simple data base) that has columns automatically corresponding to the Input and Output layers of the network, with 6 rows where we can specify the different input patterns to the network, which define our simple target detection task.  The Name column is useful for labeling our patterns.  you'll see <code>(matrix)</code> in the Input and Output columns, and if you click on one of those, an extra editor shows up at the bottom of the window to allow you to enter values for the \"matrix\" of input and output units.  The Name column, in contrast, has just a single value for each row (i.e., a \"scalar\"), so it can be edited directly in the main table view.

Here is what you should enter, where we're calling the 1st output unit the \"non-target\" and the 2nd one the target, and the Input units are ordered bottom-to-top, left-to-right:
<table>
<tr><th>Name</th> <th>Input</th> <th>Output</th></tr>
<tr><td>A</td><td>000<br>100</td><td>01</td></tr>
<tr><td>B</td><td>000<br>010</td><td>10</td></tr>
<tr><td>C</td><td>000<br>001</td><td>10</td></tr>
<tr><td>X</td><td>100<br>000</td><td>01</td></tr>
<tr><td>Y</td><td>010<br>000</td><td>10</td></tr>
<tr><td>Z</td><td>001<br>000</td><td>10</td></tr>
</table>

== Visualizing the Data Patterns ==

The best way to make sure you've entered the right patterns is to create a \"Grid View\" of your input data -- do this by selecting the <code>View/New Grid View</code> option from the menu at the top of the data table editor that you've been using to enter input patterns with.  This link will do this for you if you can't seem to find it: [[.data.gp.InputData.StdInputData.NewGridView()]].  Go ahead and keep the \"New Frame\" default for the dialog that pops up (you can also add multiple view elements together in a single 'frame' in the 3d view -- we'll do that later).

This will create a [[.T3Tab.StdInputData]] tab in the right view panel, and display your input patterns, which hopefully match those shown in the above table.  If not, you can correct them by clicking back on StdInputData in the left browser -- you cannot edit values in the grid view display.

The next step is to create [[.docs.Programs]] to control the presentation of these input patterns to the network.

</body>
</html>
";
  };
  taDoc @[3] {
   name="Programs";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Programs for Controlling the Simulation =

Again return to the [[.PanelTab.LeabraWizard_0]] wizard panel, and now select <code>Programs/Std Programs</code> from the bottom menu.  (return to these docs by clicking back on <code>docs/Programs</code> in the browser).

This created a set of standard programs that organize the presentation of input patterns to the network into a hierarchy of time scales:

* LeabraBatch -- iterates over multiple simulated \"subjects\" -- each having their own different random initial weights (we won't use this initially).
* LeabraTrain -- a complete training of the network from random initial weights to final correct performance, by iterating over multiple \"epochs\"
* LeabraEpoch -- one full pass through all of the different task input patterns
* LeabraTrial -- processes one input pattern, using two ''phases'' of settling -- the minus phase presents the input stimulus, and allows the network to come up with its own best guess as to the correct response, and the plus phase presents the correct answer to allow the network to learn to perform the task correctly.
* LeabraSettle -- multiple updates of neural unit activations to process a given input/output pattern.
* LeabraCycle -- a single cycle of updating of neural unit activation states (roughly 5-10msec of simulated real time)

There are also some other supporting programs that we'll discuss later.

== Running the Simulation ==

First, make sure you're viewing the [[.T3Tab.Network_0]] network view tab, and then click on the 
 [[.programs.gp.LeabraAll_Std.LeabraTrain]] program.  Press the 
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] button at the bottom of the window, followed by 
the [[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] button (these links will actually do this for you!).

You should then see the network processing each of the input patterns for the task multiple times, as it iterates over epochs of trials of settles of cycles of processing.  Depending on your hardware, this may wiz by in quite a blur.

Once it finishes, you can see more clearly what it is doing by hitting the [[.programs.gp.LeabraAll_Std.LeabraTrain.Step()|Step]] button, 
which will perform one phase of settling at a time.  You should observe that the network gets the correct output unit active in the minus phase (look for <code>MINUS_PHASE</code> or <code>PLUS_PHASE</code> in the text region at the bottom of the network 3d view display.  It has successfully learned the task!

The next step is more clearly monitor the performance of the network as it learns, by recording 
[[.docs.OutputData]] from the network.



</body>
</html>
";
  };
  taDoc @[4] {
   name="OutputData";
   auto_open=0;
   text="<html>
<head></head>
<body>
= Monitoring, Analysing, and Displaying Output Data =

* Graph epoch data
* record input/output patterns
* etc.

</body>
</html>
";
  };
  taDoc @[5] {
   name="TaskProgram";
   auto_open=0;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
  };
  taDoc @[6] {
   name="PfcBg";
   auto_open=0;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   name="LeabraWizard_0";
   auto_open=1;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   name="data_base";
  };
  taDataAnal @[1] {
   name="data_anal";
  };
  taDataGen @[2] {
   name="data_gen";
  };
  taImageProc @[3] {
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  step_prog=NULL;
  tags=;
  desc=;
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   m_data=.projects[1]$0$;
   name="Browser";
   visible=1;
   m_is_root=0;
   m_is_proj_viewer=1;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     m_data=NULL;
     name="Application";
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     m_data=NULL;
     name="Tree";
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$0$;
    };
    PanelViewer @[1] {
     m_data=NULL;
     name="Panels";
     visible=1;
    };
    T3DataViewer @[2] {
     m_data=NULL;
     name="T3Frames";
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       m_data=NULL;
       name="Frame1";
       visible=1;
       root_view {
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	};
       };
       camera_pos {x=0: y=0: z=-1.517074: };
       camera_orient {x=0: y=0: z=1: rot=0: };
       camera_focdist=2.482926;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     m_data=NULL;
     name="Tools";
     visible=1;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 use_change_log=0;
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
 };
};

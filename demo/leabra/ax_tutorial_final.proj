// ta_Dump File v2.0
LeabraProject .projects[1] { 
  Doc_Group @.docs = [8] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
    taDoc @[3] { };
    taDoc @[4] { };
    taDoc @[5] { };
    taDoc @[6] { };
    taDoc @[7] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp[0] = [2] { 
      DataTable @[0] { 
    UserDataItem_List @*(.user_data_) { 
	  UserDataItem @[0] { };
    };

	DataTableCols @.data = [3] {
	  String_Data @[0] { };
	  float_Data @[1] { };
	  float_Data @[2] { };
	};
      };
      DataTable @[1] { 
    UserDataItem_List @*(.user_data_) { 
	  UserDataItem @[0] { };
	  UserDataItem @[1] { };
	  UserDataItem @[2] { };
    };

	DataTableCols @.data = [2] {
	  String_Data @[0] { };
	  String_Data @[1] { };
	};
      };
    };
    DataTable_Group @.gp[1] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [12] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  int_Data @[2] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  String_Data @[3] { };
	  String_Data @[4] { };
	  int_Data @[5] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  float_Data @[6] { };
	  float_Data @[7] { };
	  float_Data @[8] { };
	  float_Data @[9] { };
	  float_Data @[10] { };
	  float_Data @[11] { };
	};
      };
      DataTable @[1] { 
	DataTableCols @.data = [8] {
	  int_Data @[0] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  int_Data @[1] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { };
	  float_Data @[3] { };
	  float_Data @[4] { };
	  float_Data @[5] { };
	  float_Data @[6] { };
	  float_Data @[7] { };
	};
      };
    };
    DataTable_Group @.gp[2] = [2] { 
      DataTable @[0] { 
	DataTableCols @.data = [3] {
	  float_Data @[0] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
      };
};
	  float_Data @[1] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
	      UserDataItem @[1] { };
	      UserDataItem @[2] { };
      };
};
	  String_Data @[2] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	};
      };
      DataTable @[1] { 
    UserDataItem_List @*(.user_data_) { 
	  UserDataItem @[0] { };
    };

	DataTableCols @.data = [3] {
	  String_Data @[0] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  float_Data @[1] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	  float_Data @[2] { 
      UserDataItem_List @*(.user_data_) { 
	      UserDataItem @[0] { };
      };
};
	};
      };
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
  };

  Program_Group @.programs = [1] {
    Program @[0] { 
      ProgType_List @.types = [2] {
	DynEnumType @[0] { 
	  DynEnumItem_List @.enums = [6] {
	    DynEnumItem @[0] { };
	    DynEnumItem @[1] { };
	    DynEnumItem @[2] { };
	    DynEnumItem @[3] { };
	    DynEnumItem @[4] { };
	    DynEnumItem @[5] { };
	  };
	};
	DynEnumType @[1] { 
	  DynEnumItem_List @.enums = [2] {
	    DynEnumItem @[0] { };
	    DynEnumItem @[1] { };
	  };
	};
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      ProgEl_List @.init_code = [1] {
	InitNamedUnits @[0] { };
      };

      ProgEl_List @.prog_code = [2] {
	ResetDataRows @[0] { };
	ForLoop @[1] { 
	  ProgEl_List @.loop_code = [6] {
	    IfElse @[0] { 
	      ProgEl_List @.true_code = [1] {
		AssignExpr @[0] { };
	      };

	      ProgEl_List @.false_code = [1] {
		AssignExpr @[0] { };
	      };
	    };
	    PrintVar @[1] { };
	    AddNewDataRow @[2] { };
	    SetUnitsVar @[3] { };
	    DoneWritingDataRow @[4] { };
	    IfBreak @[5] { };
	  };
	};
      };
    };
    Program_Group @.gp[0] = [10] { 
      Program @[0] { 
	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @[1] { 
	ProgObjList @.objs = [1] {
	  RndSeed @[0] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @[0] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @[0] { };
	      DynEnumItem @[1] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	  ProgVar @[6] { };
	};

	ProgEl_List @.init_code = [5] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { };
	    };
	  };
	  IfGuiPrompt @[4] { 
	    ProgEl_List @.yes_code = [2] {
	      MethodCall @[0] { };
	      PrintExpr @[1] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [7] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [2] {
	      MethodCall @[0] { };
	      PrintExpr @[1] { };
	    };
	  };
	  AssignExpr @[4] { };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[6] { };
	};
      };
      Program @[2] { 
	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [5] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	};

	ProgEl_List @.init_code = [2] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	};

	ProgEl_List @.prog_code = [9] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { };
	  NetDataLoop @[4] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[1] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { };
		};
	      };
	    };
	  };
	  IfElse @[5] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { };
	    };
	  };
	  MethodCall @[6] { };
	  ProgramCall @[7] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[8] { };
	};
      };
      Program @[3] { 
	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [6] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { };
	    };
	  };
	  MethodCall @[3] { };
	  ProgramCall @[4] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[5] { };
	};
      };
      Program @[4] { 
	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { };
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { };
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @[5] { 
	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { };
	  NetUpdateView @[1] { };
	};
      };
      Program @[6] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @[0] { 
	    LayerDataEl_List @.layer_data = [3] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	    };
	  };
	};

	ProgVar_List @.args = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @[0] { };
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [1] {
	  MethodCall @[0] { };
	};
      };
      Program @[7] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [10] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	      NetMonItem @[8] { };
	      NetMonItem @[9] { };
	    };
	  };
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { };
	  MethodCall @[1] { };
	  MethodCall @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @[8] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @[0] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @[0] { };
	      NetMonItem @[1] { };
	      NetMonItem @[2] { };
	      NetMonItem @[3] { };
	      NetMonItem @[4] { };
	      NetMonItem @[5] { };
	      NetMonItem @[6] { };
	      NetMonItem @[7] { };
	    };
	  };
	};

	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { };
	  MethodCall @[1] { };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [3] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [3] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	    };
	  };
	  MethodCall @[5] { };
	};
      };
      Program @[9] { 
	ProgVar_List @.args = [1] {
	  ProgVar @[0] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @[0] { };
	  ProgVar @[1] { };
	  ProgVar @[2] { };
	  ProgVar @[3] { };
	  ProgVar @[4] { };
	  ProgVar @[5] { };
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { };
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [4] {
	    T3DataViewFrame @[0] { 
	      T3DataView_List @.children = [3] {
		NetView @[0] { 
		  ScaleRange_List @.scale_ranges = [1] {
		    ScaleRange @[0] { };
		  };
		};
		GraphTableView @[1] { 
		  T3DataView_List @.children = [8] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		    GraphColView @[3] { };
		    GraphColView @[4] { };
		    GraphColView @[5] { };
		    GraphColView @[6] { };
		    GraphColView @[7] { };
		  };
		};
		GridTableView @[2] { 
		  T3DataView_List @.children = [12] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		    GridColView @[3] { };
		    GridColView @[4] { };
		    GridColView @[5] { };
		    GridColView @[6] { };
		    GridColView @[7] { };
		    GridColView @[8] { };
		    GridColView @[9] { };
		    GridColView @[10] { };
		    GridColView @[11] { };
		  };
		};
	      };
	    };
	    T3DataViewFrame @[1] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [3] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		  };
		};
	      };
	    };
	    T3DataViewFrame @[2] { 
	      T3DataView_List @.children = [1] {
		GraphTableView @[0] { 
		  T3DataView_List @.children = [3] {
		    GraphColView @[0] { };
		    GraphColView @[1] { };
		    GraphColView @[2] { };
		  };
		};
	      };
	    };
	    T3DataViewFrame @[3] { 
	      T3DataView_List @.children = [2] {
		GridTableView @[0] { 
		  T3DataView_List @.children = [3] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		    GridColView @[2] { };
		  };
		};
		GridTableView @[1] { 
		  T3DataView_List @.children = [2] {
		    GridColView @[0] { };
		    GridColView @[1] { };
		  };
		};
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { };
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @[0] { 
      BaseSpec_Group @.specs = [4] {
	LeabraUnitSpec @[0] { };
	LeabraLayerSpec @[1] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraLayerSpec @[0] { };
	  };
	};
	FullPrjnSpec @[2] { };
	LeabraConSpec @[3] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraBiasSpec @[0] { };
	  };
	};
      };

      Layer_Group @.layers = [3] {
	LeabraLayer @[0] { 
	  Unit_Group @.units = [6] {
	  };
	};
	LeabraLayer @[1] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @[0] { };
	    LeabraPrjn @[1] { };
	  };

	  Unit_Group @.units = [16] {
	  };
	};
	LeabraLayer @[2] { 
	  Projection_Group @.projections = [1] {
	    LeabraPrjn @[0] { };
	  };

	  Unit_Group @.units = [2] {
	  };
	};
      };
    };
  };
};
LeabraProject .projects[1] {
 name="Project_0";
 desc=;
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   auto_open=1;
   text="<html>
<head></head>
<body>

= Building a Complete Model =

This project provides step-by-step directions for constructing a working neural network simulation from the ground up, including programming a simple psychological task (target detection), which we extend through several stages to ultimately simulate the more complex CPT-AX task used in working memory studies.

 '''To return to this document''' at any time, just hit the <code>ProjectDocs</code> tab at the top of this middle panel where you are now reading.

Some basic terminology:
* '''Left browser panel''' is the left portion of the window with a \"tree\" of objects in the simulation (inlcuding the netowrk, and the input/output data, etc).
* '''Middle edit panel''' is where you are currently reading -- it can display different things depending on the selected tabs at the top, and what is currently selected in the left browser panel.  The left-most tab usually shows what is selected in the browser, and the other tabs with \"pins\" down are locked in place and contain this document and the Wizard, which we will be making heavy use of.  The right-most tab represents the configuration information for the 3D display shown in the right-most view panel (which is now called \"Frame1\" and is empty).
* '''Right view panel''' shows 3d displays of various simulation objects, incuding the network, input/output patterns, and graphs of results, etc.

== Basic Task: Target Detection ==

The basic task we'll simulate involves presenting letters one at at a time to the network, and having it identify \"targets\" from \"non-targets\".  The targets are the letters 'A' and 'X', and the non-targets are 'B', 'C', 'Y', and 'Z'.

The network will have 6 input units representing each of these letters, and two output units, one for \"target\" and the other for \"non-target\".  It will have a hidden layer to learn the mapping (though this task is initially so trivial that it doesn't even require a hidden layer -- we'll make it harder later).

== Chapters ==

Here are the steps we'll go through, organized as separate document chapters (which live under the <code>docs</code> section of the browser, as does this document):
# [[.docs.BuildNet]] -- building the network
# [[.docs.InputData]] -- make basic input patterns (data) to present to the network
# [[.docs.Programs]] -- creating and controlling the programs that perform the simulation
# [[.docs.OutputData]] -- monitoring and analyzing the performance of the model
# [[.docs.TaskProgram]] -- writing a program to construct the task input patterns, including more complex tasks.
# Extras: elaborations that go all the way to the full CPT-AX task
## [[.docs.CPTAX_Program]] -- extend our basic program to the full CPT-AX task
## [[.docs.PfcBg]] -- adding a prefrontal cortex/basal ganglia to the model to handle the full CPT-AX task.

== If You Get Off Track.. ==

In the same directory where you loaded this project is a <code>ax_tutorial_final.proj</code> project file, which has the full project that will result from following these directions (not the extras).  You can load this project and refer to it to see what things are supposed to look like.


</body>
</html>
";
  };
  taDoc @[1] {
   name="BuildNet";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Building a Network =

The Wizard makes it easy to get started making a network.  It is located in the <code>wizards</code> section of the browser, and can always be found in the <code>LeabraWizard_0</code> tab at the top of this middle panel.  This link: [[.PanelTab.LeabraWizard_0]] will take you there (return to these docs by pressing the BuildNet tab).

You will see that it is currently configured for 3 layers, which is fine for our purposes.  But how do we tell it how big to make these layers?  The wizard has some layer configuration information tucked inside of it -- to access it, you need to open up the wizard object in the browser (as is true of most things in this simulator).  This link: [[.wizards.LeabraWizard_0.layer_cfg.Input]] will take you directly to the configuration information for the Input layer.  You can see the browser expanding to reveal the other layer configuration information as well.  Here are the layer sizes (<code>n_units</code>) you should enter:

* [[.wizards.LeabraWizard_0.layer_cfg.Input]] = 6
* [[.wizards.LeabraWizard_0.layer_cfg.Hidden]] = 16
* [[.wizards.LeabraWizard_0.layer_cfg.Output]] = 2

Note that the system automatically applies changes when you move from one selection to the next.

Next, return to the [[.PanelTab.LeabraWizard_0]] tab, and at the bottom, click the <code>Network</code> 
menu button, and choose the [[.wizards.LeabraWizard_0.StdNetwork()|Network/StdNetwork]] option.  This pops up a confirmation dialog explaining that it will create a new network according to your current specifications.  Hit OK.

You will see a network appear in the right view panel, and the left browser will expand to reveal all of the objects created (e.g., layers and specifications).  Feel free to click around on these objects now to see what they have in them -- we will just use the defaults so there is no need to change anything.

Now we'll move on to making the [[.docs.InputData]] for the simple target detection task.  Below are a few optional topics that you can explore if you wish (or come back to later at any time):

== Manipulating the 3d View ==

There are different modes and controls for the 3d view located on the extreme right-hand side of the window next to the network display.  Drag the mouse over them to see what they do (a \"tool tip\" should pop up when the mouse hovers over the button).

To begin, you can experiment with the \"hand\" tool -- if you click the mouse and move it around, you'll see that you can manipulate the \"camera view\" into the 3d view of the network.

Two key tips:
* <b>Hold down Shift to move instead of rotate</b> (while moving the mouse).
* <b>Pressing the \"home\" icon restores the initial view</b> (this is the first home one, not the blueprint guy -- the blueprint guy is for saving the current view state as the default view that the home button returns to.

At some point you'll discover that if you don't completely stop before lifting the mouse button, the view continues to rotate -- kind of mezmerizing -- apologies if you spend too much time doing this (we certainly have.. :)

If you have a scroll wheel, you'll see that it acts like a zoom.  The same effect can be had with the <b>Dolly</b> wheel (the term is an analogy to a camera dolly that moves a camera through a scene in filming a movie).

The <b>Rotx</b> and <b>Roty</b> wheels rotate precisely around the x and y axes -- these are often more useful than the mouse-based rotation because they don't introduce off-angles.

The <b>Flashlight</b> button is very useful for zooming in on something of interest (especially for large complicated displays) -- after clicking on it, then click on an object in the view (NOTE: text doesn't work for this purpose).  Thus button stays on until unclicked or another button is clicked, so you can do repeated exploration.

Finally, for extra thrills, you can click the right mouse button (or ctrl+mouse on a Mac) and configure many interesting display options -- check out the different still draw styles, and the stereo options -- dig out those old red/green stereo glasses!

== Configuring the Network View ==

The middle panel tab labeled [[.PanelTab.Network_0]] provides various parameters for controlling the network display.  There are 3 main segments
 (see the wiki [[.Wiki.Network_View]] page for more info):
* Display parameters at the top (font sizes, display style etc) (mouse over to get more info, and explore!)
* Network variable selector -- what value to display in the units in the network view (activations vs. weights vs. netinputs etc).  If you select one of the weight variables (e.g., r.wt for receiving weights into a selected unit; s.wt is for sending weights out), you then need to use the red arrow tool in the viewer to select a unit to view -- it will turn green, and you should be able to see its weights.
* Spec selector and viewer -- this is very handy for seeing where your specs are used in the network -- try clicking on the <code>HiddenLayer</code> and then <code>Input_Output</code> -- note that the green layer border changes color indicating which layers are using these layer specs.  You can also use the context menu to edit the specs right there.

== Changing the Network Configuration ==

You can also configure the network layout interactively in the viewer, including repositioning the layers, and orienting the network display relative to other objects in the view (which we postpone for later, when this arises).

To do this, select the <b>red arrow</b> tool, and you'll see that transparent purple arrow objects now appear on the layers, and a fancy box thing appears on the network text box.  These are the manipulation controls.  Try clicking on one of the horizontal arrows for the Output layer, and moving it around.  This moves within the \"horizontal\" plane (the X-Y plane for the network).  The vertical arrows not surprisingly move in the vertical dimension (the Z axis for the network).

</body>
</html>
";
  };
  taDoc @[2] {
   name="InputData";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Input Data  (Patterns to Present to the Network) =

(Note -- to return to this document, click on docs/InputData in the left browser window).

We return to the [[.PanelTab.LeabraWizard_0]] wizard tab, and move across to the next menu button on the
bottom labeled <code>Data</code>, and select the [[.wizards.LeabraWizard_0.StdData()|Data/StdData]] option.  This will bring up a dialog with mostly default information already filled in (and not modifyiable because there are no other options), but there is one parameter we need to specify: <code>n_patterns</code>.  Enter 6 -- one for each of the different input letters.

This will construct a \"data table\" object (much like a spreadsheet or simple data base) that has columns automatically corresponding to the Input and Output layers of the network, with 6 rows where we can specify the different input patterns to the network, which define our simple target detection task.  The Name column is useful for labeling our patterns.  you'll see <code>(matrix)</code> in the Input and Output columns, and if you click on one of those, an extra editor shows up at the bottom of the window to allow you to enter values for the \"matrix\" of input and output units.  The Name column, in contrast, has just a single value for each row (i.e., a \"scalar\"), so it can be edited directly in the main table view.

This data table object is called [[.data.gp.InputData.StdInputData]] and it lives in the <code>data/InputData subgroup</code> in the left browser, in case you need to get back to it.

Here is what you should enter, where we're calling the 1st output unit the \"non-target\" and the 2nd one the target, and the Input units are ordered bottom-to-top, left-to-right:
<table>
<tr><th>Name</th> <th>Input</th> <th>Output</th></tr>
<tr><td>A</td><td>000<br>100</td><td>01</td></tr>
<tr><td>B</td><td>000<br>010</td><td>10</td></tr>
<tr><td>C</td><td>000<br>001</td><td>10</td></tr>
<tr><td>X</td><td>100<br>000</td><td>01</td></tr>
<tr><td>Y</td><td>010<br>000</td><td>10</td></tr>
<tr><td>Z</td><td>001<br>000</td><td>10</td></tr>
</table>

(If you're really lazy, you can just load in these data patterns from the file <code>sim_tutorial_input_data.dtbl</code> by doing [[.data.gp.InputData.StdInputData.Load()|Object/Load]]
on the [[.data.gp.InputData.StdInputData]] object).

== Visualizing the Data Patterns ==

The best way to make sure you've entered the right patterns is to create a \"Grid View\" of your input data -- do this by selecting the [[.data.gp.InputData.StdInputData.NewGridView()|View/New Grid View]] option from the menu at the top of the data table editor that you've been using to enter input patterns with.  Go ahead and keep the \"New Frame\" default for the dialog that pops up (you can also add multiple view elements together in a single 'frame' in the 3d view -- we'll do that later).

This will create a [[.T3Tab.StdInputData]] tab in the right view panel, and display your input patterns, which hopefully match those shown in the above table.  If not, you can correct them by clicking back on StdInputData in the left browser -- you cannot edit values in the grid view display.

There is also a new [[.PanelTab.StdInputData]] middle-panel tab, which contains various parameters for controlling the configuration of the grid view display.  You can mouse-over the fields to get more info.  Many of these require you to hit the Apply button at the bottom before they take effect on the view.

The next step is to create [[.docs.Programs]] to control the presentation of these input patterns to the network.

</body>
</html>
";
  };
  taDoc @[3] {
   name="Programs";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Programs for Controlling the Simulation =

Again return to the [[.PanelTab.LeabraWizard_0]] wizard panel, and now select 
[[.wizards.LeabraWizard_0.StdProgs()|Programs/Std Progs]] from the bottom menu.  (return to these docs by clicking back on <code>docs/Programs</code> in the browser).

This created a set of standard programs that organize the presentation of input patterns to the network into a hierarchy of time scales:

* LeabraBatch -- iterates over multiple simulated \"subjects\" -- each having their own different random initial weights (we won't use this initially).
* LeabraTrain -- a complete training of the network from random initial weights to final correct performance, by iterating over multiple \"epochs\"
* LeabraEpoch -- one full pass through all of the different task input patterns
* LeabraTrial -- processes one input pattern, using two ''phases'' of settling -- the minus phase presents the input stimulus, and allows the network to come up with its own best guess as to the correct response, and the plus phase presents the correct answer to allow the network to learn to perform the task correctly.
* LeabraSettle -- multiple updates of neural unit activations to process a given input/output pattern.
* LeabraCycle -- a single cycle of updating of neural unit activation states (roughly 5-10msec of simulated real time)

There are also some other supporting programs that we'll discuss later.

You might notice that the ApplyInputs program is opened up to show the LayerWriter_0 object -- this was auto-configured to apply the input data values to the appropriate (same name) layers in the network.  If you change the layer names or add additional layers, etc, you may need to go back to this object and hit the AutoConfig button to reconfigure it.  We'll do this later in the tutorial.

== Running the Simulation ==

First, make sure you're viewing the [[.T3Tab.Network_0]] network view tab, and then click on the 
 [[.programs.gp.LeabraAll_Std.LeabraTrain]] program.  Press the 
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] button at the bottom of the window, followed by 
the [[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] button (these links will actually do this for you!).

You should then see the network processing each of the input patterns for the task multiple times, as it iterates over epochs of trials of settles of cycles of processing.  Depending on your hardware, this may wiz by in quite a blur.

Once it finishes, you can see more clearly what it is doing by hitting the [[.programs.gp.LeabraAll_Std.LeabraTrain.Step()|Step]] button, 
which will perform one phase of settling at a time.  You should observe that the network gets the correct output unit active in the minus phase (look for <code>MINUS_PHASE</code> or <code>PLUS_PHASE</code> in the text region at the bottom of the network 3d view display.  It has successfully learned the task!

We'll learn a lot more about how programs work when we write one from scratch to generate our input data for training the network.  If you're adventurous, you can click on them and hit the EditProgram button to see the underlying \"guts\" that make the programs do what they do.  Everything that happens in running the simulation is explicitly listed out, and can be modified in any way that you might want -- this is very powerful and probably a bit dangerous too.. :)  Don't do anything to modify the programs at this point.

The next step is more clearly monitor the performance of the network as it learns, by recording 
[[.docs.OutputData]] from the network.

</body>
</html>
";
  };
  taDoc @[4] {
   name="OutputData";
   auto_open=0;
   text="<html>
<head></head>
<body>
= Monitoring, Analyzing, and Displaying Output Data =

In this section we explore various ways of understanding better how the network is performing.

== Graphing Learning Performance over Epochs ==

To see how your network is learning a given task, the first step is to generate a graph of the learning performance (sum squared error on the training patterns) over epochs.  Fortunately, the default programs are already collecting this data for us, so we just need to display the graph.

The data is being recorded in the [[.data.gp.OutputData.EpochOutputData]] data table object in the <code>data/OutputData subgroup</code>.  You should see a few rows of data from the previous run, and you should notice that the <code>avg_sse</code> column shows a general decrease in average sum-squared-error on the training patterns, ending in a 0, which is what stopped the training.

To graph this data, you just generate a graph view of this data table.  As a general rule in the software, all view information is always generated by a given main object like a datatable or a network -- you don't create a graph and then associate data with it -- it goes the other way.  The menu selection to create the graph view is [[.data.gp.OutputData.EpochOutputData.NewGraphView()|View/New Graph View]].  This time, let's be adventurous and instead of putting this graph in a separate view frame, put it in the <code>Network_0</code> frame.

If you happened to have put it in the wrong frame initially, don't worry -- just do the context menu over the frame view tab on the right (should be called EpochOutputData), and select Delete Frame.  Note that there can be multiple views of the same underlying data.

You should see a graph appear in the upper right of your network display, showing a decreasing line from left to right.  By default the line is (redundantly) color coded for the plot value.  You can control this and many other features of the graph display in the graph control panel.

But wait, where is that panel?  You should only see a [[.PanelTab.Network_0]] tab in the middle panel tabs.  If you click on that guy, and look at the bottom, you'll see selectors for the different view objects within this one view frame (Network_0 and EpochOutputData Graph).  Select the graph view tab at the bottom, and again mouse over the various controls and play around with them.  As you can see, there are many different ways of
configuring the graphs -- feel free to explore.  Note that there are several other variables that you could plot, including average cycles to settle, and a count of the number of errors made across trials. Also see the wiki [[.Wiki.GraphView]] page for more details.

To see your graph updating in real-time, you can re-init and run the [[.programs.gp.LeabraAll_Std.LeabraTrain]] program:
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] 
[[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]].

=== Arranging the 3d View ===

Although the [[.T3Tab.Network_0]] view is sufficient, it could be configured to look better.  We could shrink the graph view a bit, and orient it better.  To do this (optional), click on the <b>red arrow</b> button to the right of the view, and then grab the upper horizontal bar of the small purple box in the lower-left hand corner of the graph view display.  Drag this slowly down -- you'll see the green frame rotating as you do.  Do this to the point where graph is angled more \"head on\".  Similarly, you can grab the left vertical bar and rotate the graph to the left a bit to make it more face on.  Next, grab any corner of the box, and shrink the view a bit (maybe to half or so of its original size).  Finally, you can move the view down and to the right a bit, to fit in between the Hidden and Output layers.

When you've got it the way you want, you can press the <b>eye</b> button to resize the display to fit, and maybe Dolly zoom in a bit.  You could perhaps pan to the right a bit with shift-mouse.  When it looks good, hit the <b>blueprint house</b> button (\"save home\"), which saves this view configuration.

== Recording Network Activations for a Grid View ==

Another common analysis task is to look at the pattern of activations across trials.  To do this, we need to record activation values to our trial-level output data table (which was automatically created by the wizard).  The easiest way to do this is to select the network object in the network view by clicking on the thin green frame surrounding the text display at the bottom of the network, and then using the right mouse button to get the context menu, and select [[.networks[0].MonitorVar()|MonitorVar]].  For the <code>net_mon</code> field, click and select the <code>trial_netmon</code>, which is for monitoring information at the trial level (the other one is for the epoch level).  For the <code>variable</code> field, type in \"act\" (no quotes), to record activations.  This will record activations for all three layers in the network in one easy step (you could alternatively do MonitorVar on each of the layers individually, or on any other object in the network for that matter, and record any variable).

Next, we need to make a Grid View of the resulting data, which will be recorded in the [[.data.gp.OutputData.TrialOutputData]] object -- do a 
[[.data.gp.OutputData.TrialOutputData.NewGridView()|View/New Grid View]], and again let's put this in the Network_0 frame.  Follow the same general steps as before (see Arranging the 3d View above) to position this new grid view into the bottom right hand region of the view.

The grid view will not contain the new information until the
 [[.programs.gp.LeabraAll_Std.LeabraTrain]] program is 
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] and
[[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] again.  After doing that, you need to scroll the grid view display all the way over to the right -- there are too many columns to fit within the 5 columns that the standard grid view is configured to display.  To do this, select the <b>red arrow</b> tool and drag the purple bar at the bottom of the <code>TrialOutputData</code> gridview all the way to the right.  You should see some colored squares with the Input, Hidden, and Output column headers.

To really make things clean, you can select the column headers of the columns you don't want to display (e.g., ext_rew, minus cycles) and do context menu/View Properties and then hit the Hide button at the bottom of the dialog that comes up.  Ideally, you'd just want to see the trial name, sse, and the different layer activation columns.

Also, because there are just 6 events, we can set the rows to display to 6 in the grid view panel, to make the display fit just right.

Again, you can run your program and see it update the display.

== Analyzing the Hidden Layer Representations ==

Now that we have some data from the network, we can perform some powerful analysis techniques on that data. 

First, we can make a cluster plot of the Hidden Layer activations, to see if we can understand better what is being encoded.  To do this, find the [[.data_proc.data_anal]] object under <code>data_proc/data_anal</code> in the left browser.  This contains many useful analysis tools, organized by different topics in the buttons at the bottom.  Select
 [[.data_proc.data_anal.Cluster()|HighDim/Cluster]], and set the following parameters (leave the rest at their defaults):
* view = on (generate a graph of the cluster data)
* src_data = TrialOutputData
* data_col_nm = Hidden_act   (specifies the column of data that we want to cluster)
* name_col_name = trial_name (specifies the column with labels for the cluster nodes)

You should see a new graph show up, with the A,B,C,X,Y,Z labels grouped together into different clusters.  Most likely, you should observe in a trained network that the A and X are grouped together, separate from the other items.  Can you figure out why this would be the case?

Another way to process this high-dimensional activation pattern data is to project it down into 2 dimensions.  Two techniques for this are principal components analysis (PCA) and multidimensiona scaling (MDS).  To try PCA, select
[[.data_proc.data_anal.PCA2dPrjn()|HighDim/PCA2dPrjn]] -- fill in the same info you did for the Cluster plot.  You should see that the labels are distributed as points in a two-dimensional space, with the X-axis being the dimension (principal component) of the hidden layer activation patterns that captures the greatest amount of variance across patterns, and the Y-axis being the second strongest component.  Accordingly, you should see A and X on the left or the right side of the graph, and the others on the other side.  It is not clear what the vertical axis represents..

There are many more things one could do, but hopefully this gives a flavor.  The next step: [[.docs.TaskProgram]] is to write a program to automatically generate our input patterns for training the network -- initially we'll start out with the simple task we ran already, but then we'll progressively expand to more complex tasks.  

</body>
</html>
";
  };
  taDoc @[5] {
   name="TaskProgram";
   auto_open=0;
   text="<html>
<head></head>
<body>
= Programming the Task Environment =

The goal here is to write a Program that will automatically generate a set of input/output patterns to train the network.  Because the task is so easy (at least to start), this will not represent a savings in time, but will hopefully generate understanding of how Programs work, and will also provide a basis for making more complex programs.

The major steps involved are:
# Create the new Program object
# Initialize \"enums\" based on unit names -- allows us to refer to units by name (an enum is geek-speak for an enumerated set of labeled values -- more later).
# Iterate over the input units and generate the appropriate output response.
# Write the appropriate information into the input data table.

==  Create the Program ==

In the context menu (right mouse or ctrl+mouse on mac) on the <code>programs</code> item in the left browser, select [[.programs.New_gui()|New]] -- default parameters are fine, so then hit OK.
This should have created a [[.programs.Program_11]] program, which you should now click on, and change the name to: <code>AXTaskGen</code> (the rest of the links here will assume this name, so do enter exactly that name).

It is good to get in the habit of entering descriptions of various objects in your simluation, especially programs, so enter something like \"generates the simple A-X target detection task\" in the <code>desc</code> field.

Note that there are three sub-tabs or sub-panels for a Program: 

* <code>Program Ctrl</code>: For the \"end user\" to control the running and key parameters of the program
* <code>Edit Program</code>: For writing the program.
* <code>Properties</code>: For setting overall parameters of the program object, including <code>tags</code> which help people find this program if it is uploaded to a common repository, and <code>flags</code> that determine various advanced properties.

Select <code>Edit Program</code> and we can get started doing that!

== Overview of Programing Process ==

Programming in this system mostly consists of dragging program elements from the toolbar at the very left edge of the display into your program, and then configuring their properties (drag-and-drop and duplicate are also very handy here).

The Program object has several different locations for different types of program elements:
* objs -- place to put misc objects that contain local data for the program (e.g., a local DataTable that might hold some intermediate processing data for the program).
* types -- special user-defined types that define properties of corresponding variables (e.g., the enums we'll be using).
* args -- (short for arguments) this is where you put variables that other programs will set when they run  this program.
* vars -- place for other non-argument variables that are used in the program.
* functions -- you can define subroutines (functions) that can be called within a program to perform a given task that needs to be done repeatedly.  These functions are only accessible from <i>within</i> this given program.
* init_code -- actions to be performed when the user presses the Init button -- to initialize the program and other objects that it operates on (e.g., initializing the network weights, as the LeabraTrain process does).
* prog_code -- finally, this is where the main code for your program goes!  because it can depend on any of the preceding elements, it logically comes last (and it is typically the largest).

In the Toolbox, the program elements are organized into various sub-categories (Network, Ctrl, Var/Fun, etc).  Take a look through these categories and use the mouse-over to see what kinds of things are available.

== Initialize Unit Names and Enums ==

To begin your program, locate the Network category, and drag (click and hold and move the mouse) the <code>init nm units</code> element into the <code>init_code</code> section of your program.

This Init nm units is a very powerful program element, which does a lot of configuration when it is first dropped into place.  You'll see various things being created in your project, and you should get an error message indicating that it could not find the input_data table.  Just hit OK to the error message, and let's take stock of what just happened (and fix the error).

You should see that a variable named <code>input_data</code> was created in the <code>vars</code> section, and <code>unit_names</code> was created in the <code>vars</code> section.  These are both \"pointer\" variables that provide a local \"handle\" within the program to refer to objects that actually live outside of the program, in the <code>data</code> section of the overall project.

Click on the [[.programs.AXTaskGen.args.input_data]] object, and take some time to mouse over the various fields and read the tooltips.  We want to set the <code>object_val</code> field to point to our StdInputData data table -- click on it and select it.

Now go down to the  [[.programs.AXTaskGen.vars.unit_names]] object, and note that it is already set to point to the UnitNames data table, which was automatically created in the <code>data/InputData subgroup</code> section of the project.  This new datatable will contain a single row of data, with labels for each of the units in the StdInputData data table.  However, right now it is empty, because we hadn't set the input_data variable yet.

=== Entering UnitNames ===

Now that we have set input_data, we can go back to the InputNamedUnits guy in the init_code, and hit the [[.programs.AXTaskGen.init_code[0].InitNamesTable()|Init Names Table]] button.  This will pull up an informational dialog -- hit OK.
Now go back up to the [[.data.gp.InputData.UnitNames]] data table, and you should see two columns: Input and Output, with a single row of data.  Click on the Input matrix and enter text labels for each of the units, as follows:

<table>
<tr><td>X</td><td>Y</td><td>Z</td></tr>
<tr><td>A</td><td>B</td><td>C</td></tr>
</table>

For the Output matrix, you can enter N and T (for non-target and target, respectively).

=== View Data Legend ===

Next, go back to the [[.programs.AXTaskGen.init_code[0]|InitNamedUnits]] object, and select
[[.programs.AXTaskGen.init_code[0].ViewDataLegend()|View Data Legend]] -- this will configure a new view frame with the input data patterns, plus a legend from the UnitNames table showing what each of the unit names are.  These same names can also be applied directly to the network to label the units -- we'll do that later.  You might want to remove your other view frame for StdInputData (without the legend) -- do context menu and select Delete Frame.

=== Creating Enums ===

Next, we'll create those enums mentioned previously.  Click on [[.programs.AXTaskGen.init_code[0].InitDynEnums()|Init Dyn Enums]].  You will see two new entries in the <code>types</code> section of your program -- Input and Output.

Under the Input type, you should see 6 items with names like I_A, I_B, etc.  Under the Output type, you see O_N and O_T.  The first letter is taken from the first letter of the layer (I = Input, O = Output), and the remainder after the underbar is the name entered in the UnitNames table.

The purpose of these enum types is to allow you to use a symbol to refer to a unit. If you want to activate the X input unit, you can use the I_X enum value to do that.  It represents the <i>index</i> of the X unit within the input layer -- when you click on I_X, you can see that it has a value of 3.  enums have both numeric and symbolic (name-like) properties, and can be converted to and from names and numbers.  You'll understand more about why they are so useful as we go along.

We are done with the unit names for now, and can move on to writing our program.

== Iterating over the Inputs ==

The core of our program will be to <i>loop</i> or <i>iterate</i> over each of the possible input units, and then generate an appropriate output for each.  We can use a <b>for loop</b> for this purpose.

In the left Toolbox, click on the <code>Ctrl</code> category (for \"control\"), and drag the <code>for</code> element into your program code (<code>prog_code</code>).

You should now see a set of 3 main fields for the for loop object: <code>init, test, iter</code> -- the default values produce a loop that goes from 0 to 9:
* Init is for initializing your looping variable (<code>i = 0</code>), where i is the integer variable that keeps track of where we are in the loop -- it was automatically created by the for loop element. 
* Test is for testing when to terminate the loop (<code>i &lt; 10</code>) -- as long as the i variable remains less than 10, we continue looping.
* iter is what to do on each iteration prior to the test (<code>i++</code>) -- i.e., increment the loop variable.  

To see this in action, let's drag the <code>print_var</code> guy from the <code>Print..</code> category of program elements into our <code>loop_code</code> of the for loop.  This is where we put the program elements (\"code\") that we want to run during each iteration of the loop.  Select the <code>i</code> variable for the <code>print_var</code> field.  

Now we can [[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] our simple program.  You should see a sequence of \"i=0, i=1...i=9\" in the console window (typically located below the main project window).  It is a very good idea to keep that window visible during programming, as various informative messages may show up there.

Although perhaps fascinating for new programmers, this for loop is not exactly what we want.  We want to iterate over the input units, not just over the numbers from 0-9.  To do that, we need to click on the [[.programs.AXTaskGen.vars.i]] variable in the <code>vars</code> section of the program.  Change the <code>var_type</code> to DynEnum instead of Int.  Then, click on the </code>enum_type</code> field and select the Input type (which is what we created earlier).  You can also change the name of this variable to something more expressive, like <code>input_unit</code>.  Note that when you apply this name change, the for loop code automatically updates to use this new name, as does the print var guy.

Let's go back to that [[.programs.AXTaskGen.prog_code[0]|for]] loop guy, and change the <code>test</code> field to: <code>input_unit &lt;= I_Z</code>.  Note how you can just type in I_Z and this is automatically treated as a number -- this is what enums do. 
[[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] that.  Everything should be fine, up until the very end, when it tries to go beyond the I_Z case -- this will generate an error message (as it should -- one of the many advantages of using enums is that they provide built-in error-checking like this).

To get around this issue, we need to add a test inside of our loop that bails out when we get to I_Z, so that final ++ increment does not occur.  In the <code>Ctrl</code> elements, there is an <code>if.break</code> guy that does just this -- drag it into the loop_code so it appears at the end (note that you need to drop it on the loop_code guy itself to put it at the end, or go just after the print var and you'll see a thin horizontal line -- dropping there should work too).  In the <code>cond</code> field, enter <code>input_unit == I_Z</code> (note that you can do this without much typing by selecting lookup_var and lookup_enum to choose those guys off of a list).  This will break the loop at the last item (I_Z).
[[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] to confirm.

=== Generating the Correct Output ===

Next, we need to generate the correct output for each input.  To do this, we first need to create a variable to hold the output value.  Goto <code>Var/Fun</code> in the toolbox, and drag the first <code>Var</code> item into your program <code>vars</code> (select \"Copy Here\", not \"Add Var To\", when you drop -- we'll explain later).  Set the name to <code>output_unit</code> and change the type to DynEnum with enum_type selected as Output.

Now we just need to set this variable inside our for loop code, depending on the value of the input_unit variable.  The Ctrl/if guy will do this for us -- drag it into the loop_code and drop on top of the PrintVar (it will become the first element in the program).  In the <code>cond</code> condition expression, enter: <code>input_unit == I_A || input_unit == I_X</code> (again note that you can use the var and enum lookup to save some typing and make sure you've spelled them correctly).  The == is the logical test for equality, and the || is the logical OR operator (this is standard C++ syntax -- any valid C++ expression can be entered here).  This is the condition for a target.

We need to assign our output_unit variable to the target value when this \"if condition\" is true, and to the non-target case otherwise.  To assign a variable value, drag <code>var=</code> from the Var/Fun category to the true_code section of your if guy.  For the <code>result_var</code>, select output_unit, and for the <code>expr</code> expression, enter O_T (or choose from the enum_lookup).  This sets output_unit to O_T (target).  As a timesaver, drag this AssignExpr guy from true_code into false_code -- then you can just change O_T to O_N very quickly.

Finally, go to your PrintVar and select output_unit for print_var1 (or print_var2 if that is easier to see).  [[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]], and you should see the correct values for input_unit and output_unit being displayed in your console! 

== Writing the Data to the Input Data Table ==

Now that you have all the key logic of your task, you just need to write the results to the input data table.  There are three main steps for this:

# Erase any existing data at the start
# In the for loop, add a new row, and write the data for each input/output pattern
# Tell the system that we're done writing to each row so it can update the view

The first step is achieved by dragging a <code>reset_rows</code> guy from the Data toolbox to the first line of the program code (drop right on top of the for loop).  Then select the input_data variable for the data_var.

Next, drag the <code>new_row</code> guy into the loop_code, right before the final IfBreak guy (drop on top of it).  Again select input_data as the data_var.  This will add a new blank row to the data table.  Then, drag <code>set units var</code> from the Network toolbox into the loop_code, again on top of IfBreak.  This is a magic little program element that uses the name of the DynEnum type of a variable, plus its value, to determine which unit to activate in the input data table.  All you have to do is select input_unit for unit1, and output_unit for unit2, and you're done -- it automatically located the input_data datatable (based on its name).

Finally, go back to the Data toolbox, and drag the row_done guy on top of IfBreak -- this just lets the system know that you're done writing to the current row of data, and that it can update any relevant displays.

Congratulations -- you're done!!!  Select the [[.T3Tab.StdInputData]] tab in the 3d view area, and then do
[[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] -- you should see the display update with the correct patterns freshly generated by your program!

You have now done a little bit of each of the critical main elements of simulating using this system.  The next few steps in the tutorial take this simple starting point and go all the way to a more scientifically interesting model of an actual psychological task: the CPT-AX task: [[.docs.CPTAX_Program]].

</body>
</html>
";
  };
  taDoc @[6] {
   name="CPTAX_Program";
   auto_open=0;
   text="<html>
<head></head>
<body>
= CPT-AX Program =

The next challenge is to write a program that will generate the CPT-AX task (CPT stands for continuous performance task), which is the logical extension of our simple AX task to the ''sequential'' domain.  Instead of A and X each being targets, the target is now
an A ''followed by'' an X in sequence.  Other sequences such as A followed by Y or B followed by X are 
non-target sequences, which nevertheless overlap with the target sequence.  In our simplified version of this task (and in several of the actual experiments on people), we restrict the sequences to cue-probe pairs, where cues are A,B,C and probes are X,Y,Z.  See e.g., Braver, T.S., Barch, D.M. & Cohen, J.D. (1999). Cognition and control in schizophrenia: A computational model of dopamine and prefrontal function. ''Biological Psychiatry, 46,'' 312-328, for an application of this task and further discussion and references.

One implementational detail in how this task is run is key for generating interesting behavioral and neural data: the frequency of the A-X target sequence is set to be relatively high (typically 70%), so that it becomes the default expectation.  Then, the two related non-target sequences become much more interesting.  For A-Y, there should be a strong expectation of getting an X, which will be influenced by the extent to which the A cue is well remembered.  Errors on this trial type, where people might press \"target\" at the Y, would actually suggest strong maintenance of the A cue.  A similar argument applies to B-X, where the X is typically a target, but if you remember the B cue, you should not press the target key.  The C,Z items serve as baseline controls, as does the B-Y sequence.

== Plan for the Program ==

With the above in mind, we can sketch out the logic of our overall program:
* Flip a weighted coin to determine whether we want to generate a target sequence or not.  70% of the time we generate a target sequence, in which case we just produce A followed by X and that is easy.
* Generating a non-target sequence is harder.  We need to randomly select from the cues (A,B,C) and the probes (X,Y,Z), while ensuring that we don't randomly pick A-X.  We'll discuss a couple of different strategies for this.
* We can do the above cue-probe generation process multiple times to generate a larger set of trials that we will run on a given epoch worth of network training.  That is just a simple for loop around the above code.

== List of Variables ==

Once we have this plan in place, we can create a set of variables that we'll need -- the general flow of programming in this system involves creating variables and then opearating on them, so getting the variables down is the key first step:
* pct_target -- how frequent should the target sequence be?  this is actually a proportion, but pct is a much simpler label -- for the default case it should be .7
* rnd_number -- a random number between 0 and 1 (floating point or Real) that we'll generate to simulate the flipping of a weighted coin.
* cue -- the identity of the cue input (A,B, or C) represented as a DynEnum of type Input, taking on values I_A, I_B, or I_C.
* probe -- the identity of the probe input (X,Y, or Z), represented by an Input DynEnum as well.
* output_unit -- correct answer for the output layer (DynEnum of type Output) -- we'll have the model respond \"non-target\" for all the cue items, and \"target\" for the targets.

== Getting Started: Copy and Modify ==

The easiest way to get started is to duplicate and modify the existing AXTaskGen program (this is a general rule -- if there is a program that has several elements that you want, just copy and modify instead of starting from scratch).  To do this, click on the AXTaskGen program in the left browser, and use the context menu to select Duplicate.  In the new program, enter the name as CPTAXGen, and update the description to reflect what we're doing.

Now go to EditProgram, and click on the ForLoop object in the prog_code, and use the context menu to Delete that object -- this will also delete everything within it, which is almost all of the code from the previous program.  All that should remain is the ResetDataRows at the start (which we can use in any case).

We can now setup our variables as indicated above.  Just rename input_unit to cue, then duplicate it and call it probe.  Then drag a new var (from Var/Fun toolbox) into vars and call it \"pct_target\", and set the type to Real, and enter a value of .7.  Duplicate it, and call it \"rnd_number\".  It would be a good idea to enter the descriptions for each variable in their desc fields (you can copy and paste from the above text if you want).

== Flipping a Weighted Coin For the Target ==

The first step in our actual program code is to flip a weighted coin to decide if it is a target sequence or not.  We do this by generating a random number (rnd_number) which is uniformly distributed between 0 and 1.  We then see if this number is ''less than'' our target percent value -- this will be true 70% of the time for a value of .7, and that is what we want!

* in the Toolbox, Misc Fun, there is a random() guy -- grab that and put it at the end of your program (drop on prog_code or after the reset data rows).  Set the result_var to rnd_number, and click on the method -- in the browser window that comes up, you can select different categories (in the menu at the top) of random numbers to generate -- select \"Float\", and then pick ZeroOne.  This will set rnd_number = a random number between 0 and 1.
* Go to Ctrl toolbox and drag <code>if</code> to the end of your program.  In the cond expression, type/select: <code>rnd_number &lt; pct_target</code>.

The true_code for this if is now the target case, and the false_code is the non-target.  To set the target values, we just need to assign cue and probe to A and X respectively.  Drag var= from the Var/Fun toolbox into true_code, and set the result_var to cue, and choose the I_A enum from the enum_lookup button.  Drag var= again and set probe = I_X.  Finally, drag var= and set output_unit = O_T.

== Generating the Non-Target ==

There are two strategies for generating the non-target sequence that excludes A-X:
* Brute force: randomly generate a cue and a probe and check that they aren't A-X -- if they are, then repeat the process until they aren't.  This is not particularly efficient, but it is easy to code.
* Choose from a list: generate a list of all possible cue-probe combinations, remove A-X from this list, and then randomly select an item from this list.  This is more efficient overall, but harder to code.  It is left as an excercise for later, as it demonstrates some important techniques.

To do the brute-force method, you need to enclose the random generation code in a \"do\" loop, which does some things (generates the random cue/probe) and then tests whether it should loop again (if it is A-X) or not.

Drag the <b>do</b> guy from Ctrl into your false_code of the target if test.  Enter/lookup <code>cue == I_A && probe == I_X</code> as the test for continuing to loop ( == is the equality operator, and && is logical AND).

Now inside the loop_code, we need to randomly generate a cue and a probe.  Drag the random() guy from Misc Fun in there, and set the result_var to cue.  For the method, select the Int category, and choose IntMinMax -- we'll specify a minimum and maximum value to generate random numbers between.  Notice that the min and max arguments open up below this element -- these are the values that will be passed to the IntMinMax function.  Click on min, and enter/lookup I_A.  For the max, enter I_C + 1, because this IntMinMax function generates values ''exclusive'' of max (this is consistent with the C programming language convention, where values go between 0 and n-1 instead of 1 to n).

Just duplicate this RandomCall element, and change cue -> probe and min = I_X, max = I_Z+1.  Finally, drag var= and set output_unit = O_N to show that this is a non-target case (quicker to drag AssignExpr guy from true_code and change O_T to O_N).

To test the program at this point, you can drag a print var object to the end of the code, and select cue, probe, and output_unit for the vars to print, and do Init and Run and see that it tends to produce a predominance of A-X and O_T.  To really test it, set pct_target = 0, and Run some more.  You should never see an A-X, and only O_N.

== Generating the Input Data Patterns ==

The last step is to produce the input data patterns for the values we have generated.  This is just a matter of adding a couple of <code>new row</code> guys from the Data toolbox and <code>set units var</code> from the Network toolbox to set the units.
* drag the <code>new row</code> from Data Toolbox to the end of the program (drop on prog_code) and set data_var to input_data.
* drag the <code>set units var</code> from Network toobox to the end, and set unit 1 to the cue variable.
* Because the output is a literal in this case (O_N or non-target), we cannot set it using this element, which requires a variable.  So, you need to drag the <code>set units lit</code> to the end, and set the enum_type to Output, and the value to O_N.
* drag and drop the AddNewDataRow and SetUnitsVar guys on top of prog_code and select Copy Into to duplicate them at the end of the program, and change cue to probe in the set units var, and select output_unit for unit 2 to also set that guy.
* finally, drag a Data/row done guy to the end to tell it to update the view (select input_data as the data_var).

[[.programs.CPTAXGen.Init()|Init]]
and [[.programs.CPTAXGen.Run()|Run]] the program while looking at the 
[[.T3Tab.StdInputData]] view tab.  You should see it generate a valid cue-probe input that matches what is printed out on the console.  Keep running to see a range of inputs.

== Generating Multiple Cue-Probe Trials ==

The last bit of programming needed is to simply loop over the existing set of code multiple times to create several cue-probe sets per epoch for the network to train on.  Drag a for loop from Ctrl on top of the 2nd line of the program (RandomCall).  Then, multi-select the rest of the program code (only the guys at the main level, not the true_code or false_code within the if statement (this is done with alt-click on linux or mac-command-click on the mac -- note that order matters so select down in order!), and then drag the whole thing into the loop_code of the for guy.  Pretty slick.

If you just Run it like this, you'll get 10 trials.  It would be good to make the number of trials a variable that can be set.  Drag a var into vars and call it \"n_trials\", and set it to 50 (Int = integer type).  Then, click on the for loop and replace the 10 in the test expression with n_trials.

You can probably turn off the console printout by now -- just click on the PrintVar guy and click the OFF flag -- this keeps it around in case you want to do some debugging or something later, but it is not actually used in the code.

== Updating the Control Panel ==

If you go back to the Program Ctrl tab for the CPTAXGen program (instead of Edit Program where we've been), you'll see that all of the args and vars are present there.  However, some of those vars are actually more internal variables that the end-user doesn't need to set or configure.  So, we should remove those from the control panel, leaving only the pct_target and n_trials variables.  To do this, go back to Edit Program and click on each of the vars, and turn off the CTRL_PANEL flag for all but pct_target and n_trials.  Then go back and marvel at the clean interface you've provided for your grateful user!  The mouse-over tooltip even shows whatever comment you entered in the desc field for that variable.  This can provide a quick but quite usable interface for many different programs.

== Calling from the Epoch Program ==

The final final step is to call the CPTAXGen program every epoch, so that we get a new random selection of trials every epoch (keeps the network from simply memorizing the particular sample we happen to have generated).  To do this, we go to the [[.programs.gp.LeabraAll_Std.LeabraEpoch]] program in the LeabraAll_Std subgroup of programs, and do Edit Program.  Then drag the prog() guy from the Var/Fun toolbox just after the 3rd line of the prog_code, which starts the timer recording how long the epoch takes to process (it is a MethodCall, in blue).  Then select CPTAXGen for the target.  Note that this automatically brings up the input_data arg, and it even automatically fills this in with the input_data variable in the LeabraEpoch program -- if an arg has the same name as a variable in the calling program, it is used automatically (of course you can always change it if that isn't right).

There is one additional and <b>very critical</b> final step with the LeabraEpoch program.  Go to the Program Ctrl tab, and observe the set of program vars available for you to set.  The first one, called <code>data_loop_order</code> is set to <code>PERMUTED</code> by default -- this means that the trials (rows of the input data table) are presented in a shuffled random order (without replacment, so each trial only appears once).  Clearly this is not going to be good for our <i>sequential</i> input data.  So, change it to <code>SEQUENTIAL</code>, which will present the trials in sequential order.  Given that we're doing the randomization within our program, this should be just fine.  There is also another way of doing this that involves creating grouped trials (i.e., cue-probe), where you can randomize the order of the groups, but present the trials within the group in sequential order.  The LeabraEpochGpData program available in the standard program library does this, but that is beyond the scope of this project.

== Running the Network ==

Now you're finally ready to run the network on this CPT-AX task!  Go back to the LeabraTrain process, do Init and Run on it (initialize the weights) and see what happens!?

You should see that it will run and run and never fully learn the task (it will stop training if the error goes to zero).  There is some chance that it might get there just by virtue of a lucky set of trials -- try hitting Run again -- it should not stay at zero, and will keep running.

You probably want to turn off the network and trial output data views at some point -- just click off the display button on their respective control panels under the Network_0 view tab.

It shouldn't come as that much of a surprise that the network doesn't fully learn the task -- this task requires working memory, and this network hasn't got any!  In fact, it is quite surprising that it is able to learn as well as it can.  Turns out it can learn to use weight changes as a kind of fairly unreliable form of working memory.  Plus, the default target of AX is highly frequent, so it can get pretty far by focusing a lot on that.

In the next and final segment, we give this network some working memory, and see if that helps: [[.docs.PfcBg]]


</body>
</html>
";
  };
  taDoc @[7] {
   name="PfcBg";
   auto_open=0;
   text="<html>
<head></head>
<body>
= Adding a Prefrontal Cortex, Basal Ganglia Working Memory System =

There are many different ways of giving a neural network some amount of working or active memory, to hold on to prior events.  Perhaps the simplest is to add a \"simple recurrent network\" (SRN) context layer that holds on to the prior time step's hidden layer activations, and then feeds back into the hidden layer to provide context for the current inputs.

However, there are various limitations of this simple SRN memory, which can be overcome by having an active gating mechanism that determines when to hold onto information and when to forget it.  One scientific theory is that the basal ganglia provide this function, by interacting with the prefrontal cortex, which is widely regarded as the brain area responsible for holding onto working memory.  The specific implementation of this idea, called PBWM (prefrontal-cortex basal-ganglia working memory; O'Reilly & Frank, 2006, Neural Computation) is available through the Leabra wizard, and we'll use that.

First, to prepare the model for the PBWM components, we need to move the Input layer up to the same level as the output layer.  For anatomically-inspired reasons, PBWM locates various brain-stem dopamine systems in the lower level of the model.  To do this, click on the red arrow in the [[.T3Tab.Network_0]] panel, and click on the virtical arrow poking through the green Input layer border, and drag it up to the level of the Output layer.  The Output layer should move out of the way, and that is all you need to do, but if things don't look right, you can drag layers around with the horizontal arrows too.

Next, go to the [[.PanelTab.LeabraWizard_0]], and 
select [[.wizards.LeabraWizard_0.BgPFC()|Network/Bg PFC]].  A dialog with several options and lots of information comes up.  Turn off <code>fm_hid_cons</code>, and turn on <code>nolrn_pfc</code>.  This makes the PFC working memory layer activated directly from the input layer, and not the hidden layer, and it makes it a direct copy of the input layer, instead of having it learn new representations.  These are \"hacks\" that simplfy the model and make it easier to understand -- performance is generally the same without them.  When you hit OK, you'll get  a series of dialogs with information -- just keep hitting OK until it is done.  You should see a rather more elaborate network now, with many more layers.

For complete details about these layers, see the  [[http://psych.colorado.edu/~oreilly/pubs-abstr.html#OReillyFrank06|O'Reilly and Frank, 2006]] paper (O'Reilly, R.C. & Frank, M.J. (2006). Making Working Memory Work: A Computational Model of Learning in the Frontal Cortex and Basal Ganglia. <i>Neural Computation, 18,</i> 283-328.)  Here is a very brief overview:
* First, note that there are four separate <b>stripes</b> (groups of units) in the PFC and Matrix layers -- this was determined by the <code>n_stripes</code> parameter in the wizard.  Each stripe can be independently updated, such that this system can remember up to 4 different things at the same time, each with a different \"updating policy\" of when memories are updated and maintained.  The active maintenance of the memory is in PFC, and the updating signals (and updating policy more generally) come from the Matrix units (a subset of basal ganglia units).
* PV* and LV* and friends at the very bottom layer of the network: these represent the dopaminergic system, which provides reinforcement learning signals to train up the dynamic gating system in the basal ganglia.  The PV layers represent primary values of reward (i.e., actual externally-delivered reward values), while the LV layers represent learned (\"anticipated\") values -- together, they account for Pavlovian conditioning phenomena and associated dopaminergic firing data.
* Matrix: this is the dynamic gating system representing the matrix units of the basal ganglia.  Every even-index unit within a stripe represents \"Go\", while the odd-index units represent \"NoGo.\"  The Go units cause updating of the PFC, while the NoGo units cause the PFC to maintain its existing memory representation.
* SNrThal: represents the substantia nigra pars reticulata (SNr) and the associated area of the thalamus, which produce a competition among the Go/NoGo units within a given stripe.  If there is more overall Go activity in a given stripe, then the associated SNrThal unit gets activated, and it drives updating in PFC.
* PFC: has 4 different stripes each of which has a localist one-to-one representation of the input units (due to the nolrn_pfc flag).  Thus, you can look at these PFC representations and see directly what the network is maintaining.

== Setting the RewTarg Input ==

Before we can run the model, we need to do one extra bit of configuration.  The PBWM model learns from rewards and punishments generated based on how it is performing the task. Only the reward values generated on the probe trials are relevant, however, so we need to tell the model when the relevant trials are.  This is done using the RewTarg layer (in the bottom layer), which is a new input layer that was added by the wizard.  When we set this unit activation to 1, then that tells the network that this is a trial when reward should be computed based on the difference between the network's output and the correct answer.  Note that this is not the direct value of the reward itself, just the indicator of when reward should be computed.

The procedural steps for making this RewTarg work are mostly the same for any kind of change in the input data table structure (e.g., adding more input units), so these steps are generally useful:
* First, go to the [[.PanelTab.LeabraWizard_0]] and 
select [[.wizards.LeabraWizard_0.UpdateInputDataFmNet()|Data/UpdateInputDataFmNet]] -- this will automatically reconfigure your StdInputData table to include the RewTarg input (and it will adjust it to any other changes you might make in your network -- a very useful function!).
* Next, we need to update the program that applies the input data to the network, so that it will appropriately apply the new RewTarg input to the network.  This is the [[.programs.gp.LeabraAll_Std.ApplyInputs]] program in LeabraAll_Std subgroup.  
In its objs section, there is an object called  [[.programs.gp.LeabraAll_Std.ApplyInputs.LayerWriter_0]], which provides the info for mapping input data the network layers. 
Hit [[.programs.gp.LeabraAll_Std.ApplyInputs.LayerWriter_0.AutoConfig()|AutoConfig]] on this object, and it will automatically update based on the new input data and network configuration.
* Now we need to modify our [[.programs.CPTAXGen]] program to set this RewTarg input value correctly.  This requires several steps:
** Update the unit names so we can refer to the rew targ input using an enum: click on the InitNamedUnits object in the init_code section of the program (under Edit Program tab) and hit the [[.programs.CPTAXGen.init_code[0].InitNamesTable()|InitNamesTable]] button -- this will update the UnitNames data table to match the updates in the input data table.
** Go to [[.data.gp.InputData.UnitNames]] and enter the name \"rew_targ\" for the single RewTarg unit.
** Go back to InitNamedUnits and do [[.programs.CPTAXGen.init_code[0].InitDynEnums()|InitDynEnums]] -- this will add a RewTarg DynEnum in the types section (it would also update the enums based on any other changes you might have made in the UnitNames table -- again a very useful function to remember)
** Now we are finally ready to add the code to set the rew_targ input for the probe trial.  Just drag a <code>set units lit</code> from the Network toolbox to end of the prog_code before the DoneWritingRowData guy, and set the enum_type to RewTarg, and the value should be R_rew_targ.

Finally, you can hit [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]]
and [[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] on the LeabraTrain program to run your new network (select Yes to Initialize the weights).

== Increasing the Hidden Layer Size ==

It may or may not learn the task very quickly (depends on your random initial weights, etc).  It turns out from playing with this model a bit that the initial 16 unit hidden layer is just a bit too small to handle all the new information being represented in the PFC layer.  So, click on the Hidden layer's green border in the Network_0 3d view, and you should see the edit panel for the network in the middle panel.  Locate the <code>un_geom</code> line, and change it to 5 x 5 (25 units) instead of 4 x 4.  When you hit apply, the layer will change size in the display, but the extra units will not be filled in.  You need to click back on the Network_0 tab in the middle panel, and hit the Build button at the bottom to rebuild the network based on the changes you made.

Now [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]]
and [[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] on the LeabraTrain program again, select Yes to initialize the weights, and you should see the network learning within 10-20 epochs or so (again, toggle off the display button on the Network view control panel to speed things up -- same with the TrialOutputData Grid display).

== Displaying Unit Names ==

Once the network has learned, we can use the Step button on the Train program to see how it operates step by step (turn the network and trial grid log display's back on).  By default, the step goes one settle at a time -- you can change this to LeabraTrial to get one trial at a time.

To better visualize what is happening, you can change the input, output, and PFC layers to display the name of the most active unit, rather than just the raw unit activations.  This makes it just that much easier to figure out what the network is doing.

There are two steps to this.  First, we need to get the unit name labels from the UnitNames data table into our network.  Then, we need to configure the network display to show the labels instead of the units.
# Go to our good friend the [[.programs.CPTAXGen.init_code[0]|InitNamedUnits]] object in the 
init_code of the [[.programs.CPTAXGen]] program.  There is a LabelNetwork button there, but if you press it, you'll get an error about not finding a network variable to apply the names to.  To create this variable, you can just copy the network variable from the args section of any of the programs in the LeabraAll_Std subgroup, and put it in the args of the CPTAXGen program (do context menu copy on the network variable and then context menu paste on args, or you can actually open up the args section of a program in the left browser and drag the network directly into your CPTAXGen args in the middle browser -- that is a convenient way to do various copies).  
Then do [[.programs.CPTAXGen.init_code[0].LabelNetwork()|LabelNetwork]] again, and this time it should work.
# In the [[.T3Tab.Network_0]] view, select the red arrow and then click on the Input layer (green border) to select it, and then use the context menu (right mouse button or mac-command-mouse) to select <code>Disp Output Name</code>.  Repeat this for the Output and PFC layers.

Now Step your LeabraTrain program, and you should see the names of the active units.

In the network that we trained (which you can load into Network_0 by clicking on that guy and doing Object/Load and selecting <code>ax_tutorial_cptax.net</code>), it is very clear that the middle two stripes update for an A or a C, while the first and third stripe update for B.  No stripes update for any of the probe stimuli.  This encoding of the cue but not the probe is just what you'd expect the network to learn.

It might be easier to see what the network is doing if you change the pct_target to .25 or something instead of .7 -- you don't have to spend so much time clicking through AX trials.

That is all we have for now.  You might notice a project called <code>12ax4s.proj</code> in this same directory -- that is an even more complex version of the CPT-AX task involving an outer-loop of 1 or 2 stimuli that determines what the inner-loop target sequence is (AX or BY).  These same mechanisms can learn that more difficult task, though it takes longer.  It is described in detail in the O'Reilly & Frank 2006 paper referenced above.

</body>
</html>
";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="LeabraWizard_0";
   auto_open=1;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=6;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=16;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=2;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=5;
     };
    };
    name="StdInputData";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] "A_T";"B_N";"C_N";"X_T";"Y_N";"Z_N";      };
     };
     float_Data @[1] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;2;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [3 2 6] 1;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;1;0;0;0;0;0;0;1;      };
     };
     float_Data @[2] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [2 1 6] 0;1;1;0;1;0;0;1;1;0;1;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="N_ROWS";
      value 2 0=1;
     };
     UserDataItem @[1] {
      name="MAT_VAL_TEXT";
      value 2 0=1;
     };
     UserDataItem @[2] {
      name="WIDTH";
      value 6 0=3.299999952316284;
     };
    };
    name="UnitNames";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;2;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [3 2 1] "A";"B";"C";"X";"Y";"Z";      };
     };
     String_Data @[1] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [2 1 1] "N";"T";      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 0;0;0;0;0;0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 4;4;4;4;4;4;      };
     };
     int_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 0;1;2;3;4;5;      };
     };
     String_Data @[3] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] "A";"B";"X";"Z";"C";"Y";      };
     };
     String_Data @[4] {
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] ;;;;;;      };
     };
     int_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
       };
      };
      name="phase_no";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 2;2;2;2;2;2;      };
     };
     float_Data @[6] {
      name="minus_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 19;15;17;15;24;15;      };
     };
     float_Data @[7] {
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 0;0;0;0;0;0;      };
     };
     float_Data @[8] {
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 0;0;0;0;0;0;      };
     };
     float_Data @[9] {
      name="Input_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;2;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [3 2 6] 0.94999999;0;0;0;0;0;0;0.94999999;0;0;0;0;0;0;0;0.94999999;0;0;0;0;0;0;0;0.94999999;0;0;0.94999999;0;0;0;0;0;0;0;0.94999999;0;      };
     };
     float_Data @[10] {
      name="Hidden_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 4;4;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [4 4 6] 0.00086805352;1.8642718e-10;0.330585;0.0015773361;0.93028665;9.0074366e-09;0.88704109;0.033813108;3.5524962e-17;0.038050365;6.7375536e-18;3.5077696e-09;0.8143025;0;5.76158e-12;1.5870679e-05;0.14163497;0;0.8233881;0.71903008;5.1851879e-07;0.00054625864;9.6354313e-05;0.91281921;8.0780159e-18;7.4803248e-16;0;0.40498275;3.5874049e-08;0.47268921;0.87569469;0;6.950488e-05;0.059135236;0.93415415;5.0818968e-13;0.90018451;0.71779019;1.7388861e-10;0;1.9112464e-05;0.12876695;1.1738714e-09;0.0022920975;0.32924685;0;3.3947881e-12;2.8693067e-11;0.13797449;0;0.1298116;0.77483231;5.4063669e-15;0.028271448;0.32306844;0.90327013;0;0.5036431;0.0031129136;0.81254017;0.0095546609;0.00047446505;0.53713733;0;0.79832458;0;0.83907288;0.85883737;1.0595816e-09;0.88461679;0.45203692;0.85695237;0;0.50920594;0;0.067914188;7.3147224e-15;3.2935127e-06;7.828154e-05;0;0.00016419968;0;0.001963885;0.87850517;8.9151555e-08;0.05604152;0.056203242;0.0010021889;3.9429768e-11;0.010948555;1.2222836e-05;0.94211942;3.3120289e-14;0.76022035;7.2917915e-06;0;      };
     };
     float_Data @[11] {
      name="Output_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [2 1 6] 0;0.94999999;0.94999999;0;0;0.94999999;0.94999999;0;0.94999999;0;0.94999999;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 0;1;2;3;4;      };
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 0.62116563;0.61234158;0.30128685;0.3179386;0;      };
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 2;2;1;1;0;      };
     };
     float_Data @[4] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
     float_Data @[5] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 22.333334;25.833334;18.833334;17.833334;17.5;      };
     };
     float_Data @[6] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
     float_Data @[7] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [5] 0;0;0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   DataTable @[0] {
    name="TrialOutputData_col_Hidden_act_Cluster";
    desc=;
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     float_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="X_AXIS";
	value 1 0=1;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=13.43964862823486;
       };
      };
      name="X";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [53] 0;0;0;0;0;4.3747625;4.3747625;6.2901859;4.3747625;4.3747625;4.3747625;4.3747625;6.2901859;4.3747625;4.3747625;4.3747625;0;0;0;4.3747625;4.3747625;7.9630947;4.3747625;4.3747625;4.3747625;4.3747625;7.9630947;7.9630947;10.339836;7.9630947;7.9630947;7.9630947;7.9630947;10.339836;10.339836;11.686651;10.339836;10.339836;10.339836;10.339836;11.686651;10.339836;10.339836;10.339836;7.9630947;7.9630947;4.3747625;4.3747625;0;0;0;0;0;      };
     };
     float_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="PLOT_1";
	value 1 0=1;
       };
       UserDataItem @[1] {
	name="MAX";
	value 6 0=5.800000190734863;
       };
       UserDataItem @[2] {
	name="MIN";
	value 6 0=0.2000000029802322;
       };
      };
      name="Y";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [53] 2.1875;2.1875;2.1875;2.1875;1;1;0.5;0.5;0.5;0.5;1;1.5;1.5;1.5;1.5;1;1;2.1875;3.375;3.375;2.5;2.5;2.5;2.5;3.375;4.25;4.25;3.5;3.5;3.5;3.5;4.25;5;5;4.5;4.5;4.5;4.5;5;5.5;5.5;5.5;5.5;5;5;4.25;4.25;3.375;3.375;2.1875;2.1875;2.1875;2.1875;      };
     };
     String_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="PLOT_2";
	value 1 0=1;
       };
      };
      name="Label";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [53] ;;;;;;;"A";;;;;"X";;;;;;;;;"C";;;;;;;"Y";;;;;;;"B";;;;;"Z";;;;;;;;;;;;;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
   DataTable @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItemBase;
     el_def=0;
     UserDataItem @[0] {
      name="PLOT_STYLE";
      value 9 0="POINTS";
     };
    };
    name="TrialOutputData_col_Hidden_act_PCA2dPrjn";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="PLOT_2";
	value 1 0=1;
       };
      };
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] "A";"B";"X";"Z";"C";"Y";      };
     };
     float_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="X_AXIS";
	value 1 0=1;
       };
      };
      name="x_prjn";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] 0.80219531;-0.86114419;0.66741771;-0.95372766;-0.50205368;-0.75487661;      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @[0] {
	name="PLOT_1";
	value 1 0=1;
       };
      };
      name="y_prjn";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      ar {
       name=;
	    [6] -0.19432957;0.3668336;0.6415717;0.23273477;1.3112323;-0.32664657;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
   };
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  step_prog=NULL;
  tags=;
  desc=;
  Program @[0] {
   name="AXTaskGen";
   tags=;
   desc="generates the simple A-X target detection task";
   flags=;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=DynEnumType;
    el_def=0;
    DynEnumType @[0] {
     name="Input";
     desc=;
     enums {
      name=;
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @[0] {
       name="I_A";
       value=0;
       desc=;
      };
      DynEnumItem @[1] {
       name="I_B";
       value=1;
       desc=;
      };
      DynEnumItem @[2] {
       name="I_C";
       value=2;
       desc=;
      };
      DynEnumItem @[3] {
       name="I_X";
       value=3;
       desc=;
      };
      DynEnumItem @[4] {
       name="I_Y";
       value=4;
       desc=;
      };
      DynEnumItem @[5] {
       name="I_Z";
       value=5;
       desc=;
      };
     };
     bits=0;
    };
    DynEnumType @[1] {
     name="Output";
     desc=;
     enums {
      name=;
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @[0] {
       name="O_N";
       value=0;
       desc=;
      };
      DynEnumItem @[1] {
       name="O_T";
       value=1;
       desc=;
      };
     };
     bits=0;
    };
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="input_data";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects[1].data.gp[0][0]$0$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK;
     desc=;
    };
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="unit_names";
     var_type=T_Object;
     object_type=taOBase;
     object_val=.projects[1].data.gp[0][1]$1$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK;
     desc=;
    };
    ProgVar @[1] {
     name="input_unit";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=.projects[1].programs[0].types[0]$2$;
      value=5;
     };
     objs_ptr=0;
     flags=NULL_CHECK;
     desc=;
    };
    ProgVar @[2] {
     name="output_unit";
     var_type=T_DynEnum;
     dyn_enum_val {
      enum_type=.projects[1].programs[0].types[1]$3$;
      value=0;
     };
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK;
     desc=;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   load_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    InitNamedUnits @[0] {
     desc=;
     flags=;
     input_data_var=.projects[1].programs[0].args[0]$4$;
     unit_names_var=.projects[1].programs[0].vars[0]$5$;
     network_var=NULL;
     init_label_net=1;
     n_lay_name_chars=1;
    };
   };
   prog_code {
    name=;
    el_typ=ProgEl;
    el_def=0;
    ResetDataRows @[0] {
     desc=;
     flags=;
     data_var=$4$;
    };
    ForLoop @[1] {
     desc=;
     flags=;
     loop_code {
      name=;
      el_typ=ProgEl;
      el_def=0;
      IfElse @[0] {
       desc=;
       flags=;
       cond {
	expr="input_unit == I_A ||  input_unit == I_X";
	flags=;
	var_expr="$#0#$ == I_A ||  $#0#$ == I_X";
	vars {
	};
	var_names{ input_unit;	};
	bad_vars{ 	};
       };
       true_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=;
	 result_var=.projects[1].programs[0].vars[2]$6$;
	 expr {
	  expr="O_T";
	  flags=;
	  var_expr="O_T";
	  vars {
	  };
	  var_names{ 	  };
	  bad_vars{ 	  };
	 };
	};
       };
       false_code {
	name=;
	el_typ=ProgEl;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=;
	 result_var=$6$;
	 expr {
	  expr="O_N";
	  flags=;
	  var_expr="O_N";
	  vars {
	  };
	  var_names{ 	  };
	  bad_vars{ 	  };
	 };
	};
       };
      };
      PrintVar @[1] {
       desc=;
       flags=;
       message=;
       print_var=.projects[1].programs[0].vars[1]$7$;
       print_var2=$6$;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
      };
      AddNewDataRow @[2] {
       desc=;
       flags=;
       data_var=$4$;
      };
      SetUnitsVar @[3] {
       desc=;
       flags=;
       input_data_var=$4$;
       set_nm=1;
       offset=NULL;
       unit_1=$7$;
       unit_2=$6$;
       unit_3=NULL;
       unit_4=NULL;
      };
      DoneWritingDataRow @[4] {
       desc=;
       flags=;
       data_var=$4$;
      };
      IfBreak @[5] {
       desc=;
       flags=;
       cond {
	expr="input_unit ==  I_Z";
	flags=;
	var_expr="$#0#$ ==  I_Z";
	vars {
	};
	var_names{ input_unit;	};
	bad_vars{ 	};
       };
      };
     };
     init {
      expr="input_unit = 0";
      flags=NO_VAR_ERRS;
      var_expr="$#0#$ = 0";
      vars {
      };
      var_names{ input_unit;      };
      bad_vars{       };
     };
     test {
      expr="input_unit <= I_Z";
      flags=NO_VAR_ERRS;
      var_expr="$#0#$ <= I_Z";
      vars {
      };
      var_names{ input_unit;      };
      bad_vars{       };
     };
     iter {
      expr="input_unit++";
      flags=NO_VAR_ERRS;
      var_expr="$#0#$++";
      vars {
      };
      var_names{ input_unit;      };
      bad_vars{       };
     };
    };
   };
  };
  Program_Group @.gp[0] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   step_prog=.projects[1].programs.gp[0][4]$8$;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @[0] {
    name="LeabraBatch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=SHOW_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=.projects[1].networks[0]$9$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$0$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
     };
     ProgVar @[2] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="maximum number of batch runs to perform";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK;
      desc="batch counter";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=.projects[1].programs.gp[0][0].args[0]$10$;
      local_ctr_var=.projects[1].programs.gp[0][0].vars[0]$11$;
      counter=Network::batch;
     };
    };
    prog_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=;
      network_var=$10$;
      local_ctr_var=$11$;
      counter=Network::batch;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=;
      loop_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=;
	target=.projects[1].programs.gp[0][1]$12$;
	targ_ld_init="*LeabraTrain*";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ network;	   };
	   bad_vars{ 	   };
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ input_data;	   };
	   bad_vars{ 	   };
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	   flags=;
	   var_expr="true";
	   vars {
	   };
	   var_names{ 	   };
	   bad_vars{ 	   };
	  };
	 };
	};
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=;
	network_var=$10$;
	local_ctr_var=$11$;
	counter=Network::batch;
       };
      };
      test {
       expr="batch < max_batch";
       flags=;
       var_expr="$#0#$ < $#1#$";
       vars {
       };
       var_names{ batch;max_batch;       };
       bad_vars{        };
      };
     };
    };
   };
   Program @[1] {
    name="LeabraTrain";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=SHOW_STEP;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @[0] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @[1] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$9$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="network to train";
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$0$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="datatable with training patterns";
     };
     ProgVar @[2] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="max_epoch";
      var_type=T_Int;
      int_val=500;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="maximum number of epochs to run";
     };
     ProgVar @[1] {
      name="epoch";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
     };
     ProgVar @[2] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
     };
     ProgVar @[3] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects[1].programs.gp[0][1].types[0]$13$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="how to initialize the random numbers when the Init button is pressed";
     };
     ProgVar @[4] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
     };
     ProgVar @[5] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects[1].programs.gp[0][1].objs[0]$14$;
      objs_ptr=1;
      flags=NULL_CHECK;
      desc="random seed that is used at start of training -- if OldSeed is called";
     };
     ProgVar @[6] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[1].networks[0].train_time$15$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=;
      result_var=.projects[1].programs.gp[0][1].args[2]$16$;
      expr {
       expr="false";
       flags=;
       var_expr="false";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][1].args[0]$17$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	 flags=;
	 var_expr="false";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=.projects[1].programs.gp[0][1].vars[6]$18$;
      expr {
       expr="network.train_time";
       flags=;
       var_expr="$#0#$.train_time";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=;
      cond {
       expr="rnd_init == OLD_SEED";
       flags=;
       var_expr="$#0#$ == OLD_SEED";
       vars {
       };
       var_names{ rnd_init;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=;
	result_var=NULL;
	obj=.projects[1].programs.gp[0][1].vars[5]$19$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=;
	result_var=NULL;
	obj=$19$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     IfGuiPrompt @[4] {
      desc="don't initialize weights without checking";
      flags=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$17$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	 flags=;
	 var_expr="$#0#$.name << \" Weights Initialized\"";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=;
      result_var=$18$;
      expr {
       expr="network.train_time";
       flags=;
       var_expr="$#0#$.train_time";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=;
      result_var=NULL;
      obj=$18$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	 flags=;
	 var_expr="true";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=;
      obj=$17$;
      path="train_mode";
      expr {
       expr="train_mode";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ train_mode;       };
       bad_vars{        };
      };
      update_after=0;
     };
     IfElse @[3] {
      desc=;
      flags=;
      cond {
       expr="no_prompts";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ no_prompts;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=;
	result_var=NULL;
	obj=$17$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       PrintExpr @[1] {
	desc=;
	flags=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	 flags=;
	 var_expr="$#0#$.name << \" Weights Initialized\"";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     AssignExpr @[4] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=;
      result_var=.projects[1].programs.gp[0][1].vars[1]$20$;
      expr {
       expr="network.epoch";
       flags=;
       var_expr="$#0#$.epoch";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     WhileLoop @[5] {
      desc="main loop over epochs of training";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=;
	target=.projects[1].programs.gp[0][2]$21$;
	targ_ld_init="*LeabraEpoch*";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ network;	   };
	   bad_vars{ 	   };
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ input_data;	   };
	   bad_vars{ 	   };
	  };
	 };
	};
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=;
	network_var=$17$;
	local_ctr_var=$20$;
	counter=Network::epoch;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	 flags=;
	 var_expr="$#0#$.cnt_err <= $#1#$";
	 vars {
	 };
	 var_names{ network;err_stopcrit;	 };
	 bad_vars{ 	 };
	};
       };
      };
      test {
       expr="epoch < max_epoch";
       flags=;
       var_expr="$#0#$ < $#1#$";
       vars {
       };
       var_names{ epoch;max_epoch;       };
       bad_vars{        };
      };
     };
     MethodCall @[6] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=;
      result_var=NULL;
      obj=$18$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
   };
   Program @[2] {
    name="LeabraEpoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=SHOW_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$9$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="network to operate on";
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$0$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="table of patterns to present to the network, one row at a time";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=DataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
     };
     ProgVar @[1] {
      name="trial";
      var_type=T_Int;
      int_val=5;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK;
      desc="current trial (event) within the epoch -- increments automatically";
     };
     ProgVar @[2] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects[1].data.gp[1][0]$22$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
     };
     ProgVar @[3] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects[1].networks[0].epoch_time$23$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="timer to record time required to perform one epoch of processing (object is on network -- this is a pointer to it)";
     };
     ProgVar @[4] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=6;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=.projects[1].programs.gp[0][2].args[0]$24$;
      local_ctr_var=.projects[1].programs.gp[0][2].vars[1]$25$;
      counter=Network::trial;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=.projects[1].programs.gp[0][2].vars[3]$26$;
      expr {
       expr="network.epoch_time";
       flags=;
       var_expr="$#0#$.epoch_time";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter (local variable and in the network)";
      flags=;
      network_var=$24$;
      local_ctr_var=$25$;
      counter=Network::trial;
     };
     AssignExpr @[1] {
      desc="get pointer to epoch timer object on network";
      flags=;
      result_var=$26$;
      expr {
       expr="network.epoch_time";
       flags=;
       var_expr="$#0#$.epoch_time";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     MethodCall @[2] {
      desc="start the epoch timer to record computation time per epoch";
      flags=;
      result_var=NULL;
      obj=$26$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	 flags=;
	 var_expr="true";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][2].vars[2]$27$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetDataLoop @[4] {
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the trial program, passing network and input_data";
	flags=;
	target=.projects[1].programs.gp[0][3]$28$;
	targ_ld_init="*LeabraTrial*";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ network;	   };
	   bad_vars{ 	   };
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ input_data;	   };
	   bad_vars{ 	   };
	  };
	 };
	};
       };
       IfElse @[1] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	 flags=;
	 var_expr="$#0#$.Compute_Weights_Test($#1#$+1)";
	 vars {
	 };
	 var_names{ network;trial;	 };
	 bad_vars{ 	 };
	};
	true_code {
	 name=;
	 el_typ=MethodCall;
	 el_def=0;
	 MethodCall @[0] {
	  desc="update the weight values based on changes computed by trial program";
	  flags=;
	  result_var=NULL;
	  obj=$24$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgEl;
	 el_def=0;
	};
       };
      };
      data_var=.projects[1].programs.gp[0][2].args[1]$29$;
      index_var=.projects[1].programs.gp[0][2].vars[4]$30$;
      order_var=.projects[1].programs.gp[0][2].vars[0]$31$;
      order=PERMUTED;
      item_idx_list{ 0;1;3;5;2;4;      };
      dmem_nprocs=1;
      dmem_this_proc=0;
     };
     IfElse @[5] {
      desc="if full batch mode, update only at end of epoch";
      flags=;
      cond {
       expr="network.wt_update == Network::BATCH";
       flags=;
       var_expr="$#0#$.wt_update == Network::BATCH";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="final update of weights based on accumulated changes";
	flags=;
	result_var=NULL;
	obj=$24$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     MethodCall @[6] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=;
      result_var=NULL;
      obj=$24$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[7] {
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=;
      target=.projects[1].programs.gp[0][8]$32$;
      targ_ld_init="*LeabraEpochMonitor*";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[8] {
      desc="done with the computation in the epoch -- record time it took";
      flags=;
      result_var=NULL;
      obj=$26$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
   };
   Program @[3] {
    name="LeabraTrial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=SHOW_STEP;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$9$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="network to operate on -- typically set by higher-level calling programs";
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$0$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="datatable containing training input/output patterns";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="phase_no";
      var_type=T_Int;
      int_val=2;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="determines whether to update any network view displays after trial is completed";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=.projects[1].programs.gp[0][3].args[0]$33$;
      local_ctr_var=.projects[1].programs.gp[0][3].vars[0]$34$;
      counter=LeabraNetwork::phase_no;
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=;
      network_var=$33$;
      local_ctr_var=$34$;
      counter=LeabraNetwork::phase_no;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=;
      result_var=NULL;
      obj=$33$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=;
	target=$8$;
	targ_ld_init="*LeabraSettle*";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ network;	   };
	   bad_vars{ 	   };
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ input_data;	   };
	   bad_vars{ 	   };
	  };
	 };
	};
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=;
	network_var=$33$;
	local_ctr_var=$34$;
	counter=LeabraNetwork::phase_no;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=;
	result_var=NULL;
	obj=$33$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
       flags=;
       var_expr="$#0#$ < $#1#$.phase_max";
       vars {
       };
       var_names{ phase_no;network;       };
       bad_vars{        };
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=;
      result_var=NULL;
      obj=$33$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[4] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=;
      target=.projects[1].programs.gp[0][7]$35$;
      targ_ld_init="*LeabraTrialMonitor*";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     NetUpdateView @[5] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=;
      network_var=$33$;
      update_var=.projects[1].programs.gp[0][3].vars[1]$36$;
     };
    };
   };
   Program @[4] {
    name="LeabraSettle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$9$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc=;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$0$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc=;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK;
      desc="current cycle of settling (local loop counter)";
     };
     ProgVar @[1] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="if true, will update network views at end of settling";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=.projects[1].programs.gp[0][4].args[0]$37$;
      local_ctr_var=.projects[1].programs.gp[0][4].vars[0]$38$;
      counter=Network::cycle;
     };
    };
    prog_code {
     name=;
     el_typ=NetCounterInit;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=;
      network_var=$37$;
      local_ctr_var=$38$;
      counter=Network::cycle;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=;
      result_var=NULL;
      obj=$37$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=;
      target=.projects[1].programs.gp[0][6]$39$;
      targ_ld_init="*ApplyInputs*";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ input_data;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=;
      result_var=NULL;
      obj=$37$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=;
      cond {
       expr="network.phase_no <= 1";
       flags=;
       var_expr="$#0#$.phase_no <= 1";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=.projects[1].programs.gp[0][4].vars[1]$40$;
	expr {
	 expr="network.min_cycles";
	 flags=;
	 var_expr="$#0#$.min_cycles";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=;
	result_var=$40$;
	expr {
	 expr="network.min_cycles_phase2";
	 flags=;
	 var_expr="$#0#$.min_cycles_phase2";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=;
      loop_code {
       name=;
       el_typ=ProgramCall;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=;
	target=.projects[1].programs.gp[0][5]$41$;
	targ_ld_init="*LeabraCycle*";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	   flags=;
	   var_expr="$#0#$";
	   vars {
	   };
	   var_names{ network;	   };
	   bad_vars{ 	   };
	  };
	 };
	};
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=;
	network_var=$37$;
	local_ctr_var=$38$;
	counter=Network::cycle;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=;
	cond {
	 expr="cycle < min_cycles";
	 flags=;
	 var_expr="$#0#$ < $#1#$";
	 vars {
	 };
	 var_names{ cycle;min_cycles;	 };
	 bad_vars{ 	 };
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	 flags=;
	 var_expr="($#0#$.maxda < $#0#$.maxda_stopcrit) ||
 ($#0#$.trg_max_act > $#0#$.trg_max_act_stopcrit)";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
       flags=;
       var_expr="$#0#$ < $#1#$.cycle_max";
       vars {
       };
       var_names{ cycle;network;       };
       bad_vars{        };
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=;
      result_var=NULL;
      obj=$37$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
       flags=;
       var_expr="$#0#$.phase == LeabraNetwork::MINUS_PHASE";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=;
	result_var=NULL;
	obj=$37$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=;
      cond {
       expr="network.phase_no == 1";
       flags=;
       var_expr="$#0#$.phase_no == 1";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=;
	result_var=NULL;
	obj=$37$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=;
      network_var=$37$;
      update_var=.projects[1].programs.gp[0][4].vars[2]$42$;
     };
    };
   };
   Program @[5] {
    name="LeabraCycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$9$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc=;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][5].args[0]$43$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=;
      network_var=$43$;
      update_var=.projects[1].programs.gp[0][5].vars[0]$44$;
     };
    };
   };
   Program @[6] {
    name="ApplyInputs";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$0$;
      network=$9$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	ext_flags=EXT;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	chan_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	ext_flags=TARG;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	ext_flags=;
	noise {name="": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$9$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="network to apply inputs to -- typically set by calling program";
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$0$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="input datatable containing input/output patterns";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects[1].programs.gp[0][6].objs[0]$45$;
      objs_ptr=1;
      flags=NULL_CHECK;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][6].vars[0]$46$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=0;
	def_val=;
	expr {
	 expr="input_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ input_data;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=0;
	def_val=;
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=;
      result_var=NULL;
      obj=$46$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	 flags=;
	 var_expr="false";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=;
      result_var=NULL;
      obj=$46$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
   };
   Program @[7] {
    name="LeabraTrialMonitor";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="group_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="group_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="phase_no";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="phase_no";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="cycle";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="minus_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[8] {
	name="ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[9] {
	name="act";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$9$;
      data=$22$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$9$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="network to record data from";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$22$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
     };
     ProgVar @[1] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[1].programs.gp[0][7].objs[0]$47$;
      objs_ptr=1;
      flags=NULL_CHECK;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][7].vars[1]$48$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=0;
	def_val=;
	expr {
	 expr="trial_mon_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ trial_mon_data;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=0;
	def_val=;
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=;
      result_var=NULL;
      obj=$48$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	 flags=;
	 var_expr="false";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=;
      result_var=NULL;
      obj=$48$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	 flags=;
	 var_expr="true";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][7].vars[0]$49$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=;
      result_var=NULL;
      obj=$48$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$49$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][7].args[0]$50$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ trial_mon_data;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	 flags=;
	 var_expr="1";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
    };
   };
   Program @[8] {
    name="LeabraEpochMonitor";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @[0] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @[0] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[1] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[2] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[3] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[4] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[5] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$9$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[6] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @[7] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$9$;
      data=.projects[1].data.gp[1][1]$51$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$9$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="network to get data from";
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$51$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="data table to write the epoch data to";
     };
     ProgVar @[1] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects[1].programs.gp[0][8].objs[0]$52$;
      objs_ptr=1;
      flags=NULL_CHECK;
      desc="network monitor object that contains full specs for what to record and where to get it";
     };
     ProgVar @[2] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$23$;
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=AssignExpr;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=.projects[1].programs.gp[0][8].vars[2]$53$;
      expr {
       expr="network.epoch_time";
       flags=;
       var_expr="$#0#$.epoch_time";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][8].vars[1]$54$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=0;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ epoch_mon_data;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=0;
	def_val=;
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=;
      result_var=NULL;
      obj=$54$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	 flags=;
	 var_expr="false";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=;
      result_var=NULL;
      obj=$54$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	 flags=;
	 var_expr="true";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=;
      result_var=NULL;
      obj=.projects[1].programs.gp[0][8].vars[0]$55$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=;
      result_var=NULL;
      obj=$54$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=;
      result_var=$53$;
      expr {
       expr="network.epoch_time";
       flags=;
       var_expr="$#0#$.epoch_time";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$55$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=0;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	 flags=;
	 var_expr="$#0#$.used.GetTotSecs()";
	 vars {
	 };
	 var_names{ epoch_timer;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=0;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	 flags=;
	 var_expr="\"epoch_time_tot\"";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=0;
	def_val=;
	expr {
	 expr="-1";
	 flags=;
	 var_expr="-1";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=;
      result_var=NULL;
      obj=$55$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="const Variant&";
	name="val";
	required=0;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	 flags=;
	 var_expr="$#0#$.used.GetUsrSecs()";
	 vars {
	 };
	 var_names{ epoch_timer;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="col_name";
	required=0;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	 flags=;
	 var_expr="\"epoch_time_usr\"";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=0;
	def_val=;
	expr {
	 expr="-1";
	 flags=;
	 var_expr="-1";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=;
      result_var=NULL;
      obj=$55$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
   };
   Program @[9] {
    name="SaveWeights";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=;
    objs {
     name=;
     el_typ=taOBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$9$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc=;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="user-provided tag (startup script will set this!)";
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK;
      desc="user-provided subdirectory to save weights in";
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK;
      desc="final generated file name -- do not edit!";
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="string rep of epoch with leading zeros";
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="string rep of batch with leading zeros";
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK;
      desc="batch + epoch";
     };
    };
    functions {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    load_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=;
      cond {
       expr="taMisc::dmem_proc > 0";
       flags=;
       var_expr="taMisc::dmem_proc > 0";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=;
      result_var=.projects[1].programs.gp[0][9].vars[4]$56$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=0;
	def_val=;
	expr {
	 expr="network.batch";
	 flags=;
	 var_expr="$#0#$.batch";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=0;
	def_val=;
	expr {
	 expr="2";
	 flags=;
	 var_expr="2";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=;
      result_var=.projects[1].programs.gp[0][9].vars[3]$57$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=0;
	def_val=;
	expr {
	 expr="network.epoch";
	 flags=;
	 var_expr="$#0#$.epoch";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=0;
	def_val=;
	expr {
	 expr="4";
	 flags=;
	 var_expr="4";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=;
      result_var=.projects[1].programs.gp[0][9].vars[5]$58$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
       flags=;
       var_expr="$#0#$ + \".\" + batch_str + \"_\" + epoch_str";
       vars {
       };
       var_names{ tag;       };
       bad_vars{        };
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=;
      result_var=.projects[1].programs.gp[0][9].vars[2]$59$;
      obj=.projects[1].programs.gp[0][9].args[0]$60$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	 flags=;
	 var_expr="\".wts.gz\"";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ final_tag;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ wts_subdir;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	 flags=;
	 var_expr="false";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=;
      result_var=NULL;
      obj=$60$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="const taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ fname;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	 flags=;
	 var_expr="Network::NET_FMT";
	 vars {
	 };
	 var_names{ 	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
    };
   };
  };
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   m_data=.projects[1]$61$;
   name="Browser";
   visible=1;
   m_is_root=0;
   m_is_proj_viewer=1;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     m_data=NULL;
     name="Application";
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     m_data=NULL;
     name="Tree";
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$61$;
    };
    PanelViewer @[1] {
     m_data=NULL;
     name="Panels";
     visible=1;
    };
    T3DataViewer @[2] {
     m_data=NULL;
     name="T3Frames";
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       m_data=NULL;
       name="Network_0";
       visible=1;
       root_view {
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 NetView @[0] {
	  m_data=$9$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  lay_disp_modes{ Input=0;Hidden=0;Output=0;	  };
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs[0]$62$;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  display=1;
	  ordered_uvg_list{ act;	  };
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=4: y=4: z=3: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.02;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_F;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	  };
	 };
	 GraphTableView @[1] {
	  m_data=$51$;
FloatTransform @*(.m_transform) {scale={x=0.649613: y=0.6496129: z=0.6496134: }: rotate={x=0.8604479: y=-0.5067047: z=-0.05377775: rot=0.2454511: }: translate={x=1.109841: y=0.9358078: z=-0.06408901: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    m_data=.projects[1].data.gp[1][1].data[0]$63$;
	    m_transform=NULL;
	    name="batch";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    m_data=.projects[1].data.gp[1][1].data[1]$64$;
	    m_transform=NULL;
	    name="epoch";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    m_data=.projects[1].data.gp[1][1].data[2]$65$;
	    m_transform=NULL;
	    name="avg_sse";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.6211656: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    m_data=.projects[1].data.gp[1][1].data[3]$66$;
	    m_transform=NULL;
	    name="cnt_err";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=2: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    m_data=.projects[1].data.gp[1][1].data[4]$67$;
	    m_transform=NULL;
	    name="avg_ext_rew";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    m_data=.projects[1].data.gp[1][1].data[5]$68$;
	    m_transform=NULL;
	    name="avg_cycles";
	    visible=1;
	    fixed_range {fix_min=0: min=17.5: fix_max=0: max=25.83333: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    m_data=.projects[1].data.gp[1][1].data[6]$69$;
	    m_transform=NULL;
	    name="epoch_time_tot";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    m_data=.projects[1].data.gp[1][1].data[7]$70$;
	    m_transform=NULL;
	    name="epoch_time_usr";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=0.649613: y=0.6496129: z=0.6496134: }: rotate={x=0.8604479: y=-0.5067047: z=-0.05377775: rot=0.2454511: }: translate={x=1.109841: y=0.9358078: z=-0.06408901: }: };
	  view_rows=10000;
	  view_range {min=0: max=4: };
	  display_on=1;
	  manip_ctrl_on=1;
	  x_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=4: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=4: };
	   range {min=0: max=4: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Z;
	   col_name="batch";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="avg_sse";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0.6211656: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0.6211656: };
	   range {min=0: max=0.6211656: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  plot_2 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	  };
	  plot_3 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	  };
	  plot_4 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	  };
	  plot_5 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	  };
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  graph_type=XY;
	  plot_style=LINE;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  color_mode=VALUE_COLOR;
	  negative_draw=0;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  label_spacing=-1;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  err_1 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_2 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_3 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_4 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_5 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$62$;
	   auto_scale=0;
	  };
	  raster_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  width=1;
	  depth=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	 GridTableView @[2] {
	  m_data=$22$;
FloatTransform @*(.m_transform) {scale={x=0.779668: y=0.779668: z=0.779668: }: rotate={x=1: y=0: z=0: rot=0.1187652: }: translate={x=1.070672: y=-0.3119916: z=-4.729297e-06: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    m_data=.projects[1].data.gp[1][0].data[0]$71$;
	    m_transform=NULL;
	    name="batch";
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    m_data=.projects[1].data.gp[1][0].data[1]$72$;
	    m_transform=NULL;
	    name="epoch";
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    m_data=.projects[1].data.gp[1][0].data[2]$73$;
	    m_transform=NULL;
	    name="trial";
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[3] {
	    m_data=.projects[1].data.gp[1][0].data[3]$74$;
	    m_transform=NULL;
	    name="trial_name";
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[4] {
	    m_data=.projects[1].data.gp[1][0].data[4]$75$;
	    m_transform=NULL;
	    name="group_name";
	    visible=0;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[5] {
	    m_data=.projects[1].data.gp[1][0].data[5]$76$;
	    m_transform=NULL;
	    name="phase_no";
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[6] {
	    m_data=.projects[1].data.gp[1][0].data[6]$77$;
	    m_transform=NULL;
	    name="minus_cycles";
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[7] {
	    m_data=.projects[1].data.gp[1][0].data[7]$78$;
	    m_transform=NULL;
	    name="sse";
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[8] {
	    m_data=.projects[1].data.gp[1][0].data[8]$79$;
	    m_transform=NULL;
	    name="ext_rew";
	    visible=0;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[9] {
	    m_data=.projects[1].data.gp[1][0].data[9]$80$;
	    m_transform=NULL;
	    name="Input_act";
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[10] {
	    m_data=.projects[1].data.gp[1][0].data[10]$81$;
	    m_transform=NULL;
	    name="Hidden_act";
	    visible=1;
	    text_width=4;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[11] {
	    m_data=.projects[1].data.gp[1][0].data[11]$82$;
	    m_transform=NULL;
	    name="Output_act";
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.779668: y=0.779668: z=0.779668: }: rotate={x=1: y=0: z=0: rot=0.1187652: }: translate={x=1.070672: y=-0.3119916: z=-4.729297e-06: }: };
	  view_rows=6;
	  view_range {min=0: max=5: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=2: max=6: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$62$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	 };
	};
       };
       camera_pos {x=0.8697404: y=0.5564175: z=2.785391: };
       camera_orient {x=0: y=0: z=1: rot=0: };
       camera_focdist=3.112823;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
      };
      T3DataViewFrame @[1] {
       m_data=NULL;
       name="TrialOutputData_col_Hidden_act_Cluster";
       visible=1;
       root_view {
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  m_data=.projects[1].data.gp[2][0]$83$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    m_data=.projects[1].data.gp[2][0].data[0]$84$;
	    m_transform=NULL;
	    name="X";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    m_data=.projects[1].data.gp[2][0].data[1]$85$;
	    m_transform=NULL;
	    name="Y";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    m_data=.projects[1].data.gp[2][0].data[2]$86$;
	    m_transform=NULL;
	    name="Label";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=52: };
	  display_on=1;
	  manip_ctrl_on=1;
	  x_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="X";
	   fixed_range {fix_min=0: min=0: fix_max=1: max=13.43965: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=13.43965: };
	   range {min=0: max=13.43965: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Y";
	   fixed_range {fix_min=1: min=0.2: fix_max=1: max=5.8: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0.2: max=5.8: };
	   range {min=0.2: max=5.8: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  plot_2 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="Label";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	  };
	  plot_3 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	  };
	  plot_4 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	  };
	  plot_5 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	  };
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  graph_type=XY;
	  plot_style=LINE;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  color_mode=VALUE_COLOR;
	  negative_draw=0;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  label_spacing=-1;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  err_1 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_2 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_3 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_4 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_5 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$62$;
	   auto_scale=0;
	  };
	  raster_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  width=1;
	  depth=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       camera_pos {x=1.4275: y=0.445: z=1.624621: };
       camera_orient {x=0: y=0: z=1: rot=0: };
       camera_focdist=1.637121;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
      };
      T3DataViewFrame @[2] {
       m_data=NULL;
       name="TrialOutputData_col_Hidden_act_PCA2dPrjn";
       visible=1;
       root_view {
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GraphTableView @[0] {
	  m_data=.projects[1].data.gp[2][1]$87$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    m_data=.projects[1].data.gp[2][1].data[0]$88$;
	    m_transform=NULL;
	    name="trial_name";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    m_data=.projects[1].data.gp[2][1].data[1]$89$;
	    m_transform=NULL;
	    name="x_prjn";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    m_data=.projects[1].data.gp[2][1].data[2]$90$;
	    m_transform=NULL;
	    name="y_prjn";
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=10000;
	  view_range {min=0: max=5: };
	  display_on=1;
	  manip_ctrl_on=1;
	  x_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="x_prjn";
	   fixed_range {fix_min=0: min=-0.9537277: fix_max=0: max=0.8021953: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.9537277: max=0.8021953: };
	   range {min=-0.9537277: max=0.8021953: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  plot_1 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="y_prjn";
	   fixed_range {fix_min=0: min=-0.3266466: fix_max=0: max=1.311232: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=-0.3266466: max=1.311232: };
	   range {min=-0.3266466: max=1.311232: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  plot_2 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=Y;
	   col_name="trial_name";
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="red": r=1: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=-6e-07: max=6e-07: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=SQUARE;
	  };
	  plot_3 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=DIAMOND;
	  };
	  plot_4 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=TRIANGLE;
	  };
	  plot_5 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	   data_range {min=0: max=1: };
	   range {min=0: max=1: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=PLUS;
	  };
	  alt_y_2=0;
	  alt_y_3=0;
	  alt_y_4=0;
	  alt_y_5=0;
	  graph_type=XY;
	  plot_style=POINTS;
	  line_width=2;
	  point_size=MEDIUM;
	  point_spacing=1;
	  bar_space=0.2;
	  color_mode=VALUE_COLOR;
	  negative_draw=0;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  label_spacing=-1;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  err_1 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_2 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_3 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_4 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_5 {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   line_style=SOLID;
	   point_style=CIRCLE;
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=0;
	   zero=0;
	   spec=$62$;
	   auto_scale=0;
	  };
	  raster_axis {
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   data_range {min=0: max=0: };
	   range {min=0: max=0: };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  width=1;
	  depth=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       camera_pos {x=1.451592: y=0.445: z=1.652272: };
       camera_orient {x=0: y=0: z=1: rot=0: };
       camera_focdist=1.664772;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
      };
      T3DataViewFrame @[3] {
       m_data=NULL;
       name="StdInputData";
       visible=1;
       root_view {
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	 GridTableView @[0] {
	  m_data=$0$;
FloatTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    m_data=.projects[1].data.gp[0][0].data[0]$91$;
	    m_transform=NULL;
	    name="Name";
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    m_data=.projects[1].data.gp[0][0].data[1]$92$;
	    m_transform=NULL;
	    name="Input";
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[2] {
	    m_data=.projects[1].data.gp[0][0].data[2]$93$;
	    m_transform=NULL;
	    name="Output";
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=5;
	  view_range {min=1: max=5: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=2: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$62$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	 };
	 GridTableView @[1] {
	  m_data=$1$;
FloatTransform @*(.m_transform) {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=1.13: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @[0] {
	    m_data=.projects[1].data.gp[0][1].data[0]$94$;
	    m_transform=NULL;
	    name="Input";
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @[1] {
	    m_data=.projects[1].data.gp[0][1].data[1]$95$;
	    m_transform=NULL;
	    name="Output";
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=0.33: y=0.33: z=0.33: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=1.13: z=0: }: };
	  view_rows=1;
	  view_range {min=0: max=0: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=1: };
	  width=3.3;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=1;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$62$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	 };
	};
       };
       camera_pos {x=1.582117: y=0.7139999: z=1.759859: };
       camera_orient {x=0: y=0: z=1: rot=0: };
       camera_focdist=1.769859;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     m_data=NULL;
     name="Tools";
     visible=1;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 use_change_log=0;
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   name="Network_0";
   desc=;
   specs {
    name=;
    el_typ=LeabraUnitSpec;
    el_def=0;
    LeabraUnitSpec @[0] {
     name="LeabraUnitSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects[1].networks[0].specs[3].children[0]$96$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {thr=0.25: gain=600: nvar=0.005: avg_dt=0.005: send_delta=1: i_thr=STD: };
     spike {decay=0.05: v_m_r=0: eq_gain=10: eq_dt=0.02: hard_gain=0.4: };
     depress {p_spike=P_NXX1: rec=0.2: asymp_act=0.5: depl=0.2105263: max_amp=2: };
     opt_thresh {send=0.1: delta=0.005: learn=0.01: updt_wts=1: phase_dif=0: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {name="": type=UNIFORM: mean=0.1500000059604645: var=0: par=1: };
     dt {vm=0.3: net=0.7: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: };
     g_bar {e=1: l=0.1: i=1: h=0.01: a=0.03: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.05: b_dec_dt=0.05: a_thr=0.8: d_thr=0.7: g_dt=0.1: init=0: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=0: trl=0: };
     act_reg {on=0: min=0: max=0.35: wt_dt=0.2: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     noise_type=NO_NOISE;
     noise {name="": type=GAUSSIAN: mean=0: var=0.001000000047497451: par=1: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=1;
      cur_val=0;
     };
    };
    LeabraLayerSpec @[1] {
     name="HiddenLayer";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Input_Output";
       desc=;
       unique{ compute_i;i_kwta_pt;kwta;       };
       children {
	name=;
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       inhib_group=ENTIRE_LAYER;
       kwta {k_from=USE_PAT_K: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
       compute_i=KWTA_INHIB;
       i_kwta_pt=0.25;
       gp_i_pt=0.2;
       tie_brk {on=0: k_thr=1: diff_thr=0.2: };
       adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
       clamp {hard=1: gain=0.5: d_gain=0: };
       decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
       net_rescale {on=0: max_net=0.6: net_extra=0.2: };
       abs_net_adapt {
	on=0;
	trg_net=0.5;
	tol=0.1;
	abs_lrate=0.1;
       };
      };
     };
     inhib_group=ENTIRE_LAYER;
     kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.25: pat_q=0.5: diff_act_pct=0: act_pct=0.1: gp_i=0: gp_g=0.5: };
     compute_i=KWTA_AVG_INHIB;
     i_kwta_pt=0.6;
     gp_i_pt=0.2;
     tie_brk {on=0: k_thr=1: diff_thr=0.2: };
     adapt_i {type=NONE: tol=0.02: p_dt=0.1: mx_d=0.9: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: d_gain=0: };
     decay {event=1: phase=1: phase2=0: clamp_phase2=0: };
     net_rescale {on=0: max_net=0.6: net_extra=0.2: };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    FullPrjnSpec @[2] {
     name="FullPrjnSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
    };
    LeabraConSpec @[3] {
     name="LeabraConSpec_0";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name=;
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: };
       wt_scale_init {init=0: abs=1: rel=1: };
       wt_sig {gain=6: off=1.25: };
       lrate=0.01;
       cur_lrate=0.01;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	last_ctr=-1;
	default_val=1;
	interpolate=0;
	cur_val=0;
       };
       lmix {hebb=0.001: err=0.999: err_sb=1: };
       savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
       dwt_thresh=0.1;
      };
     };
     rnd {name="": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     inhib=0;
     wt_scale {abs=1: rel=1: };
     wt_scale_init {init=0: abs=1: rel=1: };
     wt_sig {gain=6: off=1.25: };
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      last_ctr=-1;
      default_val=1;
      interpolate=0;
      cur_val=0;
     };
     lmix {hebb=0.001: err=0.999: err_sb=1: };
     savg_cor {cor=0.4: thresh=0.001: norm_con_n=0: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    LeabraLayer @[0] {
     name="Input";
     flags=;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     un_geom {x=3: y=2: n_not_xy=0: n=6: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=3: y=2: n_not_xy=0: n=6: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[1].networks[0].layers[1].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=3: y=2: n_not_xy=0: n=6: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=.projects[1].networks[0].specs[0]$97$: };
     ext_flag=EXT;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {avg=0: max=0: max_i=-1: };
     i_thrs {avg=0: max=0: max_i=-1: };
     acts {avg=0.1583333: max=0.95: max_i=4: };
     acts_p {avg=0.1583333: max=0.95: max_i=4: };
     acts_m {avg=0.1583333: max=0.95: max_i=4: };
     phase_dif_ratio=1;
     kwta {k=1: pct=0.1666667: pct_c=0.8333333: adth_k=1: k_ithr=0: k1_ithr=0: ithr_r=0: ithr_diff=0: tie_brk=0: };
     i_val {kwta=0: g_i=0.25: gp_g_i=0: g_i_orig=0.25: };
     un_g_i {avg=0: max=0: max_i=-1: };
     adapt_i {avg_avg=0.1666667: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     spec {type=LeabraLayerSpec: spec=.projects[1].networks[0].specs[1].children[0]$98$: };
     stm_gain=0.5;
     hard_clamped=1;
     dav=0;
     net_rescale=1;
     avg_netin {avg=0: max=0: max_i=-1: };
     avg_netin_sum {avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     da_updt=0;
     misc_iar{      };
    };
    LeabraLayer @[1] {
     name="Hidden";
     flags=;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=1: };
     un_geom {x=4: y=4: n_not_xy=0: n=16: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=4: y=4: n_not_xy=0: n=16: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       from_type=CUSTOM;
       from=.projects[1].networks[0].layers[0]$99$;
       spec {type=FullPrjnSpec: spec=.projects[1].networks[0].specs[2]$100$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects[1].networks[0].specs[3]$101$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
      LeabraPrjn @[1] {
       name="Fm_Output";
       from_type=CUSTOM;
       from=.projects[1].networks[0].layers[2]$102$;
       spec {type=FullPrjnSpec: spec=$100$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$101$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[1].networks[0].layers[2].projections[0];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=4: y=4: n_not_xy=0: n=16: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$97$: };
     ext_flag=;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {avg=0.4590682: max=0.6847615: max_i=11: };
     i_thrs {avg=3.343001: max=5.036362: max_i=11: };
     acts {avg=0.1691993: max=0.9421194: max_i=11: };
     acts_p {avg=0.1691993: max=0.9421194: max_i=11: };
     acts_m {avg=0.1691048: max=0.9421028: max_i=11: };
     phase_dif_ratio=0.9994416;
     kwta {k=4: pct=0.25: pct_c=0.75: adth_k=1: k_ithr=4.274104: k1_ithr=3.032634: ithr_r=0.3431429: ithr_diff=0.2904632: tie_brk=0: };
     i_val {kwta=3.777516: g_i=3.777516: gp_g_i=0: g_i_orig=3.777516: };
     un_g_i {avg=3.777516: max=3.777516: max_i=0: };
     adapt_i {avg_avg=0.2483672: i_kwta_pt=0.6: g_bar_i=1: g_bar_l=0.1: };
     spec {type=LeabraLayerSpec: spec=.projects[1].networks[0].specs[1]$103$: };
     stm_gain=0.5;
     hard_clamped=0;
     dav=0;
     net_rescale=1;
     avg_netin {avg=0: max=0: max_i=-1: };
     avg_netin_sum {avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     da_updt=0;
     misc_iar{      };
    };
    LeabraLayer @[2] {
     name="Output";
     flags=;
     layer_type=TARGET;
     pos {x=1: y=1: z=2: };
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     act_geom {x=2: y=1: n_not_xy=0: n=2: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       from_type=CUSTOM;
       from=.projects[1].networks[0].layers[1]$104$;
       spec {type=FullPrjnSpec: spec=$100$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$101$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       netin_avg=0;
       netin_rel=0;
       avg_netin_avg=0;
       avg_netin_avg_sum=0;
       avg_netin_rel=0;
       avg_netin_rel_sum=0;
       avg_netin_n=0;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects[1].networks[0].layers[1].projections[1];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      unique_geom=0;
      geom {x=2: y=1: n_not_xy=0: n=2: };
      units_lesioned=0;
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$97$: };
     ext_flag=TARG|EXT;
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     output_name=;
     sse=0;
     icon_value=0;
     netin {avg=0.3151529: max=0.3820235: max_i=0: };
     i_thrs {avg=2.2632: max=2.764318: max_i=0: };
     acts {avg=0.475: max=0.95: max_i=0: };
     acts_p {avg=0.475: max=0.95: max_i=0: };
     acts_m {avg=0.4735676: max=0.9466937: max_i=0: };
     phase_dif_ratio=0.9969844;
     kwta {k=1: pct=0.5: pct_c=0.5: adth_k=1: k_ithr=2.764318: k1_ithr=1.762081: ithr_r=0.4502986: ithr_diff=0.3625622: tie_brk=0: };
     i_val {kwta=2.01264: g_i=0.25: gp_g_i=0: g_i_orig=0.25: };
     un_g_i {avg=2.01264: max=2.01264: max_i=0: };
     adapt_i {avg_avg=0.4951769: i_kwta_pt=0.25: g_bar_i=1: g_bar_l=0.1: };
     spec {type=LeabraLayerSpec: spec=$98$: };
     stm_gain=0.5;
     hard_clamped=1;
     dav=0;
     net_rescale=1;
     avg_netin {avg=0: max=0: max_i=-1: };
     avg_netin_sum {avg=0: max=0: max_i=-1: };
     avg_netin_n=0;
     da_updt=0;
     misc_iar{      };
    };
   };
   flags=;
   auto_build=AUTO_BUILD;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   batch=0;
   epoch=5;
   trial=5;
   cycle=15;
   time=0;
   group_name=;
   trial_name="Y";
   output_name=;
   sse_unit_avg=0;
   sse_sqrt=0;
   sse=0;
   sum_sse=0;
   avg_sse=0;
   cnt_err_tol=0;
   cnt_err=0;
   cur_sum_sse=0;
   avg_sse_n=0;
   cur_cnt_err=0;
   train_time {name="train_time": start={usr=6180: sys=1150: tot=2683278016: }: end={usr=6362: sys=1168: tot=2683278218: }: used={usr=182: sys=18: tot=202: }: n_used=1: };
   epoch_time {name="epoch_time": start={usr=6326: sys=1164: tot=2683278177: }: end={usr=6362: sys=1168: tot=2683278218: }: used={usr=36: sys=4: tot=41: }: n_used=1: };
   trial_time {name="trial_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: n_used=0: };
   settle_time {name="settle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: n_used=0: };
   cycle_time {name="cycle_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: n_used=0: };
   wt_sync_time {name="wt_sync_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: n_used=0: };
   misc_time {name="misc_time": start={usr=0: sys=0: tot=0: }: end={usr=0: sys=0: tot=0: }: used={usr=0: sys=0: tot=0: }: n_used=0: };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   lay_layout=THREE_D;
   n_units=24;
   n_cons=160;
   max_size {x=4: y=4: z=3: };
   font_sizes {
    net_name=0.05;
    net_vals=0.05;
    layer=0.04;
    layer_vals=0.03;
    prjn=0.01;
    unit=0.02;
    un_nm_len=3;
   };
   view_params {
    xy_square=0;
    unit_spacing=0.05;
    prjn_disp=L_R_F;
    prjn_name=0;
    prjn_width=0.002;
    prjn_trans=0.5;
    lay_trans=0.5;
    unit_trans=0.6;
   };
   phase_order=MINUS_PLUS;
   no_plus_test=1;
   trial_init=DECAY_STATE;
   sequence_init=DO_NOTHING;
   first_plus_dwt=ONLY_FIRST_DWT;
   phase=PLUS_PHASE;
   phase_no=2;
   phase_max=2;
   cycle_max=60;
   min_cycles=15;
   min_cycles_phase2=35;
   minus_cycles=15;
   avg_cycles=17.5;
   avg_cycles_sum=0;
   avg_cycles_n=0;
   netin_mod=1;
   send_delta=1;
   maxda_stopcrit=0.005;
   maxda=6.318092e-06;
   trg_max_act_stopcrit=1;
   trg_max_act=0;
   ext_rew=0;
   avg_ext_rew=0;
   avg_ext_rew_sum=0;
   avg_ext_rew_n=0;
  };
 };
};

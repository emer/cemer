// ta_Dump File v2.0
LeabraProject .projects[1] { 
  Doc_Group @.docs = [7] {
    taDoc @[0] { };
    taDoc @[1] { };
    taDoc @[2] { };
    taDoc @[3] { };
    taDoc @[4] { };
    taDoc @[5] { };
    taDoc @[6] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };

      LayerWizElList @.layer_cfg = [3] {
	LayerWizEl @[0] { };
	LayerWizEl @[1] { };
	LayerWizEl @[2] { };
      };
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @[0] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
    taDataAnal @[1] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
    taDataGen @[2] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
    taImageProc @[3] { 
   UserDataItem_List @*(.user_data_) { 
	UserDataItem @[0] { };
   };
};
  };

  DataViewer_List @.viewers = [1] {
    MainWindowViewer @[0] { 
      ToolBar_List @.toolbars = [1] {
	ToolBar @[0] { };
      };

      FrameViewer_List @.frames = [3] {
	tabBrowseViewer @[0] { };
	PanelViewer @[1] { };
	T3DataViewer @[2] { 
	  T3DataViewFrame_List @.frames = [1] {
	    T3DataViewFrame @[0] { };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @[0] { };
      };
    };
  };
};
LeabraProject .projects[1] {
 name="Project_0";
 desc=;
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   name="ProjectDocs";
   auto_open=1;
   text="<html>
<head></head>
<body>

= Building a Complete Model =

This project provides step-by-step directions for constructing a working neural network simulation from the ground up, including programming a simple psychological task (target detection), which we extend through several stages to ultimately simulate the more complex CPT-AX task used in working memory studies.

 '''To return to this document''' at any time, just hit the <code>ProjectDocs</code> tab at the top of this middle panel where you are now reading.

Some basic terminology:
* '''Left browser panel''' is the left portion of the window with a \"tree\" of objects in the simulation (inlcuding the netowrk, and the input/output data, etc).
* '''Middle edit panel''' is where you are currently reading -- it can display different things depending on the selected tabs at the top, and what is currently selected in the left browser panel.  The left-most tab usually shows what is selected in the browser, and the other tabs with \"pins\" down are locked in place and contain this document and the Wizard, which we will be making heavy use of.  The right-most tab represents the configuration information for the 3D display shown in the right-most view panel (which is now called \"Frame1\" and is empty).
* '''Right view panel''' shows 3d displays of various simulation objects, incuding the network, input/output patterns, and graphs of results, etc.

== Basic Task: Target Detection ==

The basic task we'll simulate involves presenting letters one at at a time to the network, and having it identify \"targets\" from \"non-targets\".  The targets are the letters 'A' and 'X', and the non-targets are 'B', 'C', 'Y', and 'Z'.

The network will have 6 input units representing each of these letters, and two output units, one for \"target\" and the other for \"non-target\".  It will have a hidden layer to learn the mapping (though this task is initially so trivial that it doesn't even require a hidden layer -- we'll make it harder later).

== Chapters ==

Here are the steps we'll go through, organized as separate document chapters (which live under the <code>docs</code> section of the browser, as does this document):
# [[.docs.BuildNet]] -- building the network
# [[.docs.InputData]] -- make basic input patterns (data) to present to the network
# [[.docs.Programs]] -- creating and controlling the programs that perform the simulation
# [[.docs.OutputData]] -- monitoring and analyzing the performance of the model<br>
# [[.docs.TaskProgram]] -- writing a program to construct the task input patterns, including more complex tasks.
# [[.docs.PfcBg]] -- adding a prefrontal cortex/basal ganglia to the model to handle the full CPT-AX task.

</body>
</html>
";
  };
  taDoc @[1] {
   name="BuildNet";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Building a Network =

The Wizard makes it easy to get started making a network.  It is located in the <code>wizards</code> section of the browser, and can always be found in the <code>LeabraWizard_0</code> tab at the top of this middle panel.  This link: [[.PanelTab.LeabraWizard_0]] will take you there (return to these docs by pressing the BuildNet tab).

You will see that it is currently configured for 3 layers, which is fine for our purposes.  But how do we tell it how big to make these layers?  The wizard has some layer configuration information tucked inside of it -- to access it, you need to open up the wizard object in the browser (as is true of most things in this simulator).  This link: [[.wizards.LeabraWizard_0.layer_cfg.Input]] will take you directly to the configuration information for the Input layer.  You can see the browser expanding to reveal the other layer configuration information as well.  Here are the layer sizes (<code>n_units</code>) you should enter:

* [[.wizards.LeabraWizard_0.layer_cfg.Input]] = 6
* [[.wizards.LeabraWizard_0.layer_cfg.Hidden]] = 16
* [[.wizards.LeabraWizard_0.layer_cfg.Output]] = 2

Note that the system automatically applies changes when you move from one selection to the next.

Next, return to the [[.PanelTab.LeabraWizard_0]] tab, and at the bottom, click the <code>Network</code> 
menu button, and choose the [[.wizards.LeabraWizard_0.StdNetwork()|Network/StdNetwork]] option.  This pops up a confirmation dialog explaining that it will create a new network according to your current specifications.  Hit OK.

You will see a network appear in the right view panel, and the left browser will expand to reveal all of the objects created (e.g., layers and specifications).  Feel free to click around on these objects now to see what they have in them -- we will just use the defaults so there is no need to change anything.

Now we'll move on to making the [[.docs.InputData]] for the simple target detection task.  Below are a few optional topics that you can explore if you wish (or come back to later at any time):

== Manipulating the 3d View ==

There are different modes and controls for the 3d view located on the extreme right-hand side of the window next to the network display.  Drag the mouse over them to see what they do (a \"tool tip\" should pop up when the mouse hovers over the button).

To begin, you can experiment with the \"hand\" tool -- if you click the mouse and move it around, you'll see that you can manipulate the \"camera view\" into the 3d view of the network.

Two key tips:
* <b>Hold down Shift to move instead of rotate</b> (while moving the mouse).
* <b>Pressing the \"home\" icon restores the initial view</b> (this is the first home one, not the blueprint guy -- the blueprint guy is for saving the current view state as the default view that the home button returns to.

At some point you'll discover that if you don't completely stop before lifting the mouse button, the view continues to rotate -- kind of mezmerizing -- apologies if you spend too much time doing this (we certainly have.. :)

If you have a scroll wheel, you'll see that it acts like a zoom.  The same effect can be had with the <b>Dolly</b> wheel (the term is an analogy to a camera dolly that moves a camera through a scene in filming a movie).

The <b>Rotx</b> and <b>Roty</b> wheels rotate precisely around the x and y axes -- these are often more useful than the mouse-based rotation because they don't introduce off-angles.

The <b>Flashlight</b> button is very useful for zooming in on something of interest (especially for large complicated displays) -- after clicking on it, then click on an object in the view (NOTE: text doesn't work for this purpose).  Thus button stays on until unclicked or another button is clicked, so you can do repeated exploration.

Finally, for extra thrills, you can click the right mouse button (or ctrl+mouse on a Mac) and configure many interesting display options -- check out the different still draw styles, and the stereo options -- dig out those old red/green stereo glasses!

== Configuring the Network View ==

The middle panel tab labeled [[.PanelTab.Network_0]] provides various parameters for controlling the network display.  There are 3 main segments
 (see the wiki [[.Wiki.Network_View]] page for more info):
* Display parameters at the top (font sizes, display style etc) (mouse over to get more info, and explore!)
* Network variable selector -- what value to display in the units in the network view (activations vs. weights vs. netinputs etc).  If you select one of the weight variables (e.g., r.wt for receiving weights into a selected unit; s.wt is for sending weights out), you then need to use the red arrow tool in the viewer to select a unit to view -- it will turn green, and you should be able to see its weights.
* Spec selector and viewer -- this is very handy for seeing where your specs are used in the network -- try clicking on the <code>HiddenLayer</code> and then <code>Input_Output</code> -- note that the green layer border changes color indicating which layers are using these layer specs.  You can also use the context menu to edit the specs right there.

== Changing the Network Configuration ==

You can also configure the network layout interactively in the viewer, including repositioning the layers, and orienting the network display relative to other objects in the view (which we postpone for later, when this arises).

To do this, select the <b>red arrow</b> tool, and you'll see that transparent purple arrow objects now appear on the layers, and a fancy box thing appears on the network text box.  These are the manipulation controls.  Try clicking on one of the horizontal arrows for the Output layer, and moving it around.  This moves within the \"horizontal\" plane (the X-Y plane for the network).  The vertical arrows not surprisingly move in the vertical dimension (the Z axis for the network).

</body>
</html>
";
  };
  taDoc @[2] {
   name="InputData";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Input Data  (Pattenrs to Present to the Network) =

(Note -- to return to this document, click on docs/InputData in the left browser window).

We return to the [[.PanelTab.LeabraWizard_0]] wizard tab, and move across to the next menu button on the
bottom labeled <code>Data</code>, and select the [[.wizards.LeabraWizard_0.StdData()|Data/StdData]] option.  This will bring up a dialog with mostly default information already filled in (and not modifyiable because there are no other options), but there is one parameter we need to specify: <code>n_patterns</code>.  Enter 6 -- one for each of the different input letters.

This will construct a \"data table\" object (much like a spreadsheet or simple data base) that has columns automatically corresponding to the Input and Output layers of the network, with 6 rows where we can specify the different input patterns to the network, which define our simple target detection task.  The Name column is useful for labeling our patterns.  you'll see <code>(matrix)</code> in the Input and Output columns, and if you click on one of those, an extra editor shows up at the bottom of the window to allow you to enter values for the \"matrix\" of input and output units.  The Name column, in contrast, has just a single value for each row (i.e., a \"scalar\"), so it can be edited directly in the main table view.

This data table object is called [[.data.gp.InputData.StdInputData]] and it lives in the <code>data/InputData subgroup</code> in the left browser, in case you need to get back to it.

Here is what you should enter, where we're calling the 1st output unit the \"non-target\" and the 2nd one the target, and the Input units are ordered bottom-to-top, left-to-right:
<table>
<tr><th>Name</th> <th>Input</th> <th>Output</th></tr>
<tr><td>A</td><td>000<br>100</td><td>01</td></tr>
<tr><td>B</td><td>000<br>010</td><td>10</td></tr>
<tr><td>C</td><td>000<br>001</td><td>10</td></tr>
<tr><td>X</td><td>100<br>000</td><td>01</td></tr>
<tr><td>Y</td><td>010<br>000</td><td>10</td></tr>
<tr><td>Z</td><td>001<br>000</td><td>10</td></tr>
</table>

(If you're really lazy, you can just load in these data patterns from the file <code>sim_tutorial_input_data.dtbl</code> by doing [[.data.gp.InputData.StdInputData.Load()|Object/Load]]
on the [[.data.gp.InputData.StdInputData]] object).

== Visualizing the Data Patterns ==

The best way to make sure you've entered the right patterns is to create a \"Grid View\" of your input data -- do this by selecting the [[.data.gp.InputData.StdInputData.NewGridView()|View/New Grid View]] option from the menu at the top of the data table editor that you've been using to enter input patterns with.  Go ahead and keep the \"New Frame\" default for the dialog that pops up (you can also add multiple view elements together in a single 'frame' in the 3d view -- we'll do that later).

This will create a [[.T3Tab.StdInputData]] tab in the right view panel, and display your input patterns, which hopefully match those shown in the above table.  If not, you can correct them by clicking back on StdInputData in the left browser -- you cannot edit values in the grid view display.

There is also a new [[.PanelTab.StdInputData]] middle-panel tab, which contains various parameters for controlling the configuration of the grid view display.  You can mouse-over the fields to get more info.  Many of these require you to hit the Apply button at the bottom before they take effect on the view.

The next step is to create [[.docs.Programs]] to control the presentation of these input patterns to the network.

</body>
</html>
";
  };
  taDoc @[3] {
   name="Programs";
   auto_open=0;
   text="<html>
<head></head>
<body>

= Programs for Controlling the Simulation =

Again return to the [[.PanelTab.LeabraWizard_0]] wizard panel, and now select 
[[.wizards.LeabraWizard_0.StdProgs()|Programs/Std Progs]] from the bottom menu.  (return to these docs by clicking back on <code>docs/Programs</code> in the browser).

This created a set of standard programs that organize the presentation of input patterns to the network into a hierarchy of time scales:

* LeabraBatch -- iterates over multiple simulated \"subjects\" -- each having their own different random initial weights (we won't use this initially).
* LeabraTrain -- a complete training of the network from random initial weights to final correct performance, by iterating over multiple \"epochs\"
* LeabraEpoch -- one full pass through all of the different task input patterns
* LeabraTrial -- processes one input pattern, using two ''phases'' of settling -- the minus phase presents the input stimulus, and allows the network to come up with its own best guess as to the correct response, and the plus phase presents the correct answer to allow the network to learn to perform the task correctly.
* LeabraSettle -- multiple updates of neural unit activations to process a given input/output pattern.
* LeabraCycle -- a single cycle of updating of neural unit activation states (roughly 5-10msec of simulated real time)

There are also some other supporting programs that we'll discuss later.

You might notice that the ApplyInputs program is opened up to show the LayerWriter_0 object -- this was auto-configured to apply the input data values to the appropriate (same name) layers in the network.  If you change the layer names or add additional layers, etc, you may need to go back to this object and hit the AutoConfig button to reconfigure it.  We'll do this later in the tutorial.

== Running the Simulation ==

First, make sure you're viewing the [[.T3Tab.Network_0]] network view tab, and then click on the 
 [[.programs.gp.LeabraAll_Std.LeabraTrain]] program.  Press the 
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] button at the bottom of the window, followed by 
the [[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] button (these links will actually do this for you!).

You should then see the network processing each of the input patterns for the task multiple times, as it iterates over epochs of trials of settles of cycles of processing.  Depending on your hardware, this may wiz by in quite a blur.

Once it finishes, you can see more clearly what it is doing by hitting the [[.programs.gp.LeabraAll_Std.LeabraTrain.Step()|Step]] button, 
which will perform one phase of settling at a time.  You should observe that the network gets the correct output unit active in the minus phase (look for <code>MINUS_PHASE</code> or <code>PLUS_PHASE</code> in the text region at the bottom of the network 3d view display.  It has successfully learned the task!

We'll learn a lot more about how programs work when we write one from scratch to generate our input data for training the network.  If you're adventurous, you can click on them and hit the EditProgram button to see the underlying \"guts\" that make the programs do what they do.  Everything that happens in running the simulation is explicitly listed out, and can be modified in any way that you might want -- this is very powerful and probably a bit dangerous too.. :)  Don't do anything to modify the programs at this point.

The next step is more clearly monitor the performance of the network as it learns, by recording 
[[.docs.OutputData]] from the network.

</body>
</html>
";
  };
  taDoc @[4] {
   name="OutputData";
   auto_open=0;
   text="<html>
<head></head>
<body>
= Monitoring, Analyzing, and Displaying Output Data =

In this section we explore various ways of understanding better how the network is performing.

== Graphing Learning Performance over Epochs ==

To see how your network is learning a given task, the first step is to generate a graph of the learning performance (sum squared error on the training patterns) over epochs.  Fortunately, the default programs are already collecting this data for us, so we just need to display the graph.

The data is being recorded in the [[.data.gp.OutputData.EpochOutputData]] data table object in the <code>data/OutputData subgroup</code>.  You should see a few rows of data from the previous run, and you should notice that the <code>avg_sse</code> column shows a general decrease in average sum-squared-error on the training patterns, ending in a 0, which is what stopped the training.

To graph this data, you just generate a graph view of this data table.  As a general rule in the software, all view information is always generated by a given main object like a datatable or a network -- you don't create a graph and then associate data with it -- it goes the other way.  The menu selection to create the graph view is [[.data.gp.OutputData.EpochOutputData.NewGraphView()|View/New Graph View]].  This time, let's be adventurous and instead of putting this graph in a separate view frame, put it in the <code>Network_0</code> frame.

If you happened to have put it in the wrong frame initially, don't worry -- just do the context menu over the frame view tab on the right (should be called EpochOutputData), and select Delete Frame.  Note that there can be multiple views of the same underlying data.

You should see a graph appear in the upper right of your network display, showing a decreasing line from left to right.  By default the line is (redundantly) color coded for the plot value.  You can control this and many other features of the graph display in the graph control panel.

But wait, where is that panel?  You should only see a [[.PanelTab.Network_0]] tab in the middle panel tabs.  If you click on that guy, and look at the bottom, you'll see selectors for the different view objects within this one view frame (Network_0 and EpochOutputData Graph).  Select the graph view tab at the bottom, and again mouse over the various controls and play around with them.  As you can see, there are many different ways of
configuring the graphs -- feel free to explore.  Note that there are several other variables that you could plot, including average cycles to settle, and a count of the number of errors made across trials. Also see the wiki [[.Wiki.GraphView]] page for more details.

To see your graph updating in real-time, you can re-init and run the [[.programs.gp.LeabraAll_Std.LeabraTrain]] program:
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] 
[[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]].

=== Arranging the 3d View ===

Although the [[.T3Tab.Network_0]] view is sufficient, it could be configured to look better.  We could shrink the graph view a bit, and orient it better.  To do this (optional), click on the <b>red arrow</b> button to the right of the view, and then grab the upper horizontal bar of the small purple box in the lower-left hand corner of the graph view display.  Drag this slowly down -- you'll see the green frame rotating as you do.  Do this to the point where graph is angled more \"head on\".  Similarly, you can grab the left vertical bar and rotate the graph to the left a bit to make it more face on.  Next, grab any corner of the box, and shrink the view a bit (maybe to half or so of its original size).  Finally, you can move the view down and to the right a bit, to fit in between the Hidden and Output layers.

When you've got it the way you want, you can press the <b>eye</b> button to resize the display to fit, and maybe Dolly zoom in a bit.  You could perhaps pan to the right a bit with shift-mouse.  When it looks good, hit the <b>blueprint house</b> button (\"save home\"), which saves this view configuration.

== Recording Network Activations for a Grid View ==

Another common analysis task is to look at the pattern of activations across trials.  To do this, we need to record activation values to our trial-level output data table (which was automatically created by the wizard).  The easiest way to do this is to select the network object in the network view by clicking on the thin green frame surrounding the text display at the bottom of the network, and then using the right mouse button to get the context menu, and select [[.networks[0].MonitorVar()|MonitorVar]].  For the <code>net_mon</code> field, click and select the <code>trial_netmon</code>, which is for monitoring information at the trial level (the other one is for the epoch level).  For the <code>variable</code> field, type in \"act\" (no quotes), to record activations.  This will record activations for all three layers in the network in one easy step (you could alternatively do MonitorVar on each of the layers individually, or on any other object in the network for that matter, and record any variable).

Next, we need to make a Grid View of the resulting data, which will be recorded in the [[.data.gp.OutputData.TrialOutputData]] object -- do a 
[[.data.gp.OutputData.TrialOutputData.NewGridView()|View/New Grid View]], and again let's put this in the Network_0 frame.  Follow the same general steps as before (see Arranging the 3d View above) to position this new grid view into the bottom right hand region of the view.

The grid view will not contain the new information until the
 [[.programs.gp.LeabraAll_Std.LeabraTrain]] program is 
 [[.programs.gp.LeabraAll_Std.LeabraTrain.Init()|Init]] and
[[.programs.gp.LeabraAll_Std.LeabraTrain.Run()|Run]] again.  After doing that, you need to scroll the grid view display all the way over to the right -- there are too many columns to fit within the 5 columns that the standard grid view is configured to display.  To do this, select the <b>red arrow</b> tool and drag the purple bar at the bottom of the <code>TrialOutputData</code> gridview all the way to the right.  You should see some colored squares with the Input, Hidden, and Output column headers.

To really make things clean, you can select the column headers of the columns you don't want to display (e.g., ext_rew, minus cycles) and do context menu/View Properties and then hit the Hide button at the bottom of the dialog that comes up.  Ideally, you'd just want to see the trial name, sse, and the different layer activation columns.

Also, because there are just 6 events, we can set the rows to display to 6 in the grid view panel, to make the display fit just right.

Again, you can run your program and see it update the display.

== Analyzing the Hidden Layer Representations ==

Now that we have some data from the network, we can perform some powerful analysis techniques on that data. 

First, we can make a cluster plot of the Hidden Layer activations, to see if we can understand better what is being encoded.  To do this, find the [[.data_proc.data_anal]] object under <code>data_proc/data_anal</code> in the left browser.  This contains many useful analysis tools, organized by different topics in the buttons at the bottom.  Select
 [[.data_proc.data_anal.Cluster()|HighDim/Cluster]], and set the following parameters (leave the rest at their defaults):
* view = on (generate a graph of the cluster data)
* src_data = TrialOutputData
* data_col_nm = Hidden_act   (specifies the column of data that we want to cluster)
* name_col_name = trial_name (specifies the column with labels for the cluster nodes)

You should see a new graph show up, with the A,B,C,X,Y,Z labels grouped together into different clusters.  Most likely, you should observe in a trained network that the A and X are grouped together, separate from the other items.  Can you figure out why this would be the case?

Another way to process this high-dimensional activation pattern data is to project it down into 2 dimensions.  Two techniques for this are principal components analysis (PCA) and multidimensiona scaling (MDS).  To try PCA, select
[[.data_proc.data_anal.PCA2dPrjn()|HighDim/PCA2dPrjn]] -- fill in the same info you did for the Cluster plot.  You should see that the labels are distributed as points in a two-dimensional space, with the X-axis being the dimension (principal component) of the hidden layer activation patterns that captures the greatest amount of variance across patterns, and the Y-axis being the second strongest component.  Accordingly, you should see A and X on the left or the right side of the graph, and the others on the other side.  It is not clear what the vertical axis represents..

There are many more things one could do, but hopefully this gives a flavor.  The next step: [[.docs.TaskProgram]] is to write a program to automatically generate our input patterns for training the network -- initially we'll start out with the simple task we ran already, but then we'll progressively expand to more complex tasks.  

</body>
</html>
";
  };
  taDoc @[5] {
   name="TaskProgram";
   auto_open=0;
   text="<html>
<head></head>
<body>
= Programming the Task Environment =

The goal here is to write a Program that will automatically generate a set of input/output patterns to train the network.  Because the task is so easy (at least to start), this will not represent a savings in time, but will hopefully generate understanding of how Programs work, and will also provide a basis for making more complex programs.

The major steps involved are:
# Create the new Program object
# Initialize \"enums\" based on unit names -- allows us to refer to units by name (an enum is geek-speak for an enumerated set of labeled values -- more later).
# Iterate over the input units and generate the appropriate output response.
# Write the appropriate information into the input data table.

==  Create the Program ==

In the context menu (right mouse or ctrl+mouse on mac) on the <code>programs</code> item in the left browser, select [[.programs.New_gui()|New]] -- default parameters are fine, so then hit OK.
This should have created a [[.programs.Program_11]] program, which you should now click on, and change the name to: <code>AXTaskGen</code> (the rest of the links here will assume this name, so do enter exactly that name).

It is good to get in the habit of entering descriptions of various objects in your simluation, especially programs, so enter something like \"generates the simple A-X target detection task\" in the <code>desc</code> field.

Note that there are three sub-tabs or sub-panels for a Program: 

* <code>Program Ctrl</code>: For the \"end user\" to control the running and key parameters of the program
* <code>Edit Program</code>: For writing the program.
* <code>Properties</code>: For setting overall parameters of the program object, including <code>tags</code> which help people find this program if it is uploaded to a common repository, and <code>flags</code> that determine various advanced properties.

Select <code>Edit Program</code> and we can get started doing that!

== Overview of Programing Process ==

Programming in this system mostly consists of dragging program elements from the toolbar at the very left edge of the display into your program, and then configuring their properties (drag-and-drop and duplicate are also very handy here).

The Program object has several different locations for different types of program elements:
* objs -- place to put misc objects that contain local data for the program (e.g., a local DataTable that might hold some intermediate processing data for the program).
* types -- special user-defined types that define properties of corresponding variables (e.g., the enums we'll be using).
* args -- (short for arguments) this is where you put variables that other programs will set when they run  this program.
* vars -- place for other non-argument variables that are used in the program.
* functions -- you can define subroutines (functions) that can be called within a program to perform a given task that needs to be done repeatedly.  These functions are only accessible from <i>within</i> this given program.
* init_code -- actions to be performed when the user presses the Init button -- to initialize the program and other objects that it operates on (e.g., initializing the network weights, as the LeabraTrain process does).
* prog_code -- finally, this is where the main code for your program goes!  because it can depend on any of the preceding elements, it logically comes last (and it is typically the largest).

In the Toolbox, the program elements are organized into various sub-categories (Network, Ctrl, Var/Fun, etc).  Take a look through these categories and use the mouse-over to see what kinds of things are available.

== Initialize Unit Names and Enums ==

To begin your program, locate the Network category, and drag (click and hold and move the mouse) the <code>init nm units</code> element into the <code>init_code</code> section of your program.

This Init nm units is a very powerful program element, which does a lot of configuration when it is first dropped into place.  You'll see various things being created in your project, and you should get an error message indicating that it could not find the input_data table.  Just hit OK to the error message, and let's take stock of what just happened (and fix the error).

You should see that a variable named <code>input_data</code> was created in the <code>vars</code> section, and <code>unit_names</code> was created in the <code>vars</code> section.  These are both \"pointer\" variables that provide a local \"handle\" within the program to refer to objects that actually live outside of the program, in the <code>data</code> section of the overall project.

Click on the [[.programs.AXTaskGen.args.input_data]] object, and take some time to mouse over the various fields and read the tooltips.  We want to set the <code>object_val</code> field to point to our StdInputData data table -- click on it and select it.

Now go down to the  [[.programs.AXTaskGen.args.unit_names]] object, and note that it is already set to point to the UnitNames data table, which was automatically created in the <code>data/InputData subgroup</code> section of the project.  This new datatable will contain a single row of data, with labels for each of the units in the StdInputData data table.  However, right now it is empty, because we hadn't set the input_data variable yet.

=== Entering UnitNames ===

Now that we have set input_data, we can go back to the InputNamedUnits guy in the init_code, and hit the [[.programs.AXTaskGen.init_code[0].InitNamesTable()|Init Names Table]] button.  This will pull up an informational dialog -- hit OK.
Now go back up to the [[.data.gp.InputData.UnitNames]] data table, and you should see two columns: Input and Output, with a single row of data.  Click on the Input matrix and enter text labels for each of the units, as follows:

<table>
<tr><td>X</td><td>Y</td><td>Z</td></tr>
<tr><td>A</td><td>B</td><td>C</td></tr>
</table>

For the Output matrix, you can enter N and T (for non-target and target, respectively).

=== View Data Legend ===

Next, go back to the [[.programs.AXTaskGen.init_code[0]|InitNamedUnits]] object, and select
[[.programs.AXTaskGen.init_code[0].ViewDataLegend()|View Data Legend]] -- this will configure a new view frame with the input data patterns, plus a legend from the UnitNames table showing what each of the unit names are.  These same names can also be applied directly to the network to label the units -- we'll do that later.  You might want to remove your other view frame for StdInputData (without the legend) -- do context menu and select Delete Frame.

=== Creating Enums ===

Next, we'll create those enums mentioned previously.  Click on [[.programs.AXTaskGen.init_code[0].InitDynEnums()|Init Dyn Enums]].  You will see two new entries in the <code>types</code> section of your program -- Input and Output.

Under the Input type, you should see 6 items with names like I_A, I_B, etc.  Under the Output type, you see O_N and O_T.  The first letter is taken from the first letter of the layer (I = Input, O = Output), and the remainder after the underbar is the name entered in the UnitNames table.

The purpose of these enum types is to allow you to use a symbol to refer to a unit. If you want to activate the X input unit, you can use the I_X enum value to do that.  It represents the <i>index</i> of the X unit within the input layer -- when you click on I_X, you can see that it has a value of 3.  enums have both numeric and symbolic (name-like) properties, and can be converted to and from names and numbers.  You'll understand more about why they are so useful as we go along.

We are done with the unit names for now, and can move on to writing our program.

== Iterating over the Inputs ==

The core of our program will be to <i>loop</i> or <i>iterate</i> over each of the possible input units, and then generate an appropriate output for each.  We can use a <b>for loop</b> for this purpose.

In the left Toolbox, click on the <code>Ctrl</code> category (for \"control\"), and drag the <code>for</code> element into your program code (<code>prog_code</code>).

You should now see a set of 3 main fields for the for loop object: <code>init, test, iter</code>.  Init is for initializing your looping variable, test is for testing when to terminate the loop, and iter is for what to do on each iteration prior to the test (i.e., increment the loop variable).  The default values produce a loop that goes from 0 to 9.

To see this, let's drag the <code>print_var</code> guy from the <code>Print..</code> category of program elements into our <code>loop_code</code> of the for loop.  This is where we put the program elements (\"code\") that we want to run during each iteration of the loop.  Select the <code>i</code> variable for the <code>print_var</code> field.  

Now we can [[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] our simple program.  You should see a sequence of \"i=0, i=1...i=9\" in the console window (typically located below the main project window).  It is a very good idea to keep that window visible during programming, as various informative messages may show up there.

Although perhaps fascinating for new programmers, this for loop is not exactly what we want.  We want to iterate over the input units, not just over the numbers from 0-9.  To do that, we need to click on the [[.programs.AXTaskGen.vars.i]] variable in the <code>vars</code> section of the program.  Change the <code>var_type</code> to DynEnum instead of Int.  Then, click on the </code>enum_type</code> field and select the Input type (which is what we created earlier).  You can also change the name of this variable to something more expressive, like <code>input_unit</code>.  Note that when you apply this name change, the for loop code automatically updates to use this new name, as does the print var guy.

Let's go back to that [[.programs.AXTaskGen.prog_code[0]|for]] loop guy, and change the <code>test</code> field to: <code>input_unit &lt;= I_Z</code>.  [[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] that.  Everything should be fine, up until the very end, when it tries to go beyond the I_Z case -- this will generate an error message (as it should -- one of the many advantages of using enums is that they provide built-in error-checking like this).

To get around this issue, we need to add a test inside of our loop that bails out when we get to I_Z, so that final ++ increment does not occur.  In the <code>Ctrl</code> elements, there is an <code>if.break</code> guy that does just this -- drag it into the loop_code so it appears at the end (note that you need to drop it on the loop_code guy itself to put it at the end, or go just after the print var and you'll see a thin horizontal line -- dropping there should work too).  In the <code>cond</code> field, enter <code>input_unit == I_Z</code> (note that you can do this without much typing by selecting lookup_var and lookup_enum to choose those guys off of a list).  This will break the loop at the last item (I_Z).
[[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] to confirm.

=== Generating the Correct Output ===

Next, we need to generate the correct output for each input.  To do this, we first need to create a variable to hold the output value.  Goto <code>Var/Fun</code> in the toolbox, and drag the first <code>Var</code> item into your program <code>vars</code> (select \"Copy Here\", not \"Add Var To\", when you drop -- we'll explain later).  Set the name to <code>output_unit</code> and change the type to DynEnum with enum_type selected as Output.

Now we just need to set this variable inside our for loop code, depending on the value of the input_unit variable.  The Ctrl/if guy will do this for us -- drag it into the loop_code and drop on top of the PrintVar (it will become the first element in the program).  In the <code>cond</code> condition expression, enter: <code>input_unit == I_A || input_unit == I_X</code> (again note that you can use the var and enum lookup to save some typing and make sure you've spelled them correctly).  The == is the logical test for equality, and the || is the logical OR operator (this is standard C++ syntax -- any valid C++ expression can be entered here).  This is the condition for a target.

Thus, we need to assign our output_unit variable to the target value when this \"if condition\" is true, and to the non-target case otherwise.  To assign a variable value, drag <code>var=</code> from the Var/Fun category to the true_code section of your if guy.  For the <code>result_var</code>, select output_unit, and for the <code>expr</code> expression, enter O_T (or choose from the enum_lookup).  This sets output_unit to O_T (target).  As a timesaver, drag this AssignExpr guy from true_code into false_code -- then you can just change O_T to O_N very quickly.

Finally, go to your PrintVar and select output_unit for print_var1 (or print_var2 if that is easier to see).  [[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]], and you should see the correct values for input_unit and output_unit being displayed in your console! 

== Writing the Data to the Input Data Table ==

Now that you have all the key logic of your task, you just need to write the results to the input data table.  There are three main steps for this:

# Erase any existing data at the start
# In the for loop, add a new row, and write the data for each input/output pattern
# Tell the system that we're done writing to each row so it can update the view

The first step is achieved by dragging a <code>reset_rows</code> guy from the Data toolbox to the first line of the program code (drop right on top of the for loop).  Then select the input_data variable for the data_var.

Next, drag the <code>new_row</code> guy into the loop_code, right before the final IfBreak guy (drop on top of if).  Again select input_data as the data_var.  This will add a new blank row to the data table.  Then, drag <code>set units var</code> from the Network toolbox into the loop_code, again on top of IfBreak.  This is a magic little program element that uses the name of the DynEnum type of a variable, plus its value, to determine which unit to activate in the input data table.  All you have to do is select input_unit for unit1, and output_unit for unit2, and you're done -- it automatically located the input_data datatable (based on its name).

Finally, go back to the Data toolbox, and drag the row_done guy on top of IfBreak -- this just lets the system know that you're done writing to the current row of data, and that it can update any relevant displays.

Congratulations -- you're done!!!  Select the [[.T3Tab.StdInputData]] tab in the 3d view area, and then do
[[.programs.AXTaskGen.Init()|Init]] 
and [[.programs.AXTaskGen.Run()|Run]] -- you should see the display update with the correct patterns freshly generated by your program!

You have now done a little bit of each of the critical main elements of simulating using this system.  The next few steps in the tutorial take this simple starting point and go all the way to a more scientifically interesting model of an actual psychological task.

</body>
</html>
";
  };
  taDoc @[6] {
   name="PfcBg";
   auto_open=0;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="LeabraWizard_0";
   auto_open=1;
   n_layers=3;
   layer_cfg {
    name=;
    el_typ=LayerWizEl;
    el_def=0;
    LayerWizEl @[0] {
     name="Input";
     n_units=25;
     io_type=INPUT;
    };
    LayerWizEl @[1] {
     name="Hidden";
     n_units=25;
     io_type=HIDDEN;
    };
    LayerWizEl @[2] {
     name="Output";
     n_units=25;
     io_type=OUTPUT;
    };
   };
   connectivity=BIDIRECTIONAL;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="data_base";
  };
  taDataAnal @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="data_anal";
  };
  taDataGen @[2] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="data_gen";
  };
  taImageProc @[3] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @[0] {
     name="NO_CLIP";
     value 1 0=1;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  step_prog=NULL;
  tags=;
  desc=;
 };
 viewers {
  name=;
  el_typ=TopLevelViewer;
  el_def=0;
  MainWindowViewer @[0] {
   m_data=.projects[1]$0$;
   name="Browser";
   visible=1;
   m_is_root=0;
   m_is_proj_viewer=1;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     m_data=NULL;
     name="Application";
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=FrameViewer;
    el_def=0;
    tabBrowseViewer @[0] {
     m_data=NULL;
     name="Tree";
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$0$;
    };
    PanelViewer @[1] {
     m_data=NULL;
     name="Panels";
     visible=1;
    };
    T3DataViewer @[2] {
     m_data=NULL;
     name="T3Frames";
     visible=1;
     frames {
      name=;
      el_typ=T3DataViewFrame;
      el_def=0;
      T3DataViewFrame @[0] {
       m_data=NULL;
       name="Frame1";
       visible=1;
       root_view {
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=T3DataView;
	 el_def=0;
	};
       };
       camera_pos {x=0: y=0: z=-1.517074: };
       camera_orient {x=0: y=0: z=1: rot=0: };
       camera_focdist=2.482926;
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=DockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     m_data=NULL;
     name="Tools";
     visible=1;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 use_change_log=0;
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
 };
};

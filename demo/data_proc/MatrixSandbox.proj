// ta_Dump File v3.0 -- code v8.0.0.0 rev9957
BpProject .projects["MatrixSandbox"] { 
 Doc_Group @.docs = [0] {
 };

 Wizard_Group @.wizards = [0] {
 };

 ControlPanel_Group @.ctrl_panels = [1] {
  ClusterRun @["ClusterRun"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["user_pinned"] { };
   };

   EditMbrItem_Group @.mbrs = [0] {
   };

   EditMthItem_Group @.mths = [0] {
   };

   DataTableCols @.jobs_running.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_running.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_running.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_done.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_done.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_done.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_deleted.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_deleted.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_deleted.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_archive.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_archive.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_archive.control_panel_cells = [0] {
   };

   DataTableCols @.file_list.data = [11] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["file_name"] { };
    String_Data @["tag"] { };
    String_Data @["size"] { };
    String_Data @["kind"] { };
    String_Data @["date_modified"] { };
    String_Data @["date_created"] { };
    String_Data @["svn_file_path"] { };
    String_Data @["proj_file_path"] { };
    String_Data @["file_path"] { };
   };

   DataOpList @.file_list.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.file_list.control_panel_cells = [0] {
   };

   DataTableCols @.cluster_info.data = [6] {
    String_Data @["queue"] { };
    String_Data @["job_no"] { };
    String_Data @["user"] { };
    String_Data @["state"] { };
    String_Data @["procs"] { };
    String_Data @["start_time"] { };
   };

   DataOpList @.cluster_info.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.cluster_info.control_panel_cells = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.param_sets = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp["InputData"] = [1] { 
   DataTable @["test"] { 
    DataTableCols @.data = [1] {
     float_Data @["temp"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
  DataTable_Group @.gp["OutputData"] { 
  };
  DataTable_Group @.gp["AnalysisData"] { 
  };
 };

 Program_TopGroup @.programs = [4] {
  Program @["Matrix_2D"] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @["DocLink"] { };
   };

   ProgObjList @.objs = [1] {
    Random @["Random_0"] { };
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [2] {
    ProgVar @["Random_0"] { };
    ProgVar @["cell_value"] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @["in_matrix_2d"] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    DataGenCall @[3] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintExpr @[4] { };
    PrintExpr @[5] { };
    PrintExpr @[6] { };
    PrintVar @[7] { };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [7] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
     };
    };
    PrintVar @[9] { };
   };
  };
  Program @["Matrix_3D"] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @["DocLink"] { };
   };

   ProgObjList @.objs = [1] {
    Random @["Random_0"] { };
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [2] {
    ProgVar @["Random_0"] { };
    ProgVar @["cell_value"] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [15] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @["in_matrix_3d"] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    DataGenCall @[3] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintExpr @[4] { };
    PrintExpr @[5] { };
    PrintExpr @[6] { };
    PrintVar @[7] { };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    PrintExpr @[9] { };
    PrintExpr @[10] { };
    PrintExpr @[11] { };
    PrintVar @[12] { };
    MethodCall @[13] { 
     ProgArg_List @.meth_args = [7] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
     };
    };
    PrintVar @[14] { };
   };
  };
  Program @["Slicing"] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @["DocLink"] { };
   };

   ProgObjList @.objs = [1] {
    Random @["Random_0"] { };
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [2] {
    ProgVar @["Random_0"] { };
    ProgVar @["cell_value"] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [16] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @["in_matrix_3d"] { };
      ProgVar @["slice_of_matrix"] { };
      ProgVar @["out_matrix"] { };
      ProgVar @["kernel"] { };
      ProgVar @["i"] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    DataGenCall @[3] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[4] { };
    AssignExpr @[5] { };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    PrintVar @[7] { };
    AssignExpr @[8] { };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    AssignExpr @[10] { };
    MethodCall @[11] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    ForLoop @[12] { 
     ProgEl_List @.loop_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    PrintVar @[13] { };
    MathCall @[14] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[15] { };
   };
  };
  Program @["Convolve_test"] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @["DocLink"] { };
   };

   ProgObjList @.objs = [1] {
    Random @["Random_0"] { };
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [2] {
    ProgVar @["Random_0"] { };
    ProgVar @["cell_value"] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [18] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [7] {
      ProgVar @["in_matrix_2d"] { };
      ProgVar @["slice_of_matrix"] { };
      ProgVar @["out_matrix"] { };
      ProgVar @["kernel"] { };
      ProgVar @["i"] { };
      ProgVar @["y"] { };
      ProgVar @["x"] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    ForLoop @[3] { 
     ProgEl_List @.loop_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    PrintVar @[4] { };
    AssignExpr @[5] { };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    AssignExpr @[7] { };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [8] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
     };
    };
    ForLoop @[9] { 
     ProgEl_List @.loop_code = [1] {
      ForLoop @[0] { 
       ProgEl_List @.loop_code = [2] {
	If @[0] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [8] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	   };
	  };
	 };
	};
	Else @[1] { 
	 ProgEl_List @.else_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [8] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	   };
	  };
	 };
	};
       };
      };
     };
    };
    MathCall @[10] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[11] { };
    MathCall @[12] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[13] { };
    ForLoop @[14] { 
     ProgEl_List @.loop_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    PrintVar @[15] { };
    MathCall @[16] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    PrintVar @[17] { };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @["Browser2"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["view_win_lft"] { };
    UserDataItem @["view_win_top"] { };
    UserDataItem @["view_win_wd"] { };
    UserDataItem @["view_win_ht"] { };
    UserDataItem @["view_win_iconified"] { };
    UserDataItem @["view_splitter_state"] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @["Application"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_visible"] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @["Navigator"] { };
    PanelViewer @["Editor"] { };
    T3PanelViewer @["T3Frames"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_panel_selected"] { };
     };

     T3Panel_List @.panels = [1] {
      T3Panel @["Frame1"] { 
       T3DataView_List @.root_view.children = [0] {
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @["Vw_0"] { };
	T3SavedView @["Vw_1"] { };
	T3SavedView @["Vw_2"] { };
	T3SavedView @["Vw_3"] { };
	T3SavedView @["Vw_4"] { };
	T3SavedView @["Vw_5"] { };
	T3SavedView @["Vw_6"] { };
	T3SavedView @["Vw_7"] { };
	T3SavedView @["Vw_8"] { };
	T3SavedView @["Vw_9"] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @["Tools"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_lft"] { };
      UserDataItem @["view_win_top"] { };
      UserDataItem @["view_win_wd"] { };
      UserDataItem @["view_win_ht"] { };
      UserDataItem @["view_win_iconified"] { };
      UserDataItem @["view_visible"] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [0] {
 };
};
BpProject .projects["MatrixSandbox"] {
 name="MatrixSandbox";
 desc=;
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 author="Randall C. O'Reilly";
 email="emergent-users@grey.colorado.edu";
 license {
  license=GPLv2;
  owner_name="Regents of the University of Colorado";
  org="CCNLab at the University of Colorado Boulder";
  year="2016";
  custom=;
 };
 pub_cite=;
 wiki {
  wiki=;
  page_name=;
 };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
 };
 wizards {
  name="wizards";
  el_typ=Wizard;
  el_def=0;
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  ClusterRun @["ClusterRun"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="ClusterRun";
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=EditMbrItem;
    el_def=0;
   };
   mths {
    name="mths";
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   jobs_running {
    name="jobs_running";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
    [0]     };
    last_sort_spec {
     name=;
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name=;
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_done {
    name="jobs_done";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
    [0]     };
    last_sort_spec {
     name=;
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name=;
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_deleted {
    name="jobs_deleted";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
    [0]     };
    last_sort_spec {
     name=;
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name=;
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_archive {
    name="jobs_archive";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
    [0]     };
    last_sort_spec {
     name=;
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name=;
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   file_list {
    name="file_list";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="cluster where this job was submitted / run";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_name"] {
      name="file_name";
      desc="name of file -- does not include any path information";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="job tag associated with this file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["size"] {
      name="size";
      desc="size of file -- with typical suffixes (K = kilobytes, M = megabytes, G = gigabytes)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["kind"] {
      name="kind";
      desc="type of file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_modified"] {
      name="date_modified";
      desc="timestamp for when the file was last modified";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_created"] {
      name="date_created";
      desc="timestamp for when the file was first created";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["svn_file_path"] {
      name="svn_file_path";
      desc="path to file in SVN repository, relative to root of svn_repo repository";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["proj_file_path"] {
      name="proj_file_path";
      desc="path to file relative to the parent project directory -- e.g., results/filename.dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_path"] {
      name="file_path";
      desc="full path to file on local file system, including all parent directories and name of file -- takes you directly to the file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
    [0]     };
    last_sort_spec {
     name=;
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name=;
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   cluster_info {
    name="cluster_info";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["queue"] {
      name="queue";
      desc="queue that this info relates to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number or total number of actve jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["state"] {
      name="state";
      desc="current scheduler state -- or description of global state info";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["procs"] {
      name="procs";
      desc="number of processors for this job or for global state info";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="timestamp for when the job was submitted or started running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
    [0]     };
    last_sort_spec {
     name=;
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name=;
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=0;
   proj_name=;
   auto_updt_interval=10;
   auto_updt_timeout=30;
   cluster=;
   clusters=;
   users=;
   last_submit_time=;
   notes=;
   label=;
   extra_files=;
   svn_repo=;
   repo_url=;
   queue=;
   run_time=;
   exe_cmd="emergent";
   ram_gb=-1;
   n_threads=2;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=0;
  };
 };
 param_sets {
  name="param_sets";
  el_typ=ParamSet;
  el_def=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp["InputData"] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @["test"] {
    name="test";
    desc=;
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     float_Data @["temp"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_50";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1004016101360321;
	val_type_fixed=0;
       };
      };
      name="temp";
      col_flags=SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;3;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=0;
      ar {
       name="ar";
      [3 3 1] 7;8;9;4;5;6;1;2;3;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [1] 0;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
  DataTable_Group @.gp["OutputData"] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp["AnalysisData"] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @["Matrix_2D"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @["DocLink"] {
     name="DocLink";
     doc=.projects["MatrixSandbox"].programs["Matrix_2D"].doc$$;
    };
   };
   name="Matrix_2D";
   short_nm="blur";
   tags=;
   desc=;
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=0;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=float_Matrix;
    el_def=0;
    Random @["Random_0"] {name="Random_0": type=GAUSSIAN: mean=0.3: var=1: par=1: };
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["Random_0"] {
     name="Random_0";
     var_type=T_Object;
     object_type=Random;
     object_val=.projects["MatrixSandbox"].programs["Matrix_2D"].objs["Random_0"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["cell_value"] {
     name="cell_value";
     var_type=T_Real;
     real_val=1.139253735542297;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["in_matrix_2d"] {
       name="in_matrix_2d";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc="create a new object for our variable to point to -- this is essential!";
     flags=CAN_REVERT_TO_CODE;
     code_string="in_matrix_2d = new float_Matrix";
     pre_compile_code_string="in_matrix_2d = new float_Matrix";
     result_var=.projects["MatrixSandbox"].programs["Matrix_2D"].prog_code[0].local_vars["in_matrix_2d"]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=0;
     code_string="in_matrix_2d->SetGeom(2, 3, 5, , , , , )";
     pre_compile_code_string="in_matrix_2d->SetGeom(2, 3, 5, , , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Matrix_2D"].prog_code[0].local_vars["in_matrix_2d"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="5";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    DataGenCall @[3] {
     desc="fill matrix with noise";
     flags=0;
     code_string="taDataGen::AddNoiseMat(in_matrix_2d, Random_0)";
     pre_compile_code_string="taDataGen::AddNoiseMat(in_matrix_2d, Random_0)";
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::AddNoiseMat;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="mat";
       required=1;
       def_val=;
       prev_expr="in_matrix_2d";
       expr {
	expr="in_matrix_2d";
       };
      };
      ProgArg @[1] {
       arg_type=const_Random_ref;
       type="Random&";
       name="rnd_spec";
       required=1;
       def_val=;
       prev_expr="Random_0";
       expr {
	expr="Random_0";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    PrintExpr @[4] {
     desc="The number of dimensions in the matrix";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"dimensions = \" + in_matrix_2d->dims()";
     pre_compile_code_string="Print \"dimensions = \" + in_matrix_2d->dims()";
     expr {
      expr="\"dimensions = \" + in_matrix_2d->dims()";
     };
     debug=0;
    };
    PrintExpr @[5] {
     desc="The number of frames is the size of the last dimension";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"frames = \" + in_matrix_2d->Frames()";
     pre_compile_code_string="Print \"frames = \" + in_matrix_2d->Frames()";
     expr {
      expr="\"frames = \" + in_matrix_2d->Frames()";
     };
     debug=0;
    };
    PrintExpr @[6] {
     desc="The number of elements in each frame (product of inner dimensions)";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"frame size = \" + in_matrix_2d->FrameSize()";
     pre_compile_code_string="Print \"frame size = \" + in_matrix_2d->FrameSize()";
     expr {
      expr="\"frame size = \" + in_matrix_2d->FrameSize()";
     };
     debug=0;
    };
    PrintVar @[7] {
     desc=;
     flags=0;
     code_string="Print  in_matrix_2d";
     pre_compile_code_string="Print  in_matrix_2d";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Matrix_2D"].prog_code[0].local_vars["in_matrix_2d"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    MethodCall @[8] {
     desc="for any matrix access is inner to outer (for a 2d matrix this is basically column, row - row being the frame)";
     flags=0;
     code_string="cell_value = in_matrix_2d->FastElAsFloat(1, 2, , , , , )";
     pre_compile_code_string="cell_value = in_matrix_2d->FastElAsFloat(1, 2, , , , , )";
     result_var=.projects["MatrixSandbox"].programs["Matrix_2D"].vars["cell_value"]$$;
     obj=$.projects["MatrixSandbox"].programs["Matrix_2D"].prog_code[0].local_vars["in_matrix_2d"]$;
     method=taMatrix::FastElAsFloat;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="1";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="float FastElAsFloat(int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" get element as float without range checking";
    };
    PrintVar @[9] {
     desc=;
     flags=0;
     code_string="Print  cell_value";
     pre_compile_code_string="Print  cell_value";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Matrix_2D"].vars["cell_value"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program @["Matrix_3D"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @["DocLink"] {
     name="DocLink";
     doc=.projects["MatrixSandbox"].programs["Matrix_3D"].doc$$;
    };
   };
   name="Matrix_3D";
   short_nm="DMtrx";
   tags=;
   desc=;
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=0;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
    Random @["Random_0"] {name="Random_0": type=GAUSSIAN: mean=0.3: var=1: par=1: };
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["Random_0"] {
     name="Random_0";
     var_type=T_Object;
     object_type=Random;
     object_val=.projects["MatrixSandbox"].programs["Matrix_3D"].objs["Random_0"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["cell_value"] {
     name="cell_value";
     var_type=T_Real;
     real_val=0.6977747082710266;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["in_matrix_3d"] {
       name="in_matrix_3d";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc="create a new object for our variable to point to -- this is essential!";
     flags=CAN_REVERT_TO_CODE;
     code_string="in_matrix_3d = new float_Matrix";
     pre_compile_code_string="in_matrix_3d = new float_Matrix";
     result_var=.projects["MatrixSandbox"].programs["Matrix_3D"].prog_code[0].local_vars["in_matrix_3d"]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=0;
     code_string="in_matrix_3d->SetGeom(3, 5, 6, 2, , , , )";
     pre_compile_code_string="in_matrix_3d->SetGeom(3, 5, 6, 2, , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Matrix_3D"].prog_code[0].local_vars["in_matrix_3d"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="5";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="6";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    DataGenCall @[3] {
     desc="fill matrix with noise";
     flags=0;
     code_string="taDataGen::AddNoiseMat(in_matrix_3d, Random_0)";
     pre_compile_code_string="taDataGen::AddNoiseMat(in_matrix_3d, Random_0)";
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::AddNoiseMat;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="mat";
       required=1;
       def_val=;
       prev_expr="in_matrix_3d";
       expr {
	expr="in_matrix_3d";
       };
      };
      ProgArg @[1] {
       arg_type=const_Random_ref;
       type="Random&";
       name="rnd_spec";
       required=1;
       def_val=;
       prev_expr="Random_0";
       expr {
	expr="Random_0";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    PrintExpr @[4] {
     desc="The number of dimensions was set at 3";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"dimensions = \" + in_matrix_3d->dims()";
     pre_compile_code_string="Print \"dimensions = \" + in_matrix_3d->dims()";
     expr {
      expr="\"dimensions = \" + in_matrix_3d->dims()";
     };
     debug=0;
    };
    PrintExpr @[5] {
     desc="The number of frames is the size of the last dimension";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"frames = \" + in_matrix_3d->Frames()";
     pre_compile_code_string="Print \"frames = \" + in_matrix_3d->Frames()";
     expr {
      expr="\"frames = \" + in_matrix_3d->Frames()";
     };
     debug=0;
    };
    PrintExpr @[6] {
     desc="The number of elements in each frame (product of inner dimensions)";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"frame size = \" + in_matrix_3d->FrameSize()";
     pre_compile_code_string="Print \"frame size = \" + in_matrix_3d->FrameSize()";
     expr {
      expr="\"frame size = \" + in_matrix_3d->FrameSize()";
     };
     debug=0;
    };
    PrintVar @[7] {
     desc=;
     flags=0;
     code_string="Print  in_matrix_3d";
     pre_compile_code_string="Print  in_matrix_3d";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Matrix_3D"].prog_code[0].local_vars["in_matrix_3d"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    MethodCall @[8] {
     desc=;
     flags=0;
     code_string="in_matrix_3d->AddFrames(2)";
     pre_compile_code_string="in_matrix_3d->AddFrames(2)";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Matrix_3D"].prog_code[0].local_vars["in_matrix_3d"]$;
     method=taMatrix::AddFrames;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="n";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
     };
     meth_sig="bool AddFrames(int n)";
     meth_desc=" add n new blank frames -- note that this assumes incremental growth and thus calls AllocFrames in advance";
    };
    PrintExpr @[9] {
     desc="The number of dimensions was set at 3";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"dimensions = \" + in_matrix_3d->dims()";
     pre_compile_code_string="Print \"dimensions = \" + in_matrix_3d->dims()";
     expr {
      expr="\"dimensions = \" + in_matrix_3d->dims()";
     };
     debug=0;
    };
    PrintExpr @[10] {
     desc="We now have a matrix that is 5 x 6 x 4";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"frames = \" + in_matrix_3d->Frames()";
     pre_compile_code_string="Print \"frames = \" + in_matrix_3d->Frames()";
     expr {
      expr="\"frames = \" + in_matrix_3d->Frames()";
     };
     debug=0;
    };
    PrintExpr @[11] {
     desc="The number of elements in each frame (product of inner dimensions)";
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"frame size = \" + in_matrix_3d->FrameSize()";
     pre_compile_code_string="Print \"frame size = \" + in_matrix_3d->FrameSize()";
     expr {
      expr="\"frame size = \" + in_matrix_3d->FrameSize()";
     };
     debug=0;
    };
    PrintVar @[12] {
     desc=;
     flags=0;
     code_string="Print  in_matrix_3d";
     pre_compile_code_string="Print  in_matrix_3d";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Matrix_3D"].prog_code[0].local_vars["in_matrix_3d"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    MethodCall @[13] {
     desc="for a 3d matrix the access is inner to outer with the frame being the most outer";
     flags=0;
     code_string="cell_value = in_matrix_3d->FastElAsFloat(0, 1, 1, , , , )";
     pre_compile_code_string="cell_value = in_matrix_3d->FastElAsFloat(0, 1, 1, , , , )";
     result_var=.projects["MatrixSandbox"].programs["Matrix_3D"].vars["cell_value"]$$;
     obj=$.projects["MatrixSandbox"].programs["Matrix_3D"].prog_code[0].local_vars["in_matrix_3d"]$;
     method=taMatrix::FastElAsFloat;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="1";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="1";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="float FastElAsFloat(int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" get element as float without range checking";
    };
    PrintVar @[14] {
     desc=;
     flags=0;
     code_string="Print  cell_value";
     pre_compile_code_string="Print  cell_value";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Matrix_3D"].vars["cell_value"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program @["Slicing"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @["DocLink"] {
     name="DocLink";
     doc=.projects["MatrixSandbox"].programs["Slicing"].doc$$;
    };
   };
   name="Slicing";
   short_nm="Slicin";
   tags=;
   desc=;
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=0;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
    Random @["Random_0"] {name="Random_0": type=GAUSSIAN: mean=0.3: var=1: par=1: };
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["Random_0"] {
     name="Random_0";
     var_type=T_Object;
     object_type=Random;
     object_val=.projects["MatrixSandbox"].programs["Slicing"].objs["Random_0"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["cell_value"] {
     name="cell_value";
     var_type=T_Real;
     real_val=0.697775;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["in_matrix_3d"] {
       name="in_matrix_3d";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["slice_of_matrix"] {
       name="slice_of_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["out_matrix"] {
       name="out_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["kernel"] {
       name="kernel";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["i"] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc="create a new object for our local variable to point to -- this is essential!";
     flags=CAN_REVERT_TO_CODE;
     code_string="in_matrix_3d = new float_Matrix";
     pre_compile_code_string="in_matrix_3d = new float_Matrix";
     result_var=.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["in_matrix_3d"]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    MethodCall @[2] {
     desc="A matrix that is 10x10x4";
     flags=0;
     code_string="in_matrix_3d->SetGeom(3, 10, 10, 4, , , , )";
     pre_compile_code_string="in_matrix_3d->SetGeom(3, 10, 10, 4, , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["in_matrix_3d"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="10";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="10";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="4";
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    DataGenCall @[3] {
     desc="fill matrix with random values";
     flags=0;
     code_string="taDataGen::AddNoiseMat(in_matrix_3d, Random_0)";
     pre_compile_code_string="taDataGen::AddNoiseMat(in_matrix_3d, Random_0)";
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::AddNoiseMat;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="mat";
       required=1;
       def_val=;
       prev_expr="in_matrix_3d";
       expr {
	expr="in_matrix_3d";
       };
      };
      ProgArg @[1] {
       arg_type=const_Random_ref;
       type="Random&";
       name="rnd_spec";
       required=1;
       def_val=;
       prev_expr="Random_0";
       expr {
	expr="Random_0";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    PrintVar @[4] {
     desc=;
     flags=0;
     code_string="Print  in_matrix_3d";
     pre_compile_code_string="Print  in_matrix_3d";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["in_matrix_3d"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    AssignExpr @[5] {
     desc="create another float_matrix object ";
     flags=CAN_REVERT_TO_CODE;
     code_string="slice_of_matrix = new float_Matrix";
     pre_compile_code_string="slice_of_matrix = new float_Matrix";
     result_var=.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["slice_of_matrix"]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    MethodCall @[6] {
     desc="the matrix will get its geometry from the matrix we are slicing";
     flags=0;
     code_string="slice_of_matrix = in_matrix_3d->GetFrameSlice_(3)";
     pre_compile_code_string="slice_of_matrix = in_matrix_3d->GetFrameSlice_(3)";
     result_var=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["slice_of_matrix"]$;
     obj=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["in_matrix_3d"]$;
     method=taMatrix::GetFrameSlice_;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="frame";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
     };
     meth_sig="taMatrix_ptr GetFrameSlice_(int frame)";
     meth_desc=" return a slice, of exactly one frame; will have dim-1 of us";
    };
    PrintVar @[7] {
     desc="the slice should be a 10x10 matrix";
     flags=0;
     code_string="Print  slice_of_matrix";
     pre_compile_code_string="Print  slice_of_matrix";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["slice_of_matrix"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    AssignExpr @[8] {
     desc="create another float_matrix to hold the result of the convolution we will do";
     flags=CAN_REVERT_TO_CODE;
     code_string="out_matrix = new float_Matrix()";
     pre_compile_code_string="out_matrix = new float_Matrix()";
     result_var=.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["out_matrix"]$$;
     expr {
      expr="new float_Matrix()";
     };
    };
    MethodCall @[9] {
     desc="set the geometry to be the same as the matrix we will pass in to the convolve method";
     flags=0;
     code_string="out_matrix->SetGeom(2, 10, 10, , , , , )";
     pre_compile_code_string="out_matrix->SetGeom(2, 10, 10, , , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["out_matrix"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="10";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="10";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    AssignExpr @[10] {
     desc="the kernel matrix to convolve with the slice of matrix";
     flags=CAN_REVERT_TO_CODE;
     code_string="kernel = new float_Matrix()";
     pre_compile_code_string="kernel = new float_Matrix()";
     result_var=.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["kernel"]$$;
     expr {
      expr="new float_Matrix()";
     };
    };
    MethodCall @[11] {
     desc="a 2x2 matrix";
     flags=0;
     code_string="kernel->SetGeom(2, 3, 3, , , , , )";
     pre_compile_code_string="kernel->SetGeom(2, 3, 3, , , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["kernel"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    ForLoop @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i = 0; i < 9; i++)";
     pre_compile_code_string="for (i = 0; i < 9; i++)";
     loop_code {
      name="ProgEl_List_54";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=0;
       code_string="kernel->Set_Flat(.111, i)";
       pre_compile_code_string="kernel->Set_Flat(.111, i)";
       result_var=NULL;
       obj=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["kernel"]$;
       method=taMatrixT_float_::Set_Flat;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_float_ref;
	 type="float&";
	 name="item";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr=".111";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="i";
	 };
	};
       };
       meth_sig="void Set_Flat(float& item, int idx)";
       meth_desc=" safely assign values to items in the matrix, treated as a flat vector";
      };
     };
     init {
      expr="i = 0";
     };
     test {
      expr="i < 9";
     };
     iter {
      expr="i++";
     };
    };
    PrintVar @[13] {
     desc="the slice should be a 10x10 matrix";
     flags=0;
     code_string="Print  kernel";
     pre_compile_code_string="Print  kernel";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["kernel"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    MathCall @[14] {
     desc=;
     flags=0;
     code_string="taMath_float::mat_frame_convolve(out_matrix, slice_of_matrix, kernel)";
     pre_compile_code_string="taMath_float::mat_frame_convolve(out_matrix, slice_of_matrix, kernel)";
     result_var=NULL;
     object_type=taMath_float;
     method=taMath_float::mat_frame_convolve;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="out_mat";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="out_matrix";
       };
      };
      ProgArg @[1] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="in_mat";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="slice_of_matrix";
       };
      };
      ProgArg @[2] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="kernel";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="kernel";
       };
      };
     };
    };
    PrintVar @[15] {
     desc=;
     flags=0;
     code_string="Print  out_matrix";
     pre_compile_code_string="Print  out_matrix";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Slicing"].prog_code[0].local_vars["out_matrix"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program @["Convolve_test"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @["DocLink"] {
     name="DocLink";
     doc=.projects["MatrixSandbox"].programs["Convolve_test"].doc$$;
    };
   };
   name="Convolve_test";
   short_nm="cnvtst";
   tags=;
   desc=;
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=0;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
    Random @["Random_0"] {name="Random_0": type=GAUSSIAN: mean=0.3: var=1: par=1: };
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["Random_0"] {
     name="Random_0";
     var_type=T_Object;
     object_type=Random;
     object_val=.projects["MatrixSandbox"].programs["Convolve_test"].objs["Random_0"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["cell_value"] {
     name="cell_value";
     var_type=T_Real;
     real_val=0.697775;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string="LocalVars (7 vars)";
     pre_compile_code_string="LocalVars (7 vars)";
     local_vars {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["in_matrix_2d"] {
       name="in_matrix_2d";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["slice_of_matrix"] {
       name="slice_of_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["out_matrix"] {
       name="out_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["kernel"] {
       name="kernel";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["i"] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["y"] {
       name="y";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["x"] {
       name="x";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="in_matrix_2d = new float_Matrix";
     pre_compile_code_string="in_matrix_2d = new float_Matrix";
     result_var=.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["in_matrix_2d"]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=0;
     code_string="in_matrix_2d->SetGeom(2, 5, 5, , , , , )";
     pre_compile_code_string="in_matrix_2d->SetGeom(2, 5, 5, , , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["in_matrix_2d"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="5";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="5";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    ForLoop @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i = 0; i < 25; i++)";
     pre_compile_code_string="for (i = 0; i < 25; i++)";
     loop_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=0;
       code_string="in_matrix_2d->Set_Flat(i, i)";
       pre_compile_code_string="in_matrix_2d->Set_Flat(i, i)";
       result_var=NULL;
       obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["in_matrix_2d"]$;
       method=taMatrixT_float_::Set_Flat;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_float_ref;
	 type="float&";
	 name="item";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="i";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="i";
	 };
	};
       };
       meth_sig="void Set_Flat(float& item, int idx)";
       meth_desc=" safely assign values to items in the matrix, treated as a flat vector";
      };
     };
     init {
      expr="i = 0";
     };
     test {
      expr="i < 25";
     };
     iter {
      expr="i++";
     };
    };
    PrintVar @[4] {
     desc=;
     flags=0;
     code_string="Print  in_matrix_2d";
     pre_compile_code_string="Print  in_matrix_2d";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["in_matrix_2d"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="out_matrix = new float_Matrix()";
     pre_compile_code_string="out_matrix = new float_Matrix()";
     result_var=.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["out_matrix"]$$;
     expr {
      expr="new float_Matrix()";
     };
    };
    MethodCall @[6] {
     desc=;
     flags=0;
     code_string="out_matrix->SetGeom(2, 5, 5, , , , , )";
     pre_compile_code_string="out_matrix->SetGeom(2, 5, 5, , , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["out_matrix"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="5";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="5";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    AssignExpr @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="kernel = new float_Matrix()";
     pre_compile_code_string="kernel = new float_Matrix()";
     result_var=.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$$;
     expr {
      expr="new float_Matrix()";
     };
    };
    MethodCall @[8] {
     desc=;
     flags=0;
     code_string="kernel->SetGeom(2, 3, 3, , , , , )";
     pre_compile_code_string="kernel->SetGeom(2, 3, 3, , , , , )";
     result_var=NULL;
     obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$;
     method=taMatrix::SetGeom;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="2";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="d0";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="d1";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="3";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="d2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="d3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=int;
       type="int";
       name="d4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=int;
       type="int";
       name="d5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=int;
       type="int";
       name="d6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool SetGeom(int size, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
     meth_desc=" set geom for matrix -- if matches current size, it is non-destructive";
    };
    ForLoop @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (y=0;  y<3;  y++)";
     pre_compile_code_string="for (y=0;  y<3;  y++)";
     loop_code {
      name="ProgEl_List_63";
      el_typ=ProgCode;
      el_def=0;
      ForLoop @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (x=0;  x<3;  x++)";
       pre_compile_code_string="for (x=0;  x<3;  x++)";
       loop_code {
	name="ProgEl_List_64";
	el_typ=ProgCode;
	el_def=0;
	If @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (x == 1 && y == 1)";
	 pre_compile_code_string="if (x == 1 && y == 1)";
	 cond {
	  expr="x == 1 && y == 1";
	 };
	 true_code {
	  name="ProgEl_List_65";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="kernel->Set(1, x, y, , , , , )";
	   pre_compile_code_string="kernel->Set(1, x, y, , , , , )";
	   result_var=NULL;
	   obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$;
	   method=taMatrixT_float_::Set;
	   meth_args {
	    name="ProgArg_List_0";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_float_ref;
	     type="float&";
	     name="item";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="1";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="d0";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="x";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="d1";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="y";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=int;
	     type="int";
	     name="d2";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[4] {
	     arg_type=int;
	     type="int";
	     name="d3";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=int;
	     type="int";
	     name="d4";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=int;
	     type="int";
	     name="d5";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=int;
	     type="int";
	     name="d6";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="void Set(float& item, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
	   meth_desc=" safely assign values to items in the matrix";
	  };
	 };
	};
	Else @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string=;
	 pre_compile_code_string=;
	 else_code {
	  name="else_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="kernel->Set(.1, x, y, , , , , )";
	   pre_compile_code_string="kernel->Set(.1, x, y, , , , , )";
	   result_var=NULL;
	   obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$;
	   method=taMatrixT_float_::Set;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_float_ref;
	     type="float&";
	     name="item";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr=".1";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="d0";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="x";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="d1";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="y";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=int;
	     type="int";
	     name="d2";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[4] {
	     arg_type=int;
	     type="int";
	     name="d3";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=int;
	     type="int";
	     name="d4";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=int;
	     type="int";
	     name="d5";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=int;
	     type="int";
	     name="d6";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="void Set(float& item, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
	   meth_desc=" safely assign values to items in the matrix";
	  };
	 };
	};
       };
       init {
	expr="x=0";
       };
       test {
	expr=" x<3";
       };
       iter {
	expr=" x++";
       };
      };
     };
     init {
      expr="y=0";
     };
     test {
      expr=" y<3";
     };
     iter {
      expr=" y++";
     };
    };
    MathCall @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taMath_float::vec_norm_sum(kernel, 1.0, )";
     pre_compile_code_string="taMath_float::vec_norm_sum(kernel, 1.0, )";
     result_var=NULL;
     object_type=taMath_float;
     method=taMath_float::vec_norm_sum;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="vec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="kernel";
       };
      };
      ProgArg @[1] {
       arg_type=float;
       type="float";
       name="sum";
       required=0;
       def_val="1.0f";
       prev_expr=;
       expr {
	expr="1.0";
       };
      };
      ProgArg @[2] {
       arg_type=float;
       type="float";
       name="min_val";
       required=0;
       def_val="0.0f";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    PrintVar @[11] {
     desc=;
     flags=0;
     code_string="Print  kernel";
     pre_compile_code_string="Print  kernel";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    MathCall @[12] {
     desc=;
     flags=0;
     code_string="taMath_float::mat_frame_convolve(out_matrix, in_matrix_2d, kernel)";
     pre_compile_code_string="taMath_float::mat_frame_convolve(out_matrix, in_matrix_2d, kernel)";
     result_var=NULL;
     object_type=taMath_float;
     method=taMath_float::mat_frame_convolve;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="out_mat";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="out_matrix";
       };
      };
      ProgArg @[1] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="in_mat";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="in_matrix_2d";
       };
      };
      ProgArg @[2] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="kernel";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="kernel";
       };
      };
     };
    };
    PrintVar @[13] {
     desc=;
     flags=0;
     code_string="Print  out_matrix";
     pre_compile_code_string="Print  out_matrix";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["out_matrix"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    ForLoop @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i = 0; i < 9; i++)";
     pre_compile_code_string="for (i = 0; i < 9; i++)";
     loop_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=0;
       code_string="kernel->Set_Flat(.111, i)";
       pre_compile_code_string="kernel->Set_Flat(.111, i)";
       result_var=NULL;
       obj=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$;
       method=taMatrixT_float_::Set_Flat;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_float_ref;
	 type="float&";
	 name="item";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr=".111";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="i";
	 };
	};
       };
       meth_sig="void Set_Flat(float& item, int idx)";
       meth_desc=" safely assign values to items in the matrix, treated as a flat vector";
      };
     };
     init {
      expr="i = 0";
     };
     test {
      expr="i < 9";
     };
     iter {
      expr="i++";
     };
    };
    PrintVar @[15] {
     desc=;
     flags=0;
     code_string="Print  kernel";
     pre_compile_code_string="Print  kernel";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["kernel"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    MathCall @[16] {
     desc=;
     flags=0;
     code_string="taMath_float::mat_frame_convolve(out_matrix, in_matrix_2d, kernel)";
     pre_compile_code_string="taMath_float::mat_frame_convolve(out_matrix, in_matrix_2d, kernel)";
     result_var=NULL;
     object_type=taMath_float;
     method=taMath_float::mat_frame_convolve;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="out_mat";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="out_matrix";
       };
      };
      ProgArg @[1] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="in_mat";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="in_matrix_2d";
       };
      };
      ProgArg @[2] {
       arg_type=const_float_Matrix_ptr;
       type="float_Matrix*";
       name="kernel";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="kernel";
       };
      };
     };
    };
    PrintVar @[17] {
     desc=;
     flags=0;
     code_string="Print  out_matrix";
     pre_compile_code_string="Print  out_matrix";
     message=;
     print_var=$.projects["MatrixSandbox"].programs["Convolve_test"].prog_code[0].local_vars["out_matrix"]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @["Browser2"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_79";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["view_win_lft"] {
     name="view_win_lft";
     value 8 0=0.0300879;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_top"] {
     name="view_win_top";
     value 8 0=0.05332535;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_wd"] {
     name="view_win_wd";
     value 8 0=0.9276538;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_ht"] {
     name="view_win_ht";
     value 8 0=0.5751948;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_iconified"] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_splitter_state"] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAEAAAADAAABZgAAAo8AAAAAAQAAAAcBAAAAAQE=";
     val_type_fixed=0;
    };
   };
   name="Browser2";
   m_data=.projects["MatrixSandbox"]$$;
   cur_font_size=12;
   visible=1;
   win_name=".projects[\"MatrixSandbox\"] - MatrixSandbox.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @["Application"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_80";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_visible"] {
       name="view_win_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=12;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @["Navigator"] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     root_typ=BpProject;
     root_md=NULL;
     m_root=$.projects["MatrixSandbox"]$;
    };
    PanelViewer @["Editor"] {
     name="Editor";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
    };
    T3PanelViewer @["T3Frames"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_81";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_panel_selected"] {
       name="view_panel_selected";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="T3Frames";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @["Frame1"] {
       name="Frame1";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=T3DataViewMain;
	 el_def=0;
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {
	field_of_view=45;
	near_distance=0.1;
	focal=5;
	far_distance=1000;
       };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["Vw_0"] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0: y=0: z=-0.4765596: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=3.52344;
	};
	T3SavedView @["Vw_1"] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_2"] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_3"] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_4"] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_5"] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_6"] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_7"] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_8"] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_9"] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @["Tools"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_82";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_lft"] {
       name="view_win_lft";
       value 8 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_top"] {
       name="view_win_top";
       value 8 0=0.005991612;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_wd"] {
       name="view_win_wd";
       value 8 0=0.02772143;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_ht"] {
       name="view_win_ht";
       value 8 0=0.5302576;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_iconified"] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_visible"] {
       name="view_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc=;
 tree_state{ .;.docs;.wizards;.ctrl_panels;.param_sets;.data;.data.gp[0];.data.gp[1];.data.gp[2];.programs;.networks; };
 networks {
  name="networks";
  el_typ=BpNetwork;
  el_def=0;
 };
};

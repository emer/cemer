// ta_Dump File v3.0 -- code v8.0.0.0 rev9957
LeabraProject .projects["fft_image_xform"] { 
 Doc_Group @.docs = [2] {
  taDoc @["ProjectDoc"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["user_pinned"] { };
   };
  };
  taDoc @["ChangeLog"] { };
 };

 Wizard_Group @.wizards = [1] {
  LeabraWizard @["LeabraWizard_0"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["NO_CLIP"] { };
    UserDataItem @["user_pinned"] { };
   };
  };
 };

 ControlPanel_Group @.ctrl_panels = [1] {
  ClusterRun @["ClusterRun"] { 
   EditMbrItem_Group @.mbrs = [0] {
   };

   EditMthItem_Group @.mths = [0] {
   };

   DataTableCols @.jobs_running.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_running.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_running.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_done.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_done.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_done.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_deleted.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_deleted.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_deleted.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_archive.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_archive.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_archive.control_panel_cells = [0] {
   };

   DataTableCols @.file_list.data = [11] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["file_name"] { };
    String_Data @["tag"] { };
    String_Data @["size"] { };
    String_Data @["kind"] { };
    String_Data @["date_modified"] { };
    String_Data @["date_created"] { };
    String_Data @["svn_file_path"] { };
    String_Data @["proj_file_path"] { };
    String_Data @["file_path"] { };
   };

   DataOpList @.file_list.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.file_list.control_panel_cells = [0] {
   };

   DataTableCols @.cluster_info.data = [6] {
    String_Data @["queue"] { };
    String_Data @["job_no"] { };
    String_Data @["user"] { };
    String_Data @["state"] { };
    String_Data @["procs"] { };
    String_Data @["start_time"] { };
   };

   DataOpList @.cluster_info.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.cluster_info.control_panel_cells = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.param_sets = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp["InputData"] { 
  };
  DataTable_Group @.gp["OutputData"] { 
  };
  DataTable_Group @.gp["AnalysisData"] { 
  };
 };

 Program_TopGroup @.programs = [1] {
  Program @["FFTest"] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @["DocLink"] { };
   };

   ProgObjList @.objs = [3] {
    taImage @["taImage_orig"] { };
    taImage @["taImage_recon"] { };
    DataTable @["Images"] { 
     DataTableCols @.data = [3] {
      String_Data @["Manip"] { };
      float_Data @["Orig"] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @["IMAGE"] { };
       };
      };
      float_Data @["Recon"] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @["IMAGE"] { };
       };
      };
     };

     DataOpList @.last_sort_spec.ops = [0] {
     };

     DataTableCell_List @.control_panel_cells = [0] {
     };
    };
   };

   ProgType_List @.types = [1] {
    DynEnumType @["ManipType"] { 
     DynEnumItem_List @.enums = [4] {
      DynEnumItem @["ROTATE_FFT"] { };
      DynEnumItem @["SET_FFT_INDEXES"] { };
      DynEnumItem @["LOW_PASS_FILTER"] { };
      DynEnumItem @["HI_PASS_FILTER"] { };
     };
    };
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [14] {
    ProgVar @["image_size"] { };
    ProgVar @["manip_type"] { };
    ProgVar @["taImage_orig"] { };
    ProgVar @["taImage_recon"] { };
    ProgVar @["Images"] { };
    ProgVar @["rotate_angle"] { };
    ProgVar @["start_angle"] { };
    ProgVar @["end_angle"] { };
    ProgVar @["angle_inc"] { };
    ProgVar @["fft_start_index"] { };
    ProgVar @["fft_end_index"] { };
    ProgVar @["fft_real_val"] { };
    ProgVar @["fft_imag_val"] { };
    ProgVar @["fft_index"] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [9] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [7] {
      ProgVar @["flt_img"] { };
      ProgVar @["img_recon"] { };
      ProgVar @["img_fft"] { };
      ProgVar @["fft_xform"] { };
      ProgVar @["recon_fft"] { };
      ProgVar @["im_x"] { };
      ProgVar @["im_y"] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    AssignExpr @[5] { };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    Switch @[8] { 
     ProgEl_List @.cases = [4] {
      CaseBlock @[0] { 
       ProgEl_List @.prog_code = [1] {
	ForLoop @[0] { 
	 ProgEl_List @.loop_code = [9] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  AssignExpr @[1] { };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  MethodCall @[4] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  MethodCall @[5] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  MethodCall @[6] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  UserScript @[7] { };
	  MemberMethodCall @[8] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
       };
      };
      CaseBlock @[1] { 
       ProgEl_List @.prog_code = [1] {
	ForLoop @[0] { 
	 ProgEl_List @.loop_code = [11] {
	  AssignExpr @[0] { };
	  UserScript @[1] { };
	  UserScript @[2] { };
	  MethodCall @[3] { 
	   ProgArg_List @.meth_args = [8] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	   };
	  };
	  AssignExpr @[4] { };
	  MethodCall @[5] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  MethodCall @[6] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  MethodCall @[7] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  MethodCall @[8] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  UserScript @[9] { };
	  MemberMethodCall @[10] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
       };
      };
      CaseBlock @[2] { 
       ProgEl_List @.prog_code = [1] {
	ForLoop @[0] { 
	 ProgEl_List @.loop_code = [10] {
	  AssignExpr @[0] { };
	  UserScript @[1] { };
	  UserScript @[2] { };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  MethodCall @[5] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  MethodCall @[6] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  MethodCall @[7] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  UserScript @[8] { };
	  MemberMethodCall @[9] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
       };
      };
      CaseBlock @[3] { 
       ProgEl_List @.prog_code = [1] {
	ForLoop @[0] { 
	 ProgEl_List @.loop_code = [10] {
	  AssignExpr @[0] { };
	  UserScript @[1] { };
	  UserScript @[2] { };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  MethodCall @[5] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  MethodCall @[6] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  MethodCall @[7] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	  UserScript @[8] { };
	  MemberMethodCall @[9] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
       };
      };
     };
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @["Browser2"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["view_win_lft"] { };
    UserDataItem @["view_win_top"] { };
    UserDataItem @["view_win_wd"] { };
    UserDataItem @["view_win_ht"] { };
    UserDataItem @["view_win_iconified"] { };
    UserDataItem @["view_splitter_state"] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @["Application"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_visible"] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @["Navigator"] { };
    PanelViewer @["Editor"] { };
    T3PanelViewer @["T3Frames"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_panel_selected"] { };
     };

     T3Panel_List @.panels = [1] {
      T3Panel @["Frame1"] { 
       T3DataView_List @.root_view.children = [1] {
	GridTableView @["Images_Grid"] { 
	 T3DataView_List @.children = [3] {
	  GridColView @["Manip"] { };
	  GridColView @["Orig"] { };
	  GridColView @["Recon"] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @["Vw_0"] { };
	T3SavedView @["Recon_Zoom"] { };
	T3SavedView @["Vw_2"] { };
	T3SavedView @["Vw_3"] { };
	T3SavedView @["Vw_4"] { };
	T3SavedView @["Vw_5"] { };
	T3SavedView @["Vw_6"] { };
	T3SavedView @["Vw_7"] { };
	T3SavedView @["Vw_8"] { };
	T3SavedView @["Vw_9"] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @["Tools"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_lft"] { };
      UserDataItem @["view_win_top"] { };
      UserDataItem @["view_win_wd"] { };
      UserDataItem @["view_win_ht"] { };
      UserDataItem @["view_win_iconified"] { };
      UserDataItem @["view_visible"] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [0] {
 };
};
LeabraProject .projects["fft_image_xform"] {
 name="fft_image_xform";
 desc="demonstrates what you can do with fast fourier transforms on images -- fun!";
 tags="Demo, Fast Fourier Transform, Images, Low Pass Filter, Hi Pass Filter, Phase Rotation";
 version {
  major=8;
  minor=0;
  step=2;
 };
 author="Randall C. O'Reilly";
 email="emergent-users@grey.colorado.edu";
 license {
  license=GPLv2;
  owner_name="Regents of the University of Colorado";
  org="CCNLab at the University of Colorado Boulder";
  year="2016";
  custom=;
 };
 pub_cite=;
 wiki {
  wiki="emergent";
  page_name="demos/fft_image_xform";
 };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @["ProjectDoc"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_109";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="ProjectDoc";
   desc=;
   web_doc=1;
   wiki="emergent";
   url="demos/fft_image_xform";
   full_url="https://grey.colorado.edu/emergent/index.php/demos/fft_image_xform";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text=;
  };
  taDoc @["ChangeLog"] {
   name="ChangeLog";
   desc=;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>


<li>Tue Aug 30 03:13:53 2016 version: 8.0.2 user: oreilly file_name: <code>fft_image_xform.proj</code> <br>
Project updated on wiki: emergent changes: doc link


<li>Tue Aug 30 03:11:18 2016 version: 8.0.1 user: oreilly file_name: <code>fft_image_xform.proj</code> <br>
Published on wiki: emergent page: demos/fft_image_xform with description: demonstrates what you can do with fast fourier transforms on images -- fun! tags: Demo, Fast Fourier Transform, Images, Low Pass Filter, Hi Pass Filter, Phase Rotation author: Randall C. O'Reilly email: emergent-users@grey.colorado.edu version: 8.0.0 pub_cite: 
</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<P>
<li>Tue Aug 30 03:13:53 2016 version: 8.0.2 user: oreilly file_name: <code>fft_image_xform.proj</code> <br>
Project updated on wiki: emergent changes: doc link
<P>
<P>
<li>Tue Aug 30 03:11:18 2016 version: 8.0.1 user: oreilly file_name: <code>fft_image_xform.proj</code> <br>
Published on wiki: emergent page: demos/fft_image_xform with description: demonstrates what you can do with fast fourier transforms on images -- fun! tags: Demo, Fast Fourier Transform, Images, Low Pass Filter, Hi Pass Filter, Phase Rotation author: Randall C. O'Reilly email: emergent-users@grey.colorado.edu version: 8.0.0 pub_cite: 
</ul>
</body>
</html>
";
  };
 };
 wizards {
  name="wizards";
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @["LeabraWizard_0"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_6";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=0;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_0";
  };
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  ClusterRun @["ClusterRun"] {
   name="ClusterRun";
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=EditMbrItem;
    el_def=0;
   };
   mths {
    name="mths";
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   jobs_running {
    name="jobs_running";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_done {
    name="jobs_done";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_deleted {
    name="jobs_deleted";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_archive {
    name="jobs_archive";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   file_list {
    name="file_list";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="cluster where this job was submitted / run";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_name"] {
      name="file_name";
      desc="name of file -- does not include any path information";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="job tag associated with this file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["size"] {
      name="size";
      desc="size of file -- with typical suffixes (K = kilobytes, M = megabytes, G = gigabytes)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["kind"] {
      name="kind";
      desc="type of file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_modified"] {
      name="date_modified";
      desc="timestamp for when the file was last modified";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_created"] {
      name="date_created";
      desc="timestamp for when the file was first created";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["svn_file_path"] {
      name="svn_file_path";
      desc="path to file in SVN repository, relative to root of svn_repo repository";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["proj_file_path"] {
      name="proj_file_path";
      desc="path to file relative to the parent project directory -- e.g., results/filename.dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_path"] {
      name="file_path";
      desc="full path to file on local file system, including all parent directories and name of file -- takes you directly to the file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   cluster_info {
    name="cluster_info";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["queue"] {
      name="queue";
      desc="queue that this info relates to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number or total number of actve jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["state"] {
      name="state";
      desc="current scheduler state -- or description of global state info";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["procs"] {
      name="procs";
      desc="number of processors for this job or for global state info";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="timestamp for when the job was submitted or started running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=0;
   proj_name=;
   auto_updt_interval=10;
   auto_updt_timeout=30;
   cluster=;
   clusters=;
   users=;
   last_submit_time=;
   notes=;
   label=;
   extra_files=;
   svn_repo=;
   repo_url=;
   queue=;
   run_time=;
   exe_cmd="emergent";
   ram_gb=0;
   n_threads=1;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=0;
  };
 };
 param_sets {
  name="param_sets";
  el_typ=ParamSet;
  el_def=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp["InputData"] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp["OutputData"] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp["AnalysisData"] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @["FFTest"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @["DocLink"] {
     name="DocLink";
     doc=.projects["fft_image_xform"].programs["FFTest"].doc$$;
    };
   };
   name="FFTest";
   short_nm="FFTest";
   tags=;
   desc=;
   version {
    major=0;
    minor=0;
    step=0;
   };
   author="Randall C. O'Reilly";
   email="emergent-users@grey.colorado.edu";
   flags=0;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taImage;
    el_def=0;
    taImage @["taImage_orig"] {
     name="taImage_orig";
    };
    taImage @["taImage_recon"] {
     name="taImage_recon";
    };
    DataTable @["Images"] {
     name="Images";
     desc=;
     data {
      name="data";
      el_typ=double_Data;
      el_def=0;
      String_Data @["Manip"] {
       name="Manip";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{ 1;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
      };
      float_Data @["Orig"] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_8";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @["IMAGE"] {
	 name="IMAGE";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="Orig";
       col_flags=SAVE_DATA;
       is_matrix=1;
       cell_geom{ 320;320;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [2] ;;       };
       width=0;
      };
      float_Data @["Recon"] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_8";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @["IMAGE"] {
	 name="IMAGE";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="Recon";
       col_flags=SAVE_DATA;
       is_matrix=1;
       cell_geom{ 320;320;       };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [2] ;;       };
       width=0;
      };
     };
     data_flags=AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
     row_indexes {
      name="row_indexes";
     [0]      };
     last_sort_spec {
      name="last_sort_spec";
      ops {
       name="ops";
       el_typ=DataSortEl;
       el_def=0;
      };
     };
     control_panel_cells {
      name="control_panel_cells";
      el_typ=DataTableCell;
      el_def=0;
     };
    };
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
    DynEnumType @["ManipType"] {
     name="ManipType";
     desc=;
     enums {
      name="DynEnumItem_List_0";
      el_typ=DynEnumItem;
      el_def=0;
      DynEnumItem @["ROTATE_FFT"] {
       name="ROTATE_FFT";
       value=0;
       desc="rotate the fft values by varying degrees";
      };
      DynEnumItem @["SET_FFT_INDEXES"] {
       name="SET_FFT_INDEXES";
       value=1;
       desc="set individual fft indicies to given values";
      };
      DynEnumItem @["LOW_PASS_FILTER"] {
       name="LOW_PASS_FILTER";
       value=2;
       desc=;
      };
      DynEnumItem @["HI_PASS_FILTER"] {
       name="HI_PASS_FILTER";
       value=3;
       desc=;
      };
     };
     bits=0;
    };
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["image_size"] {
     name="image_size";
     var_type=T_Int;
     int_val=320;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="image size (make square)";
     init_from=NULL;
    };
    ProgVar @["manip_type"] {
     name="manip_type";
     var_type=T_DynEnum;
     dyn_enum_val {
      user_data_=NULL;
      enum_type=.projects["fft_image_xform"].programs["FFTest"].types["ManipType"]$$;
      value=2;
     };
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["taImage_orig"] {
     name="taImage_orig";
     var_type=T_Object;
     object_type=taImage;
     object_val=.projects["fft_image_xform"].programs["FFTest"].objs["taImage_orig"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["taImage_recon"] {
     name="taImage_recon";
     var_type=T_Object;
     object_type=taImage;
     object_val=.projects["fft_image_xform"].programs["FFTest"].objs["taImage_recon"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["Images"] {
     name="Images";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects["fft_image_xform"].programs["FFTest"].objs["Images"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["rotate_angle"] {
     name="rotate_angle";
     var_type=T_Real;
     real_val=190;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["start_angle"] {
     name="start_angle";
     var_type=T_Real;
     real_val=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="starting rotation angle in degrees";
     init_from=NULL;
    };
    ProgVar @["end_angle"] {
     name="end_angle";
     var_type=T_Real;
     real_val=180;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="ending rotation angle in degrees";
     init_from=NULL;
    };
    ProgVar @["angle_inc"] {
     name="angle_inc";
     var_type=T_Real;
     real_val=10;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="angle increment";
     init_from=NULL;
    };
    ProgVar @["fft_start_index"] {
     name="fft_start_index";
     var_type=T_Int;
     int_val=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="starting index for setting fft values directly to fft_set_val";
     init_from=NULL;
    };
    ProgVar @["fft_end_index"] {
     name="fft_end_index";
     var_type=T_Int;
     int_val=20;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["fft_real_val"] {
     name="fft_real_val";
     var_type=T_Real;
     real_val=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="value to set fft at index to";
     init_from=NULL;
    };
    ProgVar @["fft_imag_val"] {
     name="fft_imag_val";
     var_type=T_Real;
     real_val=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="value to set fft at index to";
     init_from=NULL;
    };
    ProgVar @["fft_index"] {
     name="fft_index";
     var_type=T_Int;
     int_val=21;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (7 vars)";
     pre_compile_code_string="LocalVars (7 vars)";
     local_vars {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["flt_img"] {
       name="flt_img";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["img_recon"] {
       name="img_recon";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["img_fft"] {
       name="img_fft";
       var_type=T_Object;
       object_type=complex_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["fft_xform"] {
       name="fft_xform";
       var_type=T_Object;
       object_type=complex_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["recon_fft"] {
       name="recon_fft";
       var_type=T_Object;
       object_type=complex_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["im_x"] {
       name="im_x";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["im_y"] {
       name="im_y";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taImage_orig->LoadImage(\"giraffe.jpg\")";
     pre_compile_code_string="taImage_orig->LoadImage(\"giraffe.jpg\")";
     result_var=NULL;
     obj=.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$$;
     method=taImage::LoadImage;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"giraffe.jpg\"";
       };
      };
     };
     meth_sig="bool LoadImage(taString& fname)";
     meth_desc=" load the image from given file name (leave file name blank to get a chooser)";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taImage_orig->GetImageSize(im_x, im_y)";
     pre_compile_code_string="taImage_orig->GetImageSize(im_x, im_y)";
     result_var=NULL;
     obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
     method=taImage::GetImageSize;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int_ref;
       type="int&";
       name="width";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="im_x";
       };
      };
      ProgArg @[1] {
       arg_type=int_ref;
       type="int&";
       name="height";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="im_y";
       };
      };
     };
     meth_sig="bool GetImageSize(int& width, int& height)";
     meth_desc=" get size of current image";
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taImage_orig->ScaleImage((double)image_size / im_x, (double)image_size / im_y, true)";
     pre_compile_code_string="taImage_orig->ScaleImage((double)image_size / im_x, (double)image_size / im_y, true)";
     result_var=NULL;
     obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
     method=taImage::ScaleImage;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float;
       type="float";
       name="sx";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="(double)image_size / im_x";
       };
      };
      ProgArg @[1] {
       arg_type=float;
       type="float";
       name="sy";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="(double)image_size / im_y";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="smooth";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="bool ScaleImage(float sx, float sy, bool smooth = true)";
     meth_desc=" scale image by given normalized scaling factors in each dimension";
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taImage_orig->ImageToMatrix_grey(flt_img)";
     pre_compile_code_string="taImage_orig->ImageToMatrix_grey(flt_img)";
     result_var=NULL;
     obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
     method=taImage::ImageToMatrix_grey;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ref;
       type="float_Matrix&";
       name="grey_data";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="flt_img";
       };
      };
     };
     meth_sig="bool ImageToMatrix_grey(float_Matrix& grey_data)";
     meth_desc=" convert image to greyscale Matrix floating point image data (alias for ImageToGrey_float): note that this uses standard matrix convention where 0,0 = bottom left of image, not top left..";
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="img_fft = fft2(flt_img)";
     pre_compile_code_string="img_fft = fft2(flt_img)";
     result_var=.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["img_fft"]$$;
     expr {
      expr="fft2(flt_img)";
     };
    };
    MethodCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="fft_xform->SetGeomN(img_fft.geom)";
     pre_compile_code_string="fft_xform->SetGeomN(img_fft.geom)";
     result_var=NULL;
     obj=.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["fft_xform"]$$;
     method=taMatrix::SetGeomN;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_MatrixGeom_ref;
       type="MatrixGeom&";
       name="geom_";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="img_fft.geom";
       };
      };
     };
     meth_sig="bool SetGeomN(MatrixGeom& geom_)";
     meth_desc=" set geom for any sized matrix -- if matches current size, it is non-destructive";
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Images->ResetData()";
     pre_compile_code_string="Images->ResetData()";
     result_var=NULL;
     obj=.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$$;
     method=DataTable::ResetData;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    Switch @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="switch(manip_type)";
     pre_compile_code_string="switch(manip_type)";
     switch_var=.projects["fft_image_xform"].programs["FFTest"].vars["manip_type"]$$;
     cases {
      name="ProgEl_List_139";
      el_typ=CaseBlock;
      el_def=0;
      CaseBlock @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: ROTATE_FFT";
       pre_compile_code_string="case: ROTATE_FFT";
       prog_code {
	name="ProgEl_List_139";
	el_typ=ProgCode;
	el_def=0;
	ForLoop @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (rotate_angle = start_angle;  rotate_angle <= end_angle;  rotate_angle += angle_inc)";
	 pre_compile_code_string="for (rotate_angle = start_angle;  rotate_angle <= end_angle;  rotate_angle += angle_inc)";
	 loop_code {
	  name="ProgEl_List_142";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="fft_xform->ExpiAll(taMath_double::rad_per_deg * rotate_angle)";
	   pre_compile_code_string="fft_xform->ExpiAll(taMath_double::rad_per_deg * rotate_angle)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["fft_xform"]$;
	   method=complex_Matrix::ExpiAll;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=double;
	     type="double";
	     name="angle";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="taMath_double::rad_per_deg * rotate_angle";
	     };
	    };
	   };
	   meth_sig="void ExpiAll(double angle)";
	   meth_desc=" sets complex numbers in this matrix from angle in input matrix, using exponential of i * angle = cos(angle) + i sin(angle) (Euler's formula) -- initializes all matrix values to the same numbers";
	  };
	  AssignExpr @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft = img_fft * fft_xform";
	   pre_compile_code_string="recon_fft = img_fft * fft_xform";
	   result_var=.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["recon_fft"]$$;
	   expr {
	    expr="img_fft * fft_xform";
	   };
	  };
	  AssignExpr @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="img_recon = real(ffti2(recon_fft))";
	   pre_compile_code_string="img_recon = real(ffti2(recon_fft))";
	   result_var=.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["img_recon"]$$;
	   expr {
	    expr="real(ffti2(recon_fft))";
	   };
	  };
	  MethodCall @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   pre_compile_code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   result_var=NULL;
	   obj=.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$$;
	   method=taImage::ImageFromMatrix_grey;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_float_Matrix_ref;
	     type="float_Matrix&";
	     name="grey_data";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="img_recon";
	     };
	    };
	   };
	   meth_sig="bool ImageFromMatrix_grey(float_Matrix& grey_data)";
	   meth_desc=" convert from greyscale Matrix floating point image data to this image: note that this uses standard matrix convention where 0,0 = bottom left of image, not top left.. resulting image is size of matrix data (makes a new image)";
	  };
	  MethodCall @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images->AddBlankRow()";
	   pre_compile_code_string="Images->AddBlankRow()";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   method=DataTable::AddBlankRow;
	   meth_args {
	    name="ProgArg_List_0";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="int AddBlankRow()";
	   meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	  };
	  MethodCall @[5] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   pre_compile_code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name="ProgArg_List_0";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Orig\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  MethodCall @[6] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   pre_compile_code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Recon\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  UserScript @[7] {
	   desc=;
	   flags=OFF|PROG_ERROR|CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   pre_compile_code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   script {
	    expr="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   };
	  };
	  MemberMethodCall @[8] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"].SetVal(\"Rotate: \" + String(rotate_angle), -1)";
	   pre_compile_code_string="Images[\"Manip\"].SetVal(\"Rotate: \" + String(rotate_angle), -1)";
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   path="[\"Manip\"]";
	   result_var=NULL;
	   method=DataCol::SetVal;
	   meth_args {
	    name="ProgArg_List_0";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="val";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Rotate: \" + String(rotate_angle)";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool SetVal(Variant& val, int row)";
	   meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), -ve row is from end (-1=last)";
	  };
	 };
	 init {
	  expr="rotate_angle = start_angle";
	 };
	 test {
	  expr=" rotate_angle <= end_angle";
	 };
	 iter {
	  expr=" rotate_angle += angle_inc";
	 };
	};
       };
       case_val {
	expr="ROTATE_FFT";
       };
       is_default=0;
      };
      CaseBlock @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: SET_FFT_INDEXES";
       pre_compile_code_string="case: SET_FFT_INDEXES";
       prog_code {
	name="ProgEl_List_140";
	el_typ=ProgCode;
	el_def=0;
	ForLoop @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (fft_index = fft_start_index; fft_index <= fft_end_index; fft_index++)";
	 pre_compile_code_string="for (fft_index = fft_start_index; fft_index <= fft_end_index; fft_index++)";
	 loop_code {
	  name="ProgEl_List_142";
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft = img_fft";
	   pre_compile_code_string="recon_fft = img_fft";
	   result_var=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["recon_fft"]$;
	   expr {
	    expr="img_fft";
	   };
	  };
	  UserScript @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft[0,fft_index:fft_index+1,fft_index:fft_index+1] = fft_real_val;";
	   pre_compile_code_string="recon_fft[0,fft_index:fft_index+1,fft_index:fft_index+1] = fft_real_val;";
	   script {
	    expr="recon_fft[0,fft_index:fft_index+1,fft_index:fft_index+1] = fft_real_val;";
	   };
	  };
	  UserScript @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft[1,fft_index:fft_index+1,fft_index:fft_index+1] = fft_imag_val;";
	   pre_compile_code_string="recon_fft[1,fft_index:fft_index+1,fft_index:fft_index+1] = fft_imag_val;";
	   script {
	    expr="recon_fft[1,fft_index:fft_index+1,fft_index:fft_index+1] = fft_imag_val;";
	   };
	  };
	  MethodCall @[3] {
	   desc=;
	   flags=OFF|CAN_REVERT_TO_CODE;
	   code_string="recon_fft->Set(fft_real_val, fft_real_or_imag, fft_index, 0, , , , )";
	   pre_compile_code_string="recon_fft->Set(fft_real_val, fft_real_or_imag, fft_index, 0, , , , )";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["recon_fft"]$;
	   method=taMatrixT_double_::Set;
	   meth_args {
	    name="ProgArg_List_0";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_double_ref;
	     type="double&";
	     name="item";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="fft_real_val";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="d0";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="fft_real_or_imag";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="d1";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="fft_index";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=int;
	     type="int";
	     name="d2";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="0";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=int;
	     type="int";
	     name="d3";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=int;
	     type="int";
	     name="d4";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=int;
	     type="int";
	     name="d5";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=int;
	     type="int";
	     name="d6";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="void Set(double& item, int d0, int d1 = 0, int d2 = 0, int d3 = 0, int d4 = 0, int d5 = 0, int d6 = 0)";
	   meth_desc=" safely assign values to items in the matrix";
	  };
	  AssignExpr @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="img_recon = real(ffti2(recon_fft))";
	   pre_compile_code_string="img_recon = real(ffti2(recon_fft))";
	   result_var=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["img_recon"]$;
	   expr {
	    expr="real(ffti2(recon_fft))";
	   };
	  };
	  MethodCall @[5] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   pre_compile_code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageFromMatrix_grey;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_float_Matrix_ref;
	     type="float_Matrix&";
	     name="grey_data";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="img_recon";
	     };
	    };
	   };
	   meth_sig="bool ImageFromMatrix_grey(float_Matrix& grey_data)";
	   meth_desc=" convert from greyscale Matrix floating point image data to this image: note that this uses standard matrix convention where 0,0 = bottom left of image, not top left.. resulting image is size of matrix data (makes a new image)";
	  };
	  MethodCall @[6] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images->AddBlankRow()";
	   pre_compile_code_string="Images->AddBlankRow()";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   method=DataTable::AddBlankRow;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="int AddBlankRow()";
	   meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	  };
	  MethodCall @[7] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   pre_compile_code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Orig\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  MethodCall @[8] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   pre_compile_code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Recon\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  UserScript @[9] {
	   desc=;
	   flags=OFF|PROG_ERROR|CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   pre_compile_code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   script {
	    expr="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   };
	  };
	  MemberMethodCall @[10] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"].SetVal(\"Index: \" + String(fft_index) + \" = \" + String(fft_real_val) + \" + i\" + String(fft_imag_val), -1)";
	   pre_compile_code_string="Images[\"Manip\"].SetVal(\"Index: \" + String(fft_index) + \" = \" + String(fft_real_val) + \" + i\" + String(fft_imag_val), -1)";
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   path="[\"Manip\"]";
	   result_var=NULL;
	   method=DataCol::SetVal;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="val";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Index: \" + String(fft_index) + \" = \" + String(fft_real_val) + \" + i\" + String(fft_imag_val)";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool SetVal(Variant& val, int row)";
	   meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), -ve row is from end (-1=last)";
	  };
	 };
	 init {
	  expr="fft_index = fft_start_index";
	 };
	 test {
	  expr="fft_index <= fft_end_index";
	 };
	 iter {
	  expr="fft_index++";
	 };
	};
       };
       case_val {
	expr="SET_FFT_INDEXES";
       };
       is_default=0;
      };
      CaseBlock @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: LOW_PASS_FILTER";
       pre_compile_code_string="case: LOW_PASS_FILTER";
       prog_code {
	name="ProgEl_List_29";
	el_typ=ProgCode;
	el_def=0;
	ForLoop @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (fft_index = fft_start_index; fft_index <= fft_end_index; fft_index++)";
	 pre_compile_code_string="for (fft_index = fft_start_index; fft_index <= fft_end_index; fft_index++)";
	 loop_code {
	  name="ProgEl_List_30";
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft = img_fft";
	   pre_compile_code_string="recon_fft = img_fft";
	   result_var=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["recon_fft"]$;
	   expr {
	    expr="img_fft";
	   };
	  };
	  UserScript @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft[0,fft_index:,fft_index:] = fft_real_val;";
	   pre_compile_code_string="recon_fft[0,fft_index:,fft_index:] = fft_real_val;";
	   script {
	    expr="recon_fft[0,fft_index:,fft_index:] = fft_real_val;";
	   };
	  };
	  UserScript @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft[1,fft_index:,fft_index:] = fft_imag_val;";
	   pre_compile_code_string="recon_fft[1,fft_index:,fft_index:] = fft_imag_val;";
	   script {
	    expr="recon_fft[1,fft_index:,fft_index:] = fft_imag_val;";
	   };
	  };
	  AssignExpr @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="img_recon = real(ffti2(recon_fft))";
	   pre_compile_code_string="img_recon = real(ffti2(recon_fft))";
	   result_var=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["img_recon"]$;
	   expr {
	    expr="real(ffti2(recon_fft))";
	   };
	  };
	  MethodCall @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   pre_compile_code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageFromMatrix_grey;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_float_Matrix_ref;
	     type="float_Matrix&";
	     name="grey_data";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="img_recon";
	     };
	    };
	   };
	   meth_sig="bool ImageFromMatrix_grey(float_Matrix& grey_data)";
	   meth_desc=" convert from greyscale Matrix floating point image data to this image: note that this uses standard matrix convention where 0,0 = bottom left of image, not top left.. resulting image is size of matrix data (makes a new image)";
	  };
	  MethodCall @[5] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images->AddBlankRow()";
	   pre_compile_code_string="Images->AddBlankRow()";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   method=DataTable::AddBlankRow;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="int AddBlankRow()";
	   meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	  };
	  MethodCall @[6] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   pre_compile_code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Orig\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  MethodCall @[7] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   pre_compile_code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Recon\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  UserScript @[8] {
	   desc=;
	   flags=OFF|PROG_ERROR|CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   pre_compile_code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   script {
	    expr="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   };
	  };
	  MemberMethodCall @[9] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"].SetVal(\"LPF Index: \" + String(fft_index), -1)";
	   pre_compile_code_string="Images[\"Manip\"].SetVal(\"LPF Index: \" + String(fft_index), -1)";
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   path="[\"Manip\"]";
	   result_var=NULL;
	   method=DataCol::SetVal;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="val";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"LPF Index: \" + String(fft_index)";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool SetVal(Variant& val, int row)";
	   meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), -ve row is from end (-1=last)";
	  };
	 };
	 init {
	  expr="fft_index = fft_start_index";
	 };
	 test {
	  expr="fft_index <= fft_end_index";
	 };
	 iter {
	  expr="fft_index++";
	 };
	};
       };
       case_val {
	expr="LOW_PASS_FILTER";
       };
       is_default=0;
      };
      CaseBlock @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: HI_PASS_FILTER";
       pre_compile_code_string="case: HI_PASS_FILTER";
       prog_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	ForLoop @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (fft_index = fft_start_index; fft_index <= fft_end_index; fft_index++)";
	 pre_compile_code_string="for (fft_index = fft_start_index; fft_index <= fft_end_index; fft_index++)";
	 loop_code {
	  name=;
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft = img_fft";
	   pre_compile_code_string="recon_fft = img_fft";
	   result_var=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["recon_fft"]$;
	   expr {
	    expr="img_fft";
	   };
	  };
	  UserScript @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft[0,:fft_index+1,:fft_index+1] = fft_real_val;";
	   pre_compile_code_string="recon_fft[0,:fft_index+1,:fft_index+1] = fft_real_val;";
	   script {
	    expr="recon_fft[0,:fft_index+1,:fft_index+1] = fft_real_val;";
	   };
	  };
	  UserScript @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="recon_fft[1,:fft_index+1,:fft_index+1] = fft_imag_val;";
	   pre_compile_code_string="recon_fft[1,:fft_index+1,:fft_index+1] = fft_imag_val;";
	   script {
	    expr="recon_fft[1,:fft_index+1,:fft_index+1] = fft_imag_val;";
	   };
	  };
	  AssignExpr @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="img_recon = real(ffti2(recon_fft))";
	   pre_compile_code_string="img_recon = real(ffti2(recon_fft))";
	   result_var=$.projects["fft_image_xform"].programs["FFTest"].prog_code[0].local_vars["img_recon"]$;
	   expr {
	    expr="real(ffti2(recon_fft))";
	   };
	  };
	  MethodCall @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   pre_compile_code_string="taImage_recon->ImageFromMatrix_grey(img_recon)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageFromMatrix_grey;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_float_Matrix_ref;
	     type="float_Matrix&";
	     name="grey_data";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="img_recon";
	     };
	    };
	   };
	   meth_sig="bool ImageFromMatrix_grey(float_Matrix& grey_data)";
	   meth_desc=" convert from greyscale Matrix floating point image data to this image: note that this uses standard matrix convention where 0,0 = bottom left of image, not top left.. resulting image is size of matrix data (makes a new image)";
	  };
	  MethodCall @[5] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images->AddBlankRow()";
	   pre_compile_code_string="Images->AddBlankRow()";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   method=DataTable::AddBlankRow;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="int AddBlankRow()";
	   meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	  };
	  MethodCall @[6] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   pre_compile_code_string="taImage_orig->ImageToDataCell(Images, \"Orig\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_orig"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Orig\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  MethodCall @[7] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   pre_compile_code_string="taImage_recon->ImageToDataCell(Images, \"Recon\", -1)";
	   result_var=NULL;
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["taImage_recon"]$;
	   method=taImage::ImageToDataCell;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=DataTable_ptr;
	     type="DataTable*";
	     name="dt";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="Images";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Recon\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool ImageToDataCell(DataTable* dt, Variant& col, int row)";
	   meth_desc=" set image to datatable cell indexed by col (name or number) and row -- uses cell dimensionality and type -- only amount that fits in cell is copied. row = -1 = last row";
	  };
	  UserScript @[8] {
	   desc=;
	   flags=OFF|PROG_ERROR|CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   pre_compile_code_string="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   script {
	    expr="Images[\"Manip\"][-1] = \"Rotate: \" + String(rotate_angle);";
	   };
	  };
	  MemberMethodCall @[9] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="Images[\"Manip\"].SetVal(\"HPF Index: \" + String(fft_index), -1)";
	   pre_compile_code_string="Images[\"Manip\"].SetVal(\"HPF Index: \" + String(fft_index), -1)";
	   obj=$.projects["fft_image_xform"].programs["FFTest"].vars["Images"]$;
	   path="[\"Manip\"]";
	   result_var=NULL;
	   method=DataCol::SetVal;
	   meth_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="val";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"HPF Index: \" + String(fft_index)";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool SetVal(Variant& val, int row)";
	   meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), -ve row is from end (-1=last)";
	  };
	 };
	 init {
	  expr="fft_index = fft_start_index";
	 };
	 test {
	  expr="fft_index <= fft_end_index";
	 };
	 iter {
	  expr="fft_index++";
	 };
	};
       };
       case_val {
	expr="HI_PASS_FILTER";
       };
       is_default=0;
      };
     };
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @["Browser2"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_42";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["view_win_lft"] {
     name="view_win_lft";
     value 8 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_top"] {
     name="view_win_top";
     value 8 0=0.04553625;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_wd"] {
     name="view_win_wd";
     value 8 0=1;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_ht"] {
     name="view_win_ht";
     value 8 0=0.7992811;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_iconified"] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_splitter_state"] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAEAAAADAAABAAAAAfwAAAKMAQAAAAcBAAAAAQA=";
     val_type_fixed=0;
    };
   };
   name="Browser2";
   m_data=.projects["fft_image_xform"]$$;
   cur_font_size=12;
   visible=1;
   win_name=".projects[\"fft_image_xform\"] - fft_image_xform.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @["Application"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_43";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_visible"] {
       name="view_win_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=12;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @["Navigator"] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects["fft_image_xform"]$;
    };
    PanelViewer @["Editor"] {
     name="Editor";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
    };
    T3PanelViewer @["T3Frames"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_44";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_panel_selected"] {
       name="view_panel_selected";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="T3Frames";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @["Frame1"] {
       name="Frame1";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GridTableView;
	 el_def=0;
	 GridTableView @["Images_Grid"] {
	  name="Images_Grid";
	  m_data=$.projects["fft_image_xform"].programs["FFTest"].objs["Images"]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @["Manip"] {
	    name="Manip";
	    m_data=.projects["fft_image_xform"].programs["FFTest"].objs["Images"].data["Manip"]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Orig"] {
	    name="Orig";
	    m_data=.projects["fft_image_xform"].programs["FFTest"].objs["Images"].data["Orig"]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=320;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=1;
	    mat_odd_vert=1;
	   };
	   GridColView @["Recon"] {
	    name="Recon";
	    m_data=.projects["fft_image_xform"].programs["FFTest"].objs["Images"].data["Recon"]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    text_width=320;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=1;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=5;
	  view_range {min=0: max=-1: };
	  page_rows=10;
	  display_on=1;
	  manip_ctrl_on=1;
	  view_cols=5;
	  page_cols=5;
	  col_range {min=0: max=2: };
	  need_scale_update=1;
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs["C_ColdHot"]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.4;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.05: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	  use_custom_paging=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {
	field_of_view=45;
	near_distance=0.1;
	focal=5;
	far_distance=1000;
       };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["Vw_0"] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5174999: z=1.443747: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.453747;
	};
	T3SavedView @["Recon_Zoom"] {
	 name="Recon_Zoom";
	 view_saved=1;
	 pos {x=1.8365: y=0.8675009: z=0.428737: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0.438737;
	};
	T3SavedView @["Vw_2"] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_3"] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_4"] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_5"] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_6"] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_7"] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_8"] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_9"] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @["Tools"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_45";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_lft"] {
       name="view_win_lft";
       value 8 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_top"] {
       name="view_win_top";
       value 8 0=0.005991612;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_wd"] {
       name="view_win_wd";
       value 8 0=0.02772143;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_ht"] {
       name="view_win_ht";
       value 8 0=0.7543439;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_iconified"] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_visible"] {
       name="view_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="Project updated on wiki: emergent changes: doc link";
 tree_state{ .;.docs;.wizards;.wizards[0];.ctrl_panels;.param_sets;.data;.data.gp[0];.data.gp[1];.data.gp[2];.programs;.networks; };
 networks {
  name="networks";
  el_typ=LeabraNetwork;
  el_def=0;
 };
};

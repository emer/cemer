// ta_Dump File v3.0 -- code v8.0.0.0 rev9957
LeabraProject .projects["std_wizards"] { 
 Doc_Group @.docs = [2] {
  taDoc @["ProjectDoc"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["user_pinned"] { };
   };
  };
  taDoc @["ChangeLog"] { };
 };

 Wizard_Group @.wizards = [1] {
  LeabraWizard @["LeabraWizard_0"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["NO_CLIP"] { };
    UserDataItem @["user_pinned"] { };
   };
  };
 };

 ControlPanel_Group @.ctrl_panels = [1] {
  ClusterRun @["ClusterRun"] { 
   EditMbrItem_Group @.mbrs = [0] {
   };

   EditMthItem_Group @.mths = [0] {
   };

   DataTableCols @.jobs_running.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_running.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_running.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_done.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_done.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_done.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_deleted.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_deleted.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_deleted.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_archive.data = [33] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["label"] { };
    String_Data @["notes"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
    String_Data @["done_svn"] { };
    String_Data @["last_svn"] { };
   };

   DataOpList @.jobs_archive.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_archive.control_panel_cells = [0] {
   };

   DataTableCols @.file_list.data = [11] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["file_name"] { };
    String_Data @["tag"] { };
    String_Data @["size"] { };
    String_Data @["kind"] { };
    String_Data @["date_modified"] { };
    String_Data @["date_created"] { };
    String_Data @["svn_file_path"] { };
    String_Data @["proj_file_path"] { };
    String_Data @["file_path"] { };
   };

   DataOpList @.file_list.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.file_list.control_panel_cells = [0] {
   };

   DataTableCols @.cluster_info.data = [6] {
    String_Data @["queue"] { };
    String_Data @["job_no"] { };
    String_Data @["user"] { };
    String_Data @["state"] { };
    String_Data @["procs"] { };
    String_Data @["start_time"] { };
   };

   DataOpList @.cluster_info.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.cluster_info.control_panel_cells = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.param_sets = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp["InputData"] { 
  };
  DataTable_Group @.gp["OutputData"] { 
  };
  DataTable_Group @.gp["AnalysisData"] { 
  };
 };

 Program_TopGroup @.programs = [1] {
  Program @["NetworkWizard"] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @["DocLink"] { };
   };

   ProgObjList @.objs = [3] {
    taGuiDialog @["Dlg1"] { };
    taGuiDialog @["Dlg2"] { };
    DataTable @["NetworkConfig"] { 
     DataTableCols @.data = [8] {
      String_Data @["Group"] { };
      String_Data @["Name"] { };
      String_Data @["Type"] { };
      int_Data @["Size_X"] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @["NARROW"] { };
       };
      };
      int_Data @["Size_Y"] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @["NARROW"] { };
       };
      };
      int_Data @["UnitGps_X"] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @["NARROW"] { };
       };
      };
      int_Data @["UnitGps_Y"] { 
       UserDataItem_List @*(.user_data_) {
	UserDataItem @["NARROW"] { };
       };
      };
      String_Data @["RecvPrjns"] { };
     };

     DataOpList @.last_sort_spec.ops = [0] {
     };

     DataTableCell_List @.control_panel_cells = [0] {
     };
    };
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [0] {
   };

   ProgVar_List @.vars = [7] {
    ProgVar @["Dlg1"] { };
    ProgVar @["Dlg2"] { };
    ProgVar @["network"] { };
    ProgVar @["n_layers"] { };
    ProgVar @["curow"] { };
    ProgVar @["NetworkConfig"] { };
    ProgVar @["rval"] { };
   };

   Function_List @.functions = [6] {
    Function @["NewNetwork"] { 
     ProgVar_List @.args = [0] {
     };

     ProgEl_List @.fun_code = [4] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      AssignExpr @[1] { };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      PrintVar @[3] { };
     };
    };
    Function @["NLayersFmNetwork"] { 
     ProgVar_List @.args = [0] {
     };

     ProgEl_List @.fun_code = [5] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      IfReturn @[1] { };
      AssignExpr @[2] { };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      PrintVar @[4] { };
     };
    };
    Function @["ConfigOneLayer"] { 
     ProgVar_List @.args = [3] {
      ProgVar @["lay_no"] { };
      ProgVar @["nm"] { };
      ProgVar @["typ"] { };
     };

     ProgEl_List @.fun_code = [5] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    Function @["NewNetDefaultConfig"] { 
     ProgVar_List @.args = [0] {
     };

     ProgEl_List @.fun_code = [6] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [3] {
	ProgVar @["n_lays"] { };
	ProgVar @["lay"] { };
	ProgVar @["i"] { };
       };
      };
      AssignExpr @[1] { };
      If @[2] { 
       ProgEl_List @.true_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
       };
      };
      If @[3] { 
       ProgEl_List @.true_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
       };
      };
      If @[4] { 
       ProgEl_List @.true_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
       };
      };
      If @[5] { 
       ProgEl_List @.true_code = [2] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	ForLoop @[1] { 
	 ProgEl_List @.loop_code = [1] {
	  FunctionCall @[0] { 
	   ProgArg_List @.fun_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	 };
	};
       };
      };
     };
    };
    Function @["AddNewLayerRow"] { 
     ProgVar_List @.args = [0] {
     };

     ProgEl_List @.fun_code = [3] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };
    };
    Function @["RefreshLayerList"] { 
     ProgVar_List @.args = [0] {
     };

     ProgEl_List @.fun_code = [2] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };
    };
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [53] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @["new_net"] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MemberAssign @[2] { };
    MemberAssign @[3] { };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    AssignExpr @[6] { };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    AssignExpr @[10] { };
    MethodCall @[11] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[12] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    MethodCall @[13] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[14] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    MethodCall @[15] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    AssignExpr @[16] { };
    MethodCall @[17] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[18] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[19] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    MethodCall @[20] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[21] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    MethodCall @[22] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    IfReturn @[23] { };
    Comment @[24] { };
    If @[25] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    MethodCall @[26] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[27] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[28] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[29] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
    MethodCall @[30] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MemberAssign @[31] { };
    MemberAssign @[32] { };
    MethodCall @[33] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[34] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[35] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    AssignExpr @[36] { };
    MethodCall @[37] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[38] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[39] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    AssignExpr @[40] { };
    MethodCall @[41] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[42] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    AssignExpr @[43] { };
    MethodCall @[44] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[45] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    MethodCall @[46] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[47] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    MethodCall @[48] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    IfReturn @[49] { };
    Comment @[50] { };
    MethodCall @[51] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[52] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @["Browser2"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["view_win_lft"] { };
    UserDataItem @["view_win_top"] { };
    UserDataItem @["view_win_wd"] { };
    UserDataItem @["view_win_ht"] { };
    UserDataItem @["view_win_iconified"] { };
    UserDataItem @["view_splitter_state"] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @["Application"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_visible"] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @["Navigator"] { };
    PanelViewer @["Editor"] { };
    T3PanelViewer @["T3Frames"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_panel_selected"] { };
     };

     T3Panel_List @.panels = [1] {
      T3Panel @["Frame1"] { 
       T3DataView_List @.root_view.children = [0] {
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @["Vw_0"] { };
	T3SavedView @["Vw_1"] { };
	T3SavedView @["Vw_2"] { };
	T3SavedView @["Vw_3"] { };
	T3SavedView @["Vw_4"] { };
	T3SavedView @["Vw_5"] { };
	T3SavedView @["Vw_6"] { };
	T3SavedView @["Vw_7"] { };
	T3SavedView @["Vw_8"] { };
	T3SavedView @["Vw_9"] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @["Tools"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_lft"] { };
      UserDataItem @["view_win_top"] { };
      UserDataItem @["view_win_wd"] { };
      UserDataItem @["view_win_ht"] { };
      UserDataItem @["view_win_iconified"] { };
      UserDataItem @["view_visible"] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [0] {
 };
};
LeabraProject .projects["std_wizards"] {
 name="std_wizards";
 desc="standard wizards constructed in Programs using taGui programmable gui -- good starting point for making your own custom wizards.";
 tags="Demo, Program, taGui, Dialog";
 version {
  major=8;
  minor=0;
  step=2;
 };
 author="Randall C. O'Reilly";
 email="emergent-users@grey.colorado.edu";
 license {
  license=GPLv2;
  owner_name="Regents of the University of Colorado";
  org="CCNLab at the University of Colorado Boulder";
  year="2016";
  custom=;
 };
 pub_cite=;
 wiki {
  wiki="emergent";
  page_name="demos/std_wizards";
 };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @["ProjectDoc"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_116";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="ProjectDoc";
   desc=;
   web_doc=1;
   wiki="emergent";
   url="demos/std_wizards";
   full_url="https://grey.colorado.edu/emergent/index.php/demos/std_wizards";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text=;
  };
  taDoc @["ChangeLog"] {
   name="ChangeLog";
   desc=;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>


<li>Tue Aug 30 03:27:21 2016 version: 8.0.2 user: oreilly file_name: <code>std_wizards.proj</code> <br>
Project updated on wiki: emergent changes: doc lnk


<li>Tue Aug 30 03:21:30 2016 version: 8.0.1 user: oreilly file_name: <code>std_wizards.proj</code> <br>
Published on wiki: emergent page: demos/std_wizards with description: standard wizards constructed in Programs using taGui programmable gui -- good starting point for making your own custom wizards. tags: Demo, Program, taGui, Dialog author: Randall C. O'Reilly email: emergent-users@grey.colorado.edu version: 8.0.0 pub_cite: 
</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<P>
<li>Tue Aug 30 03:27:21 2016 version: 8.0.2 user: oreilly file_name: <code>std_wizards.proj</code> <br>
Project updated on wiki: emergent changes: doc lnk
<P>
<P>
<li>Tue Aug 30 03:21:30 2016 version: 8.0.1 user: oreilly file_name: <code>std_wizards.proj</code> <br>
Published on wiki: emergent page: demos/std_wizards with description: standard wizards constructed in Programs using taGui programmable gui -- good starting point for making your own custom wizards. tags: Demo, Program, taGui, Dialog author: Randall C. O'Reilly email: emergent-users@grey.colorado.edu version: 8.0.0 pub_cite: 
</ul>
</body>
</html>
";
  };
 };
 wizards {
  name="wizards";
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @["LeabraWizard_0"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_6";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=0;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_0";
  };
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  ClusterRun @["ClusterRun"] {
   name="ClusterRun";
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=EditMbrItem;
    el_def=0;
   };
   mths {
    name="mths";
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   jobs_running {
    name="jobs_running";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_done {
    name="jobs_done";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_deleted {
    name="jobs_deleted";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_archive {
    name="jobs_archive";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph -- in general notes should have more general info and then label should JUST describe what is unique about the current run";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of physical nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="actually pb_n_batches_per -- re-using this parameter that was previously used for a different purpose -- number of batches to run sequentially within a single job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["done_svn"] {
      name="done_svn";
      desc="svn revision when this job was moved from running to done -- this will contain full set of files generated when running -- for deleted jobs can also recover to this";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["last_svn"] {
      name="last_svn";
      desc="last svn revision for command submission that affected this job in some significant way -- for deleted jobs, this is the svn revision that we recover to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   file_list {
    name="file_list";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="cluster where this job was submitted / run";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_name"] {
      name="file_name";
      desc="name of file -- does not include any path information";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="job tag associated with this file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["size"] {
      name="size";
      desc="size of file -- with typical suffixes (K = kilobytes, M = megabytes, G = gigabytes)";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["kind"] {
      name="kind";
      desc="type of file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_modified"] {
      name="date_modified";
      desc="timestamp for when the file was last modified";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_created"] {
      name="date_created";
      desc="timestamp for when the file was first created";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["svn_file_path"] {
      name="svn_file_path";
      desc="path to file in SVN repository, relative to root of svn_repo repository";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["proj_file_path"] {
      name="proj_file_path";
      desc="path to file relative to the parent project directory -- e.g., results/filename.dat";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_path"] {
      name="file_path";
      desc="full path to file on local file system, including all parent directories and name of file -- takes you directly to the file";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   cluster_info {
    name="cluster_info";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["queue"] {
      name="queue";
      desc="queue that this info relates to";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number or total number of actve jobs";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user name";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["state"] {
      name="state";
      desc="current scheduler state -- or description of global state info";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["procs"] {
      name="procs";
      desc="number of processors for this job or for global state info";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="timestamp for when the job was submitted or started running";
      col_flags=SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=0;
   proj_name=;
   auto_updt_interval=10;
   auto_updt_timeout=30;
   cluster=;
   clusters=;
   users=;
   last_submit_time=;
   notes=;
   label=;
   extra_files=;
   svn_repo=;
   repo_url=;
   queue=;
   run_time=;
   exe_cmd="emergent";
   ram_gb=0;
   n_threads=1;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=1;
  };
 };
 param_sets {
  name="param_sets";
  el_typ=ParamSet;
  el_def=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp["InputData"] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp["OutputData"] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp["AnalysisData"] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @["NetworkWizard"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @["DocLink"] {
     name="DocLink";
     doc=.projects["std_wizards"].programs["NetworkWizard"].doc$$;
    };
   };
   name="NetworkWizard";
   short_nm="NtwWzr";
   tags=;
   desc="network wizard based on gui dialog technology";
   version {
    major=0;
    minor=0;
    step=0;
   };
   author=;
   email=;
   flags=0;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=DataTable;
    el_def=0;
    taGuiDialog @["Dlg1"] {
     name="Dlg1";
     prompt="Network Wizard Step 1 of 2: Select Network and Number of Layers";
     win_title="Network Wizard Step 1 of 2";
     width=300;
     height=200;
    };
    taGuiDialog @["Dlg2"] {
     name="Dlg2";
     prompt="Network Wizard Step 2 of 2: Enter Layer Names, Sizes, and Projections (Prjns)";
     win_title="Network Wizard Step 2 of 2";
     width=900;
     height=600;
    };
    DataTable @["NetworkConfig"] {
     name="NetworkConfig";
     desc=;
     data {
      name="data";
      el_typ=String_Data;
      el_def=0;
      String_Data @["Group"] {
       name="Group";
       desc="name of layer group to put layer in -- layer groups are useful for organizing layers logically, moving them together, etc";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] ;;;       };
      };
      String_Data @["Name"] {
       name="Name";
       desc="name of layer -- will be updated to be a valid C language label so it can be referred to in Programs etc";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] "Input";"Hidden";"Output";       };
      };
      String_Data @["Type"] {
       name="Type";
       desc="functional type of layer in terms of input/output data -- options are: INPUT, TARGET, OUTPUT, HIDDEN -- TARGET means it learns from target output data, while OUTPUT means it generates output error signals but does not use output values for error-driven learning, HIDDEN doesn't get any input/output, and INPUT is simply an input layer";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] "INPUT";"HIDDEN";"TARGET";       };
      };
      int_Data @["Size_X"] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_8";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @["NARROW"] {
	 name="NARROW";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="Size_X";
       desc="size of layer (number of units) in the horizontal (X) axis";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] 5;5;5;       };
      };
      int_Data @["Size_Y"] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_9";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @["NARROW"] {
	 name="NARROW";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="Size_Y";
       desc="size of layer (number of units) in the vertical (Y) axis";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] 5;5;5;       };
      };
      int_Data @["UnitGps_X"] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_10";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @["NARROW"] {
	 name="NARROW";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="UnitGps_X";
       desc="number of unit groups (subgroups of units within a layer) in the horizontal (X) axis -- set to 0 to not have any subgroups at all";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] 0;0;0;       };
      };
      int_Data @["UnitGps_Y"] {
       UserDataItem_List @*(.user_data_) {
	name="UserDataItem_List_11";
	el_typ=UserDataItem;
	el_def=0;
	UserDataItem @["NARROW"] {
	 name="NARROW";
	 value 1 0=1;
	 val_type_fixed=0;
	};
       };
       name="UnitGps_Y";
       desc="number of unit groups (subgroups of units within a layer) in the vertical (Y) axis -- set to 0 to not have any subgroups at all";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] 0;0;0;       };
      };
      String_Data @["RecvPrjns"] {
       name="RecvPrjns";
       desc="receiving projections -- connections from other layers that send into this one -- these must be valid names of other layers in the network, separated by a space if there are multiple";
       col_flags=SAVE_DATA;
       is_matrix=0;
       cell_geom{        };
       calc_expr {
	expr=;
       };
       dim_names {
	name="dim_names";
       [0]        };
       width=0;
       ar {
	name="ar";
       [3] ;;;       };
      };
     };
     data_flags=SAVE_ROWS|AUTO_CALC;
     auto_load=NO_AUTO_LOAD;
     auto_load_file=;
     keygen 4 0=0;
     row_indexes {
      name="row_indexes";
     [3] 0;1;2;     };
     last_sort_spec {
      name="last_sort_spec";
      ops {
       name="ops";
       el_typ=DataSortEl;
       el_def=0;
      };
     };
     control_panel_cells {
      name="control_panel_cells";
      el_typ=DataTableCell;
      el_def=0;
     };
    };
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["Dlg1"] {
     name="Dlg1";
     var_type=T_Object;
     object_type=taGuiDialog;
     object_val=.projects["std_wizards"].programs["NetworkWizard"].objs["Dlg1"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["Dlg2"] {
     name="Dlg2";
     var_type=T_Object;
     object_type=taGuiDialog;
     object_val=.projects["std_wizards"].programs["NetworkWizard"].objs["Dlg2"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["network"] {
     name="network";
     var_type=T_Object;
     object_type=Network;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["n_layers"] {
     name="n_layers";
     var_type=T_Int;
     int_val=3;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["curow"] {
     name="curow";
     var_type=T_String;
     string_val="nlayers";
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["NetworkConfig"] {
     name="NetworkConfig";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects["std_wizards"].programs["NetworkWizard"].objs["NetworkConfig"]$$;
     objs_ptr=1;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["rval"] {
     name="rval";
     var_type=T_Int;
     int_val=0;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
    Function @["NewNetwork"] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="NewNetwork() returns: int";
     pre_compile_code_string="NewNetwork() returns: int";
     name="NewNetwork";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
     };
     fun_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       pre_compile_code_string="LocalVars (0 vars)";
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network = .networks.New(1)";
       pre_compile_code_string="network = .networks.New(1)";
       result_var=.projects["std_wizards"].programs["NetworkWizard"].vars["network"]$$;
       expr {
	expr=".networks.New(1)";
       };
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Dlg1->Revert()";
       pre_compile_code_string="Dlg1->Revert()";
       result_var=NULL;
       obj=.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$$;
       method=taGuiDialog::Revert;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Revert()";
       meth_desc=" Revert any outstanding changes in the dialog, and update to reflect current contents";
      };
      PrintVar @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  \"New network created\" network";
       pre_compile_code_string="Print  \"New network created\" network";
       message="New network created";
       print_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["network"]$;
       print_var2=NULL;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=0;
      };
     };
    };
    Function @["NLayersFmNetwork"] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="NLayersFmNetwork() returns: int";
     pre_compile_code_string="NLayersFmNetwork() returns: int";
     name="NLayersFmNetwork";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
     };
     fun_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       pre_compile_code_string="LocalVars (0 vars)";
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
       };
      };
      IfReturn @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if(!network) return";
       pre_compile_code_string="if(!network) return";
       cond {
	expr="!network";
       };
      };
      AssignExpr @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="n_layers = network.layers.leaves";
       pre_compile_code_string="n_layers = network.layers.leaves";
       result_var=.projects["std_wizards"].programs["NetworkWizard"].vars["n_layers"]$$;
       expr {
	expr="network.layers.leaves";
       };
      };
      MethodCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Dlg1->Revert()";
       pre_compile_code_string="Dlg1->Revert()";
       result_var=NULL;
       obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
       method=taGuiDialog::Revert;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Revert()";
       meth_desc=" Revert any outstanding changes in the dialog, and update to reflect current contents";
      };
      PrintVar @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  \"Read n_layers from network\" n_layers network";
       pre_compile_code_string="Print  \"Read n_layers from network\" n_layers network";
       message="Read n_layers from network";
       print_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["n_layers"]$;
       print_var2=$.projects["std_wizards"].programs["NetworkWizard"].vars["network"]$;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=0;
      };
     };
    };
    Function @["ConfigOneLayer"] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ConfigOneLayer(int lay_no, String nm, String typ) returns: int";
     pre_compile_code_string="ConfigOneLayer(int lay_no, String nm, String typ) returns: int";
     name="ConfigOneLayer";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["lay_no"] {
       name="lay_no";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["nm"] {
       name="nm";
       var_type=T_String;
       string_val=;
       flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["typ"] {
       name="typ";
       var_type=T_String;
       string_val=;
       flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     fun_code {
      name="ProgEl_List_55";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       pre_compile_code_string="LocalVars (0 vars)";
       local_vars {
	name="ProgVar_List_0";
	el_typ=ProgVar;
	el_def=0;
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="NetworkConfig->SetVal(nm, \"Name\", lay_no)";
       pre_compile_code_string="NetworkConfig->SetVal(nm, \"Name\", lay_no)";
       result_var=NULL;
       obj=.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$$;
       method=DataTable::SetVal;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="nm";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"Name\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_no";
	 };
	};
       };
       meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="NetworkConfig->SetVal(typ, \"Type\", lay_no)";
       pre_compile_code_string="NetworkConfig->SetVal(typ, \"Type\", lay_no)";
       result_var=NULL;
       obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$;
       method=DataTable::SetVal;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="typ";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"Type\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_no";
	 };
	};
       };
       meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
      };
      MethodCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="NetworkConfig->SetVal(5, \"Size_X\", lay_no)";
       pre_compile_code_string="NetworkConfig->SetVal(5, \"Size_X\", lay_no)";
       result_var=NULL;
       obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$;
       method=DataTable::SetVal;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="5";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"Size_X\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_no";
	 };
	};
       };
       meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
      };
      MethodCall @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="NetworkConfig->SetVal(5, \"Size_Y\", lay_no)";
       pre_compile_code_string="NetworkConfig->SetVal(5, \"Size_Y\", lay_no)";
       result_var=NULL;
       obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$;
       method=DataTable::SetVal;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="5";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"Size_Y\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_no";
	 };
	};
       };
       meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
      };
     };
    };
    Function @["NewNetDefaultConfig"] {
     desc="configure default structure for a new network";
     flags=CAN_REVERT_TO_CODE;
     code_string="NewNetDefaultConfig() returns: int";
     pre_compile_code_string="NewNetDefaultConfig() returns: int";
     name="NewNetDefaultConfig";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
     };
     fun_code {
      name="ProgEl_List_52";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (3 vars)";
       pre_compile_code_string="LocalVars (3 vars)";
       local_vars {
	name="ProgVar_List_0";
	el_typ=ProgVar;
	el_def=0;
	ProgVar @["n_lays"] {
	 name="n_lays";
	 var_type=T_Int;
	 int_val=0;
	 flags=LOCAL_VAR|USED|EDIT_VAL;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
	ProgVar @["lay"] {
	 name="lay";
	 var_type=T_Object;
	 object_type=Layer;
	 object_val=NULL;
	 objs_ptr=0;
	 flags=LOCAL_VAR|EDIT_VAL;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
	ProgVar @["i"] {
	 name="i";
	 var_type=T_Int;
	 int_val=0;
	 flags=LOCAL_VAR|USED|EDIT_VAL;
	 reference=0;
	 desc=;
	 init_from=NULL;
	};
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="n_lays = NetworkConfig.rows";
       pre_compile_code_string="n_lays = NetworkConfig.rows";
       result_var=.projects["std_wizards"].programs["NetworkWizard"].functions["NewNetDefaultConfig"].fun_code[0].local_vars["n_lays"]$$;
       expr {
	expr="NetworkConfig.rows";
       };
      };
      If @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (n_lays > 0)";
       pre_compile_code_string="if (n_lays > 0)";
       cond {
	expr="n_lays > 0";
       };
       true_code {
	name="ProgEl_List_54";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ConfigOneLayer(0, \"Input\", \"INPUT\")";
	 pre_compile_code_string="ConfigOneLayer(0, \"Input\", \"INPUT\")";
	 result_var=NULL;
	 fun=.projects["std_wizards"].programs["NetworkWizard"].functions["ConfigOneLayer"]$$;
	 fun_args {
	  name="ProgArg_List_0";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="lay_no";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="0";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=taString;
	   type="String";
	   name="nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"Input\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=taString;
	   type="String";
	   name="typ";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"INPUT\"";
	   };
	  };
	 };
	};
       };
      };
      If @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (n_lays > 1)";
       pre_compile_code_string="if (n_lays > 1)";
       cond {
	expr="n_lays > 1";
       };
       true_code {
	name="ProgEl_List_57";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ConfigOneLayer(1, \"Hidden\", \"HIDDEN\")";
	 pre_compile_code_string="ConfigOneLayer(1, \"Hidden\", \"HIDDEN\")";
	 result_var=NULL;
	 fun=$.projects["std_wizards"].programs["NetworkWizard"].functions["ConfigOneLayer"]$;
	 fun_args {
	  name="ProgArg_List_0";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="lay_no";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="1";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=taString;
	   type="String";
	   name="nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"Hidden\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=taString;
	   type="String";
	   name="typ";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"HIDDEN\"";
	   };
	  };
	 };
	};
       };
      };
      If @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (n_lays == 3)";
       pre_compile_code_string="if (n_lays == 3)";
       cond {
	expr="n_lays == 3";
       };
       true_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ConfigOneLayer(2, \"Output\", \"TARGET\")";
	 pre_compile_code_string="ConfigOneLayer(2, \"Output\", \"TARGET\")";
	 result_var=NULL;
	 fun=$.projects["std_wizards"].programs["NetworkWizard"].functions["ConfigOneLayer"]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="lay_no";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="2";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=taString;
	   type="String";
	   name="nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"Output\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=taString;
	   type="String";
	   name="typ";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"TARGET\"";
	   };
	  };
	 };
	};
       };
      };
      If @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (n_lays > 2)";
       pre_compile_code_string="if (n_lays > 2)";
       cond {
	expr="n_lays > 2";
       };
       true_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ConfigOneLayer(n_lays-1, \"Output\", \"TARGET\")";
	 pre_compile_code_string="ConfigOneLayer(n_lays-1, \"Output\", \"TARGET\")";
	 result_var=NULL;
	 fun=$.projects["std_wizards"].programs["NetworkWizard"].functions["ConfigOneLayer"]$;
	 fun_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="lay_no";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="n_lays-1";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=taString;
	   type="String";
	   name="nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"Output\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=taString;
	   type="String";
	   name="typ";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"TARGET\"";
	   };
	  };
	 };
	};
	ForLoop @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (i=2; i<n_lays-1; i++)";
	 pre_compile_code_string="for (i=2; i<n_lays-1; i++)";
	 loop_code {
	  name="ProgEl_List_63";
	  el_typ=ProgCode;
	  el_def=0;
	  FunctionCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="ConfigOneLayer(i, \"Hidden_\" + String(i-1), \"HIDDEN\")";
	   pre_compile_code_string="ConfigOneLayer(i, \"Hidden_\" + String(i-1), \"HIDDEN\")";
	   result_var=NULL;
	   fun=$.projects["std_wizards"].programs["NetworkWizard"].functions["ConfigOneLayer"]$;
	   fun_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="lay_no";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="i";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=taString;
	     type="String";
	     name="nm";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Hidden_\" + String(i-1)";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=taString;
	     type="String";
	     name="typ";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"HIDDEN\"";
	     };
	    };
	   };
	  };
	 };
	 init {
	  expr="i=2";
	 };
	 test {
	  expr="i<n_lays-1";
	 };
	 iter {
	  expr="i++";
	 };
	};
       };
      };
     };
    };
    Function @["AddNewLayerRow"] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="AddNewLayerRow() returns: int";
     pre_compile_code_string="AddNewLayerRow() returns: int";
     name="AddNewLayerRow";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
     };
     fun_code {
      name="ProgEl_List_65";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       pre_compile_code_string="LocalVars (0 vars)";
       local_vars {
	name="ProgVar_List_0";
	el_typ=ProgVar;
	el_def=0;
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="NetworkConfig->AddBlankRow()";
       pre_compile_code_string="NetworkConfig->AddBlankRow()";
       result_var=NULL;
       obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Dlg2->Apply()";
       pre_compile_code_string="Dlg2->Apply()";
       result_var=NULL;
       obj=.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$$;
       method=taGuiDialog::Apply;
       meth_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Apply()";
       meth_desc=" Apply any outstanding changes in the dialog";
      };
     };
    };
    Function @["RefreshLayerList"] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="RefreshLayerList() returns: int";
     pre_compile_code_string="RefreshLayerList() returns: int";
     name="RefreshLayerList";
     return_type=T_Int;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
     };
     fun_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       pre_compile_code_string="LocalVars (0 vars)";
       local_vars {
	name=;
	el_typ=ProgVar;
	el_def=0;
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Dlg2->Apply()";
       pre_compile_code_string="Dlg2->Apply()";
       result_var=NULL;
       obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
       method=taGuiDialog::Apply;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void Apply()";
       meth_desc=" Apply any outstanding changes in the dialog";
      };
     };
    };
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="ProgVar_List_0";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["new_net"] {
       name="new_net";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->Reset()";
     pre_compile_code_string="Dlg1->Reset()";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::Reset;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Reset()";
     meth_desc=" reset contents to start over";
    };
    MemberAssign @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1.prompt = \"Network Wizard Step 1 of 2: Select Network and Number of Layers\"";
     pre_compile_code_string="Dlg1.prompt = \"Network Wizard Step 1 of 2: Select Network and Number of Layers\"";
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     path="prompt";
     expr {
      expr="\"Network Wizard Step 1 of 2: Select Network and Number of Layers\"";
     };
     update_after=0;
    };
    MemberAssign @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1.win_title = \"Network Wizard Step 1 of 2\"";
     pre_compile_code_string="Dlg1.win_title = \"Network Wizard Step 1 of 2\"";
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     path="win_title";
     expr {
      expr="\"Network Wizard Step 1 of 2\"";
     };
     update_after=0;
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddWidget(\"main\", \"\", \"\", )";
     pre_compile_code_string="Dlg1->AddWidget(\"main\", \"\", \"\", )";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddWidget;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="bool AddWidget(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a plain widget -- attributes are: tooltip=, min/max_width/height= ,font=, font_size=, bold=, italic=";
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddVBoxLayout(\"mainv\", \"\", \"main\", \"\")";
     pre_compile_code_string="Dlg1->AddVBoxLayout(\"mainv\", \"\", \"main\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddVBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddVBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a vertical box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curow = \"instr\"";
     pre_compile_code_string="curow = \"instr\"";
     result_var=.projects["std_wizards"].programs["NetworkWizard"].vars["curow"]$$;
     expr {
      expr="\"instr\"";
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     pre_compile_code_string="Dlg1->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddHBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddHBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a horizontal box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    MethodCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddLabel(\"Instructions\", \"main\", curow, \"label=Please select a network (or make a new one) and enter the number of layers.\\nYou will then be able to configure each layer in the next dialog (press OK to continue).;\")";
     pre_compile_code_string="Dlg1->AddLabel(\"Instructions\", \"main\", curow, \"label=Please select a network (or make a new one) and enter the number of layers.\\nYou will then be able to configure each layer in the next dialog (press OK to continue).;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddLabel;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"Instructions\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=Please select a network (or make a new one) and enter the number of layers.\\nYou will then be able to configure each layer in the next dialog (press OK to continue).;\"";
       };
      };
     };
     meth_sig="bool AddLabel(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a label widget -- attributes are: label=, wrap=on";
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddSpace(20, \"mainv\")";
     pre_compile_code_string="Dlg1->AddSpace(20, \"mainv\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddSpace;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="sp_size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="20";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
     };
     meth_sig="bool AddSpace(int sp_size, taString& layout)";
     meth_desc=" add space to given layout";
    };
    AssignExpr @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curow = \"netsel\"";
     pre_compile_code_string="curow = \"netsel\"";
     result_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["curow"]$;
     expr {
      expr="\"netsel\"";
     };
    };
    MethodCall @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     pre_compile_code_string="Dlg1->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddHBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddHBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a horizontal box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    MethodCall @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddProgVar(this.vars.network, \"Network\", \"main\", curow, \"tooltip=select the network to configure;\")";
     pre_compile_code_string="Dlg1->AddProgVar(this.vars.network, \"Network\", \"main\", curow, \"tooltip=select the network to configure;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddProgVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=ProgVar_ref;
       type="ProgVar&";
       name="pvar";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="this.vars.network";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"Network\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=1;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"tooltip=select the network to configure;\"";
       };
      };
     };
     meth_sig="bool AddProgVar(ProgVar& pvar, taString& nm, taString& parent, taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a program variable edit field -- IMPORTANT: must use this.vars.progvarname in program code, not the direct name of the program variable (which is not actually the full progvar) -- attributes are:";
    };
    MethodCall @[13] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddSpace(20, curow)";
     pre_compile_code_string="Dlg1->AddSpace(20, curow)";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddSpace;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="sp_size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="20";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
     };
     meth_sig="bool AddSpace(int sp_size, taString& layout)";
     meth_desc=" add space to given layout";
    };
    MethodCall @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddPushButton(\"NewNetwork\", \"main\", curow, \"this.NewNetwork()\", \"label=New Network; tooltip=press this button to create a new network to configure;\")";
     pre_compile_code_string="Dlg1->AddPushButton(\"NewNetwork\", \"main\", curow, \"this.NewNetwork()\", \"label=New Network; tooltip=press this button to create a new network to configure;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddPushButton;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"NewNetwork\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="url";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"this.NewNetwork()\"";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=New Network; tooltip=press this button to create a new network to configure;\"";
       };
      };
     };
     meth_sig="bool AddPushButton(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& url = taString(), taString& attributes = taString())";
     meth_desc=" add a pushbutton widget -- attributes are: label=";
    };
    MethodCall @[15] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddSpace(20, \"mainv\")";
     pre_compile_code_string="Dlg1->AddSpace(20, \"mainv\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddSpace;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="sp_size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="20";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
     };
     meth_sig="bool AddSpace(int sp_size, taString& layout)";
     meth_desc=" add space to given layout";
    };
    AssignExpr @[16] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curow = \"nlayers\"";
     pre_compile_code_string="curow = \"nlayers\"";
     result_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["curow"]$;
     expr {
      expr="\"nlayers\"";
     };
    };
    MethodCall @[17] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     pre_compile_code_string="Dlg1->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddHBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddHBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a horizontal box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    MethodCall @[18] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddLabel(\"nlaylbl\", \"main\", curow, \"label=N Layers: ;\")";
     pre_compile_code_string="Dlg1->AddLabel(\"nlaylbl\", \"main\", curow, \"label=N Layers: ;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddLabel;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"nlaylbl\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=N Layers: ;\"";
       };
      };
     };
     meth_sig="bool AddLabel(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a label widget -- attributes are: label=, wrap=on";
    };
    MethodCall @[19] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddProgVar(this.vars.n_layers, \"n_layers\", \"main\", curow, \"tooltip=enter the number of layers to create here\\n you will be able to change this later too;\")";
     pre_compile_code_string="Dlg1->AddProgVar(this.vars.n_layers, \"n_layers\", \"main\", curow, \"tooltip=enter the number of layers to create here\\n you will be able to change this later too;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddProgVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=ProgVar_ref;
       type="ProgVar&";
       name="pvar";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="this.vars.n_layers";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"n_layers\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=1;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"tooltip=enter the number of layers to create here\\n you will be able to change this later too;\"";
       };
      };
     };
     meth_sig="bool AddProgVar(ProgVar& pvar, taString& nm, taString& parent, taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a program variable edit field -- IMPORTANT: must use this.vars.progvarname in program code, not the direct name of the program variable (which is not actually the full progvar) -- attributes are:";
    };
    MethodCall @[20] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddStretch(curow)";
     pre_compile_code_string="Dlg1->AddStretch(curow)";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddStretch;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
     };
     meth_sig="bool AddStretch(taString& layout)";
     meth_desc=" add flexible stretch to given layout";
    };
    MethodCall @[21] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg1->AddPushButton(\"NLayersFmNetwork\", \"main\", curow, \"this.NLayersFmNetwork()\", \"label=Get N Layers From Network; tooltip=get the number of layers from the existing network;\")";
     pre_compile_code_string="Dlg1->AddPushButton(\"NLayersFmNetwork\", \"main\", curow, \"this.NLayersFmNetwork()\", \"label=Get N Layers From Network; tooltip=get the number of layers from the existing network;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::AddPushButton;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"NLayersFmNetwork\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="url";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"this.NLayersFmNetwork()\"";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=Get N Layers From Network; tooltip=get the number of layers from the existing network;\"";
       };
      };
     };
     meth_sig="bool AddPushButton(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& url = taString(), taString& attributes = taString())";
     meth_desc=" add a pushbutton widget -- attributes are: label=";
    };
    MethodCall @[22] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="rval = Dlg1->PostDialog(true)";
     pre_compile_code_string="rval = Dlg1->PostDialog(true)";
     result_var=.projects["std_wizards"].programs["NetworkWizard"].vars["rval"]$$;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg1"]$;
     method=taGuiDialog::PostDialog;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="modal";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="int PostDialog(bool modal = false)";
     meth_desc=" post the dialog -- if modal, then this call does not return until the dialog is cancled -- otherwise it returns immediately and the dialog persists";
    };
    IfReturn @[23] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if(rval == 0 || network == NULL) return";
     pre_compile_code_string="if(rval == 0 || network == NULL) return";
     cond {
      expr="rval == 0 || network == NULL";
     };
    };
    Comment @[24] {
     desc="== Dialog 2 ==";
     flags=CAN_REVERT_TO_CODE;
     code_string="// == Dialog 2 ==";
     pre_compile_code_string="// == Dialog 2 ==";
    };
    If @[25] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (network.layers.leaves == 0)";
     pre_compile_code_string="if (network.layers.leaves == 0)";
     cond {
      expr="network.layers.leaves == 0";
     };
     true_code {
      name="ProgEl_List_51";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="new_net = true";
       pre_compile_code_string="new_net = true";
       result_var=.projects["std_wizards"].programs["NetworkWizard"].prog_code[0].local_vars["new_net"]$$;
       expr {
	expr="true";
       };
      };
     };
    };
    MethodCall @[26] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="network->NetStructToTable(NetworkConfig, )";
     pre_compile_code_string="network->NetStructToTable(NetworkConfig, )";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["network"]$;
     method=Network::NetStructToTable;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dt";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr="NetworkConfig";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="list_specs";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="DataTable_ptr NetStructToTable(DataTable* dt = __null, bool list_specs = false)";
     meth_desc=" NULL_TEXT_0_NewTable record the network structure to given data table, including names of layers and layer groups, sizes, and where each layer receives projections from and sends projections to -- if list_specs also include columns for layer and unit specs";
    };
    MethodCall @[27] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="NetworkConfig->RemoveCol(\"SendPrjns\")";
     pre_compile_code_string="NetworkConfig->RemoveCol(\"SendPrjns\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$;
     method=DataTable::RemoveCol;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"SendPrjns\"";
       };
      };
     };
     meth_sig="void RemoveCol(Variant& col)";
     meth_desc=" removes indicated column";
    };
    MethodCall @[28] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="NetworkConfig->EnforceRows(n_layers)";
     pre_compile_code_string="NetworkConfig->EnforceRows(n_layers)";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["NetworkConfig"]$;
     method=DataTable::EnforceRows;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="n_rows";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="n_layers";
       };
      };
     };
     meth_sig="void EnforceRows(int n_rows)";
     meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
    };
    If @[29] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (new_net)";
     pre_compile_code_string="if (new_net)";
     cond {
      expr="new_net";
     };
     true_code {
      name="ProgEl_List_64";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="NewNetDefaultConfig()";
       pre_compile_code_string="NewNetDefaultConfig()";
       result_var=NULL;
       fun=.projects["std_wizards"].programs["NetworkWizard"].functions["NewNetDefaultConfig"]$$;
       fun_args {
	name="ProgArg_List_0";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
    MethodCall @[30] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->Reset()";
     pre_compile_code_string="Dlg2->Reset()";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::Reset;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Reset()";
     meth_desc=" reset contents to start over";
    };
    MemberAssign @[31] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2.prompt = \"Network Wizard Step 2 of 2: Enter Layer Names, Sizes, and Projections (Prjns)\"";
     pre_compile_code_string="Dlg2.prompt = \"Network Wizard Step 2 of 2: Enter Layer Names, Sizes, and Projections (Prjns)\"";
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     path="prompt";
     expr {
      expr="\"Network Wizard Step 2 of 2: Enter Layer Names, Sizes, and Projections (Prjns)\"";
     };
     update_after=0;
    };
    MemberAssign @[32] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2.win_title = \"Network Wizard Step 2 of 2\"";
     pre_compile_code_string="Dlg2.win_title = \"Network Wizard Step 2 of 2\"";
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     path="win_title";
     expr {
      expr="\"Network Wizard Step 2 of 2\"";
     };
     update_after=0;
    };
    MethodCall @[33] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->SetSize(900, 600)";
     pre_compile_code_string="Dlg2->SetSize(900, 600)";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::SetSize;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="wd";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="900";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="ht";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="600";
       };
      };
     };
     meth_sig="void SetSize(int wd, int ht)";
     meth_desc=" Set the minimum size of the dialog (also just do with width, height members)";
    };
    MethodCall @[34] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddWidget(\"main\", \"\", \"\", \"\")";
     pre_compile_code_string="Dlg2->AddWidget(\"main\", \"\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddWidget;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddWidget(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a plain widget -- attributes are: tooltip=, min/max_width/height= ,font=, font_size=, bold=, italic=";
    };
    MethodCall @[35] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddVBoxLayout(\"mainv\", \"\", \"main\", \"\")";
     pre_compile_code_string="Dlg2->AddVBoxLayout(\"mainv\", \"\", \"main\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddVBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddVBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a vertical box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    AssignExpr @[36] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curow = \"instr\"";
     pre_compile_code_string="curow = \"instr\"";
     result_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["curow"]$;
     expr {
      expr="\"instr\"";
     };
    };
    MethodCall @[37] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     pre_compile_code_string="Dlg2->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddHBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddHBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a horizontal box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    MethodCall @[38] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddLabel(\"LabelTest\", \"main\", curow, \"label=Enter the names of the network layers, optionally a Group for the layers to live in, and the number of units in X, Y dimensions per layer\\nand the receiving projections (layer names, separated by spaces) to connect from\\nHold the mouse over the colum names for more detailed information (e.g., for Type options);\")";
     pre_compile_code_string="Dlg2->AddLabel(\"LabelTest\", \"main\", curow, \"label=Enter the names of the network layers, optionally a Group for the layers to live in, and the number of units in X, Y dimensions per layer\\nand the receiving projections (layer names, separated by spaces) to connect from\\nHold the mouse over the colum names for more detailed information (e.g., for Type options);\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddLabel;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"LabelTest\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=Enter the names of the network layers, optionally a Group for the layers to live in, and the number of units in X, Y dimensions per layer\\nand the receiving projections (layer names, separated by spaces) to connect from\\nHold the mouse over the colum names for more detailed information (e.g., for Type options);\"";
       };
      };
     };
     meth_sig="bool AddLabel(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a label widget -- attributes are: label=, wrap=on";
    };
    MethodCall @[39] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddSpace(20, \"mainv\")";
     pre_compile_code_string="Dlg2->AddSpace(20, \"mainv\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddSpace;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="sp_size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="20";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
     };
     meth_sig="bool AddSpace(int sp_size, taString& layout)";
     meth_desc=" add space to given layout";
    };
    AssignExpr @[40] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curow = \"dtable\"";
     pre_compile_code_string="curow = \"dtable\"";
     result_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["curow"]$;
     expr {
      expr="\"dtable\"";
     };
    };
    MethodCall @[41] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     pre_compile_code_string="Dlg2->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddHBoxLayout;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddHBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a horizontal box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    MethodCall @[42] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddDataTable(NetworkConfig, \"NetworkStructure\", \"main\", curow, \"max_width=850; max_height=500;\")";
     pre_compile_code_string="Dlg2->AddDataTable(NetworkConfig, \"NetworkStructure\", \"main\", curow, \"max_width=850; max_height=500;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddDataTable;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dt";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="NetworkConfig";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"NetworkStructure\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=1;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"max_width=850; max_height=500;\"";
       };
      };
     };
     meth_sig="bool AddDataTable(DataTable* dt, taString& nm, taString& parent, taString& layout = taString(), taString& attributes = taString())";
     meth_desc=" add a DataTable editor for given data table -- attributes are:";
    };
    AssignExpr @[43] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curow = \"buttons\"";
     pre_compile_code_string="curow = \"buttons\"";
     result_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["curow"]$;
     expr {
      expr="\"buttons\"";
     };
    };
    MethodCall @[44] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     pre_compile_code_string="Dlg2->AddHBoxLayout(curow, \"mainv\", \"\", \"\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddHBoxLayout;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"mainv\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="widget";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"\"";
       };
      };
     };
     meth_sig="bool AddHBoxLayout(taString& nm, taString& parent = taString(), taString& widget = taString(), taString& attributes = taString())";
     meth_desc=" add a horizontal box layout to given widget (optional), and parent *layout* -- attributes are: spacing=x, margin=x";
    };
    MethodCall @[45] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddToolButton(\"AddLayer\", \"main\", curow, \"this.AddNewLayerRow()\", \"label=Add New Layer; tooltip=Add a new layer row to layer list (above)\\n use context menu on selected rows to delete (press Refresh Layer List afterwards);\")";
     pre_compile_code_string="Dlg2->AddToolButton(\"AddLayer\", \"main\", curow, \"this.AddNewLayerRow()\", \"label=Add New Layer; tooltip=Add a new layer row to layer list (above)\\n use context menu on selected rows to delete (press Refresh Layer List afterwards);\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddToolButton;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"AddLayer\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="url";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"this.AddNewLayerRow()\"";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=Add New Layer; tooltip=Add a new layer row to layer list (above)\\n use context menu on selected rows to delete (press Refresh Layer List afterwards);\"";
       };
      };
     };
     meth_sig="bool AddToolButton(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& url = taString(), taString& attributes = taString())";
     meth_desc=" add a toolbutton widget -- attributes are: label=";
    };
    MethodCall @[46] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddSpace(20, curow)";
     pre_compile_code_string="Dlg2->AddSpace(20, curow)";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddSpace;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="sp_size";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="20";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="curow";
       };
      };
     };
     meth_sig="bool AddSpace(int sp_size, taString& layout)";
     meth_desc=" add space to given layout";
    };
    MethodCall @[47] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Dlg2->AddToolButton(\"RefreshList\", \"main\", curow, \"this.RefreshLayerList()\", \"label=Refresh Layer List; tooltip=updates the list of layers and their settings (above)\\n if you used one of the context menu actions to insert or remove layers.\\n the display updating does not work automatically in this dialog;\")";
     pre_compile_code_string="Dlg2->AddToolButton(\"RefreshList\", \"main\", curow, \"this.RefreshLayerList()\", \"label=Refresh Layer List; tooltip=updates the list of layers and their settings (above)\\n if you used one of the context menu actions to insert or remove layers.\\n the display updating does not work automatically in this dialog;\")";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::AddToolButton;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"RefreshList\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="parent";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"main\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="layout";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="curow";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="url";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"this.RefreshLayerList()\"";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="attributes";
       required=0;
       def_val="taString()";
       prev_expr=;
       expr {
	expr="\"label=Refresh Layer List; tooltip=updates the list of layers and their settings (above)\\n if you used one of the context menu actions to insert or remove layers.\\n the display updating does not work automatically in this dialog;\"";
       };
      };
     };
     meth_sig="bool AddToolButton(taString& nm, taString& parent = taString(), taString& layout = taString(), taString& url = taString(), taString& attributes = taString())";
     meth_desc=" add a toolbutton widget -- attributes are: label=";
    };
    MethodCall @[48] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="rval = Dlg2->PostDialog(true)";
     pre_compile_code_string="rval = Dlg2->PostDialog(true)";
     result_var=$.projects["std_wizards"].programs["NetworkWizard"].vars["rval"]$;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["Dlg2"]$;
     method=taGuiDialog::PostDialog;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="modal";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="int PostDialog(bool modal = false)";
     meth_desc=" post the dialog -- if modal, then this call does not return until the dialog is cancled -- otherwise it returns immediately and the dialog persists";
    };
    IfReturn @[49] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if(rval == 0) return";
     pre_compile_code_string="if(rval == 0) return";
     cond {
      expr="rval == 0";
     };
    };
    Comment @[50] {
     desc="== now build the network to spec ==";
     flags=CAN_REVERT_TO_CODE;
     code_string="// == now build the network to spec ==";
     pre_compile_code_string="// == now build the network to spec ==";
    };
    MethodCall @[51] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="network->NetStructFmTable(NetworkConfig)";
     pre_compile_code_string="network->NetStructFmTable(NetworkConfig)";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["network"]$;
     method=Network::NetStructFmTable;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dt";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="NetworkConfig";
       };
      };
     };
     meth_sig="void NetStructFmTable(DataTable* dt)";
     meth_desc=" configure network structure (layer and layer group names, sizes, positions, connectivity) from data table (should be in same format as generated by NetStructToTable)";
    };
    MethodCall @[52] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="network->Build()";
     pre_compile_code_string="network->Build()";
     result_var=NULL;
     obj=$.projects["std_wizards"].programs["NetworkWizard"].vars["network"]$;
     method=Network::Build;
     meth_args {
      name="ProgArg_List_0";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Build()";
     meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
    };
   };
   step_prog=NULL;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=0;
    wiki=;
    url="local";
    full_url="local";
    text_size=1;
    text=;
    html_text=;
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @["Browser2"] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_44";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["view_win_lft"] {
     name="view_win_lft";
     value 8 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_top"] {
     name="view_win_top";
     value 8 0=0.06710605;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_wd"] {
     name="view_win_wd";
     value 8 0=1;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_ht"] {
     name="view_win_ht";
     value 8 0=0.7992811;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_iconified"] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_splitter_state"] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAEAAAADAAABAAAAAfwAAAKMAQAAAAcBAAAAAQA=";
     val_type_fixed=0;
    };
   };
   name="Browser2";
   m_data=.projects["std_wizards"]$$;
   cur_font_size=12;
   visible=1;
   win_name=".projects[\"std_wizards\"] - std_wizards.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @["Application"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_45";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_visible"] {
       name="view_win_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=12;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @["Navigator"] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects["std_wizards"]$;
    };
    PanelViewer @["Editor"] {
     name="Editor";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
    };
    T3PanelViewer @["T3Frames"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_46";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_panel_selected"] {
       name="view_panel_selected";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="T3Frames";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @["Frame1"] {
       name="Frame1";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=T3DataViewMain;
	 el_def=0;
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {
	field_of_view=45;
	near_distance=0.1;
	focal=5;
	far_distance=1000;
       };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["Vw_0"] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0.5: y=0.9143143: z=2.327804: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.531116;
	};
	T3SavedView @["Vw_1"] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_2"] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_3"] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_4"] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_5"] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_6"] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_7"] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_8"] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_9"] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @["Tools"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_47";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_lft"] {
       name="view_win_lft";
       value 8 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_top"] {
       name="view_win_top";
       value 8 0=0.005991612;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_wd"] {
       name="view_win_wd";
       value 8 0=0.02772143;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_ht"] {
       name="view_win_ht";
       value 8 0=0.7543439;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_iconified"] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_visible"] {
       name="view_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="Project updated on wiki: emergent changes: doc lnk";
 tree_state{ .;.docs;.wizards;.ctrl_panels;.param_sets;.data;.data.gp[0];.data.gp[1];.data.gp[2];.programs;.networks; };
 networks {
  name="networks";
  el_typ=LeabraNetwork;
  el_def=0;
 };
};

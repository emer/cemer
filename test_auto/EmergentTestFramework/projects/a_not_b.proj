// ta_Dump File v3.0 -- code v6.3.2.0 rev6415
LeabraProject .projects["a_not_b"] { 
  taBase_Group @.templates = [0] {
  };

  Doc_Group @.docs = [1] {
    taDoc @["ProjectDocs"] { };
  };

  Wizard_Group @.wizards = [1] {
    LeabraWizard @["LeabraWizard_1"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["NO_CLIP"] { };
   };
};
  };

  SelectEdit_Group @.edits = [2] {
    SelectEdit @["ControlPanel"] { 
      EditMbrItem_Group @.mbrs = [3] {
	EditMbrItem @[0] { };
	EditMbrItem @[1] { };
	EditMbrItem @[2] { };
      };

      EditMthItem_Group @.mths = [5] {
	EditMthItem @[0] { };
	EditMthItem @[1] { };
	EditMthItem @[2] { };
	EditMthItem @[3] { };
	EditMthItem @[4] { };
      };
    };
    ClusterRun @["ClusterRun"] { 
      EditMbrItem_Group @.mbrs = [0] {
      };

      EditMthItem_Group @.mths = [0] {
      };

      ParamSearchAlgo_List @.search_algos = [0] {
      };
    };
  };

  DataTable_Group @.data = [0] {
    DataTable_Group @.gp["InputData"] = [4] { 
      DataTable @["ABInput_Delay3"] { 
	DataTableCols @.data = [6] {
	  String_Data @["Group"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  String_Data @["Name"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Location"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Cover"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Toy"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Reach"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	};
      };
      DataTable @["ABInput_Delay5"] { 
	DataTableCols @.data = [6] {
	  String_Data @["Group"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  String_Data @["Name"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Location"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Cover"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Toy"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Reach"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	};
      };
      DataTable @["ABInput_Delay1"] { 
	DataTableCols @.data = [6] {
	  String_Data @["Group"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  String_Data @["Name"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Location"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Cover"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Toy"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  float_Data @["Reach"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	};
      };
      DataTable @["UnitNames"] { 
	DataTableCols @.data = [4] {
	  String_Data @["Location"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  String_Data @["Cover"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  String_Data @["Reach"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	  String_Data @["Toy"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["view_panel_wd"] { };
      };
};
	};
      };
    };
    DataTable_Group @.gp["OutputData"] = [2] { 
      DataTable @["TrialOutputData"] { 
	DataTableCols @.data = [10] {
	  int_Data @["batch"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["NARROW"] { };
      };
};
	  int_Data @["epoch"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["NARROW"] { };
      };
};
	  int_Data @["trial"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["NARROW"] { };
      };
};
	  String_Data @["trial_name"] { };
	  float_Data @["Locati_act"] { };
	  float_Data @["Cover_act"] { };
	  float_Data @["Toy_act"] { };
	  float_Data @["Hidden_act"] { };
	  float_Data @["Gaze_E_act"] { };
	  float_Data @["Reach_act"] { };
	};
      };
      DataTable @["EpochOutputData"] { 
	DataTableCols @.data = [8] {
	  int_Data @["batch"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["NARROW"] { };
      };
};
	  int_Data @["epoch"] { 
      UserDataItem_List @*(.user_data_) {
	      UserDataItem @["NARROW"] { };
      };
};
	  float_Data @["avg_sse"] { };
	  float_Data @["cnt_err"] { };
	  float_Data @["avg_ext_rew"] { };
	  float_Data @["avg_cycles"] { };
	  float_Data @["epoch_time_tot"] { };
	  float_Data @["epoch_time_usr"] { };
	};
      };
    };
    DataTable_Group @.gp["AnalysisData"] { 
    };
  };

  taBase_Group @.data_proc = [4] {
    taDataProc @["data_base"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["NO_CLIP"] { };
   };
};
    taDataAnal @["data_anal"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["NO_CLIP"] { };
   };
};
    taDataGen @["data_gen"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["NO_CLIP"] { };
   };
};
    taImageProc @["image_proc"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["NO_CLIP"] { };
   };
};
  };

  Program_Group @.programs = [1] {
    Program @["SetDefaults"] { 
      ProgObjList @.objs = [0] {
      };

      ProgType_List @.types = [0] {
      };

      ProgVar_List @.args = [0] {
      };

      ProgVar_List @.vars = [4] {
	ProgVar @["ABNet"] { };
	ProgVar @["ControlPanel"] { };
	ProgVar @["LeabraTrain"] { };
	ProgVar @["n_delay_3"] { };
      };

      Function_List @.functions = [0] {
      };

      ProgEl_List @.init_code = [3] {
	MemberAssign @[0] { };
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	};
      };

      ProgEl_List @.prog_code = [0] {
      };
    };
    Program_Group @.gp["LeabraAll_Std"] = [10] { 
      Program @["LeabraBatch"] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @["network"] { };
	  ProgVar @["input_data"] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @["batch"] { };
	  ProgVar @["max_batch"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [2] {
	  NetCounterInit @[0] { };
	  WhileLoop @[1] { 
	    ProgEl_List @.loop_code = [2] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [3] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		  ProgArg @[2] { };
		};
	      };
	      NetCounterIncr @[1] { };
	    };
	  };
	};
      };
      Program @["LeabraTrain"] { 
	ProgObjList @.objs = [1] {
	  RndSeed @["rnd_seed"] { };
	};

	ProgType_List @.types = [1] {
	  DynEnumType @["RndInitType"] { 
	    DynEnumItem_List @.enums = [2] {
	      DynEnumItem @["OLD_SEED"] { };
	      DynEnumItem @["NEW_SEED"] { };
	    };
	  };
	};

	ProgVar_List @.args = [3] {
	  ProgVar @["network"] { };
	  ProgVar @["input_data"] { };
	  ProgVar @["no_prompts"] { };
	};

	ProgVar_List @.vars = [7] {
	  ProgVar @["max_epoch"] { };
	  ProgVar @["epoch"] { };
	  ProgVar @["train_mode"] { };
	  ProgVar @["rnd_init"] { };
	  ProgVar @["err_stopcrit"] { };
	  ProgVar @["rnd_seed"] { };
	  ProgVar @["train_timer"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [6] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  AssignExpr @[2] { };
	  IfElse @[3] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfGuiPrompt @[5] { 
	    ProgEl_List @.yes_code = [1] {
	      PrintExpr @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [8] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MemberAssign @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      PrintExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  AssignExpr @[5] { };
	  WhileLoop @[6] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfBreak @[2] { };
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @["LeabraEpoch"] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @["network"] { };
	  ProgVar @["input_data"] { };
	};

	ProgVar_List @.vars = [10] {
	  ProgVar @["group_order"] { };
	  ProgVar @["item_order"] { };
	  ProgVar @["trial"] { };
	  ProgVar @["trial_mon_data"] { };
	  ProgVar @["epoch_timer"] { };
	  ProgVar @["group_index"] { };
	  ProgVar @["prv_group_index"] { };
	  ProgVar @["item_index"] { };
	  ProgVar @["unit_names"] { };
	  ProgVar @["Name"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  InitNamedUnits @[2] { };
	};

	ProgEl_List @.prog_code = [11] {
	  NetCounterInit @[0] { };
	  AssignExpr @[1] { };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetGroupedDataLoop @[5] { 
	    ProgEl_List @.loop_code = [5] {
	      Comment @[0] { };
	      CodeBlock @[1] { 
		ProgEl_List @.prog_code = [2] {
		  DataVarProg @[0] { };
		  IfElse @[1] { 
		    ProgEl_List @.true_code = [1] {
		      MemberAssign @[0] { };
		    };

		    ProgEl_List @.false_code = [1] {
		      MemberAssign @[0] { };
		    };
		  };
		};
	      };
	      IfElse @[2] { 
		ProgEl_List @.true_code = [2] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		  AssignExpr @[1] { };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	      ProgramCall @[3] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      IfElse @[4] { 
		ProgEl_List @.true_code = [1] {
		  MethodCall @[0] { 
		    ProgArg_List @.meth_args = [0] {
		    };
		  };
		};

		ProgEl_List @.false_code = [0] {
		};
	      };
	    };
	  };
	  IfElse @[6] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  MethodCall @[7] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[8] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[9] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[10] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};
      };
      Program @["LeabraTrial"] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @["network"] { };
	  ProgVar @["input_data"] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @["phase_no"] { };
	  ProgVar @["update_net_view"] { };
	  ProgVar @["trial"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [7] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  WhileLoop @[2] { 
	    ProgEl_List @.loop_code = [3] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [2] {
		  ProgArg @[0] { };
		  ProgArg @[1] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      MethodCall @[2] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  ProgramCall @[5] { 
	    ProgArg_List @.prog_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  NetUpdateView @[6] { };
	};
      };
      Program @["LeabraSettle"] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @["network"] { };
	  ProgVar @["input_data"] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @["cycle"] { };
	  ProgVar @["min_cycles"] { };
	  ProgVar @["update_net_view"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [1] {
	  NetCounterInit @[0] { };
	};

	ProgEl_List @.prog_code = [10] {
	  NetCounterInit @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  ProgramCall @[2] { 
	    ProgArg_List @.prog_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[4] { 
	    ProgEl_List @.true_code = [1] {
	      AssignExpr @[0] { };
	    };

	    ProgEl_List @.false_code = [1] {
	      AssignExpr @[0] { };
	    };
	  };
	  WhileLoop @[5] { 
	    ProgEl_List @.loop_code = [4] {
	      ProgramCall @[0] { 
		ProgArg_List @.prog_args = [1] {
		  ProgArg @[0] { };
		};
	      };
	      NetCounterIncr @[1] { };
	      IfContinue @[2] { };
	      IfBreak @[3] { };
	    };
	  };
	  MethodCall @[6] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  IfElse @[7] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  IfElse @[8] { 
	    ProgEl_List @.true_code = [1] {
	      MethodCall @[0] { 
		ProgArg_List @.meth_args = [0] {
		};
	      };
	    };

	    ProgEl_List @.false_code = [0] {
	    };
	  };
	  NetUpdateView @[9] { };
	};
      };
      Program @["LeabraCycle"] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @["network"] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @["update_net_view"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  NetUpdateView @[1] { };
	};
      };
      Program @["ApplyInputs"] { 
	ProgObjList @.objs = [1] {
	  LayerWriter @["LayerWriter_0"] { 
	    LayerDataEl_List @.layer_data = [6] {
	      LayerWriterEl @[0] { };
	      LayerWriterEl @[1] { };
	      LayerWriterEl @[2] { };
	      LayerWriterEl @[3] { };
	      LayerWriterEl @[4] { };
	      LayerWriterEl @[5] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [2] {
	  ProgVar @["network"] { };
	  ProgVar @["input_data"] { };
	};

	ProgVar_List @.vars = [1] {
	  ProgVar @["LayerWriter_0"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [2] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @["LeabraTrialMonitor"] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @["trial_netmon"] { 
	    NetMonItem_List @.items = [10] {
	      NetMonItem @["batch"] { };
	      NetMonItem @["epoch"] { };
	      NetMonItem @["trial"] { };
	      NetMonItem @["trial_name"] { };
	      NetMonItem @["Locati_act"] { };
	      NetMonItem @["Cover_act"] { };
	      NetMonItem @["Toy_act"] { };
	      NetMonItem @["Hidden_act"] { };
	      NetMonItem @["Gaze_E_act"] { };
	      NetMonItem @["Reach_act"] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @["network"] { };
	};

	ProgVar_List @.vars = [2] {
	  ProgVar @["trial_mon_data"] { };
	  ProgVar @["trial_netmon"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [3] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [4] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
      Program @["LeabraEpochMonitor"] { 
	ProgObjList @.objs = [1] {
	  NetMonitor @["epoch_netmon"] { 
	    NetMonItem_List @.items = [8] {
	      NetMonItem @["batch"] { };
	      NetMonItem @["epoch"] { };
	      NetMonItem @["avg_sse"] { };
	      NetMonItem @["cnt_err"] { };
	      NetMonItem @["avg_ext_rew"] { };
	      NetMonItem @["avg_cycles"] { };
	      NetMonItem @["epoch_time_tot"] { };
	      NetMonItem @["epoch_time_usr"] { };
	    };
	  };
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @["network"] { };
	};

	ProgVar_List @.vars = [3] {
	  ProgVar @["epoch_mon_data"] { };
	  ProgVar @["epoch_netmon"] { };
	  ProgVar @["epoch_timer"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [4] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MethodCall @[2] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	    };
	  };
	};

	ProgEl_List @.prog_code = [6] {
	  MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	  AssignExpr @[2] { };
	  MethodCall @[3] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	  };
	};
      };
      Program @["SaveWeights"] { 
	ProgObjList @.objs = [0] {
	};

	ProgType_List @.types = [0] {
	};

	ProgVar_List @.args = [1] {
	  ProgVar @["network"] { };
	};

	ProgVar_List @.vars = [6] {
	  ProgVar @["tag"] { };
	  ProgVar @["wts_subdir"] { };
	  ProgVar @["fname"] { };
	  ProgVar @["epoch_str"] { };
	  ProgVar @["batch_str"] { };
	  ProgVar @["final_tag"] { };
	};

	Function_List @.functions = [0] {
	};

	ProgEl_List @.init_code = [0] {
	};

	ProgEl_List @.prog_code = [6] {
	  IfReturn @[0] { };
	  MiscCall @[1] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  MiscCall @[2] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	  AssignExpr @[3] { };
	  MethodCall @[4] { 
	    ProgArg_List @.meth_args = [4] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	    };
	  };
	  MethodCall @[5] { 
	    ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	    };
	  };
	};
      };
    };
  };

  taViewer_List @.viewers = [1] {
    MainWindowViewer @["Browser3"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["view_win_lft"] { };
	UserDataItem @["view_win_top"] { };
	UserDataItem @["view_win_wd"] { };
	UserDataItem @["view_win_ht"] { };
	UserDataItem @["view_win_iconified"] { };
	UserDataItem @["view_splitter_state"] { };
   };

      ToolBar_List @.toolbars = [1] {
	ToolBar @["Application"] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @["view_win_visible"] { };
     };
};
      };

      FrameViewer_List @.frames = [3] {
	BrowseViewerTaBase @["Tree"] { };
	PanelViewer @["Panels"] { };
	T3PanelViewer @["T3Frames"] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @["view_panel_selected"] { };
     };

	  T3Panel_List @.panels = [3] {
	    T3Panel @["ABNet"] { 
	      T3DataView_List @.children = [1] {
		NetView @["projects_Project_0_viewers_Browser3_frames_T3Frames_frames_ABNet_root_view_children_0"] { 
		  ScaleRange_List @.scale_ranges = [13] {
		    ScaleRange @[0] { };
		    ScaleRange @[1] { };
		    ScaleRange @[2] { };
		    ScaleRange @[3] { };
		    ScaleRange @[4] { };
		    ScaleRange @[5] { };
		    ScaleRange @[6] { };
		    ScaleRange @[7] { };
		    ScaleRange @[8] { };
		    ScaleRange @[9] { };
		    ScaleRange @[10] { };
		    ScaleRange @[11] { };
		    ScaleRange @[12] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @["View_0"] { };
		T3SavedView @["View_1"] { };
		T3SavedView @["View_2"] { };
		T3SavedView @["View_3"] { };
		T3SavedView @["View_4"] { };
		T3SavedView @["View_5"] { };
	      };
	    };
	    T3Panel @["TrialOutputDataGrid"] { 
	      T3DataView_List @.children = [1] {
		GridTableView @["projects_Project_0_viewers_Browser3_frames_T3Frames_frames_TrialOutputDataGrid_root_view_children_0"] { 
		  T3DataView_List @.children = [10] {
		    GridColView @["batch"] { };
		    GridColView @["epoch"] { };
		    GridColView @["trial"] { };
		    GridColView @["trial_name"] { };
		    GridColView @["Locati_act"] { };
		    GridColView @["Cover_act"] { };
		    GridColView @["Toy_act"] { };
		    GridColView @["Hidden_act"] { };
		    GridColView @["Gaze_E_act"] { };
		    GridColView @["Reach_act"] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @["View_0"] { };
		T3SavedView @["View_1"] { };
		T3SavedView @["View_2"] { };
		T3SavedView @["View_3"] { };
		T3SavedView @["View_4"] { };
		T3SavedView @["View_5"] { };
	      };
	    };
	    T3Panel @["InputData"] { 
	      T3DataView_List @.children = [1] {
		GridTableView @["projects_Project_0_viewers_Browser3_frames_T3Frames_frames_InputData_root_view_children_0"] { 
		  T3DataView_List @.children = [6] {
		    GridColView @["Group"] { };
		    GridColView @["Name"] { };
		    GridColView @["Location"] { };
		    GridColView @["Cover"] { };
		    GridColView @["Toy"] { };
		    GridColView @["Reach"] { };
		  };
		};
	      };

	      T3SavedView_List @.saved_views = [6] {
		T3SavedView @["View_0"] { };
		T3SavedView @["View_1"] { };
		T3SavedView @["View_2"] { };
		T3SavedView @["View_3"] { };
		T3SavedView @["View_4"] { };
		T3SavedView @["View_5"] { };
	      };
	    };
	  };
	};
      };

      DockViewer_List @.docks = [1] {
	ToolBoxDockViewer @["Tools"] { 
     UserDataItem_List @*(.user_data_) {
	    UserDataItem @["view_win_lft"] { };
	    UserDataItem @["view_win_top"] { };
	    UserDataItem @["view_win_wd"] { };
	    UserDataItem @["view_win_ht"] { };
	    UserDataItem @["view_win_iconified"] { };
	    UserDataItem @["view_visible"] { };
     };
};
      };
    };
  };

  Network_Group @.networks = [1] {
    LeabraNetwork @["ABNet"] { 
   UserDataItem_List @*(.user_data_) {
	UserDataItem @["cos_err"] { };
	UserDataItem @["norm_err"] { };
	UserDataItem @["ext_rew"] { };
	UserDataItem @["maxda"] { };
	UserDataItem @["minus_output_name"] { };
	UserDataItem @["minus_cycles"] { };
	UserDataItem @["ct_cycle"] { };
	UserDataItem @["phase_no"] { };
	UserDataItem @["phase"] { };
	UserDataItem @["sse"] { };
	UserDataItem @["output_name"] { };
	UserDataItem @["trial_name"] { };
	UserDataItem @["group_name"] { };
	UserDataItem @["time"] { };
	UserDataItem @["cycle"] { };
	UserDataItem @["tick"] { };
	UserDataItem @["trial"] { };
	UserDataItem @["group"] { };
	UserDataItem @["epoch"] { };
	UserDataItem @["batch"] { };
   };

      BaseSpec_Group @.specs = [5] {
	LeabraUnitSpec @["UnitSpec"] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.noise_sched = [0] {
	  };
	};
	LeabraConSpec @["RecurrentCons"] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraConSpec @["ForwardCons"] { 
	  BaseSpec_Group @.children = [1] {
	    LeabraConSpec @["FmCoverToy"] { 
	      BaseSpec_Group @.children = [0] {
	      };

	      Schedule @.lrate_sched = [0] {
	      };
	    };
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	LeabraLayerSpec @["LayerSpec"] { 
	  BaseSpec_Group @.children = [0] {
	  };
	};
	LeabraBiasSpec @["BiasSpec"] { 
	  BaseSpec_Group @.children = [0] {
	  };

	  Schedule @.lrate_sched = [0] {
	  };
	};
	BaseSpec_Group @.gp["LeabraPrjns"] = [3] { 
	  FullPrjnSpec @["FullPrjn"] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  OneToOnePrjnSpec @["SelfPrjn"] { 
	    BaseSpec_Group @.children = [0] {
	    };
	  };
	  TesselPrjnSpec @["LocationPrjns"] { 
	    BaseSpec_Group @.children = [0] {
	    };

	    TessEl_List @.send_offs = [3] {
	      TessEl @[0] { };
	      TessEl @[1] { };
	      TessEl @[2] { };
	    };
	  };
	};
      };

      Layer_Group @.layers = [6] {
	LeabraLayer @["Location"] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [3] {
	    LeabraUnit @["A"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	    LeabraUnit @["B"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	    LeabraUnit @["C"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	  };
	};
	LeabraLayer @["Hidden"] { 
	  Projection_Group @.projections = [4] {
	    LeabraPrjn @["Fm_Location"] { };
	    LeabraPrjn @["Fm_Hidden"] { };
	    LeabraPrjn @["Fm_Cover"] { };
	    LeabraPrjn @["Fm_Toy"] { };
	  };

	  Unit_Group @.units = [3] {
	    LeabraUnit @["A"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [4] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
		LeabraRecvCons @[2] { 
	  [2]		};
		LeabraRecvCons @[3] { 
	  [2]		};
	      };

	      SendCons_List @.send = [3] {
		LeabraSendCons @[0] { 
	  [3]		};
		LeabraSendCons @[1] { 
	  [3]		};
		LeabraSendCons @[2] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @["B"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [4] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
		LeabraRecvCons @[2] { 
	  [2]		};
		LeabraRecvCons @[3] { 
	  [2]		};
	      };

	      SendCons_List @.send = [3] {
		LeabraSendCons @[0] { 
	  [3]		};
		LeabraSendCons @[1] { 
	  [3]		};
		LeabraSendCons @[2] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @["C"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [4] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
		LeabraRecvCons @[2] { 
	  [2]		};
		LeabraRecvCons @[3] { 
	  [2]		};
	      };

	      SendCons_List @.send = [3] {
		LeabraSendCons @[0] { 
	  [3]		};
		LeabraSendCons @[1] { 
	  [3]		};
		LeabraSendCons @[2] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @["Gaze_Expectation"] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @["Fm_Hidden"] { };
	    LeabraPrjn @["Fm_Gaze_Expectation"] { };
	  };

	  Unit_Group @.units = [3] {
	    LeabraUnit @["A"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @["B"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @["C"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @["Reach"] { 
	  Projection_Group @.projections = [2] {
	    LeabraPrjn @["Fm_Hidden"] { };
	    LeabraPrjn @["Fm_Reach"] { };
	  };

	  Unit_Group @.units = [3] {
	    LeabraUnit @["A"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @["B"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	    LeabraUnit @["C"] { 
       UserDataItem_List @*(.user_data_) {
       };

	      RecvCons_List @.recv = [2] {
		LeabraRecvCons @[0] { 
	  [3]		};
		LeabraRecvCons @[1] { 
	  [1]		};
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [1]		};
	      };
	    };
	  };
	};
	LeabraLayer @["Cover"] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @["C1"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	    LeabraUnit @["C2"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	  };
	};
	LeabraLayer @["Toy"] { 
	  Projection_Group @.projections = [0] {
	  };

	  Unit_Group @.units = [2] {
	    LeabraUnit @["T1"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	    LeabraUnit @["T2"] { 
	      RecvCons_List @.recv = [0] {
	      };

	      SendCons_List @.send = [1] {
		LeabraSendCons @[0] { 
	  [3]		};
	      };
	    };
	  };
	};
      };

      NetViewObj_Group @.view_objs = [0] {
      };
    };
  };
};
LeabraProject .projects["a_not_b"] {
 name="a_not_b";
 desc="


";
 tags=;
 version {
  major=0;
  minor=0;
  step=0;
 };
 license {
  owner="Regents of the University of Colorado";
  license=NO_LIC;
  org="CCNLab at the University of Colorado Boulder";
  year="2011";
  custom=;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 templates {
  name=;
  el_typ=taBase;
  el_def=0;
 };
 docs {
  name=;
  el_typ=taDoc;
  el_def=0;
  taDoc @["ProjectDocs"] {
   name="ProjectDocs";
   desc=;
   auto_open=1;
   web_doc=1;
   wiki="CCN";
   url="CCNBook/Sims/Executive/A_Not_B";
   full_url="http://grey.colorado.edu/CompCogNeuro/index.php/CCNBook/Sims/Executive/A_Not_B";
   text_size=1;
   text="<html>
<head></head>
<body>

</body>
</html>
";
   html_text="<!DOCTYPE html><html lang=\"en\" dir=\"ltr\" class=\"client-js\"><head>
<title>CCNBook/Sims/Executive/A Not B - Computational Cognitive Neuroscience Wiki</title>
<meta charset=\"UTF-8\">
<meta name=\"generator\" content=\"MediaWiki 1.20alpha\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/extensions/Drafts/Drafts.css?3\">
<link rel=\"alternate\" type=\"application/x-wiki\" title=\"Edit\" href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=edit\">
<link rel=\"edit\" title=\"Edit\" href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=edit\">
<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/CompCogNeuro/opensearch_desc.php\" title=\"Computational Cognitive Neuroscience Wiki (en)\">
<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"http://grey.colorado.edu/CompCogNeuro/api.php?action=rsd\">
<link rel=\"alternate\" type=\"application/atom+xml\" title=\"Computational Cognitive Neuroscience Wiki Atom feed\" href=\"/CompCogNeuro/index.php?title=Special:RecentChanges&amp;feed=atom\">
<link rel=\"stylesheet\" href=\"http://grey.colorado.edu/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared&amp;only=styles&amp;skin=gumaxdd&amp;*\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/gumaxdd/gumax_main.css?303\" media=\"screen\">
<!--[if lt IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/gumaxdd/IE50Fixes.css?303\" media=\"screen\" /><![endif]-->
<!--[if IE 5.5000]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/gumaxdd/IE55Fixes.css?303\" media=\"screen\" /><![endif]-->
<!--[if IE 6]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/gumaxdd/IE60Fixes.css?303\" media=\"screen\" /><![endif]-->
<!--[if IE 7]><link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/gumaxdd/IE70Fixes.css?303\" media=\"screen\" /><![endif]-->
<link rel=\"stylesheet\" href=\"/CompCogNeuro/skins/gumaxdd/gumax_print.css?303\" media=\"print\">
<link rel=\"stylesheet\" href=\"/CompCogNeuro/extensions/HeaderTabs/skins-jquery/ext.headertabs.jquery-large.css\"><style type=\"text/css\">.js-messagebox{margin:1em 5%;padding:0.5em 2.5%;border:1px solid #ccc;background-color:#fcfcfc;font-size:0.8em}.js-messagebox .js-messagebox-group{margin:1px;padding:0.5em 2.5%;border-bottom:1px solid #ddd}.js-messagebox .js-messagebox-group:last-child{border-bottom:thin none transparent}

/* cache key: compcogneuro:resourceloader:filter:minify-css:7:8b08bdc91c52a9ffba396dccfb5b473c */</style><meta name=\"ResourceLoaderDynamicStyles\" content=\"\">
<link rel=\"stylesheet\" href=\"http://grey.colorado.edu/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=gumaxdd&amp;*\">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}

/* cache key: compcogneuro:resourceloader:filter:minify-css:7:d5a1bf6cbd05fc6cc2705e47f52062dc */</style>

<script src=\"http://grey.colorado.edu/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=gumaxdd&amp;*\"></script><script src=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=jquery%2Cmediawiki&amp;only=scripts&amp;skin=gumaxdd&amp;version=20121215T200257Z\"></script>
<script>if(window.mw){
mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":false,\"wgNamespaceNumber\":0,\"wgPageName\":\"CCNBook/Sims/Executive/A_Not_B\",\"wgTitle\":\"CCNBook/Sims/Executive/A Not B\",\"wgCurRevisionId\":3936,\"wgArticleId\":577,\"wgIsArticle\":true,\"wgAction\":\"view\",\"wgUserName\":\"Oreilly\",\"wgUserGroups\":[\"sysop\",\"*\",\"user\",\"autoconfirmed\"],\"wgCategories\":[],\"wgBreakFrames\":false,\"wgPageContentLanguage\":\"en\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgRelevantPageName\":\"CCNBook/Sims/Executive/A_Not_B\",\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[],\"wgSearchNamespaces\":[0,1,2,3,4,5,10],\"htTabIndexes\":[],\"wgVectorEnabledModules\":{\"collapsiblenav\":true,\"collapsibletabs\":true,\"editwarning\":true,\"expandablesearch\":false,\"footercleanup\":false,\"sectioneditlinks\":false,\"simplesearch\":true,\"experiments\":true},\"wgSVGEditEditor\":false,\"wgWikiEditorEnabledModules\":{\"toolbar\":true,\"dialogs\":true,\"hidesig\":true,\"templateEditor\":false,\"templates\":false,\"preview\":true,\"previewDialog\":false,\"publish\":false,\"toc\":false}});
}</script><script>if(window.mw){
mw.loader.implement(\"user.options\",function(){mw.user.options.set({\"ccmeonemails\":0,\"cols\":80,\"date\":\"default\",\"diffonly\":0,\"disablemail\":0,\"disablesuggest\":0,\"editfont\":\"default\",\"editondblclick\":0,\"editsection\":\"1\",\"editsectiononrightclick\":\"1\",\"enotifminoredits\":\"1\",\"enotifrevealaddr\":0,\"enotifusertalkpages\":1,\"enotifwatchlistpages\":\"1\",\"extendwatchlist\":0,\"externaldiff\":0,\"externaleditor\":0,\"fancysig\":0,\"forceeditsummary\":0,\"gender\":\"unknown\",\"hideminor\":0,\"hidepatrolled\":0,\"imagesize\":2,\"justify\":0,\"math\":0,\"minordefault\":0,\"newpageshidepatrolled\":0,\"nocache\":0,\"noconvertlink\":0,\"norollbackdiff\":0,\"numberheadings\":0,\"previewonfirst\":0,\"previewontop\":\"\",\"quickbar\":5,\"rcdays\":7,\"rclimit\":50,\"rememberpassword\":\"1\",\"rows\":\"35\",\"searchlimit\":20,\"showhiddencats\":0,\"showjumplinks\":1,\"shownumberswatching\":1,\"showtoc\":1,\"showtoolbar\":1,\"skin\":\"gumaxdd\",\"stubthreshold\":0,\"thumbsize\":2,\"underline\":2,\"uselivepreview\":0,\"usenewrc\":0,\"watchcreations\":\"1\",\"watchdefault\":\"1\",\"watchdeletion\":0,
\"watchlistdays\":3,\"watchlisthideanons\":0,\"watchlisthidebots\":0,\"watchlisthideliu\":0,\"watchlisthideminor\":0,\"watchlisthideown\":0,\"watchlisthidepatrolled\":0,\"watchmoves\":\"1\",\"wllimit\":250,\"vector-simplesearch\":1,\"vector-collapsiblenav\":1,\"vector-collapsibletabs\":1,\"vector-editwarning\":1,\"vector-expandablesearch\":1,\"vector-footercleanup\":1,\"usebetatoolbar\":1,\"usebetatoolbar-cgd\":1,\"wikieditor-preview\":1,\"variant\":\"en\",\"language\":\"en\",\"searchNs0\":true,\"searchNs1\":\"1\",\"searchNs2\":\"1\",\"searchNs3\":\"1\",\"searchNs4\":\"1\",\"searchNs5\":\"1\",\"searchNs6\":false,\"searchNs7\":false,\"searchNs8\":false,\"searchNs9\":false,\"searchNs10\":\"1\",\"searchNs11\":false,\"searchNs12\":false,\"searchNs13\":false,\"searchNs14\":false,\"searchNs15\":false,\"searchNs100\":false,\"extensionDrafts_enable\":true,\"nickname\":\"\",\"timecorrection\":\"ZoneInfo|-420|America/Denver\",\"useeditwarning\":\"1\",\"watchlisttoken\":\"\"});;},{},{});mw.loader.implement(\"user.tokens\",function(){mw.user.tokens.set({\"editToken\":\"57574314ac907a0117933bbc50e80754+\\\\\",
\"watchToken\":\"a8eff4c1851c8d8166d1ed153473dc44+\\\\\"});;},{},{});

/* cache key: compcogneuro:resourceloader:filter:minify-js:7:121ac1b7e515b0d18fe6a17849f8cc14 */
}</script>
<script>if(window.mw){
mw.loader.load([\"mediawiki.page.startup\",\"mediawiki.legacy.wikibits\",\"mediawiki.legacy.ajax\"]);
}</script><script type=\"text/javascript\" src=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=jquery.client%2Ccookie%2CmessageBox%2CmwExtension%7Cmediawiki.legacy.ajax%2Cwikibits%7Cmediawiki.page.startup%7Cmediawiki.util&amp;skin=gumaxdd&amp;version=20130531T021913Z&amp;*\"></script>
</head>
<body class=\"mediawiki ltr sitedir-ltr ns-0 ns-subject page-CCNBook_Sims_Executive_A_Not_B skin-gumaxdd action-view\">
<div id=\"gumax-page\">
	<!--///===== Drop Down menu script =====///-->

	<!--/// no need for mediawiki 1.17.0 and up
	<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/gumaxdd/scripts/jquery-1.4.2.min.js?303\"></script>
	    ///-->

	<!--/// click style ///-->
	<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/gumaxdd/scripts/jquery.droppy-0.1.2.js?303\"></script>
	<script type=\"text/javascript\">jQuery(document).ready( function($){  $(function(){ $('#gumax-nav').droppy({trigger: 'click'}); })  } );</script>

	<!--/// auto style 
	<script type=\"text/javascript\" src=\"/CompCogNeuro/skins/gumaxdd/scripts/jquery.droppy.js?303\"></script>
	<script type=\"text/javascript\">jQuery(document).ready( function($){  $(function(){ $('#gumax-nav').droppy({speed: 10}); })  } );</script>
	    ///-->

	<!--///===== End of Drop Down menu =====///-->


	<div id=\"gumax-header\">

		<div id=\"gumax-p-login\">
				<!--li><a href=\"#\">My Accounts</a-->
		<ul>
			<li id=\"pt-userpage\"><a href=\"/CompCogNeuro/index.php/User:Oreilly\">Oreilly</a></li>
			<li id=\"pt-mytalk\"><a href=\"/CompCogNeuro/index.php/User_talk:Oreilly\" class=\"new\">My talk</a></li>
			<li id=\"pt-preferences\"><a href=\"/CompCogNeuro/index.php/Special:Preferences\">My preferences</a></li>
			<li id=\"pt-watchlist\"><a href=\"/CompCogNeuro/index.php/Special:Watchlist\">My watchlist</a></li>
			<li id=\"pt-mycontris\"><a href=\"/CompCogNeuro/index.php/Special:Contributions/Oreilly\">My contributions</a></li>
			<li id=\"pt-logout\"><a href=\"/CompCogNeuro/index.php?title=Special:UserLogout&amp;returnto=CCNBook%2FSims%2FExecutive%2FA+Not+B\">Log out</a></li>
		</ul>
	<!--/li-->
		</div> <!-- end of Login Tools -->

		<div id=\"gumax-p-logo\">
				<div id=\"p-logo\">
		<a style=\"background-image: url(/mediawiki/sites//CompCogNeuro/logo.png);\" href=\"/CompCogNeuro/index.php/Main_Page\"></a>
	</div>
	<script type=\"text/javascript\"> if (window.isMSIE55) fixalpha(); </script>
		</div> <!-- end of gumax-p-logo -->

		
	<div id=\"gumax-p-search\">
		<!--h5><label for=\"searchInput\">Search</label></h5-->
		<div id=\"gumax-searchBody\">
			<form action=\"/CompCogNeuro/index.php/Special:Search\" id=\"searchform\"><div>
				<input id=\"searchInput\" name=\"search\" type=\"text\" value=\"\">
				<input type=\"submit\" name=\"go\" class=\"searchButton\" id=\"searchGoButton\" value=\"Go\">&nbsp;
				<input type=\"submit\" name=\"fulltext\" class=\"searchButton\" id=\"mw-searchButton\" value=\"Search\">
			</div></form>
		</div>
	</div>

	</div> <!-- ///// end of gumax-header ///// -->

	<div style=\"clear:both\"></div>


	<div id=\"gumax-p-navigation\">
		 	<ul id=\"gumax-nav\" class=\"droppy\">
			<li><a id=\"gumax-nav-heading\" href=\"#\" class=\"has-subnav\">Navigation  »</a>
				<ul>
 					<li id=\"n-mainpage-description\"><a href=\"/CompCogNeuro/index.php/Main_Page\">Main page</a></li>
 					<li id=\"n-CCN-Book\"><a href=\"/CompCogNeuro/index.php/CCNBook/Main\">CCN Book</a></li>
 					<li id=\"n-recentchanges\"><a href=\"/CompCogNeuro/index.php/Special:RecentChanges\">Recent changes</a></li>
 					<li id=\"n-randompage\"><a href=\"/CompCogNeuro/index.php/Special:Random\">Random page</a></li>
 					<li id=\"n-help\"><a href=\"/CompCogNeuro/index.php/Help:Contents\">Help</a></li>
				<li><p style=\"margin:0; padding: 7px 0;\"></p></li>
 				</ul>
			</li>
			<li><a id=\"gumax-nav-heading\" href=\"#\" class=\"has-subnav\">Toolbox  »</a>
			<ul>
				<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CCNBook/Sims/Executive/A_Not_B\">What links here</a></li>
				<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CCNBook/Sims/Executive/A_Not_B\">Related changes</a></li>
<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\">Upload file</a></li>
<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\">Special pages</a></li>
				<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;oldid=3936\">Permanent link</a></li>			</ul>
			</li>
			<li><a id=\"gumax-nav-heading\" href=\"#\">Print/export  »</a>
			</li>
	</ul>
	</div> <!-- end of Navigation Menu -->

	<div style=\"clear:both\"></div>

	<!-- gumax-content-actions -->
	<div id=\"gumax-content-actions\">
				<ul>

			 <li id=\"ca-nstab-main\" class=\"selected\"><a href=\"/CompCogNeuro/index.php/CCNBook/Sims/Executive/A_Not_B\">Page</a></li>
			 <li id=\"ca-talk\" class=\"new\"><a href=\"/CompCogNeuro/index.php?title=Talk:CCNBook/Sims/Executive/A_Not_B&amp;action=edit&amp;redlink=1\">Discussion</a></li>
			 <li id=\"ca-edit\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=edit\">Edit</a></li>
			 <li id=\"ca-history\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=history\">History</a></li>
			 <li id=\"ca-delete\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=delete\">Delete</a></li>
			 <li id=\"ca-move\"><a href=\"/CompCogNeuro/index.php/Special:MovePage/CCNBook/Sims/Executive/A_Not_B\">Move</a></li>
			 <li id=\"ca-protect\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=protect\">Protect</a></li>
			 <li id=\"ca-unwatch\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=unwatch&amp;token=932a67ae236bc5e81cea9dc2db0ff635%2B%5C\">Unwatch</a></li>
		</ul>

	</div>
	<!-- end of gumax-content-actions -->

	<div class=\"gumax-p-navigation-spacer\"></div>

	<!-- gumax-article-picture -->
		<!-- end of gumax-article-picture -->

	<!-- gumax-content-body -->
		<div id=\"gumax-content-body\">
		<div class=\"gumax-firstHeading\">CCNBook/Sims/Executive/A Not B</div>
		<div class=\"visualClear\"></div>
		<!-- content -->
		<div id=\"content\"><div id=\"mw-js-message\" class=\"js-messagebox\" style=\"display: none; \"></div>
			<a name=\"top\" id=\"top\"></a>
						<div id=\"bodyContent\" class=\"gumax-bodyContent\">
				<h3 id=\"siteSub\">From Computational Cognitive Neuroscience Wiki</h3>
				<div id=\"contentSub\"></div>
												<div id=\"jump-to-nav\">Jump to: <a href=\"#column-one\">navigation</a>, <a href=\"#searchInput\">search</a></div>				<!-- start content -->
				<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><h1><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=edit&amp;section=1\" title=\"Edit section: The A-not-B Task and the Development of PFC Active Maintenance\">edit</a>]</span> <span class=\"mw-headline\" id=\"The_A-not-B_Task_and_the_Development_of_PFC_Active_Maintenance\"> The A-not-B Task and the Development of PFC Active Maintenance </span></h1>
<ul><li> The project file: <a href=\"/mediawiki/sites/CompCogNeuro/images/4/47/a_not_b.proj\" class=\"internal\" title=\"a not b.proj\">a_not_b.proj</a> (click and Save As to download, then open in <a href=\"/CompCogNeuro/index.php/Emergent\" title=\"Emergent\" class=\"mw-redirect\">Emergent</a>)
</li></ul>
<p>Back to <a href=\"/CompCogNeuro/index.php/CCNBook/Sims/All\" title=\"CCNBook/Sims/All\">CCNBook/Sims/All</a> or <a href=\"/CompCogNeuro/index.php/CCNBook/Executive\" title=\"CCNBook/Executive\">Executive Function Chapter</a>.
</p>
<h1><span class=\"editsection\">[<a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;action=edit&amp;section=2\" title=\"Edit section: Project Documentation\">edit</a>]</span> <span class=\"mw-headline\" id=\"Project_Documentation\"> Project Documentation </span></h1>
<p>This simulation explores how the development of PFC active maintenance abilities can help to make behavior more flexible, in the sense that it can rapidly shift with changes in the environment.  The development of flexibility has been extensively explored in the context of Piaget's famous A-not-B task, where a toy is first hidden several times in one hiding location (A), and then hidden in a new location (B).  Depending on various task parameters, young kids reliably reach back at A instead of updating to B.
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> It is recommended that you <a href=\"/CompCogNeuro/index.php?title=.docs.ProjectDocs.EditDialog()&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".docs.ProjectDocs.EditDialog() (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">click here to undock</span></a> this document from the main project window. Use the Window menu to find this window if you lose it, and you can always return to this document by browsing to this document from the <span style=\"background:#FFFFD0\"><tt><b>docs</b></tt></span> section in the left browser panel of the project's main window. <br>
</td></tr>
</tbody></table>
<p>Let's examine the network first <a href=\"/CompCogNeuro/index.php?title=.T3Tab.ABNet&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.ABNet (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ABNet</span></a>.  It has location, cover, and toy inputs, and gaze/expectation and reach outputs.  The internal hidden layer maintains information over the delay while the toy is hidden using recurrent self-connections, and represents the prefrontal cortex (PFC) in this model. 
</p><p>Notice that there are three location units corresponding to locations {{var|A}, <span style=\"background:#FFFFD0\"><tt><b>B</b></tt></span>, and <span style=\"background:#FFFFD0\"><tt><b>C</b></tt></span>, represented in the location-based units in the network.  Also, there are two cover (lid) input units corresponding to C1, the default cover type, and C2, a different cover type, and two toy units corresponding to T1, the default toy, and T2, a different toy type.
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Click on <span style=\"background:#FFFFD0\"><tt><b>r.wt</b></tt></span> so we can examine the connectivity. With the red arrow tool in the rar right frame, click on each of the three hidden units first, then the output units. <br>
</td></tr>
</tbody></table>
<p>Each of the three input layers is fully connected to the hidden layer, and the hidden layer is fully connected to each of the two output layers.  You can see that there is an initial bias for the same locations to be more strongly activating, with weights of .7, while other locations have only a .3 initial connection weight.  Connections from the toy and cover units are relatively weak at .3.  The hidden and output layers have self-recurrent excitatory connections back to each unit, which are initially of magnitude .4, but we can change this with the <span style=\"background:#FFFFD0\"><tt><b>RecurrentCons wts.mean</b></tt></span> parameter in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ControlPanel</span></a>.  Stronger weights here will improve the network's ability to maintain active representations.  We are starting out with relatively weak ones to simulate a young infant that has poor active maintenance abilities.
</p><p>Now, let's examine the input data patterns that will be presented to the network.
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.InputData&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.InputData (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">InputData</span></a> tab (right frame). <br>
</td></tr>
</tbody></table>
<p>Note that there are three types of trials (to see them all, scroll with the purple bar on the right using the red arrow), indicated by the three names used in the Group column:   
</p>
<ul><li> <span style=\"background:#FFFFD0\"><tt><b>ptrial</b></tt></span> (pre-trial or \"practice\" trials): these are presented at the start of an experiment to induce infants to reach to the A location -- they only have a single time step delay between presentation of the item and the choice test.
</li><li> <span style=\"background:#FFFFD0\"><tt><b>Atrial</b></tt></span>: test trials to the A location, which only differ from ptrials in that the delay is longer.
</li><li> <span style=\"background:#FFFFD0\"><tt><b>Btrial</b></tt></span>: this is the key test condition, which is identical to the Atrials except the toy input is in the B location.
</li></ul>
<p>Each trial consists of five segments (rows in the table) corresponding to the experimental segments of an A-not-B trial as listed below.  During each segment, patterns of activity are presented to the input units corresponding to the visible/salient aspects of the stimulus event; all other input units have no activity.  The levels of input activity represent the salience of aspects of the stimulus, with more salient aspects (e.g. a toy that the experimenter waves) producing more
activity.
</p>
<ol><li> <i>start</i>: covers sit in place on the apparatus, out of reach for the infant, and before the experimenter draws infant's attention to a particular location (weak equal activation on locations and cover inputs).
</li><li> <i>toy presentation</i> (toy-pres): experimenter draws the infant's attention to a toy (e.g., waves it) and places it into one location in apparatus (one location more strongly active, and toy T1 active)
</li><li> <i>lid presentation</i> (lid-pres): experimenter further draws the infant's attention to the location while placing the lid over the toy location (toy fading out in activation while cover is more active, and location less active)
</li><li> <i>delay</i>: the apparatus sits (out of reach) with all covers in place (equal weak location and toy activation)
</li><li> <i>choice</i>: the experimenter makes the apparatus accessible (with covers in place) for the infant's response (reaching is possible/permitted only during this segment) (inputs more active than delay but same pattern; reach layer is disinhibited) 
</li></ol>
<p>Each of these trial types can be repeated multiple times, as can the events within the trial.  In the version we will be running, the task will consist of four <i>pre-trials</i>, two <i>A</i> trials, and one <i>B</i> trial (in that exact sequence). In addition, the toy-pres inputs are presented three times during each trial, and the number of delay events is varied for 'A' and 'B' trials in order to vary the working memory \"load.\" 
</p><p>Now, let's run the network.  It will be much easier to tell what is going on in the network by looking at a grid display, rather than trying to watch each trial's activation as the network runs (but you are welcome to do so by stepping through the inputs). 
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Click on the <a href=\"/CompCogNeuro/index.php?title=.T3Tab.TrialOutputDataGrid&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".T3Tab.TrialOutputDataGrid (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">TrialOutputDataGrid</span></a> tab.  Then press the <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Init, Run</tt></span> buttons on the master <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ControlPanel</span></a>. <br>
</td></tr>
</tbody></table>
<p>When you do this, the network will run through an entire A-not-B experiment, and record the activations in the grid.  The <span style=\"background:#FFFFD0\"><tt><b>trial_name</b></tt></span> column tells you which event is being presented, and the remaining columns show the activations in each layer of the network after each event.  
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Let's focus on the pre-trials first. With the red arrow tool, scroll the purple handle along the right side up to the beginning of the table <br>
</td></tr>
</tbody></table>
<p>Notice that when the toy is presented during the <span style=\"background:#FFFFD0\"><tt><b>p-toy-pres</b></tt></span> events, the corresponding hidden 'A' location also has become activated due to spreading activations, and that the network also \"looks\" toward this location in the <span style=\"background:#FFFFD0\"><tt><b>Gaze_Expectation</b></tt></span> layer.
</p><p>Furthermore, because Hebbian learning is taking place after each trial, those units that are coactive experience weight increases, which in turn increases the propensity of the network to activate the <i>A</i> location representations on subsequent trials.
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Next, scroll down past the 4 pre-trials so that the first A-trial event (<span style=\"background:#FFFFD0\"><tt><b>A-start</b></tt></span>) is the first row displayed. (Just past midway through the table.) <br>
</td></tr>
</tbody></table>
<p>You will now see the <i>A</i> testing trials, where the network's tendency to reach to the <i>A</i> location is assessed.  Note that as a result of the Hebbian learning, the hidden and <span style=\"background:#FFFFD0\"><tt><b>Gaze_Expectation</b></tt></span> output units are even more active here than in the pretrials.
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Now scroll down to make the first B-trial event the first one displayed. <br>
</td></tr>
</tbody></table>
<hr>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#90FF90;font-size:small\"><b>Question 10.4:</b> Describe what happens to the network's internal representations and output (gaze, reach) responses over the delay and choice trials for the B trials, and how this relates to Piaget's A-not-B data in infants. <br>
</td></tr>
</tbody></table>
<hr>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Now increase the <span style=\"background:#FFFFD0\"><tt><b>RecurrentCons wts.mean</b></tt></span> parameter in the <a href=\"/CompCogNeuro/index.php?title=.PanelTab.ControlPanel&amp;action=edit&amp;redlink=1\" class=\"new\" title=\".PanelTab.ControlPanel (page does not exist)\"><span style=\"color:#000000;background-color:#C0C0C0;font-weight:bold; border:1px solid black; padding:0 3px 0 3px\">ControlPanel</span></a> to .35 from the default of .25, and <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Init, Run</tt></span> and then scroll the table (if needed) so as to see the B trial again. <br>
</td></tr>
</tbody></table>
<hr>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#90FF90;font-size:small\"><b>Question 10.5:</b> Describe how the network responds (i.e., in the gaze and reach outputs) this time, including a discussion of how the increased PFC recurrent connection strength affected the network's behavior.<br>
</td></tr>
</tbody></table>
<hr>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Now <i>decrease</i> the <span style=\"background:#FFFFD0\"><tt><b>RecurrentCons wts.mean</b></tt></span> parameter to weaker value of .2 and set <span style=\"background:#FFFFD0\"><tt><b>input data</b></tt></span> to <span style=\"background:#FFFFD0\"><tt><b>ABInput_Delay1</b></tt></span>, which simulates a shorter delay than we had seen before.  <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Init, Run</tt></span> and examine the B-trial again. <br>
</td></tr>
</tbody></table>
<p>You should observe that the gaze and reach activations are now dissociated on the B trial, reflecting the fact that the Gaze pathway is updated continuously, while the Reaching pathway has to wait until the end and is thus more sensitive to small amounts of decay.
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> A shorter delay allows infants to typically perform better (making fewer A-not-B errors) -- try going back to the original .25 recurrent weight value with this short delay condition. <br>
</td></tr>
</tbody></table>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> Next, set <span style=\"background:#FFFFD0\"><tt><b>input_data</b></tt></span> to <span style=\"background:#FFFFD0\"><tt><b>ABInput_Delay5</b></tt></span> and try the value of .35 for the recurrent weights that we found worked with a delay of 3 before. <br>
</td></tr>
</tbody></table>
<hr>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#90FF90;font-size:small\"><b>Question 10.6:</b> What happens on the 'B' trials with those two delays -- why does delay have this effect on the network's behavior?<br>
</td></tr>
</tbody></table>
<hr>
<p>You can also try to find a recurrent weight value that allows the network to succeed with the longer 5 delay condition.
</p><p>Finally, there is an interesting effect that can occur with very weak recurrent weights, which do not allow the network to maintain the representation of even the <i>A</i> location very well on 'A' trials. Because the weight changes toward 'A' depend on such maintained activity of the 'A' units, these weight-based representations will be relatively weak, making the network perseverate less to 'A' than it would with slightly stronger recurrent weights.  
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> To see this effect, set <span style=\"background:#FFFFD0\"><tt><b>input_data</b></tt></span> back to the <span style=\"background:#FFFFD0\"><tt><b>Delay3</b></tt></span> case and then reduce the <span style=\"background:#FFFFD0\"><tt><b>RecurrentCons wts.mean</b></tt></span> parameter to .1, <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Init, Run</tt></span>, and look at the activations of the units in the 'B' choice trial.  Then compare this with the case with <span style=\"background:#FFFFD0\"><tt></tt></span> of .25. <br>
</td></tr>
</tbody></table>
<p>You should see that there is a less strong 'A' response with the weaker recurrent weights (and also some residual activation of the 'B' units), meaning a less strong A-not-B error (and further analysis has confirmed that this is due to the amount of learning on the 'A' trials).
</p>
<table cellpadding=\"10\">
<tbody><tr><td style=\"background-color:#FFE0E0\"> <b>?</b> You may now close the project (use the window manager close button on the project window or <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>File/Close Project</tt></span> menu item) and then open a new one, or just quit emergent entirely by doing <span style=\"background:#E0E0E0;border:1px solid black;\"><tt>Quit emergent</tt></span> menu option or clicking the close button on the root window. <br>
</td></tr>
</tbody></table>

<!-- 
NewPP limit report
Preprocessor node count: 306/1000000
Post-expand include size: 10694/2097152 bytes
Template argument size: 5197/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key compcogneuro:pcache:idhash:577-0!*!0!!*!*!* and timestamp 20130816195048 -->
</div><div class=\"printfooter\">
Retrieved from \"<a href=\"http://grey.colorado.edu/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;oldid=3936\">http://grey.colorado.edu/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;oldid=3936</a>\"</div>
				<div id=\"catlinks\" class=\"catlinks catlinks-allhidden\"></div>				<!-- end content -->
				<div class=\"visualClear\"></div>
			</div> <!-- end of bodyContent -->
		</div> <!-- end of content -->
	</div> <!-- end of gumax-content-body -->


	<!-- end of gumax-content-body -->


	<div class=\"gumax-footer-spacer\"></div>


	<div id=\"gumax-footer\">

		<!-- personal specia tools  -->
		
		<div id=\"gumax-special-tools\">
			<ul>
					<li id=\"t-whatlinkshere\"><a href=\"/CompCogNeuro/index.php/Special:WhatLinksHere/CCNBook/Sims/Executive/A_Not_B\">What links here</a></li>
					<li id=\"t-recentchangeslinked\"><a href=\"/CompCogNeuro/index.php/Special:RecentChangesLinked/CCNBook/Sims/Executive/A_Not_B\">Related changes</a></li>
	<li id=\"t-upload\"><a href=\"/CompCogNeuro/index.php/Special:Upload\">Upload file</a></li>
	<li id=\"t-specialpages\"><a href=\"/CompCogNeuro/index.php/Special:SpecialPages\">Special pages</a></li>
					<li id=\"t-permalink\"><a href=\"/CompCogNeuro/index.php?title=CCNBook/Sims/Executive/A_Not_B&amp;oldid=3936\">Permanent link</a></li>			</ul>
		</div>

		<!-- end of personal specia tools  -->

		<!-- gumax-f-message -->
		
		<div id=\"gumax-article-message\">
			<span id=\"f-lastmod\"> This page was last modified on 16 August 2013, at 13:50.</span>
			<span id=\"f-viewcount\">This page has been accessed 1,057 times. </span>
					</div>

		<!-- end of gumax-f-message -->

		<script>if(window.mw){
mw.loader.load([\"mediawiki.user\",\"mediawiki.page.ready\",\"mediawiki.action.watch.ajax\",\"mediawiki.legacy.mwsuggest\",\"mediawiki.action.view.rightClickEdit\",\"ext.headertabs\"], null, true);
}</script>
<script type=\"text/javascript\" src=\"/CompCogNeuro/extensions/Drafts/Drafts.js?3\"></script>
<script src=\"http://grey.colorado.edu/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=gumaxdd&amp;*\"></script>

	</div> <!-- ///// end of gumax-footer ///// -->


	<!-- gumax-f-list -->
	
		<div id=\"gumax-credit-list\">
			<ul>
								<li id=\"privacy\"><a href=\"/CompCogNeuro/index.php/Project:Privacy_policy\" title=\"Project:Privacy policy\">Privacy policy</a></li>
								<li id=\"about\"><a href=\"/CompCogNeuro/index.php/Project:About\" title=\"Project:About\">About Computational Cognitive Neuroscience Wiki</a></li>
								<li id=\"disclaimer\"><a href=\"/CompCogNeuro/index.php/Project:General_disclaimer\" title=\"Project:General disclaimer\">Disclaimers</a></li>
								<li id=\"f-poweredby\"><a href=\"http://mediawiki.org\" target=\"_blank\">Powered by MediaWiki</a></li>
				<li id=\"f-designedby\"><a href=\"http://paulgu.com\" target=\"_blank\">Designed by Paul Gu</a></li>
			</ul>
		</div>

	<!-- end of gumax-f-list -->


</div><script src=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=ext.headertabs%7Cjquery.checkboxShiftClick%2CmakeCollapsible%2Cmw-jump%2Cplaceholder%7Cmediawiki.action.view.rightClickEdit%7Cmediawiki.action.watch.ajax%7Cmediawiki.api%2Cuser%7Cmediawiki.api.watch%7Cmediawiki.legacy.mwsuggest%7Cmediawiki.page.ready&amp;skin=gumaxdd&amp;version=20130609T070416Z&amp;*\" type=\"text/javascript\"></script><script src=\"/CompCogNeuro/load.php?debug=false&amp;lang=en&amp;modules=jquery.ui.core%2Ctabs%2Cwidget&amp;skin=gumaxdd&amp;version=20130330T024858Z&amp;*\" type=\"text/javascript\"></script> <!-- ===== end of gumax-page ===== -->

	<div style=\"clear:both\"></div>

	<div id=\"gumax_page_spacer\"></div>


<!-- Served in 0.208 secs. -->




	
</body></html>";
  };
 };
 wizards {
  name=;
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @["LeabraWizard_1"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
   auto_open=0;
  };
 };
 edits {
  name=;
  el_typ=SelectEdit;
  el_def=0;
  SelectEdit @["ControlPanel"] {
   name="ControlPanel";
   auto_edit=1;
   desc=;
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="RecurrentCons_wts";
     desc=" Weight randomization specification. Note that NONE means no value at all, not the mean, and should be used if some other source is setting the weights, e.g., from a projectionspec or loading from a file etc<br>  type:  type of random variable to generate<br>   * UNIFORM:  uniform with var = range on either side of the mean<br>   * BINOMIAL:  binomial with var = p, par = n<br>   * POISSON:  poisson with lambda = var<br>   * GAMMA:  gamma with var and par = stages<br>   * GAUSSIAN:  normal with var<br>   * NONE:  just the mean<br>  mean:  mean of random distribution<br>  var:  'varibility' parameter for the random numbers (gauss = standard deviation, not variance; uniform = half-range)<br>  par:  extra parameter for distribution (depends on each one)";
     cust_desc=0;
     base=.projects["a_not_b"].networks["ABNet"].specs["RecurrentCons"]$$;
     mbr=ConSpec::rnd;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[1] {
     label="input_data";
     desc=" object pointer value -- this is not the object itself, just a pointer to it -- object must exist somewhere. if it is in this program's .objs, then the name will be automatically set -- this is the current actual value of the variable at all times for global variables, and is used as an initialization value for local variables (they start with this value, but what you see here is NOT their current value as the program runs)";
     cust_desc=0;
     base=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["input_data"]$$;
     mbr=ProgVar::object_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
    EditMbrItem @[2] {
     label="cycle_update_view";
     desc=" boolean value -- this is the current actual value of the variable at all times for global variables, and is used as an initialization value for local variables (they start with this value, but what you see here is NOT their current value as the program runs)";
     cust_desc=0;
     base=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraCycle"].vars["update_net_view"]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     param_search {
      search=0;
      min_val=0;
      max_val=1;
      next_val=0;
      incr=0.1000000014901161;
     };
    };
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"]$;
     mth=Program::Stop;
    };
    EditMthItem @[4] {
     label="Defaults";
     desc=" set the program state back to the beginning";
     cust_desc=0;
     base=.projects["a_not_b"].programs["SetDefaults"]$$;
     mth=Program::Init;
    };
   };
  };
  ClusterRun @["ClusterRun"] {
   name="ClusterRun";
   auto_edit=0;
   desc=;
   mbrs {
    name=;
    el_typ=EditMbrItem;
    el_def=0;
   };
   mths {
    name=;
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   search_algos {
    name=;
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   cur_search_algo=NULL;
   last_submit_time=;
   notes=;
   extra_files=;
   svn_repo=;
   repo_url=;
   cluster=;
   queue=;
   run_time=;
   ram_gb=0;
   n_threads=1;
   use_mpi=0;
   mpi_nodes=10;
   parallel_batch=0;
   pb_batches=10;
   pb_nodes=0;
   nowin_x=0;
  };
 };
 data {
  name=;
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @.gp["InputData"] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @["ABInput_Delay3"] {
    name="ABInput_Delay3";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["Group"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [55] "ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";
"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";
"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"Atrial";"Atrial";
"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";
"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Btrial";"Btrial";"Btrial";"Btrial";
"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";      };
     };
     String_Data @["Name"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [55] "p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"p-start";"p-toy-pres";"p-toy-pres";
"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";
"p-choice";"p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"A-start";"A-toy-pres";
"A-toy-pres";"A-toy-pres";"A-lid-pres";"A-delay";"A-delay";"A-delay";"A-choice";"A-start";"A-toy-pres";"A-toy-pres";
"A-toy-pres";"A-lid-pres";"A-delay";"A-delay";"A-delay";"A-choice";"B-start";"B-toy-pres";"B-toy-pres";"B-toy-pres";
"B-lid-pres";"B-delay";"B-delay";"B-delay";"B-choice";      };
     };
     float_Data @["Location"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Location";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 55] 0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;0.94999999;
0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.60000002;0.60000002;
0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.60000002;
0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;
0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;
0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;
0.1;0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;
0;0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;
0.40000001;0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;0.60000002;0.60000002;
0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.40000001;
0.40000001;0;0.40000001;0.40000001;0;0.60000002;0.60000002;0;0.15000001;0.15000001;
0;0.1;0.94999999;0;0.1;0.94999999;0;0.1;0.94999999;0;
0.1;0.5;0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;0.40000001;
0.40000001;0;0.60000002;0.60000002;0;      };
     };
     float_Data @["Cover"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Cover";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 55] 0.15000001;0;0.1;0;0.1;0;0.1;0;0.5;0;
0.40000001;0;0.60000002;0;0.15000001;0;0.1;0;0.1;0;
0.1;0;0.5;0;0.40000001;0;0.60000002;0;0.15000001;0;
0.1;0;0.1;0;0.1;0;0.5;0;0.40000001;0;
0.60000002;0;0.15000001;0;0.1;0;0.1;0;0.1;0;
0.5;0;0.40000001;0;0.60000002;0;0;0;0.1;0;
0.1;0;0.1;0;0.5;0;0.40000001;0;0.40000001;0;
0.40000001;0;0.60000002;0;0;0;0.1;0;0.1;0;
0.1;0;0.5;0;0.40000001;0;0.40000001;0;0.40000001;0;
0.60000002;0;0.15000001;0;0.1;0;0.1;0;0.1;0;
0.5;0;0.40000001;0;0.40000001;0;0.40000001;0;0.60000002;0;
      };
     };
     float_Data @["Toy"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Toy";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 55] 0;0;0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;
0;0;0;0;0;0;0.94999999;0;0.94999999;0;
0.94999999;0;0.5;0;0;0;0;0;0;0;
0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;0;0;
0;0;0;0;0.94999999;0;0.94999999;0;0.94999999;0;
0.5;0;0;0;0;0;0;0;0.94999999;0;
0.94999999;0;0.94999999;0;0.5;0;0;0;0;0;
0;0;0;0;0;0;0.94999999;0;0.94999999;0;
0.94999999;0;0.5;0;0;0;0;0;0;0;
0;0;0;0;0.94999999;0;0.94999999;0;0.94999999;0;
0.5;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @["Reach"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Reach";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 55] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
	[55] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;    };
   };
   DataTable @["ABInput_Delay5"] {
    name="ABInput_Delay5";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["Group"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [61] "ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";
"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";
"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"Atrial";"Atrial";
"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";
"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";
"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";
"Btrial";      };
     };
     String_Data @["Name"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [61] "p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"p-start";"p-toy-pres";"p-toy-pres";
"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";
"p-choice";"p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"A-start";"A-toy-pres";
"A-toy-pres";"A-toy-pres";"A-lid-pres";"A-delay";"A-delay";"A-delay";"A-delay";"A-delay";"A-choice";"A-start";
"A-toy-pres";"A-toy-pres";"A-toy-pres";"A-lid-pres";"A-delay";"A-delay";"A-delay";"A-delay";"A-delay";"A-choice";
"B-start";"B-toy-pres";"B-toy-pres";"B-toy-pres";"B-lid-pres";"B-delay";"B-delay";"B-delay";"B-delay";"B-delay";
"B-choice";      };
     };
     float_Data @["Location"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Location";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 61] 0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;0.94999999;
0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.60000002;0.60000002;
0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.60000002;
0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;
0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;
0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;
0.1;0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;
0;0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;
0.40000001;0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;0.40000001;0.40000001;
0;0.40000001;0.40000001;0;0.60000002;0.60000002;0;0.15000001;0.15000001;0;
0.94999999;0.1;0;0.94999999;0.1;0;0.94999999;0.1;0;0.5;
0.1;0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;0.40000001;0.40000001;
0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;0.60000002;0.60000002;0;
0.15000001;0.15000001;0;0.1;0.94999999;0;0.1;0.94999999;0;0.1;
0.94999999;0;0.1;0.5;0;0.40000001;0.40000001;0;0.40000001;0.40000001;
0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;0.40000001;0.40000001;0;
0.60000002;0.60000002;0;      };
     };
     float_Data @["Cover"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Cover";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 61] 0.15000001;0;0.1;0;0.1;0;0.1;0;0.5;0;
0.40000001;0;0.60000002;0;0.15000001;0;0.1;0;0.1;0;
0.1;0;0.5;0;0.40000001;0;0.60000002;0;0.15000001;0;
0.1;0;0.1;0;0.1;0;0.5;0;0.40000001;0;
0.60000002;0;0.15000001;0;0.1;0;0.1;0;0.1;0;
0.5;0;0.40000001;0;0.60000002;0;0;0;0.1;0;
0.1;0;0.1;0;0.5;0;0.40000001;0;0.40000001;0;
0.40000001;0;0.40000001;0;0.40000001;0;0.60000002;0;0;0;
0.1;0;0.1;0;0.1;0;0.5;0;0.40000001;0;
0.40000001;0;0.40000001;0;0.40000001;0;0.40000001;0;0.60000002;0;
0.15000001;0;0.1;0;0.1;0;0.1;0;0.5;0;
0.40000001;0;0.40000001;0;0.40000001;0;0.40000001;0;0.40000001;0;
0.60000002;0;      };
     };
     float_Data @["Toy"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Toy";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 61] 0;0;0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;
0;0;0;0;0;0;0.94999999;0;0.94999999;0;
0.94999999;0;0.5;0;0;0;0;0;0;0;
0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;0;0;
0;0;0;0;0.94999999;0;0.94999999;0;0.94999999;0;
0.5;0;0;0;0;0;0;0;0.94999999;0;
0.94999999;0;0.94999999;0;0.5;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;
0;0;0;0;0;0;0;0;0;0;
0;0;      };
     };
     float_Data @["Reach"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1751313507556915;
	val_type_fixed=0;
       };
      };
      name="Reach";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 61] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
	[61] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;55;56;57;58;59;
60;    };
   };
   DataTable @["ABInput_Delay1"] {
    name="ABInput_Delay1";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["Group"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1733102202415466;
	val_type_fixed=0;
       };
      };
      name="Group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [49] "ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";
"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";
"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"ptrial";"Atrial";"Atrial";
"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";"Atrial";
"Atrial";"Atrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";"Btrial";      };
     };
     String_Data @["Name"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1733102202415466;
	val_type_fixed=0;
       };
      };
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [49] "p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"p-start";"p-toy-pres";"p-toy-pres";
"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";
"p-choice";"p-start";"p-toy-pres";"p-toy-pres";"p-toy-pres";"p-lid-pres";"p-delay";"p-choice";"A-start";"A-toy-pres";
"A-toy-pres";"A-toy-pres";"A-lid-pres";"A-delay";"A-choice";"A-start";"A-toy-pres";"A-toy-pres";"A-toy-pres";"A-lid-pres";
"A-delay";"A-choice";"B-start";"B-toy-pres";"B-toy-pres";"B-toy-pres";"B-lid-pres";"B-delay";"B-choice";      };
     };
     float_Data @["Location"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1733102202415466;
	val_type_fixed=0;
       };
      };
      name="Location";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 49] 0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;0.94999999;
0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.60000002;0.60000002;
0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;0.60000002;
0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;0.1;
0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;0;
0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;0.94999999;
0.1;0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;0.40000001;
0;0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;0;
0.94999999;0.1;0;0.94999999;0.1;0;0.5;0.1;0;0.40000001;
0.40000001;0;0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.94999999;0.1;
0;0.94999999;0.1;0;0.94999999;0.1;0;0.5;0.1;0;
0.40000001;0.40000001;0;0.60000002;0.60000002;0;0.15000001;0.15000001;0;0.1;
0.94999999;0;0.1;0.94999999;0;0.1;0.94999999;0;0.1;0.5;
0;0.40000001;0.40000001;0;0.60000002;0.60000002;0;      };
     };
     float_Data @["Cover"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1733102202415466;
	val_type_fixed=0;
       };
      };
      name="Cover";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 49] 0.15000001;0;0.1;0;0.1;0;0.1;0;0.5;0;
0.40000001;0;0.60000002;0;0.15000001;0;0.1;0;0.1;0;
0.1;0;0.5;0;0.40000001;0;0.60000002;0;0.15000001;0;
0.1;0;0.1;0;0.1;0;0.5;0;0.40000001;0;
0.60000002;0;0.15000001;0;0.1;0;0.1;0;0.1;0;
0.5;0;0.40000001;0;0.60000002;0;0;0;0.1;0;
0.1;0;0.1;0;0.5;0;0.40000001;0;0.60000002;0;
0;0;0.1;0;0.1;0;0.1;0;0.5;0;
0.40000001;0;0.60000002;0;0.15000001;0;0.1;0;0.1;0;
0.1;0;0.5;0;0.40000001;0;0.60000002;0;      };
     };
     float_Data @["Toy"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1733102202415466;
	val_type_fixed=0;
       };
      };
      name="Toy";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 49] 0;0;0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;
0;0;0;0;0;0;0.94999999;0;0.94999999;0;
0.94999999;0;0.5;0;0;0;0;0;0;0;
0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;0;0;
0;0;0;0;0.94999999;0;0.94999999;0;0.94999999;0;
0.5;0;0;0;0;0;0;0;0.94999999;0;
0.94999999;0;0.94999999;0;0.5;0;0;0;0;0;
0;0;0.94999999;0;0.94999999;0;0.94999999;0;0.5;0;
0;0;0;0;0;0;0.94999999;0;0.94999999;0;
0.94999999;0;0.5;0;0;0;0;0;      };
     };
     float_Data @["Reach"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1733102202415466;
	val_type_fixed=0;
       };
      };
      name="Reach";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 49] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
	[49] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;    };
   };
   DataTable @["UnitNames"] {
    name="UnitNames";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["Location"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1808318197727203;
	val_type_fixed=0;
       };
      };
      name="Location";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 1] "A";"B";"C";      };
     };
     String_Data @["Cover"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1808318197727203;
	val_type_fixed=0;
       };
      };
      name="Cover";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 1] "C1";"C2";      };
     };
     String_Data @["Reach"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1808318197727203;
	val_type_fixed=0;
       };
      };
      name="Reach";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 1] "A";"B";"C";      };
     };
     String_Data @["Toy"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1808318197727203;
	val_type_fixed=0;
       };
      };
      name="Toy";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 1] "T1";"T2";      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
	[1] 0;    };
   };
  };
  DataTable_Group @.gp["OutputData"] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   DataTable @["TrialOutputData"] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @["batch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_84";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     int_Data @["epoch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_85";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     int_Data @["trial"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_86";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     String_Data @["trial_name"] {
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["Locati_act"] {
      name="Locati_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 0]       };
     };
     float_Data @["Cover_act"] {
      name="Cover_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 0]       };
     };
     float_Data @["Toy_act"] {
      name="Toy_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 2;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [2 1 0]       };
     };
     float_Data @["Hidden_act"] {
      name="Hidden_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 0]       };
     };
     float_Data @["Gaze_E_act"] {
      name="Gaze_E_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 0]       };
     };
     float_Data @["Reach_act"] {
      name="Reach_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 3;1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [2] ;;      };
      width=0;
      ar {
       name=;
	    [3 1 0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
	[0]     };
   };
   DataTable @["EpochOutputData"] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @["batch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_85";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     int_Data @["epoch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_86";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["avg_sse"] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["cnt_err"] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["avg_ext_rew"] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["avg_cycles"] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["epoch_time_tot"] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
     float_Data @["epoch_time_usr"] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name=;
	    [0]       };
      width=0;
      ar {
       name=;
	    [0]       };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name=;
	[0]     };
   };
  };
  DataTable_Group @.gp["AnalysisData"] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
  };
 };
 data_proc {
  name=;
  el_typ=taDataProc;
  el_def=0;
  taDataProc @["data_base"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_base";
  };
  taDataAnal @["data_anal"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_anal";
  };
  taDataGen @["data_gen"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="data_gen";
  };
  taImageProc @["image_proc"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItemBase;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="image_proc";
  };
 };
 programs {
  name=;
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  Program @["SetDefaults"] {
   name="SetDefaults";
   short_nm="SDflts";
   tags=;
   desc=;
   flags=0;
   objs {
    name=;
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name=;
    el_typ=ProgType;
    el_def=0;
   };
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
   };
   vars {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["ABNet"] {
     name="ABNet";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=.projects["a_not_b"].networks["ABNet"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["ControlPanel"] {
     name="ControlPanel";
     var_type=T_Object;
     object_type=SelectEdit;
     object_val=.projects["a_not_b"].edits["ControlPanel"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["LeabraTrain"] {
     name="LeabraTrain";
     var_type=T_Object;
     object_type=Program;
     object_val=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"]$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["n_delay_3"] {
     name="n_delay_3";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name=;
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    MemberAssign @[0] {
     desc=;
     flags=0;
     orig_prog_code=;
     obj=.projects["a_not_b"].programs["SetDefaults"].vars["ABNet"]$$;
     path="specs.RecurrentCons.rnd.mean";
     expr {
      expr=".25";
     };
     update_after=0;
    };
    MethodCall @[1] {
     desc=;
     flags=0;
     orig_prog_code=;
     result_var=NULL;
     obj=.projects["a_not_b"].programs["SetDefaults"].vars["LeabraTrain"]$$;
     method=Program::SetVar;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="var_nm";
       required=1;
       def_val="\"\"";
       expr {
	expr="\"input_data\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="value";
       required=1;
       def_val=;
       expr {
	expr="n_delay_3";
       };
      };
     };
    };
    MethodCall @[2] {
     desc=;
     flags=0;
     orig_prog_code=;
     result_var=NULL;
     obj=.projects["a_not_b"].programs["SetDefaults"].vars["ControlPanel"]$$;
     method=SelectEdit::UpdateAfterEdit;
     meth_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
   prog_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
   };
   step_prog=NULL;
   step_n=1;
  };
  Program_Group @.gp["LeabraAll_Std"] {
   name="LeabraAll_Std";
   el_typ=Program;
   el_def=0;
   tags="Leabra, Std, All";
   desc="The full set of programs for training a standard Leabra network";
   Program @["LeabraBatch"] {
    name="LeabraBatch";
    short_nm="Batch";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=0;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns -- not used by this program, but passed to train program";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["batch"] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @["max_batch"] {
      name="max_batch";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="maximum number of batch runs to perform";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=0;
      orig_prog_code=;
      network_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraBatch"].args["network"]$$;
      local_ctr_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraBatch"].vars["batch"]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraBatch"].args["network"]$;
      local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraBatch"].vars["batch"]$;
      counter=Network::batch;
      update_after=0;
     };
     WhileLoop @[1] {
      desc="the main loop over training runs";
      flags=0;
      orig_prog_code=;
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=0;
	orig_prog_code=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="no_prompts";
	  required=1;
	  def_val=;
	  expr {
	   expr="true";
	  };
	 };
	};
	target=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"]$;
	targ_ld_init="*LeabraTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=0;
	orig_prog_code=;
	network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraBatch"].args["network"]$;
	local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraBatch"].vars["batch"]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      test {
       expr="batch < max_batch";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraTrain"] {
    name="LeabraTrain";
    short_nm="Train";
    tags="Leabra, Std";
    desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
    flags=0;
    objs {
     name=;
     el_typ=RndSeed;
     el_def=0;
     RndSeed @["rnd_seed"] {
      name="rnd_seed";
      seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;      };
      mti=156;
      is_gauss_double_cached=0;
      cached_gauss_double=0;
     };
    };
    types {
     name=;
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @["RndInitType"] {
      name="RndInitType";
      desc=;
      enums {
       name=;
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @["OLD_SEED"] {
	name="OLD_SEED";
	value=0;
	desc="use stored random seed value (recreates same sequence every time)";
       };
       DynEnumItem @["NEW_SEED"] {
	name="NEW_SEED";
	value=1;
	desc="generate new random seed (new sequence of random numbers)";
       };
      };
      bits=0;
     };
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network to train";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="datatable with training patterns";
      init_from=NULL;
     };
     ProgVar @["no_prompts"] {
      name="no_prompts";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["max_epoch"] {
      name="max_epoch";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="maximum number of epochs to run";
      init_from=NULL;
     };
     ProgVar @["epoch"] {
      name="epoch";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current epoch -- local copy, which is used to update network's epoch counter";
      init_from=NULL;
     };
     ProgVar @["train_mode"] {
      name="train_mode";
      var_type=T_HardEnum;
      int_val=1;
      hard_enum_type=Network::TrainMode;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
      init_from=NULL;
     };
     ProgVar @["rnd_init"] {
      name="rnd_init";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].types["RndInitType"]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="how to initialize the random numbers when the Init button is pressed";
      init_from=NULL;
     };
     ProgVar @["err_stopcrit"] {
      name="err_stopcrit";
      var_type=T_Real;
      real_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
      init_from=NULL;
     };
     ProgVar @["rnd_seed"] {
      name="rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].objs["rnd_seed"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="random seed that is used at start of training -- if OldSeed is called";
      init_from=NULL;
     };
     ProgVar @["train_timer"] {
      name="train_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects["a_not_b"].networks["ABNet"].train_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="records time used to train network (object lives on network -- this is a pointer to it)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["no_prompts"]$$;
      expr {
       expr="false";
      };
     };
     MethodCall @[1] {
      desc="check network to make sure it is ready to be run";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["network"]$$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     AssignExpr @[2] {
      desc="get our pointer to the network training time object";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["train_timer"]$$;
      expr {
       expr="network.train_time";
      };
     };
     IfElse @[3] {
      desc="initialize random seed (either old or new)";
      flags=0;
      orig_prog_code=;
      cond {
       expr="rnd_init == OLD_SEED";
      };
      show_false_code=1;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results)";
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["rnd_seed"]$$;
	method=RndSeed::OldSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="new random numbers each time";
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["rnd_seed"]$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="initialize network weights: could also load pre-set weights or something else here";
      flags=NON_STD;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["network"]$;
      method=Network::Init_Weights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfGuiPrompt @[5] {
      desc="don't initialize weights without checking";
      flags=OFF;
      orig_prog_code=;
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       PrintExpr @[0] {
	desc=;
	flags=0;
	orig_prog_code=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	my_mask=NULL;
	debug_level=NULL;
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      desc="get our pointer to the network training time object";
      flags=0;
      orig_prog_code=;
      result_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["train_timer"]$;
      expr {
       expr="network.train_time";
      };
     };
     MethodCall @[1] {
      desc="start timer to keep track of how long it takes to run entire training run";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["train_timer"]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MemberAssign @[2] {
      desc="set network's training mode to our local value";
      flags=0;
      orig_prog_code=;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["network"]$;
      path="train_mode";
      expr {
       expr="train_mode";
      };
      update_after=0;
     };
     MethodCall @[3] {
      desc="initialize network weights: could also load pre-set weights or something else here";
      flags=NON_STD;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["network"]$;
      method=Network::Init_Weights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc=;
      flags=OFF;
      orig_prog_code=;
      cond {
       expr="no_prompts";
      };
      show_false_code=0;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       PrintExpr @[0] {
	desc=;
	flags=0;
	orig_prog_code=;
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	my_mask=NULL;
	debug_level=NULL;
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
      };
     };
     AssignExpr @[5] {
      desc="grab the official network epoch counter: will be initialized if needed by now";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["epoch"]$$;
      expr {
       expr="network.epoch";
      };
     };
     WhileLoop @[6] {
      desc="main loop over epochs of training";
      flags=0;
      orig_prog_code=;
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the epoch program (one epoch), passes our network and input_data";
	flags=0;
	orig_prog_code=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"]$$;
	targ_ld_init="*LeabraEpoch*";
       };
       NetCounterIncr @[1] {
	desc="increment the epoch counter (locally and on network)";
	flags=0;
	orig_prog_code=;
	network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].args["network"]$;
	local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["epoch"]$;
	counter=Network::epoch;
	update_after=0;
       };
       IfBreak @[2] {
	desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here instead)";
	flags=0;
	orig_prog_code=;
	cond {
	 expr="network.cnt_err <= err_stopcrit";
	};
       };
      };
      test {
       expr="epoch < max_epoch";
      };
     };
     MethodCall @[7] {
      desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrain"].vars["train_timer"]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraEpoch"] {
    name="LeabraEpoch";
    short_nm="Epoch";
    tags="Leabra, Std";
    desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["group_order"] {
      name="group_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["item_order"] {
      name="item_order";
      var_type=T_HardEnum;
      int_val=0;
      hard_enum_type=NetGroupedDataLoop::Order;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["trial"] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["trial_mon_data"] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- if we want to reset it every epoch";
      init_from=NULL;
     };
     ProgVar @["epoch_timer"] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects["a_not_b"].networks["ABNet"].epoch_time$$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["group_index"] {
      name="group_index";
      var_type=T_Int;
      int_val=3;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["prv_group_index"] {
      name="prv_group_index";
      var_type=T_Int;
      int_val=2;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="previous group index, for determining when group changes";
      init_from=NULL;
     };
     ProgVar @["item_index"] {
      name="item_index";
      var_type=T_Int;
      int_val=9;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["unit_names"] {
      name="unit_names";
      var_type=T_Object;
      object_type=taOBase;
      object_val=.projects["a_not_b"].data.gp["InputData"]["UnitNames"]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["Name"] {
      name="Name";
      var_type=T_String;
      string_val="B-choice";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter: note also needs to do this in regular running program";
      flags=0;
      orig_prog_code=;
      network_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$$;
      local_ctr_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["trial"]$$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["epoch_timer"]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     InitNamedUnits @[2] {
      desc=;
      flags=0;
      orig_prog_code=;
      input_data_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["input_data"]$$;
      unit_names_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["unit_names"]$$;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
      n_lay_name_chars=1;
      max_unit_chars=-1;
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize trial counter";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
      local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["trial"]$;
      counter=Network::trial;
      update_after=0;
     };
     AssignExpr @[1] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["epoch_timer"]$;
      expr {
       expr="network.epoch_time";
      };
     };
     AssignExpr @[2] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["prv_group_index"]$$;
      expr {
       expr="-1";
      };
     };
     MethodCall @[3] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["epoch_timer"]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[4] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn OFF if not wanted)";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["trial_mon_data"]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetGroupedDataLoop @[5] {
      desc="iterates over groups and items within groups";
      flags=0;
      orig_prog_code=;
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       Comment @[0] {
	desc="Reach layer normally INPUT layer_type to clamp zero activation; set to OUTPUT for choice trials only";
	flags=0;
	orig_prog_code=;
       };
       CodeBlock @[1] {
	desc=;
	flags=NEW_EL;
	orig_prog_code=;
	prog_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 DataVarProg @[0] {
	  desc=;
	  flags=NEW_EL;
	  orig_prog_code=;
	  data_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["input_data"]$;
	  set_data=0;
	  row_spec=CUR_ROW;
	  row_var=NULL;
	  quiet=0;
	  var_1=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["Name"]$$;
	  var_2=NULL;
	  var_3=NULL;
	  var_4=NULL;
	 };
	 IfElse @[1] {
	  desc=;
	  flags=NEW_EL;
	  orig_prog_code=;
	  cond {
	   expr="Name.contains(\"choice\")";
	  };
	  show_false_code=1;
	  true_code {
	   name=;
	   el_typ=ProgCode;
	   el_def=0;
	   MemberAssign @[0] {
	    desc=;
	    flags=NEW_EL;
	    orig_prog_code=;
	    obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
	    path="layers.Reach.layer_type";
	    expr {
	     expr="Layer::OUTPUT";
	    };
	    update_after=0;
	   };
	  };
	  false_code {
	   name=;
	   el_typ=ProgCode;
	   el_def=0;
	   MemberAssign @[0] {
	    desc=;
	    flags=NEW_EL;
	    orig_prog_code=;
	    obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
	    path="layers.Reach.layer_type";
	    expr {
	     expr="Layer::INPUT";
	    };
	    update_after=0;
	   };
	  };
	 };
	};
       };
       IfElse @[2] {
	desc="new group -- initialize activations";
	flags=0;
	orig_prog_code=;
	cond {
	 expr="group_index !=  prv_group_index";
	};
	show_false_code=0;
	true_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=0;
	  orig_prog_code=;
	  result_var=NULL;
	  obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
	  method=Network::Init_Acts;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	 AssignExpr @[1] {
	  desc=;
	  flags=0;
	  orig_prog_code=;
	  result_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["prv_group_index"]$;
	  expr {
	   expr="group_index";
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	};
       };
       ProgramCall @[3] {
	desc="call the trial process";
	flags=0;
	orig_prog_code=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"]$$;
	targ_ld_init="*LeabraTrial*";
       };
       IfElse @[4] {
	desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
	flags=0;
	orig_prog_code=;
	cond {
	 expr="network.Compute_Weights_Test(trial+1)";
	};
	show_false_code=0;
	true_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=0;
	  orig_prog_code=;
	  result_var=NULL;
	  obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
	  method=Network::Compute_Weights;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	false_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	};
       };
      };
      data_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["input_data"]$;
      group_index_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["group_index"]$$;
      item_index_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["item_index"]$$;
      group_order_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["group_order"]$$;
      item_order_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["item_order"]$$;
      group_order=SEQUENTIAL;
      item_order=SEQUENTIAL;
      group_col=0;
      update_after=0;
      group_idx_list{ 0;28;46;      };
      item_idx_list{ 46;47;48;49;50;51;52;53;54;      };
     };
     IfElse @[6] {
      desc="if full batch mode, update only at end of epoch";
      flags=0;
      orig_prog_code=;
      cond {
       expr="network.wt_update == Network::BATCH";
      };
      show_false_code=0;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
      };
     };
     MethodCall @[7] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
      method=LeabraNetwork::Compute_StableWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[8] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].args["network"]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[9] {
      desc=;
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpoch"].vars["epoch_timer"]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[10] {
      desc="call the epoch monitor";
      flags=0;
      orig_prog_code=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraTrial"] {
    name="LeabraTrial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
    flags=0;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="datatable containing training input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["phase_no"] {
      name="phase_no";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="local phase counting variable (0 is typically minus phase, 1 is typically plus -- depends on network settings)";
      init_from=NULL;
     };
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
     ProgVar @["trial"] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=0;
      orig_prog_code=;
      network_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$$;
      local_ctr_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].vars["phase_no"]$$;
      counter=LeabraNetwork::phase_no;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize the local phase_no counter, and corresponding network one";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
      local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].vars["phase_no"]$;
      counter=LeabraNetwork::phase_no;
      update_after=1;
     };
     MethodCall @[1] {
      desc="initializes various counters at start of trial";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     WhileLoop @[2] {
      desc="loop over phases of settling in the network";
      flags=0;
      orig_prog_code=;
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the settle program (which iterates over cyles of network activation updating) for each phase";
	flags=0;
	orig_prog_code=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  expr {
	   expr="input_data";
	  };
	 };
	};
	target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"]$$;
	targ_ld_init="*LeabraSettle*";
       };
       NetCounterIncr @[1] {
	desc="increment the phase number (also on network)";
	flags=0;
	orig_prog_code=;
	network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
	local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].vars["phase_no"]$;
	counter=LeabraNetwork::phase_no;
	update_after=1;
       };
       MethodCall @[2] {
	desc="increments other phase state information to prepare for the next phase of settling";
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
	method=LeabraNetwork::Trial_UpdatePhase;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      test {
       expr="phase_no < network.phase_max";
      };
     };
     MethodCall @[3] {
      desc="after the trial is over, do final computations: Compute_dWt (learn weights), compute stats";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=0;
      orig_prog_code=;
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      show_false_code=0;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="update the weight values based on changes computed by trial program";
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
      };
     };
     ProgramCall @[5] {
      desc="records data about the trial-level processing to a datatable for graphing/processing";
      flags=0;
      orig_prog_code=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].args["network"]$;
      update_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrial"].vars["update_net_view"]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraSettle"] {
    name="LeabraSettle";
    short_nm="Settle";
    tags="Leabra, Std";
    desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
    flags=0;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["cycle"] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @["min_cycles"] {
      name="min_cycles";
      var_type=T_Int;
      int_val=15;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="IMPORTANT: this value is obtained from the network min_cycles and min_cycles_phase2 -- change the value on the network object, not here in this program!
sets the minimum number of cycles to settle for, regardless of network state changes, etc";
      init_from=NULL;
     };
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=0;
      orig_prog_code=;
      network_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$$;
      local_ctr_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].vars["cycle"]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
      local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].vars["cycle"]$;
      counter=Network::cycle;
      update_after=0;
     };
     MethodCall @[1] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[2] {
      desc="apply external input activations from the input_data table to the network
this program can be extended to do arbitrary things to generate data and apply it to network layers";
      flags=0;
      orig_prog_code=;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["ApplyInputs"]$$;
      targ_ld_init="*ApplyInputs*";
     };
     MethodCall @[3] {
      desc="initializes various counters at start of settling";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
      method=LeabraNetwork::Settle_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[4] {
      desc="get appropriate min_cycles value depending on which phase we're in";
      flags=0;
      orig_prog_code=;
      cond {
       expr="network.phase_no <= 1";
      };
      show_false_code=1;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=0;
	orig_prog_code=;
	result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].vars["min_cycles"]$$;
	expr {
	 expr="network.min_cycles";
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	desc="get minimum number of cycles from parameter on network (which is where you should change this value!)";
	flags=0;
	orig_prog_code=;
	result_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].vars["min_cycles"]$;
	expr {
	 expr="network.min_cycles_phase2";
	};
       };
      };
     };
     WhileLoop @[5] {
      desc="the main loop over cycles of updating";
      flags=0;
      orig_prog_code=;
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=0;
	orig_prog_code=;
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraCycle"]$$;
	targ_ld_init="*LeabraCycle*";
       };
       NetCounterIncr @[1] {
	desc="increment cycle counter (also on network)";
	flags=0;
	orig_prog_code=;
	network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
	local_ctr_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].vars["cycle"]$;
	counter=Network::cycle;
	update_after=0;
       };
       IfContinue @[2] {
	desc="avoid subsequent stopping criteria if below min_cycles";
	flags=0;
	orig_prog_code=;
	cond {
	 expr="cycle < min_cycles";
	};
       };
       IfBreak @[3] {
	desc="stopping criterion for settling: based either on maximum change in activation (maxda) or on the maximum activation value in the network getting over threshold (which ever comes first).  Set either parmeter to values that are always false (e.g., trg_max_act_stopcrit = -1) to eliminate associated source of criterion for stopping settling.";
	flags=0;
	orig_prog_code=;
	cond {
	 expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
	};
       };
      };
      test {
       expr="cycle < network.cycle_max";
      };
     };
     MethodCall @[6] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
      method=LeabraNetwork::Settle_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     IfElse @[7] {
      desc="only run trial-level statistics in minus phase (otherwise network may have correct answer clamped on!).  IMPORTANT: this assumes that you've got target activation values for output layers already
presented in the minus phase -- if this is not the case (values are computed on the fly), you may want to run this instead at the start of the plus phase, after ApplyInputs";
      flags=0;
      orig_prog_code=;
      cond {
       expr="network.phase == LeabraNetwork::MINUS_PHASE";
      };
      show_false_code=0;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="compute trial-level statistics";
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
	method=LeabraNetwork::Compute_TrialStats;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
      };
     };
     IfElse @[8] {
      desc="this stat must be called in plus phase when reward information is avail";
      flags=0;
      orig_prog_code=;
      cond {
       expr="network.phase_no == 1";
      };
      show_false_code=0;
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="get external reward information";
	flags=0;
	orig_prog_code=;
	result_var=NULL;
	obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
	method=LeabraNetwork::Compute_ExtRew;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
      };
     };
     NetUpdateView @[9] {
      desc="update network views, if update_net_view == true";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].args["network"]$;
      update_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraSettle"].vars["update_net_view"]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraCycle"] {
    name="LeabraCycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=0;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraCycle"].args["network"]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=0;
      orig_prog_code=;
      network_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraCycle"].args["network"]$;
      update_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraCycle"].vars["update_net_view"]$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["ApplyInputs"] {
    name="ApplyInputs";
    short_nm="AplyIn";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @["LayerWriter_0"] {
      name="LayerWriter_0";
      data=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
      network=$.projects["a_not_b"].networks["ABNet"]$;
      layer_data {
       name=;
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	chan_name="Location";
	net_target=LAYER;
	layer_name="Location";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {type=NONE: mean=0: var=0.5: par=1: name="": };
       };
       LayerWriterEl @[1] {
	chan_name="Reach";
	net_target=LAYER;
	layer_name="Reach";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=COMP;
	noise {type=NONE: mean=0: var=0.5: par=1: name="": };
       };
       LayerWriterEl @[2] {
	chan_name="Cover";
	net_target=LAYER;
	layer_name="Cover";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {type=NONE: mean=0: var=0.5: par=1: name="": };
       };
       LayerWriterEl @[3] {
	chan_name="Toy";
	net_target=LAYER;
	layer_name="Toy";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {type=NONE: mean=0: var=0.5: par=1: name="": };
       };
       LayerWriterEl @[4] {
	chan_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {type=NONE: mean=0: var=0.5: par=1: name="": };
       };
       LayerWriterEl @[5] {
	chan_name="Group";
	net_target=GROUP_NAME;
	layer_name="Group";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {type=NONE: mean=0: var=0.5: par=1: name="": };
       };
      };
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["LayerWriter_0"] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["ApplyInputs"].objs["LayerWriter_0"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["ApplyInputs"].vars["LayerWriter_0"]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataBlock_ptr;
	type="DataBlock*";
	name="db";
	required=1;
	def_val=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraTrialMonitor"] {
    name="LeabraTrialMonitor";
    short_nm="TrlMon";
    tags="Leabra, Std, Monitor";
    desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @["trial_netmon"] {
      name="trial_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @["batch"] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["epoch"] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["trial"] {
	name="trial";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="trial";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["trial_name"] {
	name="trial_name";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="trial_name";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["Locati_act"] {
	name="Locati_act";
	computed=0;
	object_type=LeabraLayer;
	object=.projects["a_not_b"].networks["ABNet"].layers["Location"]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="Aggregate": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["Cover_act"] {
	name="Cover_act";
	computed=0;
	object_type=LeabraLayer;
	object=.projects["a_not_b"].networks["ABNet"].layers["Cover"]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="Aggregate": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["Toy_act"] {
	name="Toy_act";
	computed=0;
	object_type=LeabraLayer;
	object=.projects["a_not_b"].networks["ABNet"].layers["Toy"]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="Aggregate": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["Hidden_act"] {
	name="Hidden_act";
	computed=0;
	object_type=LeabraLayer;
	object=.projects["a_not_b"].networks["ABNet"].layers["Hidden"]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="Aggregate": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["Gaze_E_act"] {
	name="Gaze_E_act";
	computed=0;
	object_type=LeabraLayer;
	object=.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="Aggregate": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["Reach_act"] {
	name="Reach_act";
	computed=0;
	object_type=LeabraLayer;
	object=.projects["a_not_b"].networks["ABNet"].layers["Reach"]$$;
	variable="act";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="Relation": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="Aggregate": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="SimpleMathSpec": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects["a_not_b"].networks["ABNet"]$;
      data=$.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"]$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network to record data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["trial_mon_data"] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to record trial-level data to (this program writes new data to this table!)";
      init_from=NULL;
     };
     ProgVar @["trial_netmon"] {
      name="trial_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].objs["trial_netmon"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="set the network and datatable for the NetMonitor";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].vars["trial_netmon"]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[1] {
      desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="update the monitor items and data schema based on current settings of the NetMonitor object";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].vars["trial_mon_data"]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data from the network and other sources -- this does the main work";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[2] {
      desc="update views and other things after writing new data to monitor data table";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].vars["trial_mon_data"]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[3] {
      desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraTrialMonitor"].args["network"]$$;
      method=Network::DMem_ShareTrialData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="trial_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_rows";
	required=0;
	def_val="1";
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["LeabraEpochMonitor"] {
    name="LeabraEpochMonitor";
    short_nm="EpcMon";
    tags="Leabra, Std, Monitor";
    desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=NetMonitor;
     el_def=0;
     NetMonitor @["epoch_netmon"] {
      name="epoch_netmon";
      items {
       name=;
       el_typ=NetMonItem;
       el_def=0;
       NetMonItem @["batch"] {
	name="batch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="batch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["epoch"] {
	name="epoch";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="epoch";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["avg_sse"] {
	name="avg_sse";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="avg_sse";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["cnt_err"] {
	name="cnt_err";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="cnt_err";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["avg_ext_rew"] {
	name="avg_ext_rew";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="avg_ext_rew";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["avg_cycles"] {
	name="avg_cycles";
	computed=0;
	object_type=LeabraNetwork;
	object=$.projects["a_not_b"].networks["ABNet"]$;
	variable="avg_cycles";
	var_label=;
	name_style=AUTO_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["epoch_time_tot"] {
	name="epoch_time_tot";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
       NetMonItem @["epoch_time_usr"] {
	name="epoch_time_usr";
	computed=1;
	object_type=NULL;
	object=NULL;
	variable="act";
	var_label=;
	name_style=MY_NAME;
	max_name_len=6;
	val_type=VT_FLOAT;
	matrix=0;
	matrix_geom{ 	};
	data_agg=0;
	data_src=NULL;
	agg_col {
	 col_name=;
	};
	agg {op=NONE: rel={name="": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: name="": };
	select_rows=0;
	select_spec {
	 col_name=;
	 on=1;
	 rel=EQUAL;
	 use_var=0;
	 cmp 0 1;
	 var=NULL;
	 enable_var=NULL;
	};
	pre_proc_1 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_2 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
	pre_proc_3 {name="": opr=NONE: arg=0: lw=-1: hi=1: };
       };
      };
      network=$.projects["a_not_b"].networks["ABNet"]$;
      data=.projects["a_not_b"].data.gp["OutputData"]["EpochOutputData"]$$;
      rmv_orphan_cols=1;
     };
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network to get data from";
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["epoch_mon_data"] {
      name="epoch_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["a_not_b"].data.gp["OutputData"]["EpochOutputData"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="data table to write the epoch data to";
      init_from=NULL;
     };
     ProgVar @["epoch_netmon"] {
      name="epoch_netmon";
      var_type=T_Object;
      object_type=NetMonitor;
      object_val=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].objs["epoch_netmon"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="network monitor object that contains full specs for what to record and where to get it";
      init_from=NULL;
     };
     ProgVar @["epoch_timer"] {
      name="epoch_timer";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects["a_not_b"].networks["ABNet"].epoch_time$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      desc="get the epoch timer from current network";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_timer"]$$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[1] {
      desc="set data and network on NetMonitor object";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_netmon"]$$;
      method=NetMonitor::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="dt";
	required=1;
	def_val=;
	expr {
	 expr="epoch_mon_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	expr {
	 expr="network";
	};
       };
      };
     };
     MethodCall @[2] {
      desc="check configuration and emit errors/warnings for problems";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
      method=taBase::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[3] {
      desc="update the monitor items and data schema based on current settings of NetMonitor";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
      method=NetMonitor::UpdateMonitors;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_first";
	required=0;
	def_val="false";
	expr {
	 expr="true";
	};
       };
      };
     };
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="add a new blank row to the data";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$$;
      method=DataTable::AddBlankRow;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     MethodCall @[1] {
      desc="get the new monitor data and stor it into the data table -- this does the main job here";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
      method=NetMonitor::GetMonVals;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[2] {
      desc="get the epoch timer from current network";
      flags=0;
      orig_prog_code=;
      result_var=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_timer"]$;
      expr {
       expr="network.epoch_time";
      };
     };
     MethodCall @[3] {
      desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetTotSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_tot\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[4] {
      desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$;
      method=DataTable::SetValColName;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="val";
	required=1;
	def_val=;
	expr {
	 expr="epoch_timer.used.GetUsrSecs()";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="col_name";
	required=1;
	def_val="\"\"";
	expr {
	 expr="\"epoch_time_usr\"";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="row";
	required=1;
	def_val=;
	expr {
	 expr="-1";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	expr {
	 expr=;
	};
       };
      };
     };
     MethodCall @[5] {
      desc="update after writing new data to monitor data table";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$;
      method=DataBlock::WriteClose;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["SaveWeights"] {
    name="SaveWeights";
    short_nm="SvWts";
    tags="Network, Weights";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
    flags=NO_STOP_STEP;
    objs {
     name=;
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name=;
     el_typ=ProgType;
     el_def=0;
    };
    args {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects["a_not_b"].networks["ABNet"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name=;
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["tag"] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="user-provided tag (startup script will set this!)";
      init_from=NULL;
     };
     ProgVar @["wts_subdir"] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="user-provided subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @["fname"] {
      name="fname";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="final generated file name -- do not edit!";
      init_from=NULL;
     };
     ProgVar @["epoch_str"] {
      name="epoch_str";
      var_type=T_String;
      string_val="0036";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @["batch_str"] {
      name="batch_str";
      var_type=T_String;
      string_val="03";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @["final_tag"] {
      name="final_tag";
      var_type=T_String;
      string_val=".03_0036";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name=;
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name=;
     el_typ=ProgCode;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not the first dmem process (only relevant for dmem = distributed memory processing)";
      flags=0;
      orig_prog_code=;
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc="get current batch counter for file name, with leading zeros to length 3";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["SaveWeights"].vars["batch_str"]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc="get current epoch counter with leading zeros to length 4";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["SaveWeights"].vars["epoch_str"]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc="string 'tag' to identify the batch, epoch, and other user id info for the weights";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["SaveWeights"].vars["final_tag"]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc="get a file name based on the project's current file name, for saving the weights";
      flags=0;
      orig_prog_code=;
      result_var=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["SaveWeights"].vars["fname"]$$;
      obj=.projects["a_not_b"].programs.gp["LeabraAll_Std"]["SaveWeights"].args["network"]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="ext";
	required=1;
	def_val=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	expr {
	 expr="false";
	};
       };
      };
     };
     MethodCall @[5] {
      desc="save the weights to that file name";
      flags=0;
      orig_prog_code=;
      result_var=NULL;
      obj=$.projects["a_not_b"].programs.gp["LeabraAll_Std"]["SaveWeights"].args["network"]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
 };
 viewers {
  name=;
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @["Browser3"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["view_win_lft"] {
     name="view_win_lft";
     value 6 0=-0.001600853749550879;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_top"] {
     name="view_win_top";
     value 6 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_wd"] {
     name="view_win_wd";
     value 6 0=0.9973319172859192;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_ht"] {
     name="view_win_ht";
     value 6 0=0.7996604442596436;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_iconified"] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_splitter_state"] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAAAAAADAAAAtAAAAoUAAAMSAQAAAAYBAAAAAQ==";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects["a_not_b"]$$;
   visible=1;
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name=;
    el_typ=ToolBar;
    el_def=0;
    ToolBar @["Application"] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_visible"] {
       name="view_win_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name=;
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @["Tree"] {
     name="Tree";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects["a_not_b"]$;
    };
    PanelViewer @["Panels"] {
     name="Panels";
     m_data=NULL;
     visible=1;
    };
    T3PanelViewer @["T3Frames"] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_86";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_panel_selected"] {
       name="view_panel_selected";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="T3Frames";
     m_data=NULL;
     visible=1;
     panels {
      name=;
      el_typ=T3Panel;
      el_def=0;
      T3Panel @["ABNet"] {
       name="ABNet";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=NetView;
	 el_def=0;
	 NetView @["projects_Project_0_viewers_Browser3_frames_T3Frames_frames_ABNet_root_view_children_0"] {
	  name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_ABNet_root_view_children_0";
	  m_data=$.projects["a_not_b"].networks["ABNet"]$;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  display=1;
	  lay_layout=THREE_D;
	  lay_mv=0;
	  net_text=1;
	  show_iconified=0;
	  net_text_xform {scale={x=0.7: y=0.7000002: z=0.7000002: }: rotate={x=1: y=0: z=0: rot=1.570796: }: translate={x=0.8759194: y=0.2726193: z=-0.4999986: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[3].units[2]";
	  con_type=ANY_CON;
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NAMES;
	  max_size {x=11: y=2: z=2.333333: };
	  max_size2d {x=3: y=16: z=1: };
	  eff_max_size {x=11: y=2: z=2.333333: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.03;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.5;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=.colorspecs["C_ColdHot"]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name=;
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    var_name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[1] {
	    var_name="r.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[2] {
	    var_name="net";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[3] {
	    var_name="ext";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[4] {
	    var_name="act_avg";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[5] {
	    var_name="act_m";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[6] {
	    var_name="act_p";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[7] {
	    var_name="act_dif";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[8] {
	    var_name="da";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[9] {
	    var_name="bias.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[10] {
	    var_name="bias.pdw";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[11] {
	    var_name="wt_prjn";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	   ScaleRange @[12] {
	    var_name="s.wt";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Location=0;Hidden=0;Gaze_Expectation=0;Reach=0;Cover=0;Toy=0;	  };
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["View_0"] {
	 name="View_0";
	 view_saved=1;
	 pos {x=0.5982096: y=0.813404: z=1.779381: };
	 orient {x=-1.000005: y=0: z=0: rot=0.1219994: };
	 focal_dist=2.133293;
	};
	T3SavedView @["View_1"] {
	 name="View_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_2"] {
	 name="View_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_3"] {
	 name="View_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_4"] {
	 name="View_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_5"] {
	 name="View_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @["TrialOutputDataGrid"] {
       name="TrialOutputDataGrid";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=GridTableView;
	 el_def=0;
	 GridTableView @["projects_Project_0_viewers_Browser3_frames_T3Frames_frames_TrialOutputDataGrid_root_view_children_0"] {
	  name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_TrialOutputDataGrid_root_view_children_0";
	  m_data=$.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"]$;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @["batch"] {
	    name="batch";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["batch"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["epoch"] {
	    name="epoch";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["epoch"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["trial"] {
	    name="trial";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["trial"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["trial_name"] {
	    name="trial_name";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["trial_name"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=16;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Locati_act"] {
	    name="Locati_act";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["Locati_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Cover_act"] {
	    name="Cover_act";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["Cover_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Toy_act"] {
	    name="Toy_act";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["Toy_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Hidden_act"] {
	    name="Hidden_act";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["Hidden_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Gaze_E_act"] {
	    name="Gaze_E_act";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["Gaze_E_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Reach_act"] {
	    name="Reach_act";
	    m_data=.projects["a_not_b"].data.gp["OutputData"]["TrialOutputData"].data["Reach_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=18;
	  view_range {min=0: max=-1: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=7;
	  col_range {min=3: max=9: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.03: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["View_0"] {
	 name="View_0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5174999: z=1.476084: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.486084;
	};
	T3SavedView @["View_1"] {
	 name="View_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_2"] {
	 name="View_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_3"] {
	 name="View_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_4"] {
	 name="View_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_5"] {
	 name="View_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @["InputData"] {
       name="InputData";
       m_data=NULL;
       visible=1;
       root_view {
	name=;
	m_data=NULL;
	m_transform=NULL;
	children {
	 name=;
	 el_typ=GridTableView;
	 el_def=0;
	 GridTableView @["projects_Project_0_viewers_Browser3_frames_T3Frames_frames_InputData_root_view_children_0"] {
	  name="projects_Project_0_viewers_Browser3_frames_T3Frames_frames_InputData_root_view_children_0";
	  m_data=$.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"]$;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name=;
	   el_typ=GridColView;
	   el_def=0;
	   GridColView @["Group"] {
	    name="Group";
	    m_data=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"].data["Group"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=8;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Name"] {
	    name="Name";
	    m_data=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"].data["Name"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=10;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Location"] {
	    name="Location";
	    m_data=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"].data["Location"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Cover"] {
	    name="Cover";
	    m_data=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"].data["Cover"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Toy"] {
	    name="Toy";
	    m_data=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"].data["Toy"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=2;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	   GridColView @["Reach"] {
	    name="Reach";
	    m_data=.projects["a_not_b"].data.gp["InputData"]["ABInput_Delay3"].data["Reach"]$$;
	    m_transform=NULL;
	    visible=1;
	    text_width=3;
	    scale_on=1;
	    mat_layout=BOT_ZERO;
	    mat_image=0;
	    mat_odd_vert=1;
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  view_rows=18;
	  view_range {min=0: max=17: };
	  display_on=1;
	  manip_ctrl_on=1;
	  col_n=5;
	  col_range {min=0: max=4: };
	  width=1;
	  grid_on=1;
	  header_on=1;
	  row_num_on=0;
	  two_d_font=0;
	  two_d_font_scale=350;
	  mat_val_text=0;
	  colorscale {
	   name="ColorScale";
	   chunks=133;
	   min=-1;
	   max=1;
	   range=1;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  grid_margin=0.01;
	  grid_line_size=0.005;
	  row_num_width=4;
	  mat_block_spc=0.1;
	  mat_block_height=0;
	  mat_rot=0;
	  mat_trans=0.6;
	  mat_size_range {min=4: max=16: };
	  text_size_range {min=0.02: max=0.03: };
	  click_vals=0;
	  lmb_val=1;
	  mmb_val=0;
	 };
	};
       };
       bg_color {r=0.8: g=0.8: b=0.8: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       stereo_view=STEREO_NONE;
       saved_views {
	name=;
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["View_0"] {
	 name="View_0";
	 view_saved=1;
	 pos {x=1.5325: y=0.5175: z=1.479059: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.489059;
	};
	T3SavedView @["View_1"] {
	 name="View_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_2"] {
	 name="View_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_3"] {
	 name="View_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_4"] {
	 name="View_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["View_5"] {
	 name="View_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name=;
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @["Tools"] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_lft"] {
       name="view_win_lft";
       value 6 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_top"] {
       name="view_win_top";
       value 6 0=-0.01867572218179703;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_wd"] {
       name="view_win_wd";
       value 6 0=0.0405549630522728;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_ht"] {
       name="view_win_ht";
       value 6 0=0.7640067934989929;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_iconified"] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_visible"] {
       name="view_visible";
       value 1 0=0;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=0;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc=;
 networks {
  name=;
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @["ABNet"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["cos_err"] {
     name="cos_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["norm_err"] {
     name="norm_err";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["ext_rew"] {
     name="ext_rew";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["maxda"] {
     name="maxda";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["minus_output_name"] {
     name="minus_output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["minus_cycles"] {
     name="minus_cycles";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["ct_cycle"] {
     name="ct_cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["phase_no"] {
     name="phase_no";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["phase"] {
     name="phase";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["sse"] {
     name="sse";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["output_name"] {
     name="output_name";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["trial_name"] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["group_name"] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["time"] {
     name="time";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["cycle"] {
     name="cycle";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["tick"] {
     name="tick";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["trial"] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["group"] {
     name="group";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["epoch"] {
     name="epoch";
     value 1 0=0;
     val_type_fixed=1;
    };
    UserDataItem @["batch"] {
     name="batch";
     value 1 0=0;
     val_type_fixed=1;
    };
   };
   name="ABNet";
   desc=;
   specs {
    name=;
    el_typ=BaseSpec;
    el_def=0;
    LeabraUnitSpec @["UnitSpec"] {
     name="UnitSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_con_type=LeabraCon;
     bias_spec {type=LeabraBiasSpec: spec=.projects["a_not_b"].networks["ABNet"].specs["BiasSpec"]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {gelin=0: thr=0.25: gain=40: nvar=0.005: avg_dt=0.005: avg_init=0.15: i_thr=STD: };
     act_lrn_on=0;
     act_lrn {gelin=1: thr=0.5: gain=100: nvar=0.005: };
     spike {rise=0: decay=0.05: g_gain=5: window=3: eq_gain=10: eq_dt=0.02: };
     spike_misc {
      exp_slope=0.02;
      spk_thr=1.2;
      clamp_max_p=0.11;
      clamp_type=REGULAR;
      vm_r=0.3;
      t_r=6;
      vm_dend=0.3;
      vm_dend_dt=0.16;
      vm_dend_time=6.25;
     };
     opt_thresh {send=0.1: delta=0.005: phase_dif=0: };
     maxda {val=INET_DA: inet_scale=1: lay_avg_thr=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=1: range=1: scale=1: };
     v_m_init {type=UNIFORM: mean=0.15: var=0: par=1: name="": };
     dt {integ=1: vm=0.3: net=0.7: midpoint=0: d_vm_max=0.025: vm_eq_cyc=0: vm_eq_dt=1: integ_time=1: vm_time=3.333333: net_time=1.428571: };
     act_avg {l_up_dt=0.6: l_dn_dt=0.05: m_dt=0.1: s_dt=0.2: ss_dt=1: use_nd=0: l_time=20: m_time=10: s_time=5: ss_time=1: };
     g_bar {e=1: l=0.1: i=1: h=0.1: a=0.5: };
     e_rev {e=1: l=0.15: i=0.15: h=1: a=0: };
     hyst {on=0: b_inc_dt=0.01: b_dec_dt=0.05: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     acc {on=0: b_inc_dt=0.01: b_dec_dt=0.01: a_thr=0.5: d_thr=0.1: g_dt=0.1: init=1: trl=0: };
     adapt {
      on=0;
      dt=0.007;
      vm_gain=0.04;
      spike_gain=0.00805;
      interval=10;
      dt_time=142.8571;
     };
     depress {on=0: rec=0.2: asymp_act=0.5: depl=0.2105263: interval=1: max_amp=2: };
     syn_delay {
      on=0;
      delay=4;
     };
     da_mod {on=0: mod=PLUS_CONT: gain=0.1: };
     noise_type=NO_NOISE;
     noise {type=GAUSSIAN: mean=0: var=0.001: par=1: name="": };
     noise_adapt {trial_fixed=1: k_pos_noise=0: mode=FIXED_NOISE: min_pct=0.5: min_pct_c=0.5: };
     noise_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=1;
     };
    };
    LeabraConSpec @["RecurrentCons"] {
     name="RecurrentCons";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
     };
     rnd {type=UNIFORM: mean=0.25: var=0: par=1: name="": };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: };
     diff_scale_p=0;
     wt_scale_p {abs=1: rel=1: sem_extra=2: };
     wt_scale_init {init=0: abs=1: rel=1: };
     learn=1;
     lrate=0;
     cur_lrate=0;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
     };
     ignore_unlearnable=1;
     wt_sig {gain=6: off=1.25: dwt_norm=0: };
     stable_mix {stable_pct=0: learn_pct=1: };
     lmix {hebb=1: err=0: err_sb=1: };
     xcal {thr_l_mix=0.01: thr_m_mix=0.99: s_mix=0.9: m_mix=0.1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
     savg_cor {cor=1: thresh=0.01: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraConSpec @["ForwardCons"] {
     name="ForwardCons";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraConSpec @["FmCoverToy"] {
       name="FmCoverToy";
       desc=;
       unique{ rnd;       };
       children {
	name=;
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {type=UNIFORM: mean=0.3: var=0: par=1: name="": };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
       learn_rule=LEABRA_CHL;
       inhib=0;
       wt_scale {abs=1: rel=1: sem_extra=2: };
       diff_scale_p=0;
       wt_scale_p {abs=1: rel=1: sem_extra=2: };
       wt_scale_init {init=0: abs=1: rel=1: };
       learn=1;
       lrate=0.02;
       cur_lrate=0.02;
       lrs_value=EPOCH;
       lrate_sched {
	name=;
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
       };
       ignore_unlearnable=1;
       wt_sig {gain=1: off=1: dwt_norm=0: };
       stable_mix {stable_pct=0: learn_pct=1: };
       lmix {hebb=1: err=0: err_sb=1: };
       xcal {thr_l_mix=0.01: thr_m_mix=0.99: s_mix=0.9: m_mix=0.1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
       savg_cor {cor=0.7: thresh=0.001: };
       rel_net_adapt {
	on=0;
	trg_fm_input=0.85;
	trg_fm_output=0.15;
	trg_lateral=0;
	trg_sum=1;
	tol_lg=0.05;
	tol_sm=0.2;
	rel_lrate=0.1;
       };
      };
     };
     rnd {type=UNIFORM: mean=0.7: var=0: par=1: name="": };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=1: sem_extra=2: };
     diff_scale_p=0;
     wt_scale_p {abs=1: rel=1: sem_extra=2: };
     wt_scale_init {init=0: abs=1: rel=1: };
     learn=1;
     lrate=0.02;
     cur_lrate=0.02;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
     };
     ignore_unlearnable=1;
     wt_sig {gain=1: off=1: dwt_norm=0: };
     stable_mix {stable_pct=0: learn_pct=1: };
     lmix {hebb=1: err=0: err_sb=1: };
     xcal {thr_l_mix=0.01: thr_m_mix=0.99: s_mix=0.9: m_mix=0.1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
     savg_cor {cor=0.7: thresh=0.001: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
    };
    LeabraLayerSpec @["LayerSpec"] {
     name="LayerSpec";
     desc=;
     unique{      };
     children {
      name=;
      el_typ=LeabraLayerSpec;
      el_def=0;
     };
     inhib_group=ENTIRE_LAYER;
     inhib {
      type=KWTA_AVG_INHIB;
      kwta_pt=0.65;
      avg_boost=0;
      low0=0;
      min_i=0;
      comp_thr=0.5;
      comp_gain=2;
      gp_pt=0.2;
     };
     kwta {k_from=USE_K: k=2: pct=0.23: pat_q=0.5: diff_act_pct=1: act_pct=0.33: };
     gp_kwta {k_from=USE_PCT: k=12: pct=0.23: pat_q=0.5: diff_act_pct=0: act_pct=0.1: };
     lay_gp_inhib {on=0: gp_g=0.5: diff_act_pct=0: act_pct_mult=0.3333333: pct_fm_frac=1: act_denom=3: };
     unit_gp_inhib {on=0: gp_g=0.5: diff_act_pct=0: act_pct_mult=0.3333333: pct_fm_frac=1: act_denom=3: };
     tie_brk {on=0: k_thr=1: diff_thr=0.2: thr_gain=0.005: loser_gain=1: };
     adapt_i {type=NONE: tol=0.05: p_dt=0: mx_d=0.2: l=0.2: a_dt=0.005: };
     clamp {hard=1: gain=0.5: max_plus=0: plus=0.01: min_clamp=0.5: };
     decay {event=0: phase=0: phase2=0: };
     ct_inhib_mod {
      manual_sravg=0;
      sravg_delay=0;
      use_sin=0;
      burst_i=0.02;
      trough_i=0.02;
      use_fin=0;
      inhib_i=0;
     };
     abs_net_adapt {
      on=0;
      trg_net=0.5;
      tol=0.1;
      abs_lrate=0.1;
     };
    };
    LeabraBiasSpec @["BiasSpec"] {
     name="BiasSpec";
     desc=;
     unique{ rnd;wt_limits;wt_scale;wt_scale_init;     };
     children {
      name=;
      el_typ=LeabraBiasSpec;
      el_def=0;
     };
     rnd {type=UNIFORM: mean=0: var=0: par=1: name="": };
     wt_limits {type=NONE: min=-1: max=5: sym=0: };
     learn_rule=LEABRA_CHL;
     inhib=0;
     wt_scale {abs=1: rel=0.02: sem_extra=2: };
     diff_scale_p=0;
     wt_scale_p {abs=1: rel=1: sem_extra=2: };
     wt_scale_init {init=0: abs=1: rel=1: };
     learn=1;
     lrate=0.01;
     cur_lrate=0.01;
     lrs_value=EPOCH;
     lrate_sched {
      name=;
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
     };
     ignore_unlearnable=1;
     wt_sig {gain=6: off=1.25: dwt_norm=0: };
     stable_mix {stable_pct=0: learn_pct=1: };
     lmix {hebb=0.01: err=0.99: err_sb=1: };
     xcal {thr_l_mix=0.01: thr_m_mix=0.99: s_mix=0.9: m_mix=0.1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
     savg_cor {cor=1: thresh=0.01: };
     rel_net_adapt {
      on=0;
      trg_fm_input=0.85;
      trg_fm_output=0.15;
      trg_lateral=0;
      trg_sum=1;
      tol_lg=0.05;
      tol_sm=0.2;
      rel_lrate=0.1;
     };
     dwt_thresh=0.1;
    };
    BaseSpec_Group @.gp["LeabraPrjns"] {
     name="LeabraPrjns";
     el_typ=BaseSpec;
     el_def=0;
     FullPrjnSpec @["FullPrjn"] {
      name="FullPrjn";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=FullPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=0;
      add_rnd_wts=0;
      add_rnd_wts_scale=1;
     };
     OneToOnePrjnSpec @["SelfPrjn"] {
      name="SelfPrjn";
      desc=;
      unique{ self_con;      };
      children {
       name=;
       el_typ=OneToOnePrjnSpec;
       el_def=0;
      };
      self_con=1;
      init_wts=0;
      add_rnd_wts=0;
      add_rnd_wts_scale=1;
      n_conns=-1;
      recv_start=0;
      send_start=0;
     };
     TesselPrjnSpec @["LocationPrjns"] {
      name="LocationPrjns";
      desc=;
      unique{       };
      children {
       name=;
       el_typ=TesselPrjnSpec;
       el_def=0;
      };
      self_con=0;
      init_wts=1;
      add_rnd_wts=0;
      add_rnd_wts_scale=1;
      recv_off {x=0: y=0: };
      recv_n {x=-1: y=-1: };
      recv_skip {x=1: y=1: };
      recv_group {x=1: y=1: };
      wrap=1;
      send_scale {x=1: y=1: };
      send_off {x=0: y=0: };
      send_offs {
       name=;
       el_typ=TessEl;
       el_def=0;
       TessEl @[0] {
	send_off {x=0: y=0: };
	wt_val=0.7;
       };
       TessEl @[1] {
	send_off {x=1: y=0: };
	wt_val=0.3;
       };
       TessEl @[2] {
	send_off {x=2: y=0: };
	wt_val=0.3;
       };
      };
      last_make_cmd=;
      last_weights_cmd=;
     };
    };
   };
   layers {
    name=;
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    pos2d {x=0: y=0: };
    max_disp_size {x=11: y=2: z=3: };
    max_disp_size2d {x=3: y=16: };
    LeabraLayer @["Location"] {
     name="Location";
     desc=;
     flags=0;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     disp_scale=1;
     un_geom {x=3: y=1: n_not_xy=0: n=3: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=3: y=1: n_not_xy=0: n=3: };
     disp_geom {x=3: y=1: n_not_xy=0: n=3: };
     scaled_disp_geom {x=3: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
      LeabraUnit @["A"] {
       name="A";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"]$$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.6;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["B"] {
       name="B";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.6;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["C"] {
       name="C";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"]$;
	 other_idx=0;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=.projects["a_not_b"].networks["ABNet"].specs["UnitSpec"]$$: };
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name=;
	  [3 1] "A";"B";"C";     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=.projects["a_not_b"].networks["ABNet"].specs["LayerSpec"]$$: };
    };
    LeabraLayer @["Hidden"] {
     name="Hidden";
     desc=;
     flags=0;
     layer_type=HIDDEN;
     pos {x=4: y=1: z=1: };
     pos2d {x=0: y=3: };
     disp_scale=1;
     un_geom {x=3: y=1: n_not_xy=0: n=3: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=3: y=1: n_not_xy=0: n=3: };
     disp_geom {x=3: y=1: n_not_xy=0: n=3: };
     scaled_disp_geom {x=3: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @["Fm_Location"] {
       name="Fm_Location";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Location"]$;
       spec {type=TesselPrjnSpec: spec=.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["LocationPrjns"]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects["a_not_b"].networks["ABNet"].specs["ForwardCons"]$$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
      LeabraPrjn @["Fm_Hidden"] {
       name="Fm_Hidden";
       off=0;
       disp=1;
       from_type=SELF;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"]$;
       spec {type=OneToOnePrjnSpec: spec=.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["SelfPrjn"]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["RecurrentCons"]$: };
       recv_idx=1;
       send_idx=2;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
      LeabraPrjn @["Fm_Cover"] {
       name="Fm_Cover";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Cover"]$;
       spec {type=FullPrjnSpec: spec=.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["FullPrjn"]$$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=.projects["a_not_b"].networks["ABNet"].specs["ForwardCons"].children["FmCoverToy"]$$: };
       recv_idx=2;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
      LeabraPrjn @["Fm_Toy"] {
       name="Fm_Toy";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Toy"]$;
       spec {type=FullPrjnSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["FullPrjn"]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["ForwardCons"].children["FmCoverToy"]$: };
       recv_idx=3;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"];
	    Projection_Group @. = [1] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"];
	    Projection_Group @. = [2] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
      LeabraUnit @["A"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="A";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {0; 1; 2; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"]$$;
	 other_idx=2;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0.25; };
	};
	LeabraRecvCons @[2] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Cover"]$$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.3; 0.3; };
	};
	LeabraRecvCons @[3] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Toy"]$$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.3; 0.3; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"]$$;
	 other_idx=0;
	};
	LeabraSendCons @[1] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"]$$;
	 other_idx=0;
	};
	LeabraSendCons @[2] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=8;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.4151643;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["B"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="B";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {1; 2; 0; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"]$;
	 other_idx=2;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0.25; };
	};
	LeabraRecvCons @[2] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Cover"]$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.3; 0.3; };
	};
	LeabraRecvCons @[3] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Toy"]$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.3; 0.3; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	LeabraSendCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	LeabraSendCons @[2] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=8;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.2882256;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["C"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="C";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Location"]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {2; 0; 1; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"]$;
	 other_idx=2;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0.25; };
	};
	LeabraRecvCons @[2] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Cover"]$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.3; 0.3; };
	};
	LeabraRecvCons @[3] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Toy"]$;
	 other_idx=0;
	};
	{ con_alloc = 2;
	 units = {0; 1; };
	 wt = {0.3; 0.3; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	LeabraSendCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	LeabraSendCons @[2] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Hidden"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=8;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["UnitSpec"]$: };
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name=;
	  [3 1] "A";"B";"C";     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["LayerSpec"]$: };
    };
    LeabraLayer @["Gaze_Expectation"] {
     name="Gaze_Expectation";
     desc=;
     flags=0;
     layer_type=OUTPUT;
     pos {x=0: y=1: z=2: };
     pos2d {x=0: y=6: };
     disp_scale=1;
     un_geom {x=3: y=1: n_not_xy=0: n=3: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=3: y=1: n_not_xy=0: n=3: };
     disp_geom {x=3: y=1: n_not_xy=0: n=3: };
     scaled_disp_geom {x=3: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @["Fm_Hidden"] {
       name="Fm_Hidden";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"]$;
       spec {type=TesselPrjnSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["LocationPrjns"]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["ForwardCons"]$: };
       recv_idx=0;
       send_idx=1;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
      LeabraPrjn @["Fm_Gaze_Expectation"] {
       name="Fm_Gaze_Expectation";
       off=0;
       disp=1;
       from_type=SELF;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"]$;
       spec {type=OneToOnePrjnSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["SelfPrjn"]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["RecurrentCons"]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
      LeabraUnit @["A"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="A";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"]$;
	 other_idx=1;
	};
	{ con_alloc = 3;
	 units = {0; 1; 2; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"]$$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.5593393;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["B"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="B";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"]$;
	 other_idx=1;
	};
	{ con_alloc = 3;
	 units = {1; 2; 0; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.1767472;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["C"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="C";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Hidden"]$;
	 other_idx=1;
	};
	{ con_alloc = 3;
	 units = {2; 0; 1; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Gaze_Expectation"].projections["Fm_Gaze_Expectation"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["UnitSpec"]$: };
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name=;
	  [3 1] "A";"B";"C";     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["LayerSpec"]$: };
    };
    LeabraLayer @["Reach"] {
     name="Reach";
     desc=;
     flags=0;
     layer_type=OUTPUT;
     pos {x=8: y=1: z=2: };
     pos2d {x=0: y=9: };
     disp_scale=1;
     un_geom {x=3: y=1: n_not_xy=0: n=3: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=3: y=1: n_not_xy=0: n=3: };
     disp_geom {x=3: y=1: n_not_xy=0: n=3: };
     scaled_disp_geom {x=3: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @["Fm_Hidden"] {
       name="Fm_Hidden";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"]$;
       spec {type=TesselPrjnSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["LocationPrjns"]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["ForwardCons"]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
      LeabraPrjn @["Fm_Reach"] {
       name="Fm_Reach";
       off=0;
       disp=1;
       from_type=SELF;
       from=$.projects["a_not_b"].networks["ABNet"].layers["Reach"]$;
       spec {type=OneToOnePrjnSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs.gp["LeabraPrjns"]["SelfPrjn"]$: };
       con_type=LeabraCon;
       recvcons_type=LeabraRecvCons;
       sendcons_type=LeabraSendCons;
       con_spec {type=LeabraConSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["RecurrentCons"]$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       direction=DIR_UNKNOWN;
       trg_netin_rel=-1;
      };
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
      LeabraUnit @["A"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="A";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {0; 1; 2; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"]$$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {0; };
	 wt = {0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.5826032;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["B"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="B";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {1; 2; 0; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {1; };
	 wt = {0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.01289319;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["C"] {
       UserDataItem_List @*(.user_data_) {
	name=;
	el_typ=UserDataItem;
	el_def=0;
       };
       name="C";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=LeabraRecvCons;
	el_def=0;
	LeabraRecvCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Hidden"]$;
	 other_idx=0;
	};
	{ con_alloc = 3;
	 units = {2; 0; 1; };
	 wt = {0.7; 0.3; 0.3; };
	};
	LeabraRecvCons @[1] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"]$;
	 other_idx=0;
	};
	{ con_alloc = 1;
	 units = {2; };
	 wt = {0.25; };
	};
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Reach"].projections["Fm_Reach"]$;
	 other_idx=1;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {2; };
	wt = {0; };
       };
       n_recv_cons=4;
       pos {x=2: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["UnitSpec"]$: };
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name=;
	  [3 1] "A";"B";"C";     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["LayerSpec"]$: };
    };
    LeabraLayer @["Cover"] {
     name="Cover";
     desc=;
     flags=0;
     layer_type=INPUT;
     pos {x=5: y=0: z=0: };
     pos2d {x=0: y=12: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=2: y=1: n_not_xy=0: n=2: };
     disp_geom {x=2: y=1: n_not_xy=0: n=2: };
     scaled_disp_geom {x=2: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Cover"];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
      LeabraUnit @["C1"] {
       name="C1";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Cover"]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0.6;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["C2"] {
       name="C2";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Cover"]$;
	 other_idx=2;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["UnitSpec"]$: };
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name=;
	  [2 1] "C1";"C2";     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["LayerSpec"]$: };
    };
    LeabraLayer @["Toy"] {
     name="Toy";
     desc=;
     flags=0;
     layer_type=INPUT;
     pos {x=9: y=0: z=0: };
     pos2d {x=0: y=15: };
     disp_scale=1;
     un_geom {x=2: y=1: n_not_xy=0: n=2: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=0: y=0: };
     flat_geom {x=2: y=1: n_not_xy=0: n=2: };
     disp_geom {x=2: y=1: n_not_xy=0: n=2: };
     scaled_disp_geom {x=2: y=1: n_not_xy=0: n=1: };
     projections {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name=;
      el_typ=LeabraPrjn;
      el_def=0;
	    Projection_Group @. = [0] = LeabraPrjn .projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Toy"];
     };
     units {
      name=;
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
      LeabraUnit @["T1"] {
       name="T1";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Toy"]$;
	 other_idx=3;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {0; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=0: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
      LeabraUnit @["T2"] {
       name="T2";
       flags=0;
       ext_flag=0;
       targ=0;
       ext=0;
       act=0;
       net=0;
       recv {
	name=;
	el_typ=RecvCons;
	el_def=0;
       };
       send {
	name=;
	el_typ=LeabraSendCons;
	el_def=0;
	LeabraSendCons @[0] {
	 con_type=LeabraCon;
	 prjn=$.projects["a_not_b"].networks["ABNet"].layers["Hidden"].projections["Fm_Toy"]$;
	 other_idx=3;
	};
       };
       bias {
	con_type=LeabraCon;
	prjn=NULL;
	other_idx=-1;
       };
       { con_alloc = 1;
	units = {1; };
	wt = {0; };
       };
       n_recv_cons=0;
       pos {x=1: y=0: z=0: };
       act_eq=0;
       act_nd=0;
       act_lrn=0;
       act_avg=0.15;
       act_m=0;
       act_p=0;
       act_dif=0;
       act_m2=0;
       act_mid=0;
       act_dif2=0;
       avg_ss=0.15;
       avg_s=0.15;
       avg_m=0.15;
       avg_l=0.15;
       act_ctxt=0;
       net_ctxt=0;
       p_act_p=0;
       davg=0;
       vcb {hyst=0: acc=0: hyst_on=0: acc_on=0: g_h=0: g_a=0: };
       dav=0;
       spk_amp=2;
      };
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["UnitSpec"]$: };
     dmem_dist=DMEM_DIST_DEFAULT;
     dist {
      fm_input=-1;
      fm_output=-1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     unit_names {
      name=;
	  [2 1] "T1";"T2";     };
     brain_area=;
     voxel_fill_pct=1;
     spec {type=LeabraLayerSpec: spec=$.projects["a_not_b"].networks["ABNet"].specs["LayerSpec"]$: };
    };
   };
   view_objs {
    name=;
    el_typ=NetViewObj;
    el_def=0;
   };
   flags=SAVE_UNITS;
   auto_build=NO_BUILD;
   brain_atlas_name=;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   sse_unit_avg=0;
   sse_sqrt=0;
   cnt_err_tol=0;
   compute_prerr=0;
   threads {
    run_time {name="": s_used=0: n_used=0: };
    sync_time {name="": s_used=0: n_used=0: };
    total_time {name="": s_used=0: n_used=0: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=0;
    interleave=1;
    ignore_lay_sync=0;
   };
   dmem_sync_level=DMEM_SYNC_NETWORK;
   dmem_nprocs=1;
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   n_units=16;
   n_cons=48;
   max_prjns=4;
   max_disp_size {x=11: y=2: z=3: };
   max_disp_size2d {x=3: y=16: };
   learn_rule=LEABRA_CHL;
   ti_mode=0;
   phase_order=PLUS_ONLY;
   no_plus_test=1;
   sequence_init=INIT_STATE;
   phase_max=1;
   time_inc=1;
   cycle_max=10;
   mid_minus_cycle=-1;
   min_cycles=15;
   min_cycles_phase2=35;
   dwt_norm_enabled=0;
   ct_time {
    use=0;
    minus=50;
    plus=20;
    inhib=1;
    n_avg_only_epcs=1;
    total_cycles=71;
    inhib_start=70;
   };
   ct_sravg {
    manual=0;
    start=30;
    end=1;
    interval=1;
    plus_s_st=19;
    plus_s_only=0;
    force_con=0;
   };
   ct_sin_i {
    start=30;
    duration=20;
    n_pi=2;
    burst_i=0.02;
    trough_i=0.02;
   };
   ct_fin_i {
    start=20;
    end=25;
    inhib_i=0;
   };
   ct_lrn_trig {
    plus_lrn_cyc=-1;
    davg_dt=0.1;
    davg_s_dt=0.05;
    davg_m_dt=0.03;
    davg_l_dt=0.0005;
    thr_min=0;
    thr_max=0.5;
    loc_max_cyc=8;
    loc_max_dec=0.01;
    lrn_delay=40;
    lrn_refract=100;
    davg_l_init=0;
    davg_max_init=0.001;
    davg_time=10;
    davg_s_time=20;
    davg_m_time=33.33334;
    davg_l_time=2000;
    lrn_delay_inc=0.025;
    lrn_refract_inc=0.01;
   };
   lrn_trig {
    davg=0;
    davg_s=0;
    davg_m=0;
    davg_smd=0;
    davg_l=0;
    davg_max=0.001;
    cyc_fm_inc=0;
    cyc_fm_dec=0;
    loc_max=0;
    lrn_max=0;
    lrn_trig=0;
    lrn=0;
   };
   net_misc {
    cyc_syn_dep=0;
    syn_dep_int=20;
   };
   maxda_stopcrit=-1;
   trg_max_act_stopcrit=1;
   norew_val=0.5;
   off_errs=1;
   on_errs=1;
   cos_err_lrn_thr=-1;
  };
 };
};

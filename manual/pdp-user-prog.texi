@c uncomment the following two lines for 'update every node' command
@c @node  prog
@c @chapter Programming in PDP++

This chapter contains some useful information for those who want to add
new functionality to the PDP++ software by compiling their own
executable.  By creating new subclasses of existing classes, and using
these new classes in your simulations, it should be possible to make
PDP++ do exactly what you want it to.

Before taking this step, you should be reasonably comfortable with the
CSS language and using it to access objects in the simulator.  Further,
you will need to know (or learn about) C++ in a bit more detail than is
covered in the CSS section of this manual.  There are a number of good
books on this subject available in most bookstores.

This chapter describes how to set up the makefiles in your own directory
where you will compile your executable.  It then describes various
coding conventions and extensions to the basic C++ language that we have
added to facilitate programming in PDP++.  We have established a standard
way of dealing with creating, copying, and deleting objects.  In
addition, each object has special functions that allow groups to manage
them.  All of these "coding conventions" are described in this chapter.

We have developed a run-time-type-information (RTTI) system called
TypeAccess, which provides type information about most classes at
run-time.  This can be used to determine what kind of unit a Unit*
object @emph{really} is, for example (i.e., is it a BpUnit or a
MyWackyBpUnit?).  

The TypeAccess system requires a more complicated than normal set of
makefiles.  Fortunately, it is reasonably straightforward to use the
makefiles we have developed, so you won't have to deal with much of this
complexity. 

Most of the graphical interface (i.e., edit dialogs, menus, etc) is
generated automatically from the information provided by TypeAccess. The
same is true for the way you can transparently access hard-coded types
and objects through CSS.  Thus, you don't need to do anything special to
be able to use your newly defined classes exactly in the way that you
use the ones that come with the software.

There are some special keywords that you can put in the comments for
your classes and class members and methods called "comment directives".
These comment directives allow you to control various aspects of how the
GUI and CSS treat your objects.  These comment directives are described
in this chapter.

@menu
* prog-make::                   Makefiles and Directory Organization
* prog-typea::                  The TypeAccess System
* prog-comdir::                 Standard TypeAccess Comment Directives
* prog-coding::                 Coding Conventions and Standards
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-make, prog-typea, prog, prog
@section Makefiles and Directory Organization

The PDP++ code should be installed in @file{/usr/local/pdp++}, or some
such similar place.  This path will be referred to from here on out as
PDPDIR.  This directory contains a set of sub-directories,
like @file{demo} and @file{manual}, etc. which contain different pieces
of the distribution.  See @ref{inst-prog} for instructions on how to
install and compile the source distribution of the PDP++ software.  In
order compile your own additions to the software, you must install and
compile the source code distribution!

The critical directories from a programmer's perspective are the
@file{src}, which contains the source code, @file{config}, which
contains the Makefile configuration stuff, @file{include} which has
links to the header files, and @file{lib} which has links to the various
libraries.

Each sub-directory within the @file{src} directory contains code
relevant to some sub-component of the PDP++ software.  These directories
are as follows:
@table @file
@item ta_string
The basic String class used throughout the software.  It is a
slightly modified version of the GNU String class that is distributed
with the libg++ distribution (version 2.6.2).
@item iv_misc
Contains a number of extra pieces of code that supplement the
InterViews GUI toolkit.
@item ta
Contains the TypeAccess system, which gives classes the ability to
know all about themselves and other classes at run time.  The use of
this software is what makes the largely automatic interface used in
PDP++ possible.  It is described further in @ref{prog-typea}.  This
directory also contains a lot of basic objects, like @b{Array}
(@ref{obj-array}), @b{List} and @b{Group} (@ref{obj-group}) objects.
@item css
Contains the code for the CSS script language (@pxref{css}).
@item iv_graphic
Contains a set of objects which implement a graphical object
manipulation environment that is used in the network viewer
(@pxref{net-view}) and the graph log (@pxref{log-views-graph}).
@item ta_misc
Contains a smorgasbord of various objects that might have
general applicability, and are not specifically PDP objects.
@item pdp
Where all of the specific pdp code is.
@item bp
Implements bp and rbp.
@item cs
Implements cs.
@item so
Implements so.
@item bpso
Implements the combined bp and so executable (just links the libraries).
@item leabra
Implements the leabra algorithm.
@end table

Each directory has a set of include files which can be accessed as
<xxx/yyy.h>, where xxx is one of the directory names given above.  In
addition, each directory has its own library, which is just
@file{libxxx.a}, where xxx is the name of the directory (without any
underbars).  The bp, cs and so directories have a library name of
libpdp_xx.a, to indicate that they are part of the pdp software.

All of the compilation results (e.g. object files) go in a subdirectory
named after the CPU type being used.  The user must set the CPU
environmental variable appropriately, as per the definitions used in the
InterViews system.  The ones that everything has been tested and
compiled on are listed in the installation guide (@pxref{inst}), and the
INSTALL file.

Other possibilities are listed in @ref{inst-prog}.  This should be the
same as when the system was first installed.

The include files and library are made in two stages.  The first stage
involves compiling the object files into the CPU subdirectory.  Then, if
everything goes ok, the library is made, which is then copied into a
further subdirectory of the CPU subdirectory called @file{lib_include}.
Also, all of the header files are compared with those already in the
@file{lib_include} subdirectory (if any), and those ones that are
different are copied over.  It is these header files in
@file{lib_include} that the @file{PDPDIR/include} directory makes links
to, and thus these are the ones that are included by other programs.
This setup allows one to test out a set of code by making an executable
in a given directory and getting things working before installing the
new header files and library for the rest of the system to use.

In order to add functionality to the software, one needs to create a new
directory, and then include various files from the above directories,
and link in their respective libraries.  This directory can be located
in the same master directory as the main distribution, or it can be
located in your own home directory somewhere.  This latter option is the
preferred one.

We have developed a shell file that does all of the things necessary to
create your own directory.  The first step is to make a master directory
off of your home directory, typically called @file{pdp++}.

Then, run the @file{PDPDIR/bin/mknewpdp} command from this new
@file{home/pdp++} directory with an argument which is the name of the
directory/executable that you want to make.  This will give you
step-by-step instructions.  In the end, you will end up with a directory
that contains some sample code in the form of a .h and .cc file with the
same name as the directory.

The script will have installed a @file{Makefile} in your directory which
is the same as the one's found in the main PDP++ directories.  These
makefiles are constructed by concatenating together a bunch of pieces
of makefiles, some of which contain standard make actions, and others
which contain specific defaults for particular machines.  All of the
pieces are found in the @file{PDPDIR/config} directory.

The makefiles named @file{Makefile.CPU.[CC|g++]} are the
machine-specific files that you should edit to make sure they have all
the right settings for your system.  This should have been done already
during the installation of the PDP++ source code distribution, see
@ref{inst-prog} for details.  

To these pieces is added the specific list of files that need to be made
in your directory. This is specified in the @file{Makefile.in} file.
This is the only makefile you should edit. It can be used to override
any of the settings in the standard makefiles, simply by redefining
definitions or actions.  If you add files to your directory, follow the
example for the one already in your default @file{Makefile.in} that was
installed with the @file{mknewpdp} command.

Note that there are a couple of compiler-specific "extra" files in the
directory.  These have the name of the directory plus a @file{_vt.cc} or
@file{_it.cc} suffix.  The @file{_vt} file is for virtual table
instantiation, which is controlled in cfront with the +e0/+e1 arguments.
It simply includes most of the header files in the software.  We have
found that by compiling everything except the @file{_vt} file with +e0
that the executables are much smaller.  This is even true in cfront
versions where they had "fixed" this problem.  You can try doing the
other way by leaving out the +e args and not using the @file{_vt} file
(see the definitions in @file{PDPDIR/config/Makefile.defs} for how to do
this: change your @file{Makefile.CPU} file and recompile the entire
distribution first..).

The @file{_ti.cc} is the template instantiation file needed by gnu g++
version 2.6.3 (reportedly, it won't be needed in 2.7).  It contains
explicit instantiations of all of the templates used in each library.
For user directories, this probably isn't needed, but its there if you
do declare any templates and encounter link problems with g++.  Also,
the @file{Makefile.CPU.g++} show how this file gets included in the
making of a given project.

@b{New for 2.0:} All of the makefile actions, as shown below, are now
available using a consistent syntax structure: all lower case, with
underbars separating different words.  This makes it much easier to
remember what command to type.  The old eclectic combinations of upper
and lower case words, etc are still available if you already know them.

The commonly-used actions that are defined in the makefile are as
follows:
@cindex Makefile, Actions
@cindex Actions, Makefile
@table @samp
@item make bin, make opt_bin, make dbg_bin
Makes the binary from the files in this directory. Bin makes the default
form specified in the make file, while opt and dbg make optimized and
debug versions, respectively.
@item make re_bin, make opt_re_bin, make dbg_re_bin
Same as above, except it first removes the executable before making.
This is useful if a library has changed but no header files from that
library were changed.
@item make lib, make opt_lib, make dbg_lib
Like the above, except it makes a library containing the relevant .o
files.
@item make new_makefile
This makes a new version of the @file{Makefile} file in the current
directory.  This concatenates all of the different parts that together
make up a single @file{Makefile}.  However, it does not make a
@code{CPU} directory, which is necessary to actually compile (see
@code{cpu_dir} next).
@item make cpu_dir, make local_cpu_dir
This makes and configures a directory with the same name as the
@code{CPU} environmental variable (reflecting the CPU type of the
machine) suitable for compiling the object files into.  If
@code{local_cpu_dir} is made first, then this directory is actually a
symbolic link to a directory created on a disk local to the current
machine, so that compilation will be faster than if the directory where
the source is located is a networked (slow) directory (i.e., NFS).  The
@code{cpu_dir} action copies the current @file{Makefile} into the
directory, and configures the directory for compiling.  Note that these
actions remove any existing dependency information, so that a
@code{depend} action should be made following either of them.
@item make depend
This automatically adds dependency information for the files in this
directory onto the @file{CPU/Makefile} file.  This allows the make
command to know when to compile these files after something they depend
on has been touched (edited).
@item make makefiles, make make_depend, make new_make_depend
These actions simply combine some of the above steps together into one
action.  @code{makefiles} does a @code{new_makefile} and then a
@code{cpu_dir}, @code{make_depend} does a @code{cpu_dir} and then a
@code{depend}, and @code{new_make_depend} does all three of the necessary
steps: @code{new_makefiles}, @code{cpu_dir}, and @code{depend}.  The only
reason you should not use the latter all the time is if your @code{make}
program has trouble using a new @file{Makefile} (i.e., as created by the
@code{make new_makefiles} action) for calling the subsequent actions.  In
this case, you have to first do a @code{make new_makefiles} and then you
can do a @code{make make_depend}.
@item make force_ta
Forces a call to the TypeAccess scanning program @file{maketa}.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-typea, prog-comdir, prog-make, prog
@section The TypeAccess System

The TypeAccess system consists of a set of objects that can hold
type information about class objects.  This type information includes
the names and types of all the members and methods in a class, the
parents of the class, etc.  This information can be used by classes to
get information about themselves at run time.  In addition, the
TypeAccess system provides a set of type-aware base classes and macros
for defining derived versions of these that can be used to easily
incorporate run-time type information into any C++ system.

In addition to being type-aware, the base classes can use their own type
information to save and load themselves automatically to and from ASCII
format text files.  Further, there is an extensible graphical interface
based on InterViews which can automatically build editing dialogs for
filling in member values and calling member functions on arbitrary
objects.  Finally, the type information can be used to provide a
transparent script-level interface to the objects from the CSS script
language.  This provides the benefits of compiled C++ for fast
execution, and the ability to perform arbitrary interactive processing
in an interpreter using the C++ language supported by CSS.

Many features of the interface and script level interface, as well as
various options that affect the way objects are saved and loaded, can be
specified in comments that follow the declaration of classes, members,
and methods.  These @i{comment directives} constitute a secondary
programming language of sorts, and they greatly increase the flexibility
of the interface.  They are documented in @ref{prog-comdir}.

Thus, the PDP++ software gets much of its functionality from the
TypeAccess system.  It provides all of the basic interface and
file-level functionality so that the programmer only needs to worry
about defining classes that perform specific tasks.  These classes can
then be flexibly used and manipulated by the end user with the generic
TypeAccess based interface.

@menu
* prog-typea-files::            Scanning Type Information using @file{maketa}
* prog-typea-args::             Startup Arguments for @file{maketa}
* prog-typea-stru::             Structure of TypeAccess Type Data
* prog-typea-base::             The Type-Aware Base Class @b{taBase}
* prog-typea-dump::             The Dump-file Format for Saving/Loading
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-typea-files, prog-typea-args, prog-typea, prog-typea
@subsection Scanning Type Information using @file{maketa}

Type information for TypeAccess is scanned from the header files using a
program called @file{maketa}, which looks for @code{class} and
@code{typedef} definitions, and records what it finds.  It operates on
all the header files in a given directory at the same time, and it
produces three output files: @file{xxx_TA_type.h}, @file{xxx_TA_inst.h},
and @file{xxx_TA.cc}, where xxx is given by a "project name" argument.
The first file contains a list of @code{extern} declarations of
instances of the @b{TypeDef} type, which is the basic object that
records information about types.  Each type that was defined with a
@code{class} or @code{typedef}, or ones that are modifications of basic
types, such as reference or pointer types, are given their own
@b{TypeDef} object, which is named with the name of the type with a
leading @code{TA_} prefix. Thus, a class named @i{MyClass} would have
corresponding @b{TypeDef} object named @i{TA_MyClass}, which can be used
directly in programs to obtain type information about the @i{MyClass}
object. a Pointers have a @code{_ptr} suffix, and references have a
@code{_ref} suffix.  Template instances are represented by replacing the
angle brackets with underbars.  The @file{xxx_TA_type.h} file must be
included in any header files which reference their own type information.

The @file{xxx_TA_inst.h} file contains declarations of "instance"
objects, which are pointers to a token of each of the classes for which
type information is available.  These instances are named @code{TAI_}
with the rest the same as the corresponding @code{TA_} name.  The
@code{-instances} argument to @file{maketa} determines if instances are
made, and this can be overridden with the @code{#NO_INSTANCE} and
@code{#INSTANCE} comment directives (@pxref{prog-comdir}).  The
@b{TypeDef} object can use an instance object of one of the type-aware
base classes to make a new token of that object given only the name of
the type to be created.  This gives the system the power to create and
delete objects at will, which is necessary for the file saving and
loading system to work.

Finally, the @file{xxx_TA.cc} file contains the actual definitions of
all the type information.  It must be compiled and linked in with the
project, and its @code{ta_Init_xxx} function must be called at the start
of the execution of the program before any type information is used.

Note that while @file{maketa} does process complexities like
@code{template} and multiply inherited classes properly, it does not
deal with multiple versions of the same function which differ only in
argument type in the same way that C++ does.  Instead, the scanner just
keeps the last version of a given method defined on the class.  This
makes the type information compatible with the limitations of CSS
in this respect, since it does not know how to use argument types to
select the proper function to be called (@pxref{css-c++-diff}).  This
limitation greatly simplifies the way that functions are called by CSS.
It is recommended that you create methods which have some hint as to
what kinds of arguments they expect, in order to get around this
limitation.  The @b{taList} and @b{taGroup} classes, for example,
contain both overloaded and specific versions of the @code{Find}
function, so the C++ programmer can call @code{Find} with any of a
number of different argument types, while the CSS programmer can use
the @code{FindName} or @code{FindType} versions of the function.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-typea-args, prog-typea-stru, prog-typea-files, prog-typea
@subsection Startup Arguments for @file{maketa}

The type-scanning program @file{maketa} takes the following arguments:

@table @code
@item [-v<level>]
Verbosity level, 1-5, 1=results,2=more detail,3=trace,4=source,5=parse.
@item [-hx | -nohx]
Generate .hx, .ccx files instead of .h, .cc.  This is used in
conjunction with a makefile that compares the .hx with the .h version of
a file and only updates the .h if it actually differs from the .hx
version.  This prevents lots of needless recompiling when the
type-scanned information is not actually different when a header file
was touched.
@item [-css]
Generate CSS stub functions.  The stub functions take @b{cssEl*}
arguments, and call member functions on classes.  These must be present
to use CSS to call member functions on classes, or to call functions
from the edit dialog menus and buttons.
@item [-instances]
Generate instance tokens of types.  Instances are needed to make tokens
of class objects.
@item [-class_only | -struct_union]
Only scan for @code{class} types (else @code{struct} and @code{union}
too). The default is to only scan for @code{class} types because they
are always used in the definition of a class object.  @code{struct} and
@code{union} can be used to modify the type name in old-style C code,
which can throw off the scanner since these don't amount to class
definitions.
@item [-I<include>]...
Path to include files (one path per -I).
@item [-D<define>]...
Define a pre-processor macro.
@item [-cpp=<cpp command>]
Explicit path for c-pre-processor.  The default is to use
@file{/usr/lib/cpp}, which doesn't work very well on C++ code, but its
there.  It is recommended that you use cccp, which is the gnu
preprocessor that comes with gcc.
@item [-hash<size>]
Size of hash tables (default 2000), use -v1 to see actual sizes after
parsing all the types.
@item project
This is the stub project name (generates
project_TA[.cc|_type.h|_inst.h]).
@item files...
These are the header files to be processed.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-typea-stru, prog-typea-base, prog-typea-args, prog-typea
@subsection Structure of TypeAccess Type Data

The classes used in storing type information in the TypeAccess system
are all defined in the @file{ta/typea.h} header file.  Basically, there
are a set of @b{Space} objects, which all derive from a basic form of
the @code{List} object (defined in @file{ta/ta_list.h}, which represent
type spaces, member spaces, method spaces, etc.  These are just
containers of objects.  The spaces are: @b{TypeSpace}, @b{MemberSpace},
@b{MethodSpace}, @b{EnumSpace}, @b{TokenSpace}.  Note that they contain
functions for finding, printing, and generally manipulating the objects
they contain.

There are corresponding @b{TypeDef}, @b{MemberDef}, @b{MethodDef}, and
@b{EnumDef} objects which hold specific information about the
corresponding aspect of type information.  The @b{TypeDef} contains the
following fields:

@tindex TypeDef
@table @code
@item String name
@vindex name of TypeDef
Holds the name of the type.
@item String desc
@vindex desc of TypeDef
A description which is obtained from the user's comment
following the declaration of the type.
@item uint size
@vindex size of TypeDef
The size of the object in bytes.
@item int ptr
@vindex ptr of TypeDef
The number of pointers this type is from a basic non-pointer type.
@item bool ref
@vindex ref of TypeDef
True if this is a reference type.
@item bool internal
@vindex internal of TypeDef
True if this type information was automatically or internally
generated.  This typically refers to pointer and reference types which
were created when the scanner encountered their use in arguments or
members of other classes that were being scanned.
@item bool formal
@vindex formal of TypeDef
True for basic level objects like @code{TA_class} and
@code{TA_template} which are are formal parents (@code{par_formal}) of
types that users declare.  These provide a way of determining some basic
features of the type.  Formal type objects are declared and installed
automatically by the type scanning system.
@item bool pre_parsed
@vindex pre_parsed of TypeDef
True if this type was registered as previously parsed by the
type scanning system (i.e., it encountered an @samp{extern TypeDef
TA_xxx} for this type, where xxx is the name of the type).  These types
don't get included in the list of types for this directory.  This
makes it possible to do type scanning on a complex set of nested
libraries.
@item String_PArray inh_opts
@vindex inh_opts of TypeDef
These are the options (comment directives) that are inherited by this
type (i.e., those declared with a @code{##} instead of a @code{#}).
@item String_PArray opts
@vindex opts of TypeDef
These are all of the options (comment directives) for this type,
including inherited and non-inherited ones.
@item String_PArray lists
@vindex lists of TypeDef
A list of the @code{#LIST_xxx} values declared for this type.
@item TypeSpace parents
@vindex parents of TypeDef
A list of parents of this type.  There are multiple parents for
multiple-inheritance @code{class} types, and for @code{internal} types
which are the combination of basic types, such as @code{unsigned long},
etc.
@item int_PArray par_off
@vindex par_off of TypeDef
A list of offsets from the start of memory occupied by this
class where the parent object begins.  These are used for multiply
inherited class types.  They are in a one-to-one correspondence with the
@code{parents} entries.
@item TypeSpace par_formal
@vindex par_formal of TypeDef
A list of the formal parents of this type, including
@code{TA_class}, etc.
@item TypeSpace par_cache
@vindex par_cache of TypeDef
A special cache of frequently-queried type parents.  Currently
if a type derives from @b{taBase}, then @code{TA_taBase} shows up here
(because a lot of the TypeAccess code checks if something is derived
from the basic type-aware type @b{taBase}).
@item TypeSpace children
@vindex children of TypeDef
A list of all the types that are derived from this one.
@item void** instance
@vindex instance of TypeDef
A pointer to a pointer of an instance of this type, if it is
kept.  The @code{GetInstance} function should be used to get the actual
instance pointer.
@item TokenSpace tokens
@vindex tokens of TypeDef
A list of the actual instances or tokens of this type that have
been created by the user (the @code{TAI_xxx} instance object is not
registered here).  These are not kept if the type does not record tokens
(see the @code{#NO_TOKENS} comment directive, @ref{comdir-objs}).
@item taivType* iv
@vindex iv of TypeDef
A pointer to an object which defines how a token of this type
appears in a GUI edit dialog.  There is a "bidding" procedure which
assigns these objects, allowing for the user to add new specialized
representations which out-bid the standard ones.  This bidding takes
place when the gui stuff is initialized, and the results are stored
here.
@item taivEdit* ive
@vindex ive of TypeDef
This is like the @code{iv} pointer, except it is the object which is
used to generate the entire edit dialog for this object.  It also
is the result of a bidding procedure.
@item taBase_Group* defaults
@vindex defaults of TypeDef
These are pointers to different @b{TypeDefault} objects for this type.
Each @b{TypeDefault} object is for a different scope where these types
can be created (i.e., a different @b{Project} in the PDP++ software).
@item EnumSpace enum_vals
@vindex enum_vals of TypeDef
Contains the enum objects contained within a given @code{enum}
declaration.
@item TypeSpace sub_types
@vindex sub_types of TypeDef
These are the sub-types declared with a @code{typedef}, @code{enum}, or
as part of a template instantiation within a @code{class} object.
@item MemberSpace members
@vindex members of TypeDef
These are the members of a @code{class} object.
@item MethodSpace methods
@vindex methods of TypeDef
These are the methods of a @code{class} object.
@item TypeSpace templ_pars
@vindex templ_pars of TypeDef
These are the template parameters for template objects.  In the
@code{template} itself, they are the formal parameters (i.e., @code{T}),
but in the template instance they point to the actual types with which
the template was instantiated.
@end table

The most important functions on the @b{TypeDef} object are as follows:

@tindex TypeDef
@table @code
@item bool HasOption(const char* op)
@findex HasOption on TypeDef
Checks to see if the given option (comment directive) (don't
include the @code{#}) is present on this type.
@item String OptionAfter(const char* op)
@findex OptionAfter on TypeDef
Returns the portion of the option (comment directive) after the
given part.  This is used for things like @code{#MENU_ON_xxx} to obtain
the xxx part.  If option is not present, an empty string is returned.
@item InheritsFrom(TypeDef* tp)
@findex InheritsFrom on TypeDef
Checks if this type inherits from the given one (versions that take
a string and a reference to a @b{TypeDef} are also defined).
Inheritance is defined only for classes, not for a pointer to a given
class, for example.  Thus, both the argument and the type this is called
on must be non-pointer, non-reference types.
@item DerivesFrom(TypeDef* tp)
@findex DerivesFrom on TypeDef
Simply checks if the given type appears anywhere in the list of
parents for this type.  Thus, a pointer to a class derives from that
class, but it does not inherit from it.
@item String GetValStr(void* base, void* par=NULL, MemberDef* memb_def=NULL)
@findex GetValStr on TypeDef
Uses the type-scanned information to obtain a string representation
of the value of an instance of this type.  @code{base} is a pointer to
the start of a token of this type, and @code{par} and @code{member_def}
can be passed if it is known that this token is in a parent class at a
particular member def.  This and the following function are used widely,
including for saving and loading of objects, etc.
@item SetValStr(const char* val, void* base, void* par=NULL, MemberDef* memb_def=NULL)
@findex SetValStr on TypeDef
Takes a string representation of a type instance, and sets the
value of the token accordingly (it is the inverse of @code{GetValStr}). 
@item CopyFromSameType(void* trg_base, void* src_base, MemberDef* memb_def=NULL)
@findex CopyFromSameType on TypeDef
Uses the type-scanned information to copy from one type instance to
the next.  Any class objects that are members are copied using that
object's copy operator if one is defined (this is only known for
derivatives of the @b{taBase} base class).
@item Dump_Save(ostream& strm, void* base, void* par=NULL, int indent=0)
@findex Dump_Save on TypeDef
This will save the given type object to a file.  Files are saved in an
ASCII format, and are capable of saving pointers to other objects when
these objects derive from the @b{taBase} object.  Special code is
present for dealing with groups of objects stored in the @b{taList} or
@b{taGroup} classes.  See @ref{prog-typea-dump} for more details.
@item Dump_Load(istream& strm, void* base, void* par=NULL)
@findex Dump_Load on TypeDef
This will load a file saved by the @code{Dump_Save} command.
@end table

The other @b{Def} objects are fairly straightforward.  Each includes a
@code{name} and @code{desc} field, and a list of @code{opts} (comment
directives) and @code{lists}.  Also, each contains an @code{iv} field
which represents the item in the GUI edit dialog, and is the result of a
bidding process (see the @code{iv} field in the @b{TypeDef} object
above).  They all have the @code{HasOption} and @code{OptionAfter}
functions plus a number of other useful functions (see the
@file{ta/typea.h} for details).

@b{MemberDef} objects contain the following additional fields. Note that
derived classes contain links (@emph{not copies}) of the members and
methods they inherit from their parent, except when the class has
multiple parents, in which case copies are made for the derived class
because the offset information will no longer be the same for the
derived class.

@tindex MemberDef
@table @code
@item TypeDef* type
@vindex type of MemberDef
The type of the member.
@item ta_memb_ptr off
@vindex off of MemberDef
The address or offset of this member relative to the start of
the memory allocated for the class in which this member was declared.
@item int base_off
@vindex base_off of MemberDef
The offset to add to the base address (address of the start of
the class object) to obtain the start of the class this member was
declared in.  This is for members of parents of multiply-inherited
derived classes.
@item bool is_static
@vindex is_static of MemberDef
True if the member was declared @code{static}.  Thus, it can be
accessed without a @code{this} pointer.  The @code{addr} field contains
its absolute address.
@item void* addr
@vindex addr of MemberDef
The absolute address (not relative to the class object) of a
static member.
@item bool fun_ptr
@vindex fun_ptr of MemberDef
True if the member is actually a pointer to a function.
@end table

The @b{MethodDef} object contains the following additional variables:

@tindex MethodDef
@table @code
@item TypeDef* type
@vindex type of MethodDef
The type of the method.
@item bool is_static
@vindex is_static of MethodDef
True if the method was declared @code{static}.
@item ta_void_fun addr
@vindex addr of MethodDef
The address of a @code{static} method.  Non-static methods do
not have their addresses recorded.  Methods are called via the
@code{stubp} function, if the @code{-css} option was used during
scanning.
@item int fun_overld
@vindex fun_overld of MethodDef
The number of times this function was overloaded (i.e., a
function of the same name was declared in the class or its parents).
TypeAccess does not perform name mangling on functions, so only one
instance of a given method is recorded.  It is the last one that the
scanner encounters that is kept.
@item int fun_argc
@vindex fun_argc of MethodDef
The number of arguments for this function.
@item int fun_argd
@vindex fun_argd of MethodDef
The index where the arguments start having default values.
Thus, the function can be called with a variable number of arguments
from @code{fun_argd} to @code{fun_argc}.
@item TypeSpace arg_types
@vindex arg_types of MethodDef
These are the types of the arguments.
@item String_PArray arg_names
@vindex arg_names of MethodDef
These are the names of the arguements (in one-to-one correspondence with
the types).
@item css_fun_stub_ptr stubp
@vindex stubp of MethodDef
A pointer to a "stub" function which calls this method using
@b{cssEl} objects as arguments.  This function is defined in the
@file{xxx_TA.cc} file if the @code{-css} argument is given to
@file{maketa}.  The @b{cssEl} objects have conversion functions for most
types of arguments, so that the function is called by casting the
arguments into the types expected by the function.  Pointers to class
objects are handled by @code{cssTA} objects which have a pointer and a
corresponding @code{TypeDef} pointer, so they know what kind of object
they point to, making conversion type-safe.  These stubs return a cssEl
object.  They also take a @code{void*} for the @code{this} object.
These stubs are used both by CSS and to call methods from the edit
dialogs from menus and buttons.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-typea-base, prog-typea-dump, prog-typea-stru, prog-typea
@subsection The Type-Aware Base Class @b{taBase}
@tindex taBase
@cindex Type-Aware Base Class
@cindex Base Class, Type-Aware

There is a basic class type called @b{taBase} that uses the TypeAccess
type information to perform a number of special functions automatically.
This object is aware of its own type information, and can thus save and
load itself, etc.  Special code has been written in both the TypeAccess
system and in CSS that takes advantage of the interface provided by the
@b{taBase} type.  Thus, it is recommended that user's derive all of
their types from this base type, and use special macros to provide
derived types with the hooks necessary to get their own type information
and use it effectively.  The type @b{TAPtr} is a @code{typedef} for a
pointer to a @b{taBase} object.  The definition of a @b{taBase} object
and the macros that are used with it are all in @file{ta/ta_base.h}.

All @b{taBase} objects have only one member, which is a reference
counter.  This provides a mechanism for determining when it is safe to
delete an object when the object is being referenced or pointed to in
various different places.  @b{taBase} provides a set of referencing and
pointer-management functions that simplify the use of a reference-count
based memory management system.  @code{Ref} increments the reference
count, @code{unRef} decrements it, @code{Done} checks if the refcount is
zero, and deletes the object if it is, and @code{unRefDone} does both.
@code{Own} both Ref's an object and sets its owner.  For pointers,
@code{SetPointer} unrefs any existing object that the pointer points to,
and sets it to point to the new object.  @code{DelPointer} does an
@code{unRefDone} on the object pointed to, and sets the pointer to NULL.
@code{OwnPointer} is like SetPointer except it also sets the owner of
the pointed-to object to the one given by the argument.  See
@ref{coding-funs} and @file{ta/ta_base.h} for more details.

@findex GetTypeDef on taBase
The one essential function that @b{taBase} provides is
@code{GetTypeDef()}, which is a virtual function that returns a pointer
to the @code{TypeDef} type descriptor for this object. This function is
defined as part of the basic macro @code{TA_BASEFUNS}, which must be
included in all classes derived from @b{taBase}.  This function makes it
possible for a generic pointer to a taBase object to find out what type
of object is really being pointed to.

There are a number of functions defined on the taBase type that simply
call the corresponding function on the @b{TypeDef} pointer.  These can
be found in the @file{ta/ta_base.h} header file.  They just make it
easier to call these commonly-used functions, instead of requiring the
user to put in a @code{GetTypeDef} function in between.

@b{taBase} also provides a simplified way of managing the construction,
deletion, and copying of an object.  Basically, construction is broken
down into a set of functions that @code{Initialize} the member
variables, @code{Register} the new token with the type if it is keeping
track of tokens, and it sets the default name of the object based on its
type name using @code{SetDefaultName}.  The @code{TA_BASEFUNS} macro
defines a default constructor that calls these three functions in that
order.  The user thus needs to provide a @code{Initialize} function for
every class defined, which does the appropriate member initialization.
Note that if this function is not defined, the one on the parent class
will be called twice, so its more efficient to include a blank
Initialize function when there are no members that need to be
initialized.

The destructor function is similar to the constructor.  A default
destructor is defined in @code{TA_BASEFUNS}, which simply calls
@code{unRegister}, and @code{Destroy}.  Thus, the user needs to provide
a @code{Destroy} function which frees any additional resources allocated
by the object, etc.  Like @code{Initialize}, a blank @code{Destroy}
should be defined when there is nothing that needs to be done to prevent
the parent function from being called twice.

Copying, cloning, and making a new token of the given type are also
supported in the @b{taBase} class.  The @code{Copy} function performs
the basic copy operations for both the copy constructor and the @code{=}
operator.  This should replace the values of this class and any of its
existing sub-objects with those of the object passed to it, as it is
intended for assignment between two existing objects.  In general, the
@code{=} operator should be used for copying all members, except for the
case of @code{LINK_GROUP} groups and lists, which should use the
@code{BorrowUnique} function (since they do not own the items in the list,
just link them).  @code{Copy} must call the parent's @code{Copy}
function as well.  As a minor simplification of calling the parent (and
to provide a copy function for just the items in a given class), it is
conventional to define a @code{Copy_} function, which does everything
except for calling the parent copy function.  The macro @code{COPY_FUNS}
can be used to define a @code{Copy} function which calls the parent
function and then @code{Copy_}.  The macro @code{SIMPLE_COPY} defines a
@code{Copy_} function which uses the type-scanned information to do the
copying.  It is slower than hand-coding things, so it probably shouldn't
be used on types which will have a lot of tokens or be copied often.

A @code{Clone} function which returns a @code{TAPtr} to a new duplicate
of this object is defined in @code{TA_BASEFUNS}, as well as an "unsafe"
version of @code{Copy} (@code{UnSafeCopy}), which takes a generic
@code{TAPtr} argument and casts it into their type.  The argument's type
should thus be tested before calling this function.  A safe interface to
this function is provided by the @code{CopyFrom} function, which does
the type checking.  Finally, the @code{MakeToken} function will create a
new token of the type.

The @b{taBase} class also contains functions for creating and
manipulating a structure hierarchy of objects.  This is where certain
objects contain groups of other objects, which contain other objects,
etc.  For example, the PDP++ software has a structure hierarchy built
around a root object, which contains projects, which contain lots of
other objects like networks, projects, environments, etc.  Special
container objects like @b{taList} and @b{taGroup} play an important role
in representing and manipulating this structure (note that it is
possible to write other types of container objects which could play the
same role simply by overloading the same functions that these objects
do).

When an object is "linked" into the object hierarchy, a function called
@code{InitLinks} is called.  This function should perform any kind of
initialization that depends on the object being situated in the
hierarchy, like being able to know what object "owns" this one.
@b{taBase} has functions for getting and setting the owner of an object.
For example, when a group (@b{taList} or @b{taGroup} creates a new
object and links it into its list of objects, it calls the
@code{SetOwner} function with a pointer to itself on this new object,
and then it calls @code{InitLinks}.  Similarly, when the object is
removed from the group, the @code{CutLinks} function is called, which
should cut any links that the object has with other objects.

An object's location in the object hierarchy can be represented by a
@emph{path} to that object from a global root object.  A given
application is assumed to have a root object, which contains all other
objects.  A pointer to that object is kept in @b{tabMisc::root}, which
is used to anchor the path to any given object.  An object can find its
path with the @code{GetPath} function, and an object can be found from a
path with the @code{FindFromPath} function.

Finally, a function for allowing an object to set the values of certain
members based on changes that might have been made in other members
after a user edits the object, called @code{UpdateAfterEdit}, is
provided.  This function is called on most objects after they are loaded
from a save file (except those with the @code{#NO_UPDATE_AFTER} comment
directive), and on all objects after the user hits @i{Apply} or @i{Ok}
in an edit dialog, and after any member is set through a CSS assign
statement.  While the object does not know which members were changed
when @code{UpdateAfterEdit} is called, the object can buffer previous
state on its own to figure this out if it is needed.

For a step-by-step guide to making a new class that derives from
@b{taBase}, see @ref{prog-coding}.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-typea-dump,  , prog-typea-base, prog-typea
@subsection The Dump-file Format for Saving/Loading

The format used for dumping objects to files an loading them back in
involves two passes.  The first pass lists all of the objects to be
saved (i.e., the object that the @code{Save} function was called on, and
any sub-objects it owns.  This is done so that during loading, all
objects will have been created before pointers to these objects attempt
to be cashed out.  The second pass then saves all of the values
associated with the members in the object.  The format is a name-value
based one, so that files can be loaded back into objects whose
definition has changed.  It skips member names it can't find, etc, so
you can continue to modify your software and still load old data.

Paths (i.e., the @code{GetPath} function) figure heavily into the saving
of objects, especially pointers.  Pointers are saved by giving the path
to the object.  These saved paths are automatically corrected if the
objects are loaded into a different location than the one they were
saved in.  All pointers that are saved are assumed to be
reference-counter based.  Thus, the @code{SetPointer} function is used
to set the pointer.  Also note that it is impossible to save a pointer
to a non-taBase derived object, since there is no way to get the path of
such an object.


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-comdir, prog-coding, prog-typea, prog
@section Standard TypeAccess Comment Directives
@cindex Comment Directives

The following sections document comment directives that are recognized
by the standard TypeAccess GUI and script-language interfaces.  These
must be placed in comments immediately following the definition of that
which the apply to.  Thus, an object directive should appear as

@example
  class whatever : public something @{  // #IGNORE comment goes here
@end example

for members and methods, it should be as follows:
@example
  class whatever : public something @{  // #IGNORE comment goes here
    int         member_1;       // #HIDDEN comment goes here
    float       member_2;
    // #READ_ONLY or here
    float       get_real();     /* #USE_RVAL note that multi-line
       old-fashioned c-style comments are legal too! */ 
@end example

@menu
* comdir-objs::                 Object Directives
* comdir-membs::                Member Directives
* comdir-meths::                Method Directives
* comdir-funs::                 Top-Level Function Directives
* comdir-pdp::                  PDP++ Specific Directives
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  comdir-objs, comdir-membs, prog-comdir, prog-comdir
@subsection Object Directives

If you add an extra "#" to the beginning of the comment directive, it
will automatically be inherited by any sub-classes of the given object.
Otherwise, it only applies to the object on which it was given.

@table @code
@item #IGNORE
Do not register this object in the list of types.
@item #NO_TOKENS
Do not keep a record of the tokens of this object type.  Types can keep
pointers to all instances or tokens of themselves.  This can be
expensive in terms of memory, but the interface uses "token menus" for
arguements or methods which are pointers to objects of the given type.
@item #NO_INSTANCE
Do not create a global instance (@code{TAI_xxx}) of this object.  This
will prevent tokens of this object from being made.
@item #INSTANCE
If default is not to create instances, then create one anyway for this
object.
@item #NO_MEMBERS
Do not store the members (including member functions) of this class.
Only the type name will be registered.
@item #NO_CSS
Do not create CSS stub functions for the member functions on this object.
@item #INLINE
Causes this item to be edited in a single line in a dialog box (e.g. for
geometry x,y,z) and affects saving/loading, etc.
@item #EDIT_INLINE
Only causes this item to be edited in a single line in a dialog box, but
in all other respects it is treated as a normal included class.  This is
useful for certain complex objects such as arrays and lists that do not
otherwise save/load well as INLINES.
@item #BUTROWS_x
Set the number of button rows to be x, useful if default allocation of 
number of rows of buttons for edit dialog is not correct
@item #EXT_xxx
Sets the default extension for saving/loading this type to xxx.
@item #COMPRESS
store dump file's of this object compressed.  Since the save files are
text, they can be large, so it is a good idea to auto-compress dump
files for large objects.
@item #MEMB_IN_GPMENU
This indicates that there is a group object as a member of this one
who's objects should appear in menus where this object appears.
@item #VIRT_BASE
This is a "virtual" base class: don't show in token menus for this
object, etc.
@item #NO_UPDATE_AFTER
Don't call UpdateAfterEdit when loading this object (and other places it
might automatically get called).  Since a list of objects which should
be updated after loading is made, small or numerous objects should not
be added to this list if not necessary.
@item #IMMEDIATE_UPDATE
Perform an immediate UpdateAfterEdit on this object after loading (i.e.,
it creates other objects..).  Normally, updating happens after all of
the other objects have been loaded.
@item #SCOPE_xxx
Type of object to use as a scope for this object.  The scope restricts
token menus and other things to only those things that share a common
parent token of the given scope type.
@item #ARRAY_ALLOC
Specific to taList_impl derivatives: this list or group should have
saved items created all together during loading (ie., like an array).
If actually using array-based memory allocation, this is essential, but
otherwise it can only speed things up a little bit.
@item #LINK_SAVE
Save the actual contents of this object even when it appears as a link
in a list.  Usually just the link pointer is saved, and the object is
saved later in the group that actually owns it. This overrides this and
saves the information in both places -- can be useful if info from the
linked object is needed during loading.
@item #NO_OK
Do not present an OK button on the edit dialog for this object.
@item #NO_CANCEL
Do not present a CANCEL button on the edit dialog for this object.
@end table


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  comdir-membs, comdir-meths, comdir-objs, prog-comdir
@subsection Member Directives

@table @code
@item #HIDDEN
Hides member from user's view in edit dialogs and CSS type information
printouts. 
@item #HIDDEN_INLINE
Hides member when inlined in another object, but not when edited itself.
This only applies to members of #INLINE objects.
@item #SHOW
Always show this member in the edit dialog (i.e., even if it was marked
#READ_ONLY).
@item #IGNORE
Does not register this member in the type information for this class.
@item #DETAIL
Flags this member as a level of detail that the user usually does not
need to deal with --- can be viewed by changing the Show setting in the
edit dialog.
@item #NO_SAVE
This member is not saved when dumping to a file.
@item #NO_SAVE_PATH_R
Don't create these objects in the 1st pass of the dump file (e.g., they
will be created automatically by something else, usually an
#IMMEDIATE_UPDATE UpdateAfterEdit function on a parent object).  This
can be used to speed up saving and loading of large numbers of
repetitive objects which can be created instead.
@item #READ_ONLY
Allows the user to see but not edit this item.  By default the gui edit
dialog will not show these items.  This prevents the member from being
changed in CSS as well.
@item #IV_READ_ONLY
Like READ_ONLY, but user can modify the value via CSS (which is
prevented by READ_ONLY).
@item #LIST_xxx
Sets the Lookup List for this element.  This is used mainly for pointers
to functions, where one wants the gui to show a list of top-level
functions that have been scanned by maketa (@pxref{comdir-funs}).
@item #TYPE_xxx
Sets the default type for members which are pointers to TypeDef objects.
This also works for MemberDef pointers.  If xxx is 'this', then the 
type of the current object is used.
@item #TYPE_ON_xxx
For object, TypeDef, or MemberDef pointers: use member xxx of this
object to anchor the listing of possible types, tokens, or members.
@item #FROM_GROUP_xxx
For token pointers, use given member xxx as the group from which to
select token options (xxx can be a pointer to a group).
@item #GROUP_OPT_OK
For FROM_GROUP_xxx mbrs, allows group itself as an option (else not
allowed).
@item #SUBTYPE_xxx
Sets this token pointer member to be only subitems (objects owned by
this one) of type xxx.  A recursive scan of members on this object is
performed to search for objects of the given type as possible values for
this field.
@item #NO_SUBTYPE
Don't search this ptr for possible subitems (use if this ptr might point
"up", causing a endless loop of searching for subitems).
@item #NO_FIND
Don't search this member for the recursive FindMembeR function which
searches recursively through objects (use if this ptr might point up in
the hierarchy, which might cause an endless loop).
@item #NO_SCOPE
Don't use scope for tokens for a token pointer member.  See SCOPE object directive
@item #LABEL_xxx
Set the label for item (or menu or button) to be xxx.
@item #OWN_POINTER
For a pointer to an object, when loading, set the owner of the obj to be
this object.  Thus, this pointer is always created and owned by this
object. 
@item #NULL_OK
A null value is ok as an option for the user (else not) for pointer to a
type, and SUBTYPE tokens.
@item #NO_NULL
A null value is not ok (for tokens) (else ok).
@item #NO_EDIT
Don't include Edit as an option on a token pointer menu (else ok).
@item #POS_ONLY
Only positive (non-negative) integers, this controls behavior of the
stepper for integer types.
@item #LINK_GROUP
This group member only has linked items (doesn't allow user to create
new tokens in this group).
@item #IN_GPMENU
This members' items should appear in the group menu. The member must be
a @b{taGroup_impl} descendent type, and the class must have a
MEMB_IN_GPMENU option set.
@item #CONDEDIT_xxx
This makes editing a member conditional on the value of another member.
For example: #CONDEDIT_OFF_type:NONE,LT_MAX specifies that this member
is to be not editable (OFF) when the type enum variable is either NONE
or LT_MAX.  One alternatively specify ON for conditions when it should
be editable.  The comparison is based on the string representation of
the member value -- sub-paths to members within contained objects can
also be used.
@item #DEF_xxx
Specifies a default value for the member.  If the field is set to a
value other than this default value, it will be highlighted in yellow to
indicate that the value is different from default.  This should only be
used where there are clear default values that are typically not
changed.
@item #AKA_xxx
This allows old project files etc to be loaded correctly after changing
the name of a field or enum by matching xxx to the new field/enum.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  comdir-meths, comdir-funs, comdir-membs, prog-comdir
@subsection Method Directives

@table @code
@item #MENU
Creates a Menu for this function item in an Edit dialog.
@item #MENU_SEP_BEFORE
Create a separator before this item in the menu.
@item #MENU_SEP_AFTER
Create a separator after this item in the menu.
@item #MENU_ON_xxx
Puts this function on given menu.  Creates menu if not already there.
This does not replace the #MENU directive.  Everything on the File and
Edit menus will be on the edit button for this class in an edit dialog.
@item #BUTTON
Creates a button for this function in the edit dialog.
@item #LABEL_xxx
Sets the label for item (or menu or button) to be xxx.
@item #USE_RVAL
Use (display) return value from this function.  Otherwise return values
are ignored.
@item #USE_RVAL_RMB
Use (display) return value from this function only if the right mouse
button was pressed on the Ok button.  Otherwise return values are ignored.
@item #NO_APPLY_BEFORE
Do not apply any changes to dialog before calling this function.  The
default is to apply the changes first.
@item #NO_REVERT_AFTER
Do not update (revert) dialog after calling this function (and do not
call the UpdateAfterEdit function either).  The default is to do both.
@item #UPDATE_MENUS
Update the global menus after calling this function (e.g., because
altered the structure reflected by those menus).
@item #ARGC_x
How many args to present to the user (if default args are available).
@item #ARG_ON_OBJ
An argument to this function is an object within the base object (e.g., a
member of the group).
@item #TYPE_xxx
For TypeDef pointer args: use given type to anchor the listing of possible
types.  if xxx == 'this', then the type of the current object is used.
@item #TYPE_ON_xxx
For a function with (any) TypeDef or Token args, uses the member xxx of
this to anchor type selection or type of tokens to present.
@item #FROM_GROUP_xxx
Performs selection of tokens for args from given group member xxx, which
is a member of this object (like ARG_ON_OBJ).  Can also specify which
arg(s) this applies to by doing #FROM_GROUP_1_gp: 1 = this arg or below
uses from_group, so put your from_group args first and specify the
highest index as this.
@item #NO_GROUP_OPT
For FROM_GROUP_xxx args, disallows group itself as an option.
@item #NO_SCOPE
Don't scope the argument to this function.  See SCOPE object directive
@item #NO_SCRIPT
Do not generate script code to call this function, if script code
recording is currently active.
@ref{comdir-objs}.
@item #GHOST_ON_xxx
For BUTTON meths, ghosts the button based on the value of boolean member
xxx of this class.  If member == true, button is ghosted.
@item #GHOST_OFF_xxx
Like above, except if member == false, button is ghosted.
@item #CONFIRM
For functions with no args, put up a dialog for confirmation (shows
function description too).
@item #NEW_FUN
Give user the option to call this (void) function during New (in the
"new" dialog).
@item #NULL_OK
A null value is ok as an option for the user (else not). for all
pointers as args.
@item #EDIT_OK
Include Edit as an option on the token pointer menu (else not)
@item #FILE_ARG_EDIT
For functions with one ostream arg, use the normal arg edit dialog,
instead of a shortcut directly to the file chooser (arg edit allows user
to choose open mode for saving).
@item #QUICK_SAVE
For functions with one ostream arg, use existing file name if possible
(default is to prompt).
@item #APPEND_FILE
For functions with one ostream arg, use append as the file opening mode.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  comdir-funs, comdir-pdp, comdir-meths, prog-comdir
@subsection Top-Level Function Directives

In addition to class objects and typedef's, it is possible to scan
information about certain top-level functions.  These functions must be
preceded by a @code{#REG_FUN} comment, and the comments that apply to
the function must precede the trailing @code{;} that ends the function
declaration.

@example
// #REG_FUN
void Cs_Simple_WtDecay(CsConSpec* spec, CsCon* cn, Unit* ru, Unit* su) 
// #LIST_CsConSpec_WtDecay Simple weight decay (subtract decay*wt)
     ;				// term here so scanner picks up comment
@end example

These functions get registered as @code{static} functions of a mythical
object with a @b{TypeDef} of @code{TA_taRegFun}.  The purpose of
registering functions in this way is to make them available for members
of classes that are pointers to functions.  These registered functions
are shown in a menu in the edit dialog if the @code{#LIST_xxx} directive
matches on the registered function and the pointer to a function.

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  comdir-pdp,  , comdir-funs, prog-comdir
@subsection PDP++ Specific Directives

@table @code
@item #NO_VIEW
For real-valued unit members, do not display this item in the net view
display. 
@item #AGGOP_xxx
(Process object only) sets the default aggregate operator for this
process's statistics.
@item #FINAL_STAT
(Stat object only) indicates if this should be created as a final stat.
@item #LOOP_STAT
(Stat object only) indicates if this should be created as a loop stat.
@item #COMPUTE_IN_xxx
(Stat object only) level at which this stat should be computed, xxx is a
process type.
@item #NO_INHERIT
In specs, makes member not-inherit from higher-ups.
@end table

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  prog-coding,  , prog-comdir, prog
@section Coding Conventions and Standards

This section describes the steps that need to be taken to define a new
class.  Every class based on the @b{taBase} type (i.e., all classes in
the PDP++ software) needs to have a set of standard methods (member
functions) that allow it to interface with the rest of the software.
Also, many commonly occurring data types and tasks that a class needs to
perform have been dealt with in a standardized way.  This chapter
familiarizes the programmer with these standards and interfaces.

Defining a new class is typically the first step a user will take in
programming with the PDP++ software.  This is because the software is
designed to be extended, not revised, by the user.  Fortunately, most
everything that is done by the PDP++ library code can be overwritten by
defining a new class that does something differently, or simply by
adding on to what the existing code does.  Both of these approaches
require the definition of a new class.

The first step in defining a new class is figuring out which existing
class to base the new one on.  This requires a knowledge of the existing
class structure, which is covered in this manual.  Once this has been
decided, the guidelines in this section should be followed as closely as
possible.  It is assumed that the reader knows C++ and the basic ideas
about constructors, destructors, virtual vs. non-virtual functions, etc.

@menu
* coding-names::                Naming Conventions
* coding-funs::                 Basic Functions
@end menu

@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  coding-names, coding-funs, prog-coding, prog-coding
@subsection Naming Conventions

The basic tension in naming something is the length vs. descriptiveness
tradeoff.  In general, we try to avoid abbreviations, but really long
words like "environment" inevitably get shortened to "Env", etc.

The bulk of the conventions we have established have to do with
distinguishing between different categories of names: class type names,
member function names, and member names being the major categories.  In
addition, the way in which names composed of multiple words are formed
is discussed.

@heading Object Class Names

Class types are first-letter-capitalized with words separated by
capitalization: e.g. @code{MyClass}.  There are certain exceptions, where
an underbar '_' is used to attach a high-frequency suffix, usually from
a template, to the name:

Common Suffixes:
@table @code
@item _List
taList derivative.
@item _Group
taGroup derivative.
@item _MGroup
MenuGroup derivative.
@item _Array
taArray derivative.
@item _SPtr
Smart Spec object pointer (PDP++).
@end table

Also if the class name contains multiple words, words which are actually
acronyms ending with a capital letter are separated from the following
word by an '_', e.g., (CE_Stat).

Classes in lower-level libraries also have the name-space identifier
prefixed to the name, which is lower case: e.g., @code{ta}, @code{taiv},
@code{css}.

@heading Enums

@code{enum} type names follow the same naming convention as class types.
@code{enum} members are all upper-case, words are separated by '_',
e.g., @code{INIT_STATE}.

@heading Member Names

Members are lower-case, words are separated by a '_', e.g., member_name.
One exception is for names ending in spec or specs in which case there
is no separation (e.g., viewspecs).

@heading Method Names

Methods are first-letter-capitalized, words are separated by
capitalization (e.g., @code{RunThis()}).  However, there some special
prefixes and suffixes that are exceptions to this rule, because they are
"high frequency" and denote a whole class of methods:

Prefixes:
@table @code
@item Dump_	
Saving and loading functions.
@item Compute_
Network computation functions (PDP++).
@item Send_
Network communication functions (PDP++).
@item C_
C code versions of process functions (PDP++).
@item Init_
Special initialize function for processes (PDP++).
@end table

Suffixes:
@table @code
@item _impl
Implementation (guts) of some other function which is the one that
should be called by the user.
@item _xxxx
Other _impl type functions that do specific aspects of the
implementation (xxx is lower case).  Examples in PDP++ include _flag,
_force.
@item _
(just a trailing underbar) This is a short version of _impl, which is
used extensively in InterViews, and sparingly in TA/PDP++.
@item _post
A function which is to be called after another one of the same name (for
two-step processes).
@item _Copy
A function called after the Copy function (e.g., to clean up pointers).
@item _gui
A special GUI version of function call.
@item _mc
A special menu callback version of function call.
@end table


@c ======================================
@c    <node>, <next>, <prev>, <up>
@node  coding-funs,  , coding-names, prog-coding
@subsection Basic Functions

These are the functions that must be either specified or considered in
any new instance of a @b{taBase} class:

@table @code
@item void Initialize()
@itemize @bullet
@item
It is called in every constructor.
@item
Do not call @code{Parent::Initialize()}, as this is a constructor
function and the parent's will be called for you by C++ as the object is
constructed.
@item
Set the initial/default values of each member in the class.
@item
Set the default type for groups that you own (@code{SetBaseType()}).
@item
Call @code{taBase::InitPointer(ptr)} on every taBase object pointer in
class, or just set all pointers to NULL.
@item
EVEN IF NOTHING NEEDS INITIALIZING: use @samp{void Initialize() @{ @};}
to avoid multiple calls to the parent's Initialize.
@end itemize

@item void Destroy()
@itemize @bullet
@item
It is called in every destructor.
@item
Do not call the parent, as C++ will automatically call the parent's
destructor for you.
@item
Free any resources you might have allocated.
@item
Call @code{CutLinks()}, if defined, to sever links with other objects.
@item 
EVEN IF NOTHING TO DESTROY: use @samp{void Destroy() @{ @};} to avoid
multiple calls to parents Destroy.
@end itemize

@item void InitLinks()
@itemize @bullet
@item
Called when an object is linked into some kind of ownership structure.
@item
Call the @code{Parent::InitLinks()}, since this is not a constructor
function and the parent's links will not otherwise be set.
@item
Own any classes contained as members: @samp{taBase::Own(recv, this);}
@item
Set any pointers to objects with default values (e.g.,
@samp{spec->SetDefaultSpec(this));}, etc.
@item
Be sure to use @samp{taBase::SetPointer(ptr, new_val);} for setting
pointers.
@item
Or use @samp{taBase::OwnPointer(ptr, new_val);} for those you own.
@item
If you do not need to do any of these InitLinks actions, then you do not
need to define an InitLinks function.
@end itemize

@item void CutLinks()
@itemize @bullet
@item
Called when an object is removed from its owner, or as part of the
@code{Destroy} function when an object is actually deleted, or
explicitly by the user when the object is a member of another object.
@item
At end of @code{CutLinks()}, call @code{Parent::CutLinks()}, since this
is not always used as a destructor function, and parent's might not be
called.  Note, however, that when it is called in the destructor, it
will be repeatedly called, so it should be robust to this (i.e., SET ANY
POINTERS YOU DELETE TO NULL SO YOU DON'T DELETE THEM AGAIN!).
@item
Should sever all links to other objects, allowing them to be freed too.
@item
Call @code{CutLinks()} on any owned members, especially groups!
@item
Use @code{taBase::DelPointer()} on any pointers.
@item
If you have a spec, call @code{CutLinks()} on it.
@item
If you have group members, call @code{CutLinks()} on those groups.
@end itemize
		
@item void Copy_(const T& cp), Copy(const T& cp)
@itemize @bullet
@item
Used to duplicate the class, Copy is the = oper and copy constructor
@item
Call @code{Parent::Copy} since this will not be called otherwise.
@item
@code{Copy_(const T& cp)} is an "implementation" that does the copying
for just this class, and does not call the parent @code{Copy}.
@item
Use @code{COPY_FUNS(T, P);} (type and parent-type) to define the default
macros for doing this:
@example
  void Copy(const T& cp)      @{ P::Copy(cp); Copy_(cp); @}
@end example
@item
Use @code{SIMPLE_COPY(T);} to define a @code{Copy_} function that
automatically copies the members unique to this class in a
member-by-member (using TypeDef) way.  This is less optimal, but easy
when members are just simple floats and ints, etc.
@item
Be sure to use @code{taBase::SetPointer(&ptr, cp.ptr)} for copying
pointers.
@end itemize

@item TA_BASEFUNS(T);
This defines the actual "basic" functions like constructors,
destructors, @code{GetTypeDef()} etc. for taBase classes.  These default
constructors and destructors call the other functions like
@code{Initialize()} and @code{Destroy()}.

@item TA_CONST_BASEFUNS(T);
This defines the actual "basic" functions like constructors, etc. for
@b{taBase} classes which have @code{const} members defined in the class.
These need to be initialized as part of the constructor, so this macro
leaves out the default constructors and destructor, which should contain
the following code:
@example
  MyClass() @{ Register(); Initialize(); SetDefaultName(); @}
  MyClass(const MyClass& cp)
   @{ Register(); Initialize(); Copy(cp); @}
  ~MyClass() @{ unRegister(); Destroy(); @}
@end example

@item TA_TMPLT_BASEFUNS(y,T);
Defines the actual "basic" functions like constructors, etc. for
@b{taBase} classes which are also templates.  @code{y} is the template
class, @code{T} is the template class parameter.

@item void UpdateAfterEdit()
@itemize @bullet
@item
Called after class members change via edit dialogs, loading from a file,
or and assign operator in CSS.
@item
Maintain consistency of member values.
@item
Update links, etc.
@end itemize
@end table

@heading When you add/remove/change any class members:

Check and add/remove/change initialization, copying, of this member in:
@table @code
@item Initialize()	
@item Copy_()
@item Copy()
@end table

@heading For classes with Specs:

A pointer to a spec is encapsulated in a SpecPtr template class, which
is declared once immediately after a new class of spec types is defined
as follows (this will not typically done by the user):
@example
  SpecPtr_of(UnitSpec);  // this defines the template class 
				    (only for base spec type)
@end example

This pointer is then included in the class with the following:
@example
  UnitSpec_SPtr  spec;  // this puts a spec pointer in the class
@end example

Also, InitLinks() should have:
@example
  spec.SetDefaultSpec(this);
@end example
So that the spec pointer will set its pointer to a default instance of
the correct spec type (the @code{this} pointer is because this also
"owns" the spec pointer object.


@heading For classes with @b{taBase} members:

All @b{taBase} members which appear as members of another class should
be owned by the parent class.  This increments their ref counter, so
that if they are ever pointed to by something else (e.g., during loading
this happens), and then unref'd, they won't then be deleted.

@code{InitLinks()} should own the object member as follows:
@example
  ta_Base::Own(obj_memb, this);
@end example

For members that derive from @b{taList} or @b{taGroup},
@code{Initialize()} should set the default type of object that goes in
the group:
@example
  gp_obj.SetDefaultType(&TA_typename);
@end example

@heading Referring to other objects via pointers:

If a class contains a pointer to another object, it should typically
refer to that object whenever the pointer is set.  The interface assumes
that this is the case, and any pointer member that it sets will use the
@code{SetPointer} function described below, which does the referencing
of the new value and the dereferencing of the current one.

HOWEVER, when the pointer is to a physical PARENT of the object 
(or just higher in the deletion hierarchy) then it should not be
referenced, as this will prevent the parent from being deleted,
which will then prevent the child from being deleted.

In this case, and in general when the pointer is just for "internal use"
of the class, and is not to be set by the user, the following comment
directives should always be used: @code{#READ_ONLY #NO_SAVE} as this
will prevent the user from overwriting the pointer, and the loading code
automatically does a reference when setting a pointer, so these should
not be saved.  DO NOT COPY SUCH POINTERS, since they typically are set
by the @code{InitLinks} based on the owner, which is usually different
for different tokens.

When managing a pointer that the user can set, there are a set of
convenient functions in taBase that manage this process (note that the
argument is a @emph{pointer} to the pointer):

@table @code
@item taBase::InitPointer(TAPtr* ptr)
initializes the pointer (or just set the ptr to NULL yourself) in @code{Initialize()}
@item taBase::SetPointer(TAPtr* ptr, TAPtr new_val)
unRef's *ptr obj if non-null, refs the new one.
@item taBase::OwnPointer(TAPtr* ptr, TAPtr new_val, TAPtr ownr)
like set, but owns the pointer too with the given owner.
@item taBase::DelPointer(ptr)
unRefDone the object pointed to, sets pointer to NULL.
@end table

Using these functions will ensure correct refcounts on objects pointed to, 
etc.

If you @code{Own} the object at the pointer, then you should either mark
the member as @code{#NO_SAVE} if it is automatically created, or
@code{#OWN_POINTER} if it is not.  This is because saving and loading,
being generic, use @code{SetPointer} unless this comment is present, in
which case they use @code{OwnPointer}.


@heading Using Group Iterators:

There are special iterator functions which iterate through the members
of a group.  One method is to iterate through those sub-groups
(including the 'this' group) which contain actual terminal elements
("leaves").  This is leaf-group iteration.  Then, the elements of each
group can be traversed simply using the @code{El} or @code{FastEl}
functions.

@itemize @bullet
@item
for leaf-group iteration, using macros (preferred method):
@example
  Con_Group* recv_gp;		// the current group
  int g;
  FOR_ITR_GP(Con_Group, recv_gp, u->recv., g)
    recv_gp->UpdateWeights();
@end example

@item
for leaf-group iteration without macros:
@example
  Con_Group* recv_gp;		// the current group
  int g;
  for(recv_gp = (Con_Group*)u->recv.FirstGp(g); recv_gp;
      recv_gp = (Con_Group*)u->recv.NextGp(g))
    recv_gp->UpdateWeights();
@end example
@end itemize

When all you care about are the leaf elements themselves, you can
iterate over them directly using leaf-iteration:

@itemize @bullet
@item
for leaf-iteration, using macros (preferred method):
@example
  Connection* con;		// the current leaf
  taLeafItr i;			// the iterator data
  FOR_ITR_EL(Connection, con, u->recv., i)
    con->UpdateWeights();
@end example

@item
for leaf-iteration without macros:
@example
  Connection* con;		// the current leaf
  taLeafItr i;			// the iterator data
  for(con = (Connection*)u->recv.FirstEl(i); con;
      con = (Connection*)u->recv.NextEl(i))
    con->UpdateWeights();
@end example
@end itemize


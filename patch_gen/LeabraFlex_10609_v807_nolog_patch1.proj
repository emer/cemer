// ta_Dump File v3.0 -- code v8.0.9.0 rev10721
LeabraProject .projects[0] { 
 Doc_Group @.docs = [2] {
  taDoc @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };
  };
  taDoc @[1] { };
 };

 Wizard_Group @.wizards = [1] {
  LeabraWizard @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };
  };
 };

 ControlPanel_Group @.ctrl_panels = [2] {
  ClusterRun @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   ControlPanelMember_Group @.mbrs = [2] {
    ControlPanelMember @[0] { };
    ControlPanelMember @[1] { };
   };

   ControlPanelMethod_Group @.mths = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
  ControlPanel @[1] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   ControlPanelMember_Group @.mbrs = [10] {
    ControlPanelMember @[0] { };
    ControlPanelMember @[1] { };
    ControlPanelMember @[2] { };
    ControlPanelMember @[3] { };
    ControlPanelMember @[4] { };
    ControlPanelMember @[5] { };
    ControlPanelMember @[6] { };
    ControlPanelMember @[7] { };
    ControlPanelMember @[8] { };
    ControlPanelMember @[9] { };
   };

   ControlPanelMethod_Group @.mths = [4] {
    ControlPanelMethod @[0] { };
    ControlPanelMethod @[1] { };
    ControlPanelMethod @[2] { };
    ControlPanelMethod @[3] { };
   };
  };
 };

 ParamSet_Group @.active_params = [0] {
  ParamSet_Group @.gp[0] = [2] { 
   ParamSet @[0] { 
    ControlPanelMember_Group @.mbrs = [18] {
     ControlPanelMember @[0] { };
     ControlPanelMember @[1] { };
     ControlPanelMember @[2] { };
     ControlPanelMember @[3] { };
     ControlPanelMember @[4] { };
     ControlPanelMember @[5] { };
     ControlPanelMember @[6] { };
     ControlPanelMember @[7] { };
     ControlPanelMember @[8] { };
     ControlPanelMember @[9] { };
     ControlPanelMember @[10] { };
     ControlPanelMember @[11] { };
     ControlPanelMember @[12] { };
     ControlPanelMember @[13] { };
     ControlPanelMember @[14] { };
     ControlPanelMember @[15] { };
     ControlPanelMember @[16] { };
     ControlPanelMember @[17] { };
    };

    ControlPanelMethod_Group @.mths = [0] {
    };
   };
   ParamSet @[1] { 
    ControlPanelMember_Group @.mbrs = [18] {
     ControlPanelMember @[0] { };
     ControlPanelMember @[1] { };
     ControlPanelMember @[2] { };
     ControlPanelMember @[3] { };
     ControlPanelMember @[4] { };
     ControlPanelMember @[5] { };
     ControlPanelMember @[6] { };
     ControlPanelMember @[7] { };
     ControlPanelMember @[8] { };
     ControlPanelMember @[9] { };
     ControlPanelMember @[10] { };
     ControlPanelMember @[11] { };
     ControlPanelMember @[12] { };
     ControlPanelMember @[13] { };
     ControlPanelMember @[14] { };
     ControlPanelMember @[15] { };
     ControlPanelMember @[16] { };
     ControlPanelMember @[17] { };
    };

    ControlPanelMethod_Group @.mths = [0] {
    };
   };
  };
  ParamSet_Group @.gp[1] = [2] { 
   ParamSet @[0] { 
    ControlPanelMember_Group @.mbrs = [1] {
     ControlPanelMember @[0] { };
    };

    ControlPanelMethod_Group @.mths = [0] {
    };
   };
   ParamSet @[1] { 
    ControlPanelMember_Group @.mbrs = [1] {
     ControlPanelMember @[0] { };
    };

    ControlPanelMethod_Group @.mths = [0] {
    };
   };
  };
 };

 ArchivedParams_Group @.archived_params = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp[0] = [1] { 
   DataTable @[0] { 
    DataTableCols @.data = [3] {
     String_Data @[0] { };
     float_Data @[1] { };
     float_Data @[2] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[1] = [4] { 
   DataTable @[0] { 
    DataTableCols @.data = [30] {
     int_Data @[0] { };
     int_Data @[1] { };
     String_Data @[2] { };
     int_Data @[3] { };
     int_Data @[4] { };
     int_Data @[5] { };
     float_Data @[6] { };
     String_Data @[7] { };
     String_Data @[8] { };
     String_Data @[9] { };
     float_Data @[10] { };
     float_Data @[11] { };
     float_Data @[12] { };
     float_Data @[13] { };
     float_Data @[14] { };
     float_Data @[15] { };
     float_Data @[16] { };
     float_Data @[17] { };
     float_Data @[18] { };
     float_Data @[19] { };
     float_Data @[20] { };
     float_Data @[21] { };
     float_Data @[22] { };
     float_Data @[23] { };
     float_Data @[24] { };
     float_Data @[25] { };
     float_Data @[26] { };
     float_Data @[27] { };
     float_Data @[28] { };
     float_Data @[29] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [41] {
     int_Data @[0] { };
     int_Data @[1] { };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
     float_Data @[9] { };
     float_Data @[10] { };
     float_Data @[11] { };
     float_Data @[12] { };
     float_Data @[13] { };
     float_Data @[14] { };
     float_Data @[15] { };
     float_Data @[16] { };
     float_Data @[17] { };
     float_Data @[18] { };
     float_Data @[19] { };
     float_Data @[20] { };
     float_Data @[21] { };
     float_Data @[22] { };
     float_Data @[23] { };
     float_Data @[24] { };
     float_Data @[25] { };
     float_Data @[26] { };
     float_Data @[27] { };
     float_Data @[28] { };
     float_Data @[29] { };
     float_Data @[30] { };
     float_Data @[31] { };
     float_Data @[32] { };
     float_Data @[33] { };
     float_Data @[34] { };
     float_Data @[35] { };
     float_Data @[36] { };
     float_Data @[37] { };
     float_Data @[38] { };
     float_Data @[39] { };
     float_Data @[40] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[2] { 
    DataTableCols @.data = [30] {
     int_Data @[0] { };
     int_Data @[1] { };
     String_Data @[2] { };
     int_Data @[3] { };
     int_Data @[4] { };
     int_Data @[5] { };
     float_Data @[6] { };
     String_Data @[7] { };
     String_Data @[8] { };
     String_Data @[9] { };
     float_Data @[10] { };
     float_Data @[11] { };
     float_Data @[12] { };
     float_Data @[13] { };
     float_Data @[14] { };
     float_Data @[15] { };
     float_Data @[16] { };
     float_Data @[17] { };
     float_Data @[18] { };
     float_Data @[19] { };
     float_Data @[20] { };
     float_Data @[21] { };
     float_Data @[22] { };
     float_Data @[23] { };
     float_Data @[24] { };
     float_Data @[25] { };
     float_Data @[26] { };
     float_Data @[27] { };
     float_Data @[28] { };
     float_Data @[29] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
   DataTable @[3] { 
    DataTableCols @.data = [32] {
     int_Data @[0] { };
     int_Data @[1] { };
     float_Data @[2] { };
     float_Data @[3] { };
     float_Data @[4] { };
     float_Data @[5] { };
     float_Data @[6] { };
     float_Data @[7] { };
     float_Data @[8] { };
     float_Data @[9] { };
     float_Data @[10] { };
     float_Data @[11] { };
     float_Data @[12] { };
     float_Data @[13] { };
     float_Data @[14] { };
     float_Data @[15] { };
     float_Data @[16] { };
     float_Data @[17] { };
     float_Data @[18] { };
     float_Data @[19] { };
     float_Data @[20] { };
     float_Data @[21] { };
     float_Data @[22] { };
     float_Data @[23] { };
     float_Data @[24] { };
     float_Data @[25] { };
     float_Data @[26] { };
     float_Data @[27] { };
     float_Data @[28] { };
     float_Data @[29] { };
     float_Data @[30] { };
     float_Data @[31] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };
   };
  };
  DataTable_Group @.gp[2] { 
  };
  DataTable_Group @.gp[3] { 
  };
 };

 Program_TopGroup @.programs = [1] {
  Program @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserData_DocLink @[0] { };
   };

   ProgObjList @.objs = [0] {
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgVar_List @.vars = [9] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
    ProgVar @[5] { };
    ProgVar @[6] { };
    ProgVar @[7] { };
    ProgVar @[8] { };
   };

   Function_List @.functions = [0] {
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [18] {
    RegisterArgs @[0] { };
    PrintExpr @[1] { };
    Comment @[2] { };
    AssignExpr @[3] { };
    ProgVarFmArg @[4] { };
    ProgVarFmArg @[5] { };
    Comment @[6] { };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    ControlPanelsFmArgs @[8] { };
    AssignExpr @[9] { };
    Comment @[10] { };
    If @[11] { 
     ProgEl_List @.true_code = [4] {
      ProgVarFmArg @[0] { };
      MiscCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      VarIncr @[2] { };
      If @[3] { 
       ProgEl_List @.true_code = [2] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [4] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	  ProgArg @[3] { };
	 };
	};
	MiscCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    Else @[12] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MiscCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    OtherProgramVar @[13] { };
    Comment @[14] { };
    ProgramCallVar @[15] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
    PrintExpr @[16] { };
    ProgramCall @[17] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Program_Group @.gp[0] = [1] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     Comment @[0] { };
     Comment @[1] { };
    };
   };
  };
  Program_Group @.gp[1] = [3] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [4] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @[0] { };
      };
     };
     AssignExpr @[1] { };
     MemberAssign @[2] { };
     ForLoop @[3] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       NetCounterIncr @[1] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [10] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [2] {
     AssignExpr @[0] { };
     WtInitPrompt @[1] { 
      ProgEl_List @.yes_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[2] { };
      };
     };
    };

    ProgEl_List @.prog_code = [5] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [0] {
      };
     };
     AssignExpr @[1] { };
     If @[2] { 
      ProgEl_List @.true_code = [3] {
       AssignExpr @[0] { };
       OtherProgramVar @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [1] {
	   ProgArg @[0] { };
	  };
	 };
	 MethodCall @[1] { 
	  ProgArg_List @.meth_args = [1] {
	   ProgArg @[0] { };
	  };
	 };
	};
       };
      };
     };
     ProgramCallVar @[3] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     WhileLoop @[4] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [1] {
     DynEnumType @[0] { 
      DynEnumItem_List @.enums = [4] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
       DynEnumItem @[2] { };
       DynEnumItem @[3] { };
      };
     };
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [1] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [2] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       Switch @[1] { 
	ProgEl_List @.cases = [4] {
	 CaseBlock @[0] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	 CaseBlock @[1] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	 CaseBlock @[2] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	 CaseBlock @[3] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     ProgramCallVar @[0] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program_Group @.gp[0] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [4] {
      ProgramCall @[0] { 
       ProgArg_List @.prog_args = [5] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
       };
      };
      ProgramCall @[1] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      If @[2] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
      Else @[3] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
     };
    };
   };
   Program_Group @.gp[1] = [1] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [6] {
      Comment @[0] { };
      MemberAssign @[1] { };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      Comment @[3] { };
      MemberAssign @[4] { };
      If @[5] { 
       ProgEl_List @.true_code = [5] {
	ProgramCall @[0] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	If @[1] { 
	 ProgEl_List @.true_code = [1] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
	MemberAssign @[2] { };
	If @[3] { 
	 ProgEl_List @.true_code = [2] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  ReturnExpr @[1] { };
	 };
	};
	ProgramCall @[4] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
   };
  };
  Program_Group @.gp[2] = [3] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     TimeUsed @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };

    ProgEl_List @.prog_code = [19] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     Comment @[1] { };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     ProgramCall @[3] { 
      ProgArg_List @.prog_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     Comment @[5] { };
     ProgramCall @[6] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[8] { };
     StopStepPoint @[9] { };
     Comment @[10] { };
     MethodCall @[11] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[12] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ProgramCall @[13] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[14] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[15] { };
     ProgramCall @[16] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[17] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[18] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     TimeUsed @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };

    ProgEl_List @.prog_code = [19] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     Comment @[1] { };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     ProgramCall @[3] { 
      ProgArg_List @.prog_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     Comment @[5] { };
     ProgramCall @[6] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[8] { };
     StopStepPoint @[9] { };
     Comment @[10] { };
     MethodCall @[11] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[12] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ProgramCall @[13] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[14] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[15] { };
     ProgramCall @[16] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[17] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[18] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [7] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [6] {
     NetCounterInit @[0] { };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetDataLoop @[3] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 StopStepPoint @[0] { };
	};
       };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[5] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
  };
  Program_Group @.gp[3] = [3] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     DataTable @[0] { 
      DataTableCols @.data = [1] {
       int_Data @[0] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [3] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 AssignExpr @[0] { };
	};
       };
       Else @[2] { 
	ProgEl_List @.true_code = [2] {
	 AssignExpr @[0] { };
	 WhileLoop @[1] { 
	  ProgEl_List @.loop_code = [1] {
	   VarIncr @[0] { };
	  };
	 };
	};
       };
      };
     };
     Function @[1] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       AssignExpr @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [1] {
	 DataProcCall @[0] { 
	  ProgArg_List @.meth_args = [3] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	  };
	 };
	};
       };
      };
     };
     Function @[2] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [5] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       FunctionCall @[1] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MethodCall @[3] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       FunctionCall @[4] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [2] {
     FunctionCall @[0] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [8] {
     FunctionCall @[0] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       FunctionCall @[0] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
      };
     };
     If @[2] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
      };
     };
     Else @[3] { 
      ProgEl_List @.true_code = [1] {
       AssignExpr @[0] { };
      };
     };
     If @[4] { 
      ProgEl_List @.true_code = [2] {
       AssignExpr @[0] { };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 RandomCall @[0] { 
	  ProgArg_List @.meth_args = [2] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	  };
	 };
	};
       };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [1] {
       FunctionCall @[0] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
      };
     };
     Else @[7] { 
      ProgEl_List @.true_code = [1] {
       VarIncr @[0] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     RandomCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     LayerWriter @[0] { 
      LayerDataEl_List @.layer_data = [3] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
      };
     };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
  };
  Program_Group @.gp[4] = [16] { 
   Program @[0] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     RndSeed_List @[0] { 
      taList @.seeds = [25] {
       RndSeed @[0] { };
       RndSeed @[1] { };
       RndSeed @[2] { };
       RndSeed @[3] { };
       RndSeed @[4] { };
       RndSeed @[5] { };
       RndSeed @[6] { };
       RndSeed @[7] { };
       RndSeed @[8] { };
       RndSeed @[9] { };
       RndSeed @[10] { };
       RndSeed @[11] { };
       RndSeed @[12] { };
       RndSeed @[13] { };
       RndSeed @[14] { };
       RndSeed @[15] { };
       RndSeed @[16] { };
       RndSeed @[17] { };
       RndSeed @[18] { };
       RndSeed @[19] { };
       RndSeed @[20] { };
       RndSeed @[21] { };
       RndSeed @[22] { };
       RndSeed @[23] { };
       RndSeed @[24] { };
      };
     };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[1] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [5] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [4] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [2] {
	 ProgVar @[0] { };
	 ProgVar @[1] { };
	};
       };
       ForeachLoop @[1] { 
	ProgEl_List @.loop_code = [2] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 MethodCall @[1] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
       ForeachLoop @[2] { 
	ProgEl_List @.loop_code = [2] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 MethodCall @[1] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     Function @[1] { 
      ProgVar_List @.args = [2] {
       ProgVar @[0] { };
       ProgVar @[1] { };
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [3] {
	 ProgVar @[0] { };
	 ProgVar @[1] { };
	 ProgVar @[2] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       ForeachLoop @[2] { 
	ProgEl_List @.loop_code = [4] {
	 MemberMethodCall @[0] { 
	  ProgArg_List @.meth_args = [1] {
	   ProgArg @[0] { };
	  };
	 };
	 If @[1] { 
	  ProgEl_List @.true_code = [2] {
	   MiscCall @[0] { 
	    ProgArg_List @.meth_args = [9] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	     ProgArg @[2] { };
	     ProgArg @[3] { };
	     ProgArg @[4] { };
	     ProgArg @[5] { };
	     ProgArg @[6] { };
	     ProgArg @[7] { };
	     ProgArg @[8] { };
	    };
	   };
	   IfContinue @[1] { };
	  };
	 };
	 If @[2] { 
	  ProgEl_List @.true_code = [2] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	   MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	 Else @[3] { 
	  ProgEl_List @.true_code = [2] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	   MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     Function @[2] { 
      ProgVar_List @.args = [2] {
       ProgVar @[0] { };
       ProgVar @[1] { };
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [3] {
	 ProgVar @[0] { };
	 ProgVar @[1] { };
	 ProgVar @[2] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       ForeachLoop @[2] { 
	ProgEl_List @.loop_code = [4] {
	 MemberMethodCall @[0] { 
	  ProgArg_List @.meth_args = [1] {
	   ProgArg @[0] { };
	  };
	 };
	 If @[1] { 
	  ProgEl_List @.true_code = [2] {
	   MiscCall @[0] { 
	    ProgArg_List @.meth_args = [9] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	     ProgArg @[2] { };
	     ProgArg @[3] { };
	     ProgArg @[4] { };
	     ProgArg @[5] { };
	     ProgArg @[6] { };
	     ProgArg @[7] { };
	     ProgArg @[8] { };
	    };
	   };
	   IfContinue @[1] { };
	  };
	 };
	 If @[2] { 
	  ProgEl_List @.true_code = [2] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	   MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	 Else @[3] { 
	  ProgEl_List @.true_code = [2] {
	   MethodCall @[0] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	   MethodCall @[1] { 
	    ProgArg_List @.meth_args = [0] {
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     Function @[3] { 
      ProgVar_List @.args = [2] {
       ProgVar @[0] { };
       ProgVar @[1] { };
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [5] {
	 ProgVar @[0] { };
	 ProgVar @[1] { };
	 ProgVar @[2] { };
	 ProgVar @[3] { };
	 ProgVar @[4] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       ForeachLoop @[2] { 
	ProgEl_List @.loop_code = [8] {
	 If @[0] { 
	  ProgEl_List @.true_code = [2] {
	   MiscCall @[0] { 
	    ProgArg_List @.meth_args = [9] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	     ProgArg @[2] { };
	     ProgArg @[3] { };
	     ProgArg @[4] { };
	     ProgArg @[5] { };
	     ProgArg @[6] { };
	     ProgArg @[7] { };
	     ProgArg @[8] { };
	    };
	   };
	   IfContinue @[1] { };
	  };
	 };
	 MethodCall @[1] { 
	  ProgArg_List @.meth_args = [2] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	  };
	 };
	 MethodCall @[2] { 
	  ProgArg_List @.meth_args = [2] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	  };
	 };
	 MemberMethodCall @[3] { 
	  ProgArg_List @.meth_args = [1] {
	   ProgArg @[0] { };
	  };
	 };
	 If @[4] { 
	  ProgEl_List @.true_code = [2] {
	   MiscCall @[0] { 
	    ProgArg_List @.meth_args = [9] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	     ProgArg @[2] { };
	     ProgArg @[3] { };
	     ProgArg @[4] { };
	     ProgArg @[5] { };
	     ProgArg @[6] { };
	     ProgArg @[7] { };
	     ProgArg @[8] { };
	    };
	   };
	   IfContinue @[1] { };
	  };
	 };
	 AssignExpr @[5] { };
	 If @[6] { 
	  ProgEl_List @.true_code = [2] {
	   MiscCall @[0] { 
	    ProgArg_List @.meth_args = [9] {
	     ProgArg @[0] { };
	     ProgArg @[1] { };
	     ProgArg @[2] { };
	     ProgArg @[3] { };
	     ProgArg @[4] { };
	     ProgArg @[5] { };
	     ProgArg @[6] { };
	     ProgArg @[7] { };
	     ProgArg @[8] { };
	    };
	   };
	   IfContinue @[1] { };
	  };
	 };
	 MemberAssign @[7] { };
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [9] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [0] {
      };
     };
     FunctionCall @[1] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     FunctionCall @[2] { 
      ProgArg_List @.fun_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     FunctionCall @[3] { 
      ProgArg_List @.fun_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     FunctionCall @[4] { 
      ProgArg_List @.fun_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     FunctionCall @[5] { 
      ProgArg_List @.fun_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     PrintExpr @[8] { };
    };
   };
   Program @[2] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [2] {
     DataTable @[0] { 
      DataTableCols @.data = [9] {
       String_Data @[0] { };
       String_Data @[1] { };
       String_Data @[2] { };
       int_Data @[3] { };
       int_Data @[4] { };
       int_Data @[5] { };
       int_Data @[6] { };
       int_Data @[7] { };
       int_Data @[8] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
     DataTable @[1] { 
      DataTableCols @.data = [9] {
       String_Data @[0] { };
       String_Data @[1] { };
       String_Data @[2] { };
       int_Data @[3] { };
       int_Data @[4] { };
       int_Data @[5] { };
       int_Data @[6] { };
       int_Data @[7] { };
       int_Data @[8] { };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };
     };
    };

    ProgType_List @.types = [2] {
     DynEnumType @[0] { 
      DynEnumItem_List @.enums = [2] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
      };
     };
     DynEnumType @[1] { 
      DynEnumItem_List @.enums = [3] {
       DynEnumItem @[0] { };
       DynEnumItem @[1] { };
       DynEnumItem @[2] { };
      };
     };
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [2] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [7] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [4] {
	 ProgVar @[0] { };
	 ProgVar @[1] { };
	 ProgVar @[2] { };
	 ProgVar @[3] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       AssignExpr @[3] { };
       Comment @[4] { };
       ForeachLoop @[5] { 
	ProgEl_List @.loop_code = [5] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 CssExpr @[1] { };
	 CssExpr @[2] { };
	 CssExpr @[3] { };
	 CssExpr @[4] { };
	};
       };
       ForLoop @[6] { 
	ProgEl_List @.loop_code = [10] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 AssignExpr @[1] { };
	 CssExpr @[2] { };
	 If @[3] { 
	  ProgEl_List @.true_code = [1] {
	   CssExpr @[0] { };
	  };
	 };
	 CssExpr @[4] { };
	 CssExpr @[5] { };
	 CssExpr @[6] { };
	 CssExpr @[7] { };
	 CssExpr @[8] { };
	 CssExpr @[9] { };
	};
       };
      };
     };
     Function @[1] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [9] {
	 ProgVar @[0] { };
	 ProgVar @[1] { };
	 ProgVar @[2] { };
	 ProgVar @[3] { };
	 ProgVar @[4] { };
	 ProgVar @[5] { };
	 ProgVar @[6] { };
	 ProgVar @[7] { };
	 ProgVar @[8] { };
	};
       };
       ForLoop @[1] { 
	ProgEl_List @.loop_code = [4] {
	 AssignExpr @[0] { };
	 IfContinue @[1] { };
	 AssignExpr @[2] { };
	 If @[3] { 
	  ProgEl_List @.true_code = [1] {
	   Switch @[0] { 
	    ProgEl_List @.cases = [3] {
	     CaseBlock @[0] { 
	      ProgEl_List @.prog_code = [1] {
	       MethodCall @[0] { 
		ProgArg_List @.meth_args = [3] {
		 ProgArg @[0] { };
		 ProgArg @[1] { };
		 ProgArg @[2] { };
		};
	       };
	      };
	     };
	     CaseBlock @[1] { 
	      ProgEl_List @.prog_code = [4] {
	       AssignExpr @[0] { };
	       If @[1] { 
		ProgEl_List @.true_code = [4] {
		 MethodCall @[0] { 
		  ProgArg_List @.meth_args = [4] {
		   ProgArg @[0] { };
		   ProgArg @[1] { };
		   ProgArg @[2] { };
		   ProgArg @[3] { };
		  };
		 };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		 AssignExpr @[3] { };
		};
	       };
	       Else @[2] { 
		ProgEl_List @.true_code = [3] {
		 AssignExpr @[0] { };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		};
	       };
	       MethodCall @[3] { 
		ProgArg_List @.meth_args = [3] {
		 ProgArg @[0] { };
		 ProgArg @[1] { };
		 ProgArg @[2] { };
		};
	       };
	      };
	     };
	     CaseBlock @[2] { 
	      ProgEl_List @.prog_code = [4] {
	       AssignExpr @[0] { };
	       If @[1] { 
		ProgEl_List @.true_code = [4] {
		 MethodCall @[0] { 
		  ProgArg_List @.meth_args = [4] {
		   ProgArg @[0] { };
		   ProgArg @[1] { };
		   ProgArg @[2] { };
		   ProgArg @[3] { };
		  };
		 };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		 AssignExpr @[3] { };
		};
	       };
	       Else @[2] { 
		ProgEl_List @.true_code = [3] {
		 AssignExpr @[0] { };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		};
	       };
	       MethodCall @[3] { 
		ProgArg_List @.meth_args = [3] {
		 ProgArg @[0] { };
		 ProgArg @[1] { };
		 ProgArg @[2] { };
		};
	       };
	      };
	     };
	    };
	   };
	  };
	 };
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     Switch @[0] { 
      ProgEl_List @.cases = [2] {
       CaseBlock @[0] { 
	ProgEl_List @.prog_code = [1] {
	 FunctionCall @[0] { 
	  ProgArg_List @.fun_args = [0] {
	  };
	 };
	};
       };
       CaseBlock @[1] { 
	ProgEl_List @.prog_code = [1] {
	 FunctionCall @[0] { 
	  ProgArg_List @.fun_args = [0] {
	  };
	 };
	};
       };
      };
     };
    };
   };
   Program @[3] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     String_Matrix @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [5] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MemberMethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 MiscCall @[0] { 
	  ProgArg_List @.meth_args = [9] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	   ProgArg @[3] { };
	   ProgArg @[4] { };
	   ProgArg @[5] { };
	   ProgArg @[6] { };
	   ProgArg @[7] { };
	   ProgArg @[8] { };
	  };
	 };
	 IfContinue @[1] { };
	};
       };
       If @[3] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
       Else @[4] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[4] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [1] {
     RndSeed @[0] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [15] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
     ProgVar @[6] { };
     ProgVar @[7] { };
     ProgVar @[8] { };
     ProgVar @[9] { };
     ProgVar @[10] { };
     ProgVar @[11] { };
     ProgVar @[12] { };
     ProgVar @[13] { };
     ProgVar @[14] { };
    };

    Function_List @.functions = [1] {
     Function @[0] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       AssignExpr @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 AssignExpr @[0] { };
	 If @[1] { 
	  ProgEl_List @.true_code = [1] {
	   VarIncr @[0] { };
	  };
	 };
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [10] {
     FunctionCall @[0] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     ProgramCall @[1] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     If @[2] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     If @[3] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     PrintExpr @[5] { };
     If @[6] { 
      ProgEl_List @.true_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       PrintVar @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [1] {
	 MemberAssign @[0] { };
	};
       };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     If @[8] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     ProgramCall @[9] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @[5] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @[6] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [5] {
     MemberAssign @[0] { };
     MemberMethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @[7] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MemberMethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     If @[3] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
    };
   };
   Program @[8] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MemberAssign @[3] { };
    };
   };
   Program @[9] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
    };
   };
   Program @[10] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @[0] { };
      };
     };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     NetUpdateView @[2] { };
    };
   };
   Program @[11] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [0] {
      };
     };
     ProgramCall @[1] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     NetUpdateView @[2] { };
    };
   };
   Program @[12] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [7] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @[0] { };
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     Comment @[3] { };
     ForLoop @[4] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[6] { };
    };
   };
   Program @[13] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @[0] { };
     ProgVar @[1] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [7] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [2] {
       ProgVar @[0] { };
       ProgVar @[1] { };
      };
     };
     Comment @[1] { };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ForLoop @[4] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       AssignExpr @[1] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[6] { };
    };
   };
   Program @[14] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @[0] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
     MemberAssign @[2] { };
    };
   };
   Program @[15] { 
    UserDataItem_List @*(.user_data_) {
     UserData_DocLink @[0] { };
    };

    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @[0] { };
    };

    ProgVar_List @.vars = [6] {
     ProgVar @[0] { };
     ProgVar @[1] { };
     ProgVar @[2] { };
     ProgVar @[3] { };
     ProgVar @[4] { };
     ProgVar @[5] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ReturnExpr @[0] { };
      };
     };
     MiscCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MiscCall @[2] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     AssignExpr @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program_Group @.gp[0] = [5] { 
    Program @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [6] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [1] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
     };

     ProgEl_List @.prog_code = [6] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      If @[1] { 
       ProgEl_List @.true_code = [1] {
	ReturnExpr @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      PrintVar @[4] { };
      If @[5] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [4] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	  ProgArg @[3] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	PrintVar @[2] { };
       };
      };
     };
    };
    Program @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      NetMonitor @[0] { 
       NetMonItem_List @.items = [26] {
	NetMonItem @[0] { };
	NetMonItem @[1] { };
	NetMonItem @[2] { };
	NetMonItem @[3] { };
	NetMonItem @[4] { };
	NetMonItem @[5] { };
	NetMonItem @[6] { };
	NetMonItem @[7] { };
	NetMonItem @[8] { };
	NetMonItem @[9] { };
	NetMonItem @[10] { };
	NetMonItem @[11] { };
	NetMonItem @[12] { };
	NetMonItem @[13] { };
	NetMonItem @[14] { };
	NetMonItem @[15] { };
	NetMonItem @[16] { };
	NetMonItem @[17] { };
	NetMonItem @[18] { };
	NetMonItem @[19] { };
	NetMonItem @[20] { };
	NetMonItem @[21] { };
	NetMonItem @[22] { };
	NetMonItem @[23] { };
	NetMonItem @[24] { };
	NetMonItem @[25] { };
       };
      };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      AssignExpr @[3] { };
     };

     ProgEl_List @.prog_code = [5] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	AssignExpr @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    Program @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      NetMonitor @[0] { 
       NetMonItem_List @.items = [30] {
	NetMonItem @[0] { };
	NetMonItem @[1] { };
	NetMonItem @[2] { };
	NetMonItem @[3] { };
	NetMonItem @[4] { };
	NetMonItem @[5] { };
	NetMonItem @[6] { };
	NetMonItem @[7] { };
	NetMonItem @[8] { };
	NetMonItem @[9] { };
	NetMonItem @[10] { };
	NetMonItem @[11] { };
	NetMonItem @[12] { };
	NetMonItem @[13] { };
	NetMonItem @[14] { };
	NetMonItem @[15] { };
	NetMonItem @[16] { };
	NetMonItem @[17] { };
	NetMonItem @[18] { };
	NetMonItem @[19] { };
	NetMonItem @[20] { };
	NetMonItem @[21] { };
	NetMonItem @[22] { };
	NetMonItem @[23] { };
	NetMonItem @[24] { };
	NetMonItem @[25] { };
	NetMonItem @[26] { };
	NetMonItem @[27] { };
	NetMonItem @[28] { };
	NetMonItem @[29] { };
       };
      };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [4] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [5] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      AssignExpr @[4] { };
     };

     ProgEl_List @.prog_code = [8] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	AssignExpr @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      AssignExpr @[3] { };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[5] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[6] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      Comment @[7] { };
     };
    };
    Program @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      NetMonitor @[0] { 
       NetMonItem_List @.items = [26] {
	NetMonItem @[0] { };
	NetMonItem @[1] { };
	NetMonItem @[2] { };
	NetMonItem @[3] { };
	NetMonItem @[4] { };
	NetMonItem @[5] { };
	NetMonItem @[6] { };
	NetMonItem @[7] { };
	NetMonItem @[8] { };
	NetMonItem @[9] { };
	NetMonItem @[10] { };
	NetMonItem @[11] { };
	NetMonItem @[12] { };
	NetMonItem @[13] { };
	NetMonItem @[14] { };
	NetMonItem @[15] { };
	NetMonItem @[16] { };
	NetMonItem @[17] { };
	NetMonItem @[18] { };
	NetMonItem @[19] { };
	NetMonItem @[20] { };
	NetMonItem @[21] { };
	NetMonItem @[22] { };
	NetMonItem @[23] { };
	NetMonItem @[24] { };
	NetMonItem @[25] { };
       };
      };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      AssignExpr @[3] { };
     };

     ProgEl_List @.prog_code = [5] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	AssignExpr @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    Program @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserData_DocLink @[0] { };
     };

     ProgObjList @.objs = [1] {
      NetMonitor @[0] { 
       NetMonItem_List @.items = [25] {
	NetMonItem @[0] { };
	NetMonItem @[1] { };
	NetMonItem @[2] { };
	NetMonItem @[3] { };
	NetMonItem @[4] { };
	NetMonItem @[5] { };
	NetMonItem @[6] { };
	NetMonItem @[7] { };
	NetMonItem @[8] { };
	NetMonItem @[9] { };
	NetMonItem @[10] { };
	NetMonItem @[11] { };
	NetMonItem @[12] { };
	NetMonItem @[13] { };
	NetMonItem @[14] { };
	NetMonItem @[15] { };
	NetMonItem @[16] { };
	NetMonItem @[17] { };
	NetMonItem @[18] { };
	NetMonItem @[19] { };
	NetMonItem @[20] { };
	NetMonItem @[21] { };
	NetMonItem @[22] { };
	NetMonItem @[23] { };
	NetMonItem @[24] { };
       };
      };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @[0] { };
     };

     ProgVar_List @.vars = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      AssignExpr @[3] { };
     };

     ProgEl_List @.prog_code = [5] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	AssignExpr @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      Comment @[4] { };
     };
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
    UserDataItem @[1] { };
    UserDataItem @[2] { };
    UserDataItem @[3] { };
    UserDataItem @[4] { };
    UserDataItem @[5] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @[0] { };
    PanelViewer @[1] { };
    T3PanelViewer @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };

     T3Panel_List @.panels = [2] {
      T3Panel @[0] { 
       T3DataView_List @.root_view.children = [1] {
	NetView @[0] { 
	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 ScaleRange_List @.scale_ranges = [1] {
	  ScaleRange @[0] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
      T3Panel @[1] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @[0] { 
	 T3DataView_List @.children = [41] {
	  GraphColView @[0] { };
	  GraphColView @[1] { };
	  GraphColView @[2] { };
	  GraphColView @[3] { };
	  GraphColView @[4] { };
	  GraphColView @[5] { };
	  GraphColView @[6] { };
	  GraphColView @[7] { };
	  GraphColView @[8] { };
	  GraphColView @[9] { };
	  GraphColView @[10] { };
	  GraphColView @[11] { };
	  GraphColView @[12] { };
	  GraphColView @[13] { };
	  GraphColView @[14] { };
	  GraphColView @[15] { };
	  GraphColView @[16] { };
	  GraphColView @[17] { };
	  GraphColView @[18] { };
	  GraphColView @[19] { };
	  GraphColView @[20] { };
	  GraphColView @[21] { };
	  GraphColView @[22] { };
	  GraphColView @[23] { };
	  GraphColView @[24] { };
	  GraphColView @[25] { };
	  GraphColView @[26] { };
	  GraphColView @[27] { };
	  GraphColView @[28] { };
	  GraphColView @[29] { };
	  GraphColView @[30] { };
	  GraphColView @[31] { };
	  GraphColView @[32] { };
	  GraphColView @[33] { };
	  GraphColView @[34] { };
	  GraphColView @[35] { };
	  GraphColView @[36] { };
	  GraphColView @[37] { };
	  GraphColView @[38] { };
	  GraphColView @[39] { };
	  GraphColView @[40] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };

	 GraphPlotView_List @.errbars = [16] {
	  GraphPlotView @[0] { };
	  GraphPlotView @[1] { };
	  GraphPlotView @[2] { };
	  GraphPlotView @[3] { };
	  GraphPlotView @[4] { };
	  GraphPlotView @[5] { };
	  GraphPlotView @[6] { };
	  GraphPlotView @[7] { };
	  GraphPlotView @[8] { };
	  GraphPlotView @[9] { };
	  GraphPlotView @[10] { };
	  GraphPlotView @[11] { };
	  GraphPlotView @[12] { };
	  GraphPlotView @[13] { };
	  GraphPlotView @[14] { };
	  GraphPlotView @[15] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @[0] { };
	T3SavedView @[1] { };
	T3SavedView @[2] { };
	T3SavedView @[3] { };
	T3SavedView @[4] { };
	T3SavedView @[5] { };
	T3SavedView @[6] { };
	T3SavedView @[7] { };
	T3SavedView @[8] { };
	T3SavedView @[9] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
      UserDataItem @[2] { };
      UserDataItem @[3] { };
      UserDataItem @[4] { };
      UserDataItem @[5] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [1] {
  LeabraNetwork @[0] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
    UserDataItem @[1] { };
    UserDataItem @[2] { };
    UserDataItem @[3] { };
    UserDataItem @[4] { };
    UserDataItem @[5] { };
    UserDataItem @[6] { };
    UserDataItem @[7] { };
    UserDataItem @[8] { };
    UserDataItem @[9] { };
    UserDataItem @[10] { };
    UserDataItem @[11] { };
    UserDataItem @[12] { };
    UserDataItem @[13] { };
    UserDataItem @[14] { };
    UserDataItem @[15] { };
    UserDataItem @[16] { };
    UserDataItem @[17] { };
    UserDataItem @[18] { };
    UserDataItem @[19] { };
    UserDataItem @[20] { };
    UserDataItem @[21] { };
    UserDataItem @[22] { };
    UserDataItem @[23] { };
    UserDataItem @[24] { };
    UserDataItem @[25] { };
    UserDataItem @[26] { };
   };

   BaseSpec_Group @.specs = [4] {
    LeabraLayerSpec @[0] { 
     BaseSpec_Group @.children = [1] {
      LeabraLayerSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };
      };
     };
    };
    LeabraUnitSpec @[1] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.noise_sched = [0] {
     };
    };
    LeabraConSpec @[2] { 
     BaseSpec_Group @.children = [2] {
      LeabraBiasSpec @[0] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
      LeabraConSpec @[1] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    FullPrjnSpec @[3] { 
     BaseSpec_Group @.children = [0] {
     };
    };
   };

   ParamSeq_Group @.param_seqs = [0] {
   };

   Layer_Group @.layers = [3] {
    LeabraLayer @[0] { 
     Projection_Group @.projections = [0] {
     };

     Unit_Group @.units = [25] {
     };
    };
    LeabraLayer @[1] { 
     Projection_Group @.projections = [2] {
      LeabraPrjn @[0] { };
      LeabraPrjn @[1] { };
     };

     Unit_Group @.units = [25] {
     };
    };
    LeabraLayer @[2] { 
     Projection_Group @.projections = [1] {
      LeabraPrjn @[0] { };
     };

     Unit_Group @.units = [25] {
     };
    };
   };

   Weights_List @.weights = [0] {
   };
  };
 };
};
LeabraProject .projects[0] {
 name="LeabraFlex_10609_v807_nolog_patch1";
 desc="flexible modular framework for Leabra Programs";
 tags="Leabra, flex";
 version {
  major=8;
  minor=0;
  step=3;
 };
 author="Randall C. O'Reilly";
 email="emergent-users@grey.colorado.edu";
 license {
  license=GPLv2;
  owner_name="Regents of the University of Colorado";
  org="CCNLab at the University of Colorado Boulder";
  year="2016";
  custom=;
 };
 pub_cite=;
 wiki {wiki="": page_name="": };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="LeabraFlexProgs";
   desc=;
   web_doc=1;
   wiki="emergent";
   url="LeabraFlexProgs";
   full_url="https://grey.colorado.edu/emergent/index.php/LeabraFlexProgs";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html><html lang=\"en\" dir=\"ltr\" class=\"client-js\"><head>
<meta charset=\"UTF-8\">
<title>LeabraFlex - emergent</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>
<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":!1,\"wgNamespaceNumber\":0,\"wgPageName\":\"LeabraFlex\",\"wgTitle\":\"LeabraFlex\",\"wgCurRevisionId\":11194,\"wgRevisionId\":11194,\"wgArticleId\":2315,\"wgIsArticle\":!0,\"wgIsRedirect\":!1,\"wgAction\":\"view\",\"wgUserName\":\"Oreilly\",\"wgUserGroups\":[\"bureaucrat\",\"svnadmins\",\"sysop\",\"*\",\"user\",\"autoconfirmed\"],\"wgCategories\":[],\"wgBreakFrames\":!1,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"LeabraFlex\",\"wgRelevantArticleId\":2315,\"wgUserId\":3,\"wgUserEditCount\":2418,\"wgUserRegistration\":1178051527000,\"wgUserNewMsgRevisionId\":null,\"wgIsProbablyEditable\":!0,
\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[],\"wgRedirectedFrom\":\"LeabraFlexProgs\",\"sfgAutocompleteValues\":[],\"sfgAutocompleteOnAllChars\":!1,\"sfgFieldProperties\":[],\"sfgDependentFields\":[],\"sfgShowOnSelect\":[],\"sfgScriptPath\":\"/emergent/extensions/SemanticForms\",\"wgSVGEditEditor\":\"http://svg-edit.googlecode.com/svn/trunk/editor/svg-editor.html\",\"wgHeaderTabsTabIndexes\":[],\"wgWikiEditorEnabledModules\":{\"toolbar\":!0,\"dialogs\":!0,\"preview\":!0,\"publish\":!1},\"wgCategoryTreePageCategoryOptions\":\"{\\\"mode\\\":0,\\\"hideprefix\\\":20,\\\"showcount\\\":true,\\\"namespaces\\\":false}\",\"wgInternalRedirectTargetUrl\":\"/emergent/index.php/LeabraFlex\"});mw.loader.implement(\"user.options\",function($,jQuery){mw.user.options.set({\"ccmeonemails\":\"1\",\"enotifminoredits\":\"1\",\"imagesize\":\"0\",\"previewontop\":\"\",\"rows\":\"30\",\"thumbsize\":\"0\",\"underline\":\"0\",\"watchmoves\":\"1\",\"editsection\":\"1\",\"rememberpassword\":\"1\",\"timecorrection\":\"ZoneInfo|-360|America/Denver\",\"watchlisttoken\":\"14fd6c804d78e99930123181974c128b983adb9e\"});});mw.loader.implement(\"user.tokens\",function($,jQuery){mw.user.tokens.set({\"editToken\":\"0a88836d7a7345a895c33b77c32d4c75573565c5+\\\\\",\"patrolToken\":\"23ddb841cfc4d5ea0a31b9b98522b291573565c5+\\\\\",\"watchToken\":\"e09a6a8fb5e56280ca057cc6e9e63054573565c5+\\\\\"});});mw.loader.load([\"mediawiki.action.view.redirect\",\"ext.smw.style\",\"ext.smw.tooltips\",\"mediawiki.page.startup\",\"mediawiki.legacy.wikibits\",\"skins.vector.js\"]);
} );</script>
<link rel=\"stylesheet\" href=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector\">
<link rel=\"stylesheet\" href=\"/emergent/extensions/HeaderTabs/skins/ext.headertabs.large.css\">
<meta name=\"ResourceLoaderDynamicStyles\" content=\"\">
<link rel=\"stylesheet\" href=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector\">
<style>a{text-decoration:none}</style>
<script async=\"\" src=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>
<meta name=\"generator\" content=\"MediaWiki 1.26.2\">
<link rel=\"ExportRDF\" type=\"application/rdf+xml\" title=\"LeabraFlex\" href=\"/emergent/index.php?title=Special:ExportRDF/LeabraFlex&amp;xmlmime=rdf\">
<link rel=\"alternate\" type=\"application/x-wiki\" title=\"Edit\" href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit\">
<link rel=\"edit\" title=\"Edit\" href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit\">
<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/emergent/opensearch_desc.php\" title=\"emergent (en)\">
<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"https://grey.colorado.edu/emergent/api.php?action=rsd\">
<link rel=\"alternate\" type=\"application/atom+xml\" title=\"emergent Atom feed\" href=\"/emergent/index.php?title=Special:RecentChanges&amp;feed=atom\">
<link rel=\"canonical\" href=\"https://grey.colorado.edu/emergent/index.php/LeabraFlex\">
<!--[if lt IE 7]><style type=\"text/css\">body{behavior:url(\"/emergent/skins/Vector/csshover.min.htc\")}</style><![endif]-->
</head>
<body class=\"mediawiki ltr sitedir-ltr ns-0 ns-subject page-LeabraFlex skin-vector action-view\">
		<div id=\"mw-page-base\" class=\"noprint\"></div>
		<div id=\"mw-head-base\" class=\"noprint\"></div>
		<div id=\"content\" class=\"mw-body\" role=\"main\">
			<a id=\"top\"></a>

						<div class=\"mw-indicators\">
</div>
			<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">LeabraFlex</h1>
									<div id=\"bodyContent\" class=\"mw-body-content\">
									<div id=\"siteSub\">From emergent</div>
								<div id=\"contentSub\"><span class=\"mw-redirectedfrom\">(Redirected from <a href=\"/emergent/index.php?title=LeabraFlexProgs&amp;redirect=no\" title=\"LeabraFlexProgs\">LeabraFlexProgs</a>)</span></div>
												<div id=\"jump-to-nav\" class=\"mw-jump\">
					Jump to:					<a href=\"#mw-head\">navigation</a>, 					<a href=\"#p-search\">search</a>
				</div>
				<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><p>Documentation for the <code>LeabraFlex</code> project template (also avail in <code>demo/leabra/leabra_flex_progs.proj</code>), which provides a different way of configuring the <a href=\"/emergent/index.php/Leabra\" title=\"Leabra\">Leabra</a> programs that is more flexible and modular -- very useful for more complex projects that require extensive novel functionality, including interactive behaviors between the network and the programs that generate inputs to the network, things that happen at different points in the settling process, and supporting multiple different ways of running the model in a more efficient, modular fashion.
</p>
<div id=\"toc\" class=\"toc\"><div id=\"toctitle\"><h2>Contents</h2></div>
<ul>
<li class=\"toclevel-1 tocsection-1\"><a href=\"#ConfigData.2FConfigTable\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">ConfigData/ConfigTable</span></a></li>
<li class=\"toclevel-1 tocsection-2\"><a href=\"#Program_Hierarchy\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Program Hierarchy</span></a></li>
<li class=\"toclevel-1 tocsection-3\"><a href=\"#UtilProgs\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">UtilProgs</span></a></li>
<li class=\"toclevel-1 tocsection-4\"><a href=\"#DMem_.28MPI.29\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">DMem (MPI)</span></a></li>
</ul>
</div>

<h1><span class=\"mw-headline\" id=\"ConfigData.2FConfigTable\">ConfigData/ConfigTable</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit&amp;section=1\" title=\"Edit section: ConfigData/ConfigTable\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h1>
<p>The <a href=\"/emergent/index.php/DataTable\" title=\"DataTable\">DataTable</a> in ConfigData/ConfigTable is key for the flex progs -- each row specifies a different configuration, which can call different Init, Run, and even Startup programs, to achieve very different behavior or configurations all within the same project.  This makes it very easy to add new functionality into the system without adding spaghetti or complex conditionals in existing programs -- just add a new config and a new program at the right level, to achieve new functionality.
</p>
<h1><span class=\"mw-headline\" id=\"Program_Hierarchy\">Program Hierarchy</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit&amp;section=2\" title=\"Edit section: Program Hierarchy\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h1>
<p>The call sequence is:
</p>
<ul><li> <b>MasterTrain</b></li></ul>
<dl><dd><ul><li> <b>InitProgs[init_prog]</b> (as spec'd in ConfigTable)</li>
<li> loop over <b>MasterRun</b> until stop_train is set to true</li></ul>
<dl><dd><ul><li> <b>RunProgs[run_prog]</b> (as spec'd in ConfigTable)</li></ul>
<dl><dd><ul><li> typically calls one or more <b>TaskProgs</b>, increments counters and does appropriate Epoch and higher-level housekeeping as necessary.</li></ul></dd></dl></dd></dl></dd></dl>
<p>MasterRun now has a <b>stop_step_grain</b> parameter that allows you to Step this program at different grain sizes (e.g., after an Epoch) and for different conditions -- this is completely extensible if you look at the underlying code, and very powerful.
</p>
<h1><span class=\"mw-headline\" id=\"UtilProgs\">UtilProgs</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit&amp;section=3\" title=\"Edit section: UtilProgs\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h1>
<p>The UtilProgs contain all the basic functionality for training a network and monitoring, etc -- the task programs should consist of calls to these util programs in the desired order to achieve whatever form of processing is required.  The built-in BasicTrain program just does the equivalent of a standard LeabraTrial.
</p>
<h1><span class=\"mw-headline\" id=\"DMem_.28MPI.29\">DMem (MPI)</span><span class=\"mw-editsection\"><span class=\"mw-editsection-bracket\">[</span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit&amp;section=4\" title=\"Edit section: DMem (MPI)\">edit</a><span class=\"mw-editsection-bracket\">]</span></span></h1>
<p>The most efficient way to use multiple distributed memory (dmem) processors (via MPI) is to split different events across processors.  The standard Leabra programs do this by interleaving trials according to dmem processor (e.g., for 10 processors, proc 0 gets trials 0, 10, 20, ..; proc 1 gets 1, 11, 21, etc..).  For these flex progs, which can have interactive behavior and ill-defined sequences of events, this strategy is not always possible (the <b>ChoosePermutedEvent</b> program in EnviroProgs does implement this behavior however).  Here are some tips:
</p>
<ul><li> After version 8.0, you can add taMisc::dmem_proc to all calls to <a href=\"/emergent/index.php/Random\" title=\"Random\">Random</a> or various Permute etc functions that use random numbers and take a <b>thr_no</b> (thread number) argument -- as documented in <a href=\"/emergent/index.php/MTRnd\" title=\"MTRnd\">MTRnd</a>, this thr_no arg selects different random number sequences that are initialized from a single common seed, and will produce statistically independent sequences.  Thus, you can ensure that each node gets different random inputs and other parameters, as appropriate, without needing to have an entirely different seed for each node.  This also means that results can be fully replicable when starting from the same random seed, and that nodes can also generate the same random numbers as needed (if this is needed, it is a good idea to pass taMisc::dmem_proc + 1 to the Random calls, and reserve 0 for the common shared thread that should only be called identically from all processors -- otherwise it will diverge from the 0'th node relative to the others.</li></ul>
<ul><li> After common weight initialization etc, the <b>TrainStart</b> program has the option to generate a new random seed just before starting the Epoch -- see the <b>dmem_new_seed</b> flag -- each processor at this point will be operating with their own random seed, so any dynamic event generation code that uses random numbers (hint: it should!) will result in different things on different nodes.  However, as a result of this, <b>every run of the simulation will be different</b>, even if using common initial starting seeds.   See first note to alternative that avoids these consequences.</li></ul>
<ul><li> It is <b>essential</b> that the different nodes still end up calling <b>Compute_Weights</b> the same number of times, after roughly the same amount of overall computation -- this is where the weight changes are synchronized across processors -- the simulation will lock up and hang if these do not align.</li></ul>
<ul><li> The <b>epoch_trials</b> value gets divided by dmem_nprocs in StdGlobalsInit, such that each processor runs this reduced number of trials, <i>with the network-&gt;trial counter going from 0 to this lower epoch_trials value</i> -- it does not do the interleaving that is done in the hierarchical programs.  This also means that trial numbers will be duplicated if you merge separate trial log data tables into a single table, which is not necessarily a problem, but you may need to do things a bit differently in analyzing the data.</li></ul>
<ul><li> If you are using a traditional list of events in an input_data table, use ChoosePermutedEvent and it will work properly with dmem, just like the standard programs.  This program maintains its own internal counter, and simply iterates in a permuted order through the events and then repeats -- it does not need to be synchronized with the trial and epoch structure of the programs (to achieve this, simply ensure that the epoch_trials is the same as the number of rows in the input data table).</li></ul>

<!-- 
NewPP limit report
Cached time: 20160512214138
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.024 seconds
Real time usage: 0.026 seconds
Preprocessor visited node count: 15/1000000
Preprocessor generated node count: 20/1000000
Post?expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key pdpwiki:pcache:idhash:2315-0!*!0!!en!*!* and timestamp 20160512214138 and revision id 11194
 -->
</div>					<div class=\"printfooter\">
						Retrieved from \"<a dir=\"ltr\" href=\"https://grey.colorado.edu/emergent/index.php?title=LeabraFlex&amp;oldid=11194\">https://grey.colorado.edu/emergent/index.php?title=LeabraFlex&amp;oldid=11194</a>\"					</div>
				<div id=\"catlinks\" class=\"catlinks catlinks-allhidden\"></div>				<div class=\"visualClear\"></div>
							</div>
		</div>
		<div id=\"mw-navigation\">
			<h2>Navigation menu</h2>

			<div id=\"mw-head\">
									<div id=\"p-personal\" role=\"navigation\" class=\"\" aria-labelledby=\"p-personal-label\">
						<h3 id=\"p-personal-label\">Personal tools</h3>
						<ul>
							<li id=\"pt-userpage\"><a href=\"/emergent/index.php/User:Oreilly\" dir=\"auto\" title=\"Your user page [.]\" accesskey=\".\">Oreilly</a></li><li id=\"pt-mytalk\"><a href=\"/emergent/index.php/User_talk:Oreilly\" class=\"new\" title=\"Your talk page [n]\" accesskey=\"n\">Talk</a></li><li id=\"pt-preferences\"><a href=\"/emergent/index.php/Special:Preferences\" title=\"Your preferences\">Preferences</a></li><li id=\"pt-watchlist\"><a href=\"/emergent/index.php/Special:Watchlist\" title=\"A list of pages you are monitoring for changes [l]\" accesskey=\"l\">Watchlist</a></li><li id=\"pt-mycontris\"><a href=\"/emergent/index.php/Special:Contributions/Oreilly\" title=\"A list of your contributions [y]\" accesskey=\"y\">Contributions</a></li><li id=\"pt-logout\"><a href=\"/emergent/index.php?title=Special:UserLogout&amp;returnto=LeabraFlex\" title=\"Log out\">Log out</a></li>						</ul>
					</div>
									<div id=\"left-navigation\">
										<div id=\"p-namespaces\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-namespaces-label\">
						<h3 id=\"p-namespaces-label\">Namespaces</h3>
						<ul>
															<li id=\"ca-nstab-main\" class=\"selected\"><span><a href=\"/emergent/index.php/LeabraFlex\" title=\"View the content page [c]\" accesskey=\"c\">Page</a></span></li>
															<li id=\"ca-talk\" class=\"new\"><span><a href=\"/emergent/index.php?title=Talk:LeabraFlex&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [t]\" accesskey=\"t\" rel=\"discussion\">Discussion</a></span></li>
													</ul>
					</div>
										<div id=\"p-variants\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-variants-label\">
												<h3 id=\"p-variants-label\">
							<span>Variants</span><a href=\"#\"></a>
						</h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id=\"right-navigation\">
										<div id=\"p-views\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-views-label\">
						<h3 id=\"p-views-label\">Views</h3>
						<ul>
															<li id=\"ca-view\" class=\"selected\"><span><a href=\"/emergent/index.php/LeabraFlex\">Read</a></span></li>
															<li id=\"ca-edit\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit\" title=\"Edit this page [e]\" accesskey=\"e\">Edit</a></span></li>
															<li id=\"ca-history\" class=\"collapsible\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=history\" title=\"Past revisions of this page [h]\" accesskey=\"h\">View history</a></span></li>
															<li id=\"ca-unwatch\" class=\"icon\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=unwatch&amp;token=f494f878fd49b9bc4a42d7984fd67370573565c5%2B%5C\" title=\"Remove this page from your watchlist [w]\" accesskey=\"w\">Unwatch</a></span></li>
													</ul>
					</div>
										<div id=\"p-cactions\" role=\"navigation\" class=\"vectorMenu\" aria-labelledby=\"p-cactions-label\">
						<h3 id=\"p-cactions-label\"><span>More</span><a href=\"#\"></a></h3>

						<div class=\"menu\">
							<ul>
																	<li id=\"ca-delete\">
										<a href=\"/emergent/index.php?title=LeabraFlex&amp;action=delete\" title=\"Delete this page [d]\" accesskey=\"d\">Delete</a>
									</li>
																	<li id=\"ca-move\">
										<a href=\"/emergent/index.php/Special:MovePage/LeabraFlex\" title=\"Move this page [m]\" accesskey=\"m\">Move</a>
									</li>
																	<li id=\"ca-protect\">
										<a href=\"/emergent/index.php?title=LeabraFlex&amp;action=protect\" title=\"Protect this page [=]\" accesskey=\"=\">Protect</a>
									</li>
																	<li id=\"ca-purge\">
										<a href=\"/emergent/index.php?title=LeabraFlex&amp;action=purge\">Refresh</a>
									</li>
															</ul>
						</div>
					</div>
										<div id=\"p-search\" role=\"search\">
						<h3>
							<label for=\"searchInput\">Search</label>
						</h3>

						<form action=\"/emergent/index.php\" id=\"searchform\">
							<div id=\"simpleSearch\">
							<input type=\"search\" name=\"search\" placeholder=\"Search\" title=\"Search emergent [f]\" accesskey=\"f\" id=\"searchInput\"><input type=\"hidden\" value=\"Special:Search\" name=\"title\"><input type=\"submit\" name=\"fulltext\" value=\"Search\" title=\"Search the pages for this text\" id=\"mw-searchButton\" class=\"searchButton mw-fallbackSearchButton\"><input type=\"submit\" name=\"go\" value=\"Go\" title=\"Go to a page with this exact name if it exists\" id=\"searchButton\" class=\"searchButton\">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id=\"mw-panel\">
				<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/emergent/index.php/Main_Page\" title=\"Visit the main page\"></a></div>
						<div class=\"portal\" role=\"navigation\" id=\"p-navigation\" aria-labelledby=\"p-navigation-label\">
			<h3 id=\"p-navigation-label\">Navigation</h3>

			<div class=\"body\">
									<ul>
						<li id=\"n-mainpage-description\"><a href=\"/emergent/index.php/Main_Page\" title=\"Visit the main page [z]\" accesskey=\"z\">Main page</a></li><li id=\"n-recentchanges\"><a href=\"/emergent/index.php/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\" accesskey=\"r\">Recent changes</a></li><li id=\"n-Documentation\"><a href=\"/emergent/index.php/User_hub\">Documentation</a></li><li id=\"n-Submit-a-bug\"><a href=\"/emergent/index.php/How_to_submit_a_bug_report\">Submit a bug</a></li><li id=\"n-Bug-tracker\"><a href=\"//grey.colorado.edu/cgi-bin/bugzilla/index.cgi\" rel=\"nofollow\">Bug tracker</a></li><li id=\"n-Mailing-list\"><a href=\"//grey.colorado.edu/cgi-bin/mailman/listinfo/emergent-users\" rel=\"nofollow\">Mailing list</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-tb\" aria-labelledby=\"p-tb-label\">
			<h3 id=\"p-tb-label\">Tools</h3>

			<div class=\"body\">
									<ul>
						<li id=\"t-whatlinkshere\"><a href=\"/emergent/index.php/Special:WhatLinksHere/LeabraFlex\" title=\"A list of all wiki pages that link here [j]\" accesskey=\"j\">What links here</a></li><li id=\"t-recentchangeslinked\"><a href=\"/emergent/index.php/Special:RecentChangesLinked/LeabraFlex\" title=\"Recent changes in pages linked from this page [k]\" accesskey=\"k\">Related changes</a></li><li id=\"t-upload\"><a href=\"/emergent/index.php/Special:Upload\" title=\"Upload files [u]\" accesskey=\"u\">Upload file</a></li><li id=\"t-specialpages\"><a href=\"/emergent/index.php/Special:SpecialPages\" title=\"A list of all special pages [q]\" accesskey=\"q\">Special pages</a></li><li id=\"t-permalink\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;oldid=11194\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=info\" title=\"More information about this page\">Page information</a></li><li id=\"t-smwbrowselink\"><a href=\"/emergent/index.php/Special:Browse/LeabraFlex\" rel=\"smw-browse\">Browse properties</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-coll-print_export\" aria-labelledby=\"p-coll-print_export-label\">
			<h3 id=\"p-coll-print_export-label\">Print/export</h3>

			<div class=\"body\">
									<ul>
						<li id=\"coll-create_a_book\"><a href=\"/emergent/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=LeabraFlex\">Create a book</a></li><li id=\"coll-download-as-rl\"><a href=\"/emergent/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=LeabraFlex&amp;oldid=11194&amp;writer=rl\">Download as PDF</a></li><li id=\"t-print\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;printable=yes\" title=\"Printable version of this page [p]\" accesskey=\"p\">Printable version</a></li>					</ul>
							</div>
		</div>
				</div>
		</div>
		<div id=\"footer\" role=\"contentinfo\">
							<ul id=\"footer-info\">
											<li id=\"footer-info-lastmod\"> This page was last modified on 4 September 2015, at 02:19.</li>
									</ul>
							<ul id=\"footer-places\">
											<li id=\"footer-places-about\"><a href=\"/emergent/index.php/emergent:About\" title=\"emergent:About\">About emergent</a></li>
									</ul>
										<ul id=\"footer-icons\" class=\"noprint\">
											<li id=\"footer-poweredbyico\">
							<a href=\"//www.mediawiki.org/\"><img src=\"/emergent/resources/assets/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\" srcset=\"/emergent/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /emergent/resources/assets/poweredby_mediawiki_176x62.png 2x\" width=\"88\" height=\"31\"></a><a href=\"https://www.semantic-mediawiki.org/wiki/Semantic_MediaWiki\"><img src=\"/emergent/extensions/SemanticMediaWiki/resources/images/smw_button.png\" alt=\"Powered by Semantic MediaWiki\" width=\"88\" height=\"31\"></a>						</li>
									</ul>
						<div style=\"clear:both\"></div>
		</div>
		<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.loader.state({\"user\":\"ready\",\"user.groups\":\"ready\"});mw.loader.load([\"mediawiki.toc\",\"mediawiki.action.view.postEdit\",\"site\",\"mediawiki.user\",\"mediawiki.hidpi\",\"mediawiki.page.ready\",\"mediawiki.searchSuggest\",\"mediawiki.page.watch.ajax\",\"ext.headertabs\"]);
} );</script><script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgBackendResponseTime\":192});
} );</script>
	

</body></html>";
  };
  taDoc @[1] {
   name="ChangeLog";
   desc=;
   web_doc=0;
   wiki=;
   url="local";
   full_url="local";
   text_size=1;
   text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>


<li>Sat Mar  4 02:19:15 2017 version: 8.0.3 user: oreilly file_name: <code>LeabraFlexParamSetExperiment.proj</code> <br>
svn rev: 10514 update startup program



<li>Fri Feb 17 01:20:30 2017 version: 8.0.2 user: oreilly file_name: <code>LeabraFlexParamSetExperiment.proj</code> <br>
svn rev: 10489 actually remove the config table finally


<li>Fri Feb 17 01:19:23 2017 version: 8.0.1 user: oreilly file_name: <code>LeabraFlexParamSetExperiment.proj</code> <br>
leabra flex using param sets experiment project -- updated by randy from John's original, to remove the config table entirely, and use StdGlobal where relevant
</ul>
</body>
</html>
";
   html_text="<html>
<head>ChangeLog</head>
<body>
<h1>ChangeLog</h1>
<ul>
<P>
<P>
<li>Sat Mar  4 02:19:15 2017 version: 8.0.3 user: oreilly file_name: <code>LeabraFlexParamSetExperiment.proj</code> <br>
svn rev: 10514 update startup program
<P>
<P>
<P>
<li>Fri Feb 17 01:20:30 2017 version: 8.0.2 user: oreilly file_name: <code>LeabraFlexParamSetExperiment.proj</code> <br>
svn rev: 10489 actually remove the config table finally
<P>
<P>
<li>Fri Feb 17 01:19:23 2017 version: 8.0.1 user: oreilly file_name: <code>LeabraFlexParamSetExperiment.proj</code> <br>
leabra flex using param sets experiment project -- updated by randy from John's original, to remove the config table entirely, and use StdGlobal where relevant
</ul>
</body>
</html>
";
  };
 };
 wizards {
  name="wizards";
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="NO_CLIP": value=1: val_type_fixed=0: };
   };
   name="LeabraWizard_1";
  };
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  master_and_clones=0;
  ClusterRun @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ClusterRun";
   cp_state=REGULAR;
   updt_while_running=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
    ControlPanelMember @[0] {
     label="run_params";
     short_label=1;
     cust_label=0;
     desc="select parameters for controlling how network is run";
     cust_desc=0;
     base=.programs.gp[1][1].vars[1]$$;
     mbr=ProgVar::object_val;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="set to explore for name to be added to tag": };
    };
    ControlPanelMember @[1] {
     label="net_params";
     short_label=1;
     cust_label=0;
     desc="select other parameters, typically network spec params -- independent of run params";
     cust_desc=0;
     base=.programs.gp[1][1].vars[2]$$;
     mbr=ProgVar::object_val;
     data {ctrl_type=CLUSTER_RUN: is_numeric=0: is_single=1: state=EXPLORE: saved_value="": range="": notes="": };
    };
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=1;
   proj_name="param_search";
   auto_updt_interval=10;
   auto_updt_timeout=30;
   cluster="dream";
   clusters="dream";
   users="oreilly";
   last_submit_time="2017_02_08_21_14_24";
   notes="testing param_set config idea";
   label=;
   extra_files=;
   svn_repo="grey_run";
   repo_url="https://grey.colorado.edu/svn/clusterun";
   queue=;
   run_time="1h";
   exe_cmd="emergent";
   ram_gb=0;
   n_threads=2;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=1;
   enable_notes=1;
  };
  ControlPanel @[1] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
   };
   name="ControlPanel";
   cp_state=REGULAR;
   updt_while_running=0;
   desc="main control panel for the system";
   mbrs {
    name="mbrs";
    el_typ=ControlPanelMember;
    el_def=0;
    ControlPanelMember @[0] {
     label="activate_params";
     short_label=1;
     cust_label=0;
     desc="whether to activate selected param sets at start of train -- otherwise just uses current values as-is";
     cust_desc=0;
     base=.programs.gp[1][1].vars[0]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="true": range="": notes="should MasterTrain activate param sets at start": };
    };
    ControlPanelMember @[1] {
     label="run_params";
     short_label=1;
     cust_label=0;
     desc="select parameters for controlling how network is run";
     cust_desc=0;
     base=$.programs.gp[1][1].vars[1]$;
     mbr=ProgVar::object_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value=".projects[\"LeabraFlexParamSetExperiment\"].active_params.gp[\"RunParams\"][\"SpecialTrain\"]": range="": notes="MasterTrain sets these params at start": };
    };
    ControlPanelMember @[2] {
     label="net_params";
     short_label=1;
     cust_label=0;
     desc="select other parameters, typically network spec params -- independent of run params";
     cust_desc=0;
     base=$.programs.gp[1][1].vars[2]$;
     mbr=ProgVar::object_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value=".projects[\"LeabraFlexParamSetExperiment\"].active_params.gp[\"MiscParams\"][\"MiscOne\"]": range="": notes="add extra params as needed..": };
    };
    ControlPanelMember @[3] {
     label="master_run_stop_step_grain";
     short_label=0;
     cust_label=0;
     desc="select grain size for Step function on MasterRun program -- can extend this functionality -- very useful!";
     cust_desc=0;
     base=.programs.gp[1][2].vars[0].dyn_enum_val$$;
     mbr=DynEnum::value;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="0": range="0:1:0.1": notes="MasterRun step can do many different things -- very useful!": };
    };
    ControlPanelMember @[4] {
     label="network_cycle_qtr";
     short_label=0;
     cust_label=1;
     desc="[Default: true]  one CycleRun runs for a full quarter number of actual cycles -- this greatly speeds up processing by reducing threading overhead, but prevents e.g., interactive viewing at the individual cycle level -- this is not saved -- have to re-engage it when needed, to prevent unintentionally slowing everything down";
     cust_desc=0;
     base=.networks[0].times$$;
     mbr=LeabraTimes::cycle_qtr;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="true": range="0:1:0.1": notes="turn OFF to see individual cycles, ON for MUCH faster running": };
    };
    ControlPanelMember @[5] {
     label="cycle_update_net_view";
     short_label=0;
     cust_label=0;
     desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
     cust_desc=0;
     base=.programs.gp[4][14].vars[0]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="true": range="0:1:0.1": notes="update network view at cycle level -- actual value depends on cycle_qtr": };
    };
    ControlPanelMember @[6] {
     label="quarter_update_net_view";
     short_label=0;
     cust_label=0;
     desc="if true, will update network views at end of settling";
     cust_desc=0;
     base=.programs.gp[4][13].vars[1]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="false": range="": notes="redundant with cycle for cycle_qtr = ON": };
    };
    ControlPanelMember @[7] {
     label="trial_update_net_view";
     short_label=0;
     cust_label=0;
     desc="determines whether to update any network view displays after trial is completed";
     cust_desc=0;
     base=.programs.gp[4][12].vars[0]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="false": range="": notes="mostly redundant but some updates happen after trial": };
    };
    ControlPanelMember @[8] {
     label="save_log_files_interactive";
     short_label=1;
     cust_label=0;
     desc="save log files when running interactively?";
     cust_desc=0;
     base=.programs.gp[4][4].vars[8]$$;
     mbr=ProgVar::bool_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="false": range="": notes="save log files while running interactively": };
    };
    ControlPanelMember @[9] {
     label="cust_tag";
     short_label=1;
     cust_label=0;
     desc="add any custom tag string here -- used for labeling log and weight files along with config info";
     cust_desc=0;
     base=.programs.gp[1][1].vars[7]$$;
     mbr=ProgVar::string_val;
     data {ctrl_type=CONTROL: is_numeric=0: is_single=1: state=EXPLORE: saved_value="mtau10_mrg1st.5": range="": notes="update this to label log files -- will also be labeled with config names ": };
    };
   };
   mths {
    name="mths";
    el_typ=ControlPanelMethod;
    el_def=0;
    group_type=GT_BUTTONS;
    ControlPanelMethod @[0] {
     label="Init";
     short_label=0;
     cust_label=0;
     desc=" run init_code, global variables retain current values unless reset in the init_code";
     cust_desc=0;
     base=.programs.gp[1][1]$$;
     mth=Program::Init;
    };
    ControlPanelMethod @[1] {
     label="Run";
     short_label=0;
     cust_label=0;
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.programs.gp[1][1]$;
     mth=Program::Run_Gui;
    };
    ControlPanelMethod @[2] {
     label="Step";
     short_label=0;
     cust_label=0;
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.programs.gp[1][1]$;
     mth=Program::Step_Gui;
    };
    ControlPanelMethod @[3] {
     label="Stop";
     short_label=0;
     cust_label=0;
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.programs.gp[1][1]$;
     mth=Program::Stop;
    };
   };
  };
 };
 active_params {
  name="active_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
  ParamSet_Group @.gp[0] {
   name="RunParams";
   el_typ=ParamSet;
   el_def=0;
   master_and_clones=1;
   ParamSet @[0] {
    name="RunMaster";
    cp_state=MASTER;
    updt_while_running=0;
    desc="default values for basic training parameters -- this is a 'master' param set -- make changes here and all others in group will auto-update";
    mbrs {
     name="mbrs";
     el_typ=ControlPanelMember;
     el_def=0;
     ControlPanelMember @[0] {
      label="run_prog";
      short_label=1;
      cust_label=0;
      desc="name of run program to run -- must exist in the RunProgs group";
      cust_desc=0;
      base=.programs.gp[1][1].vars[3]$$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="BasicRun": range="": notes="": };
     };
     ControlPanelMember @[1] {
      label="init_prog";
      short_label=1;
      cust_label=0;
      desc="name of init program -- must exist in the InitProgs group";
      cust_desc=0;
      base=.programs.gp[1][1].vars[4]$$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="BasicInit": range="": notes="": };
     };
     ControlPanelMember @[2] {
      label="startup_prog";
      short_label=1;
      cust_label=0;
      desc="additional configuration-specific startup code to run, in the StartupProgs -- any global startup stuff should still be in MasterStartup -- this should only be for startup that is specific to a particular configuration (rare)";
      cust_desc=0;
      base=.programs[0].vars[7]$$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="BasicStartup": range="": notes="": };
     };
     ControlPanelMember @[3] {
      label="train_epochs";
      short_label=1;
      cust_label=0;
      desc="number of epochs to train network for";
      cust_desc=0;
      base=.programs.gp[4][4].vars[10]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="50": range="": notes="": };
     };
     ControlPanelMember @[4] {
      label="trials_per_epoch";
      short_label=1;
      cust_label=0;
      desc="number of trials per epoch";
      cust_desc=0;
      base=.programs.gp[4][4].vars[11]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="50": range="": notes="": };
     };
     ControlPanelMember @[5] {
      label="save_final_wts";
      short_label=1;
      cust_label=0;
      desc="should final weights after training is complete be saved?";
      cust_desc=0;
      base=.programs.gp[4][5].vars[0]$$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="true": range="": notes="": };
     };
     ControlPanelMember @[6] {
      label="save_wts_interval";
      short_label=1;
      cust_label=0;
      desc="how frequently (epochs) to save weights during training";
      cust_desc=0;
      base=.programs.gp[4][7].vars[0]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="200": range="": notes="": };
     };
     ControlPanelMember @[7] {
      label="test_run";
      short_label=1;
      cust_label=0;
      desc="is this a testing-only run, no training?";
      cust_desc=0;
      base=.programs.gp[4][4].vars[13]$$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[8] {
      label="test_interval";
      short_label=1;
      cust_label=0;
      desc="how frequently (epochs) to run a test during training";
      cust_desc=0;
      base=.programs.gp[4][4].vars[14]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="1": range="": notes="": };
     };
     ControlPanelMember @[9] {
      label="log_trials";
      short_label=1;
      cust_label=0;
      desc="should trial-level data be saved to log files?";
      cust_desc=0;
      base=.programs.gp[4].gp[0][0].vars[1]$$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[10] {
      label="load_weights";
      short_label=1;
      cust_label=0;
      desc="load initial weights from a file (specified in weights_file)";
      cust_desc=0;
      base=.programs.gp[4][4].vars[1]$$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[11] {
      label="weights_file";
      short_label=1;
      cust_label=0;
      desc="full relative path (from project) of weights file to load -- use CRR: prefix to load from cluster run results directory";
      cust_desc=0;
      base=.programs.gp[4][4].vars[2]$$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="": range="": notes="": };
     };
     ControlPanelMember @[12] {
      label="load_st_epc";
      short_label=1;
      cust_label=0;
      desc="after loading weights, reset epoch counter to this value (-1 = leave at value from the loaded weights)";
      cust_desc=0;
      base=.programs.gp[4][4].vars[3]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="1": range="": notes="": };
     };
     ControlPanelMember @[13] {
      label="lrs_step_epochs";
      short_label=1;
      cust_label=0;
      desc="learning rate schedule epochs per step of decrease in learning rate";
      cust_desc=0;
      base=.programs.gp[4][4].vars[4]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="50": range="": notes="": };
     };
     ControlPanelMember @[14] {
      label="lrs_n_steps";
      short_label=1;
      cust_label=0;
      desc="number of steps in the learning rate schedule";
      cust_desc=0;
      base=.programs.gp[4][4].vars[5]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="7": range="": notes="": };
     };
     ControlPanelMember @[15] {
      label="lrs_bump_step";
      short_label=1;
      cust_label=0;
      desc="if positive (3 is typical), then bump up the learning rate at this step in the schedule -- can help improve final performance level";
      cust_desc=0;
      base=.programs.gp[4][4].vars[6]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="-1": range="": notes="": };
     };
     ControlPanelMember @[16] {
      label="n_batches";
      short_label=1;
      cust_label=0;
      desc="number of batches to run";
      cust_desc=0;
      base=.programs.gp[1][0].vars[2]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="1": range="": notes="": };
     };
     ControlPanelMember @[17] {
      label="batch_start";
      short_label=1;
      cust_label=0;
      desc="batch number to start on";
      cust_desc=0;
      base=.programs.gp[1][0].vars[1]$$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="0": range="": notes="": };
     };
    };
    mths {
     name="mths";
     el_typ=ControlPanelMethod;
     el_def=0;
     group_type=GT_BUTTONS;
    };
    date="2017_04_06_01_23_37";
   };
   ParamSet @[1] {
    name="RunConfig1";
    cp_state=CLONE;
    updt_while_running=0;
    desc="another configuration of run parameters to choose from.. make as many as you need!  this is a 'clone' of the master and will auto-update for any additions or changes to members";
    mbrs {
     name="mbrs";
     el_typ=ControlPanelMember;
     el_def=0;
     ControlPanelMember @[0] {
      label="run_prog";
      short_label=1;
      cust_label=0;
      desc="name of run program to run -- must exist in the RunProgs group";
      cust_desc=0;
      base=$.programs.gp[1][1].vars[3]$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="BasicRun": range="": notes="": };
     };
     ControlPanelMember @[1] {
      label="init_prog";
      short_label=1;
      cust_label=0;
      desc="name of init program -- must exist in the InitProgs group";
      cust_desc=0;
      base=$.programs.gp[1][1].vars[4]$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="BasicInit": range="": notes="": };
     };
     ControlPanelMember @[2] {
      label="startup_prog";
      short_label=1;
      cust_label=0;
      desc="additional configuration-specific startup code to run, in the StartupProgs -- any global startup stuff should still be in MasterStartup -- this should only be for startup that is specific to a particular configuration (rare)";
      cust_desc=0;
      base=$.programs[0].vars[7]$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="BasicStartup": range="": notes="": };
     };
     ControlPanelMember @[3] {
      label="train_epochs";
      short_label=1;
      cust_label=0;
      desc="number of epochs to train network for";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[10]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="5": range="": notes="": };
     };
     ControlPanelMember @[4] {
      label="trials_per_epoch";
      short_label=1;
      cust_label=0;
      desc="number of trials per epoch";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[11]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="25": range="": notes="": };
     };
     ControlPanelMember @[5] {
      label="save_final_wts";
      short_label=1;
      cust_label=0;
      desc="should final weights after training is complete be saved?";
      cust_desc=0;
      base=$.programs.gp[4][5].vars[0]$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[6] {
      label="save_wts_interval";
      short_label=1;
      cust_label=0;
      desc="how frequently (epochs) to save weights during training";
      cust_desc=0;
      base=$.programs.gp[4][7].vars[0]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="200": range="": notes="": };
     };
     ControlPanelMember @[7] {
      label="test_run";
      short_label=1;
      cust_label=0;
      desc="is this a testing-only run, no training?";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[13]$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[8] {
      label="test_interval";
      short_label=1;
      cust_label=0;
      desc="how frequently (epochs) to run a test during training";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[14]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="1": range="": notes="": };
     };
     ControlPanelMember @[9] {
      label="log_trials";
      short_label=1;
      cust_label=0;
      desc="should trial-level data be saved to log files?";
      cust_desc=0;
      base=$.programs.gp[4].gp[0][0].vars[1]$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[10] {
      label="load_weights";
      short_label=1;
      cust_label=0;
      desc="load initial weights from a file (specified in weights_file)";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[1]$;
      mbr=ProgVar::bool_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="false": range="": notes="": };
     };
     ControlPanelMember @[11] {
      label="weights_file";
      short_label=1;
      cust_label=0;
      desc="full relative path (from project) of weights file to load -- use CRR: prefix to load from cluster run results directory";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[2]$;
      mbr=ProgVar::string_val;
      data {ctrl_type=PARAM_SET: is_numeric=0: is_single=1: state=STABLE: saved_value="": range="": notes="": };
     };
     ControlPanelMember @[12] {
      label="load_st_epc";
      short_label=1;
      cust_label=0;
      desc="after loading weights, reset epoch counter to this value (-1 = leave at value from the loaded weights)";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[3]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="1": range="": notes="": };
     };
     ControlPanelMember @[13] {
      label="lrs_step_epochs";
      short_label=1;
      cust_label=0;
      desc="learning rate schedule epochs per step of decrease in learning rate";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[4]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="50": range="": notes="": };
     };
     ControlPanelMember @[14] {
      label="lrs_n_steps";
      short_label=1;
      cust_label=0;
      desc="number of steps in the learning rate schedule";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[5]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="7": range="": notes="": };
     };
     ControlPanelMember @[15] {
      label="lrs_bump_step";
      short_label=1;
      cust_label=0;
      desc="if positive (3 is typical), then bump up the learning rate at this step in the schedule -- can help improve final performance level";
      cust_desc=0;
      base=$.programs.gp[4][4].vars[6]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="-1": range="": notes="": };
     };
     ControlPanelMember @[16] {
      label="n_batches";
      short_label=1;
      cust_label=0;
      desc="number of batches to run";
      cust_desc=0;
      base=$.programs.gp[1][0].vars[2]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="1": range="": notes="": };
     };
     ControlPanelMember @[17] {
      label="batch_start";
      short_label=1;
      cust_label=0;
      desc="batch number to start on";
      cust_desc=0;
      base=$.programs.gp[1][0].vars[1]$;
      mbr=ProgVar::int_val;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="0": range="": notes="": };
     };
    };
    mths {
     name="mths";
     el_typ=ControlPanelMethod;
     el_def=0;
     group_type=GT_BUTTONS;
    };
    date=;
   };
  };
  ParamSet_Group @.gp[1] {
   name="NetParams";
   el_typ=ParamSet;
   el_def=0;
   master_and_clones=1;
   ParamSet @[0] {
    name="NetMaster";
    cp_state=MASTER;
    updt_while_running=0;
    desc="Network params -- this contains default values for all params -- this is a 'master' param set -- make changes here and all others in group will auto-update";
    mbrs {
     name="mbrs";
     el_typ=ControlPanelMember;
     el_def=0;
     ControlPanelMember @[0] {
      label="leabra_con_spec_0_lrate";
      short_label=0;
      cust_label=0;
      desc="[Default: 0.04]  learning rate -- how fast the weights change per experience -- since version 7.8.5, a hidden factor of 2 has been removed, so this should be 2x what you used to use previously (e.g., default used to be .02, now is .04) -- this governs the rate of change for the fastest adapting weights -- see slow_wts for a more slowly adapting factor";
      cust_desc=0;
      base=.networks[0].specs[2]$$;
      mbr=LeabraConSpec::lrate;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="0.04": range="0:1:0.1": notes="": };
     };
    };
    mths {
     name="mths";
     el_typ=ControlPanelMethod;
     el_def=0;
     group_type=GT_BUTTONS;
    };
    date="2017_04_06_01_23_37";
   };
   ParamSet @[1] {
    name="NetConfig1";
    cp_state=CLONE;
    updt_while_running=0;
    desc="another configuration of misc parameters to choose from.. make as many as you need!  this is a 'clone' of the master and will auto-update for any additions or changes to members";
    mbrs {
     name="mbrs";
     el_typ=ControlPanelMember;
     el_def=0;
     ControlPanelMember @[0] {
      label="leabra_con_spec_0_lrate";
      short_label=0;
      cust_label=0;
      desc="[Default: 0.04]  learning rate -- how fast the weights change per experience -- since version 7.8.5, a hidden factor of 2 has been removed, so this should be 2x what you used to use previously (e.g., default used to be .02, now is .04) -- this governs the rate of change for the fastest adapting weights -- see slow_wts for a more slowly adapting factor";
      cust_desc=0;
      base=$.networks[0].specs[2]$;
      mbr=LeabraConSpec::lrate;
      data {ctrl_type=PARAM_SET: is_numeric=1: is_single=1: state=STABLE: saved_value="0.02": range="0:1:0.1": notes="": };
     };
    };
    mths {
     name="mths";
     el_typ=ControlPanelMethod;
     el_def=0;
     group_type=GT_BUTTONS;
    };
    date=;
   };
  };
 };
 archived_params {
  name="archived_params";
  el_typ=ParamSet;
  el_def=0;
  master_and_clones=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp[0] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="StdInputData";
    desc="basic input data table";
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     String_Data @[0] {
      name="Name";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
      ar {
       name="ar";
      [6] "checks";"mitvert";"midhoriz";"rdiag";"ldiag";"random";      };
     };
     float_Data @[1] {
      name="Output";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=6;
      matrix_col_width=10;
      ar {
       name="ar";
      [5 5 6] 1;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;1;0;0;1;
1;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @[2] {
      name="Input";
      col_flags=SAVE_DATA|AUTO_WIDTH;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=5;
      matrix_col_width=10;
      ar {
       name="ar";
      [5 5 6] 1;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;1;0;0;0;
1;0;0;0;1;0;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [6] 0;1;2;3;4;5;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[1] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[1] {
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[2] {
      name="train_mode";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     int_Data @[3] {
      name="group";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[4] {
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[5] {
      name="tick";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[6] {
      name="time";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[7] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     String_Data @[8] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     String_Data @[9] {
      name="output_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[10] {
      name="rt_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=9;
      matrix_col_width=10;
     };
     float_Data @[11] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[12] {
      name="norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[13] {
      name="cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[14] {
      name="ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[15] {
      name="Output_lay_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[16] {
      name="Output_lay_bin_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[17] {
      name="Output_lay_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[18] {
      name="Output_lay_cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[19] {
      name="Hidden_lay_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[20] {
      name="Output_lay_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[21] {
      name="net_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
     };
     float_Data @[22] {
      name="net_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[23] {
      name="net_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[24] {
      name="Hidden_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
     };
     float_Data @[25] {
      name="Output_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
     };
     float_Data @[26] {
      name="Hidden_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=21;
      matrix_col_width=10;
     };
     float_Data @[27] {
      name="Output_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=21;
      matrix_col_width=10;
     };
     float_Data @[28] {
      name="Hidden_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[29] {
      name="Output_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[1] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[1] {
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[4] {
      name="pct_cor";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[5] {
      name="pct_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[6] {
      name="avg_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
     };
     float_Data @[7] {
      name="avg_cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
     };
     float_Data @[8] {
      name="avg_ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
     };
     float_Data @[9] {
      name="avg_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=10;
      matrix_col_width=10;
     };
     float_Data @[10] {
      name="epoch_time_tot";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[11] {
      name="epoch_time_usr";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[12] {
      name="Output_lay_avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[13] {
      name="Output_lay_cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[14] {
      name="Output_lay_pct_cor";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[15] {
      name="Output_lay_pct_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[16] {
      name="Output_lay_avg_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[17] {
      name="Output_lay_avg_cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=22;
      matrix_col_width=10;
     };
     float_Data @[18] {
      name="net_avg_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[19] {
      name="net_avg_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=22;
      matrix_col_width=10;
     };
     float_Data @[20] {
      name="net_avg_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=20;
      matrix_col_width=10;
     };
     float_Data @[21] {
      name="Hidden_avg_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[22] {
      name="Output_avg_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[23] {
      name="Hidden_avg_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=25;
      matrix_col_width=10;
     };
     float_Data @[24] {
      name="Output_avg_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=25;
      matrix_col_width=10;
     };
     float_Data @[25] {
      name="Hidden_avg_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[26] {
      name="Output_avg_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[27] {
      name="Hidden_avg_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[28] {
      name="Output_avg_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[29] {
      name="Hidden_hog_pct";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[30] {
      name="Output_hog_pct";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[31] {
      name="Hidden_dead_pct";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
     };
     float_Data @[32] {
      name="Output_dead_pct";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
     };
     float_Data @[33] {
      name="Hidden_netmax";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
     };
     float_Data @[34] {
      name="Output_netmax";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
     };
     float_Data @[35] {
      name="Input_avg_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
     };
     float_Data @[36] {
      name="Hidden_avg_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[37] {
      name="Output_avg_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[38] {
      name="Hidden_Fm_Input_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=22;
      matrix_col_width=10;
     };
     float_Data @[39] {
      name="Hidden_Fm_Output_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[40] {
      name="Output_Fm_Hidden_netrel";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[2] {
    name="TestTrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[1] {
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[2] {
      name="train_mode";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     int_Data @[3] {
      name="group";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[4] {
      name="trial";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[5] {
      name="tick";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[6] {
      name="time";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     String_Data @[7] {
      name="trial_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     String_Data @[8] {
      name="group_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     String_Data @[9] {
      name="output_name";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[10] {
      name="rt_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=9;
      matrix_col_width=10;
     };
     float_Data @[11] {
      name="sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[12] {
      name="norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[13] {
      name="cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[14] {
      name="ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[15] {
      name="Output_lay_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[16] {
      name="Output_lay_bin_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[17] {
      name="Output_lay_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[18] {
      name="Output_lay_cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[19] {
      name="Hidden_lay_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[20] {
      name="Output_lay_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[21] {
      name="net_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
     };
     float_Data @[22] {
      name="net_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[23] {
      name="net_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[24] {
      name="Hidden_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
     };
     float_Data @[25] {
      name="Output_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=15;
      matrix_col_width=10;
     };
     float_Data @[26] {
      name="Hidden_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=21;
      matrix_col_width=10;
     };
     float_Data @[27] {
      name="Output_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=21;
      matrix_col_width=10;
     };
     float_Data @[28] {
      name="Hidden_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[29] {
      name="Output_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
   DataTable @[3] {
    name="TestEpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @[0] {
      name="batch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     int_Data @[1] {
      name="epoch";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[2] {
      name="avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[3] {
      name="cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[4] {
      name="pct_cor";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[5] {
      name="pct_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=8;
      matrix_col_width=10;
     };
     float_Data @[6] {
      name="avg_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=12;
      matrix_col_width=10;
     };
     float_Data @[7] {
      name="avg_cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
     };
     float_Data @[8] {
      name="avg_ext_rew";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=11;
      matrix_col_width=10;
     };
     float_Data @[9] {
      name="avg_cycles";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=10;
      matrix_col_width=10;
     };
     float_Data @[10] {
      name="Output_lay_avg_sse";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[11] {
      name="Output_lay_cnt_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[12] {
      name="Output_lay_pct_cor";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[13] {
      name="Output_lay_pct_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=18;
      matrix_col_width=10;
     };
     float_Data @[14] {
      name="Output_lay_avg_norm_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[15] {
      name="Output_lay_avg_cos_err";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=22;
      matrix_col_width=10;
     };
     float_Data @[16] {
      name="net_avg_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=16;
      matrix_col_width=10;
     };
     float_Data @[17] {
      name="net_avg_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=22;
      matrix_col_width=10;
     };
     float_Data @[18] {
      name="net_avg_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=20;
      matrix_col_width=10;
     };
     float_Data @[19] {
      name="Hidden_avg_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[20] {
      name="Output_avg_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=19;
      matrix_col_width=10;
     };
     float_Data @[21] {
      name="Hidden_avg_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=25;
      matrix_col_width=10;
     };
     float_Data @[22] {
      name="Output_avg_trial_cos_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=25;
      matrix_col_width=10;
     };
     float_Data @[23] {
      name="Hidden_avg_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[24] {
      name="Output_avg_avg_act_diff";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=23;
      matrix_col_width=10;
     };
     float_Data @[25] {
      name="Hidden_avg_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[26] {
      name="Output_avg_net_sd";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=17;
      matrix_col_width=10;
     };
     float_Data @[27] {
      name="Hidden_netmax";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
     };
     float_Data @[28] {
      name="Output_netmax";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
     };
     float_Data @[29] {
      name="Input_avg_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=13;
      matrix_col_width=10;
     };
     float_Data @[30] {
      name="Hidden_avg_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
     float_Data @[31] {
      name="Output_avg_act";
      col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=14;
      matrix_col_width=10;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    row_height=1;
    max_col_width=50;
    keygen 4 0=0;
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    row_with_hilite=-1;
   };
  };
  DataTable_Group @.gp[2] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp[3] {
   name="ClusterRun";
   el_typ=DataTable;
   el_def=0;
   save_tables=0;
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserData_DocLink;
    el_def=0;
    UserData_DocLink @[0] {name="DocLink": doc=.programs[0].doc$$: };
   };
   name="MasterStartup";
   short_nm="Startup";
   tags="Leabra, Startup";
   desc="run project in the background (replaces leabra_startup.css)

command line is: emergent -nowin -ni -p <project name>.proj [enviro=xxx] [tag=xxx]";
   version {
    major=0;
    minor=0;
    step=0;
   };
   author="Randall C. O'Reilly";
   email="emergent-users@grey.colorado.edu";
   flags=STARTUP_RUN;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=.networks[0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="network to operate on -- updates batch counter on network and passes it to train program";
     init_from=NULL;
    };
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="batch_prog";
     var_type=T_Object;
     object_type=Program;
     object_val=.programs.gp[1][0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="set this to point to your batch process";
     init_from=NULL;
    };
    ProgVar @[1] {
     name="tag";
     var_type=T_String;
     string_val="_RunMaster_NetMaster";
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="log_dir";
     var_type=T_String;
     string_val=;
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="log file directory";
     init_from=NULL;
    };
    ProgVar @[3] {
     name="log_file_nm";
     var_type=T_String;
     string_val="/Users/oreilly/emergent/proj_templates/LeabraFlex_RunMaster_NetMaster.args";
     object_scope=NULL;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of log file";
     init_from=NULL;
    };
    ProgVar @[4] {
     name="EpochOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.data.gp[1][1]$$;
     object_scope=.data.gp[1]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="batch_str";
     var_type=T_String;
     string_val="00";
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch number as a string (leading zeros)";
     init_from=NULL;
    };
    ProgVar @[6] {
     name="batch_start";
     var_type=T_Int;
     int_val=0;
     object_scope=NULL;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch starting number";
     init_from=NULL;
    };
    ProgVar @[7] {
     name="startup_prog";
     var_type=T_String;
     string_val="BasicStartup";
     object_scope=NULL;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="additional configuration-specific startup code to run, in the StartupProgs -- any global startup stuff should still be in MasterStartup -- this should only be for startup that is specific to a particular configuration (rare)";
     init_from=NULL;
    };
    ProgVar @[8] {
     name="MyClusterRun";
     var_type=T_Object;
     object_type=ClusterRun;
     object_val=.ctrl_panels[0]$$;
     object_scope=NULL;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    RegisterArgs @[0] {
     name="RegisterArgs_RegisterArgs";
     desc="This is KEY!!! actually processes all args, including those from ProgVarFmArg guys below";
     flags=CAN_REVERT_TO_CODE;
     code_string="Register Args";
    };
    PrintExpr @[1] {
     name="PrintExpr_PrintLoadedproje_ojects0filename";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Loaded project: \" << .projects[0].file_name";
     expr {
      expr="\"Loaded project: \" << .projects[0].file_name";
     };
     debug=0;
    };
    Comment @[2] {
     name="Comment_Stdvariablesinst_upprogramitself";
     desc="= Std variables in startup program itself =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Std variables in startup program itself =";
    };
    AssignExpr @[3] {
     name="AssignExpr_tag";
     desc="start with empty tag in all cases";
     flags=CAN_REVERT_TO_CODE;
     code_string="tag = \"\"";
     result_var=.programs[0].vars[1]$$;
     expr {
      expr="\"\"";
     };
    };
    ProgVarFmArg @[4] {
     name="ProgVarFmArg_SetVartaginProgr_artupfromArgtag";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:tag in Program:MasterStartup from Arg:tag";
     prog=.programs[0]$$;
     var_name="tag";
     arg_name="tag";
    };
    ProgVarFmArg @[5] {
     name="ProgVarFmArg_SetVarlogdirinPr_upfromArglogdir";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:log_dir in Program:MasterStartup from Arg:log_dir";
     prog=$.programs[0]$;
     var_name="log_dir";
     arg_name="log_dir";
    };
    Comment @[6] {
     name="Comment_addourspecialargsfromcommandline";
     desc="add our special args from command line";
     flags=CAN_REVERT_TO_CODE;
     code_string="// add our special args from command line";
    };
    MethodCall @[7] {
     name="MethodCall_MyClusterRunActivateAlltrue";
     desc="set saved values first, before processing args";
     flags=CAN_REVERT_TO_CODE;
     code_string="run_params.CopySavedToActive()";
     result_var=NULL;
     obj=.programs[0].vars[8]$$;
     method=ControlPanel::ActivateAll;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="info_msg";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void ActivateAll(bool info_msg = true)";
     meth_desc=" activate all of the parameter sets on this and any linked param set objects -- copies the saved_value values to be the active (live) values for all parameters -- this one call can be used on a master ClusterRun or ControlPanel to activate everything in Startup program, for example -- info_msg emits a message about each ParamSet as it is activated";
    };
    ControlPanelsFmArgs @[8] {
     name="ControlPanelsFmArgs_CtrlPanelFmArgsvarMyClusterRun";
     desc="also gets any params from linked control panels";
     flags=CAN_REVERT_TO_CODE;
     code_string="CtrlPanel Fm Args: var = MyClusterRun ";
     ctrl_panel_var=$.programs[0].vars[8]$;
    };
    AssignExpr @[9] {
     name="AssignExpr_tagMyClusterRunParamSetNamestag";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="tag = \"_\" +  config_id + tag";
     result_var=$.programs[0].vars[1]$;
     expr {
      expr="\"_\" + MyClusterRun->ParamSetNames() + tag";
     };
    };
    Comment @[10] {
     name="Comment_Setlogfiles";
     desc="Set log files";
     flags=CAN_REVERT_TO_CODE;
     code_string="// Set log files";
    };
    If @[11] {
     name="If_iftaMiscCheckArgByNamebatchstart";
     desc="set tag for starting batch (new code in v 8.0)";
     flags=CAN_REVERT_TO_CODE;
     code_string="if (taMisc::CheckArgByName(\"batch_start\"))";
     cond {
      expr="taMisc::CheckArgByName(\"batch_start\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ProgVarFmArg @[0] {
       name="ProgVarFmArg_SetVarbatchstart_omArgbatchstart";
       desc="read in the arg to us too, so we can set file names based on it";
       flags=CAN_REVERT_TO_CODE;
       code_string="Set Var:batch_start in Program:MasterStartup from Arg:batch_start";
       prog=$.programs[0]$;
       var_name="batch_start";
       arg_name="batch_start";
      };
      MiscCall @[1] {
       name="MiscCall_batchstrtaMiscLe_erosbatchstart2";
       desc="string version with leading zeros";
       flags=CAN_REVERT_TO_CODE;
       code_string="batch_str = taMisc::LeadingZeros(batch_start, 2)";
       result_var=.programs[0].vars[5]$$;
       object_type=taMisc;
       method=taMisc::LeadingZeros;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="num";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="batch_start";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="len";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="2";
	 };
	};
       };
      };
      VarIncr @[2] {
       name="VarIncr_tagbatchstr";
       desc="add to tag for setting log file names";
       flags=CAN_REVERT_TO_CODE;
       code_string="tag += \".\" + batch_str";
       var=$.programs[0].vars[1]$;
       expr {
	expr="\".\" + batch_str";
       };
      };
      If @[3] {
       name="If_ifbatchstart0";
       desc="save startup args: only for first job in parallel batch mode, or this should be 0 otherwise in any case";
       flags=CAN_REVERT_TO_CODE;
       code_string="if (batch_start == 0)";
       cond {
	expr="batch_start == 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_logfilenmEpochOu_e001logdirfalse";
	 desc="save args to file: last arg is to include dmem proc number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag.before(\".00\",-1), log_dir, false)";
	 result_var=.programs[0].vars[3]$$;
	 obj=.programs[0].vars[4]$$;
	 method=taBase::GetFileNameFmProject;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ext";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\".args\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="tag";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="tag.before(\".00\",-1)";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="subdir";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_dir";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_no";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	 };
	 meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
	 meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
	};
	MiscCall @[1] {
	 name="MiscCall_taMiscFullArgStr_ToFilelogfilenm";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="taMisc::FullArgStringToFile(log_file_nm)";
	 result_var=NULL;
	 object_type=taMisc;
	 method=taMisc::FullArgStringToFile;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="fname";
	   required=1;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_file_nm";
	   };
	  };
	 };
	};
       };
      };
     };
    };
    Else @[12] {
     name="Else_If_iftaMiscCheckArgByNamebatchstart";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     cond {
      expr=;
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_logfilenmEpochOu_staglogdirfalse";
       desc="save args to file: last arg is to include dmem proc number";
       flags=CAN_REVERT_TO_CODE;
       code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag, log_dir, false)";
       result_var=$.programs[0].vars[3]$;
       obj=$.programs[0].vars[4]$;
       method=taBase::GetFileNameFmProject;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ext";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\".args\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="tag";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="tag";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="subdir";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_dir";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_no";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
       meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
      };
      MiscCall @[1] {
       name="MiscCall_taMiscFullArgStr_ToFilelogfilenm";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::FullArgStringToFile(log_file_nm)";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::FullArgStringToFile;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
       };
      };
     };
    };
    OtherProgramVar @[13] {
     name="OtherProgramVar_VarsToprogramSav_tagvar2var3var4";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Vars To:  program=SaveWeights set=to  var_1=tag  var_2=?  var_3=?  var_4=? ";
     other_prog=.programs.gp[4].gp[0][0]$$;
     set_other=1;
     var_1=$.programs[0].vars[1]$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    Comment @[14] {
     name="Comment_Callsubstartupprograms";
     desc="= Call sub-startup programs =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Call sub-startup programs =";
    };
    ProgramCallVar @[15] {
     name="ProgramCallVar_CallFmproggroupS_rtupprognetwork";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Call Fm: prog_group=StartupProgs prog_name_var=startup_prog (network)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     prog_group=.programs.gp[0]$$;
     prog_name_var=$.programs[0].vars[7]$;
    };
    PrintExpr @[16] {
     name="PrintExpr_PrintRunningbatchprogname";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Running: \" << batch_prog.name";
     expr {
      expr="\"Running: \" << batch_prog.name";
     };
     debug=0;
    };
    ProgramCall @[17] {
     name="ProgramCall_MasterBatchnetwork";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="MasterBatch(network)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     target=$.programs.gp[1][0]$;
     targ_ld_init="*MasterBatch*";
    };
   };
   step_prog=.programs.gp[4][14]$$;
   step_n=1;
   doc {
    name="doc";
    desc=;
    web_doc=1;
    wiki="emergent";
    url="Startup_program";
    full_url="https://grey.colorado.edu/emergent/index.php/Startup_program";
    text_size=1;
    text=;
    html_text=;
   };
  };
  Program_Group @.gp[0] {
   name="StartupProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[0][0].doc$$: };
    };
    name="BasicStartup";
    short_nm="BsStrt";
    tags="Leabra, Startup";
    desc="startup args specifically for fixation training parameters";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val="_RunMaster_NetMaster";
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL;
      reference=0;
      desc=;
      init_from=$.programs[0]$;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      name="Comment_thiscanbeusedfor_tiveclusterjobs";
      desc="this can be used for misc startup functions for non-interactive (cluster) jobs";
      flags=CAN_REVERT_TO_CODE;
      code_string="// this can be used for misc startup functions for non-interactive (cluster) jobs";
     };
     Comment @[1] {
      name="Comment_notethatsavinglo_orkisconfigured";
      desc="note that saving log files should happen in SaveLogFiles program, after network is configured";
      flags=CAN_REVERT_TO_CODE;
      code_string="// note that saving log files should happen in SaveLogFiles program, after network is configured";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[1] {
   name="ConfigProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][0].doc$$: };
    };
    name="MasterBatch";
    short_nm="MstBtc";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="batch_start";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch number to start on";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="n_batches";
      var_type=T_Int;
      int_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of batches to run";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitbatch";
      desc="initializes local batch counter and batch field on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: batch";
      network_var=.programs.gp[1][0].args[0]$$;
      local_ctr_var=.programs.gp[1][0].vars[0]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars1vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="i";
	var_type=T_Int;
	int_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     AssignExpr @[1] {
      name="AssignExpr_batchbatchstart";
      desc="start at the start";
      flags=CAN_REVERT_TO_CODE;
      code_string="batch = batch_start";
      result_var=$.programs.gp[1][0].vars[0]$;
      expr {
       expr="batch_start";
      };
     };
     MemberAssign @[2] {
      name="MemberAssign_networkbatchbatch";
      desc="update network";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.batch = batch";
      obj=$.programs.gp[1][0].args[0]$;
      path="batch";
      expr {
       expr="batch";
      };
      update_after=0;
     };
     ForLoop @[3] {
      name="ForLoop_fori0inbatchesi";
      desc="main loop over training runs";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i=0; i<n_batches; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_MasterTrainnetwork";
	desc="run the training program -- sets the network and input_data args";
	flags=CAN_REVERT_TO_CODE;
	code_string="MasterTrain(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[1][1]$;
	targ_ld_init="*MasterTrain*";
       };
       NetCounterIncr @[1] {
	name="NetCounterIncr_NetCounterIncrbatch";
	desc="increment the local batch counter and copy to network";
	flags=CAN_REVERT_TO_CODE;
	code_string="Net Counter Incr: batch";
	network_var=$.programs.gp[1][0].args[0]$;
	local_ctr_var=$.programs.gp[1][0].vars[0]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      init {
       expr="i=0";
      };
      test {
       expr="i<n_batches";
      };
      iter {
       expr="i++";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraBatch";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraBatch";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][1].doc$$: };
    };
    name="MasterTrain";
    short_nm="MstTrn";
    tags=;
    desc="modular event-based train program";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="activate_params";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="whether to activate selected param sets at start of train -- otherwise just uses current values as-is";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="run_params";
      var_type=T_Object;
      object_type=ParamSet;
      object_val=.active_params.gp[0][0]$$;
      object_scope=.active_params.gp[0]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="select parameters for controlling how network is run";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="net_params";
      var_type=T_Object;
      object_type=ParamSet;
      object_val=.active_params.gp[1][0]$$;
      object_scope=.active_params.gp[1]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="select other parameters, typically network spec params -- independent of run params";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="run_prog";
      var_type=T_String;
      string_val="BasicRun";
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of run program to run -- must exist in the RunProgs group";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="init_prog";
      var_type=T_String;
      string_val="BasicInit";
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of init program -- must exist in the InitProgs group";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="cluster_run";
      var_type=T_Object;
      object_type=ClusterRun;
      object_val=$.ctrl_panels[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="used for setting the tag name -- param sets with EXPLORE set will be added to tag";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="save_log_files_interactive";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="save log files when running interactively?";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="cust_tag";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="add any custom tag string here -- used for labeling log and weight files along with config info";
      init_from=NULL;
     };
     ProgVar @[8] {
      name="tag";
      var_type=T_String;
      string_val="__RunMaster_NetMaster";
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[9] {
      name="stop_train";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="set this var from any other program to stop training";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      name="AssignExpr_stoptrainfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="stop_train = false";
      result_var=.programs.gp[1][1].vars[9]$$;
      expr {
       expr="false";
      };
     };
     WtInitPrompt @[1] {
      name="WtInitPrompt_ifguiDoyouwantto_eNetworkWeights";
      desc="don't initialize weights without checking";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (gui && \"Do you want to Initialize Network Weights\")";
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name="yes_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkBuild";
	desc="need to have built network by now in any case, so do it here to make double sure -- prevents errs when loading project with startup program";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	result_var=NULL;
	obj=.programs.gp[1][1].args[0]$$;
	method=Network::Build;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
       MethodCall @[1] {
	name="MethodCall_networkInitWeights";
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.programs.gp[1][1].args[0]$;
	method=Network::Init_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[2] {
	name="PrintExpr_Printnetworkname_ghtsInitialized";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars0vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (0 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
      };
     };
     AssignExpr @[1] {
      name="AssignExpr_stoptrainfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="stop_train = false";
      result_var=$.programs.gp[1][1].vars[9]$;
      expr {
       expr="false";
      };
     };
     If @[2] {
      name="If_iftaMiscinteractive";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::interactive)";
      cond {
       expr="taMisc::interactive";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_tagcusttagcluste_amSetNamesfalse";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="tag = \"_\" + cust_tag + \"_\" + cluster_run->ParamSetNames(false)";
	result_var=.programs.gp[1][1].vars[8]$$;
	expr {
	 expr="\"_\" + cust_tag + \"_\" + cluster_run->ParamSetNames(false)";
	};
       };
       OtherProgramVar @[1] {
	name="OtherProgramVar_VarsToprogramSav_tagvar2var3var4";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Vars To:  program=SaveLogFiles set=to  var_1=tag  var_2=?  var_3=?  var_4=? ";
	other_prog=$.programs.gp[4].gp[0][0]$;
	set_other=1;
	var_1=$.programs.gp[1][1].vars[8]$;
	var_2=NULL;
	var_3=NULL;
	var_4=NULL;
       };
       If @[2] {
	name="If_ifactivateparams";
	desc="only if running interactively -- otherwise set in MasterStartup!";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (activate_params)";
	cond {
	 expr="activate_params";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_runparamsActivatetrue";
	  desc="activate config values";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="run_params->Activate(true)";
	  result_var=NULL;
	  obj=$.programs.gp[1][1].vars[1]$;
	  method=ParamSet::Activate;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=bool;
	    type="bool";
	    name="info_msg";
	    required=0;
	    def_val="false";
	    prev_expr=;
	    expr {
	     expr="true";
	    };
	   };
	  };
	  meth_sig="void Activate(bool info_msg = false)";
	  meth_desc=" copy the saved_value values to be active (live) values on the objects";
	 };
	 MethodCall @[1] {
	  name="MethodCall_netparamsActivatetrue";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="net_params->Activate(true)";
	  result_var=NULL;
	  obj=$.programs.gp[1][1].vars[2]$;
	  method=ParamSet::Activate;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=bool;
	    type="bool";
	    name="info_msg";
	    required=0;
	    def_val="false";
	    prev_expr=;
	    expr {
	     expr="true";
	    };
	   };
	  };
	  meth_sig="void Activate(bool info_msg = false)";
	  meth_desc=" copy the saved_value values to be active (live) values on the objects";
	 };
	};
       };
      };
     };
     ProgramCallVar @[3] {
      name="ProgramCallVar_CallFmproggroupI_initprognetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Call Fm: prog_group=InitProgs prog_name_var=init_prog (network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      prog_group=.programs.gp[1].gp[0]$$;
      prog_name_var=$.programs.gp[1][1].vars[4]$;
     };
     WhileLoop @[4] {
      name="WhileLoop_whilestoptrain";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="while (!stop_train)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_MasterRunnetworkrunprog";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="MasterRun(network, run_prog)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=taString;
	  type="String";
	  name="run_prog";
	  required=1;
	  def_val=;
	  prev_expr="config_id";
	  expr {
	   expr="run_prog";
	  };
	 };
	};
	target=.programs.gp[1][2]$$;
	targ_ld_init="*MasterRun*";
       };
      };
      test {
       expr="!stop_train";
      };
     };
    };
    step_prog=.programs.gp[2][1]$$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrain";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrain";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1][2].doc$$: };
    };
    name="MasterRun";
    short_nm="MstrRn";
    tags=;
    desc="modular run code -- forks off to RunProgs based on run_prog -- only neccessary to provide common step point for all run progs";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=0;
    stop_step_cond {
     expr="StopStepTest()";
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="StopStepGrain";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="TRIAL";
	value=0;
	desc="stop / step after each time through the master run program, which generally corresponds to a trial";
       };
       DynEnumItem @[1] {
	name="EPOCH";
	value=1;
	desc="stop / step after an entire epoch of processing (when network.trial is reset back to 0)";
       };
       DynEnumItem @[2] {
	name="ERROR";
	value=2;
	desc="stop /step after there is an error (sse > 0)";
       };
       DynEnumItem @[3] {
	name="CORRECT";
	value=3;
	desc="stop /step after there is a correct trial (sse == 0)";
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="run_prog";
      var_type=T_String;
      string_val="BasicRun";
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="name of run program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="stop_step_grain";
      var_type=T_DynEnum;
      object_scope=NULL;
      dyn_enum_val {
       user_data_=NULL;
       enum_type=.programs.gp[1][2].types[0]$$;
       value=1;
      };
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="select grain size for Step function on MasterRun program -- can extend this functionality -- very useful!";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="StopStepTest";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="StopStepTest() returns: bool";
      return_type=T_Bool;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       Switch @[1] {
	name="Switch_switchstopstepgrain";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="switch(stop_step_grain)";
	switch_var=.programs.gp[1][2].vars[0]$$;
	cases {
	 name="cases";
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  name="CaseBlock_caseTRIAL";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: TRIAL";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    name="ReturnExpr_returntrue";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return true";
	    expr {
	     expr="true";
	    };
	   };
	  };
	  case_val {
	   expr="TRIAL";
	  };
	  is_default=0;
	 };
	 CaseBlock @[1] {
	  name="CaseBlock_caseEPOCH";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: EPOCH";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    name="ReturnExpr_returnnetworktrial0";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return (network->trial == 0)";
	    expr {
	     expr="(network->trial == 0)";
	    };
	   };
	  };
	  case_val {
	   expr="EPOCH";
	  };
	  is_default=0;
	 };
	 CaseBlock @[2] {
	  name="CaseBlock_caseERROR";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: ERROR";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    name="ReturnExpr_returnnetworksse00f";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return (network->sse > 0.0f)";
	    expr {
	     expr="(network->sse > 0.0f)";
	    };
	   };
	  };
	  case_val {
	   expr="ERROR";
	  };
	  is_default=0;
	 };
	 CaseBlock @[3] {
	  name="CaseBlock_caseCORRECT";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: CORRECT";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    name="ReturnExpr_returnnetworksse00f";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return (network->sse == 0.0f)";
	    expr {
	     expr="(network->sse == 0.0f)";
	    };
	   };
	  };
	  case_val {
	   expr="CORRECT";
	  };
	  is_default=0;
	 };
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     ProgramCallVar @[0] {
      name="ProgramCallVar_CallFmproggroupR_rrunprognetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Call Fm: prog_group=RunProgs prog_name_var=run_prog (network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr="network";
	expr {
	 expr="network";
	};
       };
      };
      prog_group=.programs.gp[1].gp[1]$$;
      prog_name_var=.programs.gp[1][2].args[1]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraFlex";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraFlex";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program_Group @.gp[0] {
    name="InitProgs";
    el_typ=Program;
    el_def=0;
    tags=;
    desc="contains specific Init programs called at start of running by RobotInit";
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[0][0].doc$$: };
     };
     name="BasicInit";
     short_nm="BaseInit";
     tags=;
     desc="initialization for basic training";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author="Randall C. O'Reilly";
     email="emergent-users@grey.colorado.edu";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="layer_group_lesion_list";
       var_type=T_String;
       string_val=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="space-separated list of layer groups to lesion for this run -- all layers unlesioned at the start";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="layer_lesion_list";
       var_type=T_String;
       string_val=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="space-separated list of layers outside of groups to lesion for this run";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="prjn_lesion_list";
       var_type=T_String;
       string_val=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="space-separated list of projections to lesion for this run (recvlayer.Fm_sendlayer) -- prjns are NOT all unlesioned at the start, so other cases that need these on should list them in their unlesion list";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="prjn_unlesion_list";
       var_type=T_String;
       string_val=;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="space-separated list of projections to UN-lesion for this run (recvlayer.Fm_sendlayer) -- prjns are NOT all unlesioned at the start, so other cases that don't need these on should list them in their lesion list";
       init_from=NULL;
      };
      ProgVar @[4] {
       name="test_run";
       var_type=T_Bool;
       bool_val=0;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc="is this a testing-only run, no training?";
       init_from=.programs.gp[4][4]$$;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      ProgramCall @[0] {
       name="ProgramCall_ConfigNetworknet_rjnunlesionlist";
       desc="get rid of all non-essential layers";
       flags=CAN_REVERT_TO_CODE;
       code_string="ConfigNetwork(network, layer_group_lesion_list, layer_lesion_list, prjn_lesion_list, prjn_unlesion_list)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr="network";
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="lesion_layer_groups";
	 required=1;
	 def_val=;
	 prev_expr="layer_group_lesion_list";
	 expr {
	  expr="layer_group_lesion_list";
	 };
	};
	ProgArg @[2] {
	 arg_type=taString;
	 type="String";
	 name="lesion_layers";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="layer_lesion_list";
	 };
	};
	ProgArg @[3] {
	 arg_type=taString;
	 type="String";
	 name="lesion_prjns";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="prjn_lesion_list";
	 };
	};
	ProgArg @[4] {
	 arg_type=taString;
	 type="String";
	 name="un_lesion_prjns";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="prjn_unlesion_list";
	 };
	};
       };
       target=.programs.gp[4][1]$$;
       targ_ld_init="*ConfigNetwork*";
      };
      ProgramCall @[1] {
       name="ProgramCall_TrainStartnetwork";
       desc="standard init of training";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrainStart(network)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=$.programs.gp[4][4]$;
       targ_ld_init="*TrainStart*";
      };
      If @[2] {
       name="If_iftestrun";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (test_run)";
       cond {
	expr="test_run";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_abraNetworkTEST";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TEST";
	 obj=.programs.gp[1].gp[0][0].args[0]$$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TEST";
	 };
	 update_after=0;
	};
       };
      };
      Else @[3] {
       name="Else_If_iftestrun";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       cond {
	expr=;
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 name="MemberAssign_networktrainmode_braNetworkTRAIN";
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TRAIN";
	 obj=$.programs.gp[1].gp[0][0].args[0]$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TRAIN";
	 };
	 update_after=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
   Program_Group @.gp[1] {
    name="RunProgs";
    el_typ=Program;
    el_def=0;
    tags="contains individual Run programs for specific environments -- called by RobotRun";
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[1].gp[1][0].doc$$: };
     };
     name="BasicRun";
     short_nm="BaseRun";
     tags=;
     desc="run basic training -- does ";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author="Randall C. O'Reilly";
     email="emergent-users@grey.colorado.edu";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="train_epochs";
       var_type=T_Int;
       int_val=50;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][4]$;
      };
      ProgVar @[1] {
       name="trials_per_epoch_eff";
       var_type=T_Int;
       int_val=50;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][4]$;
      };
      ProgVar @[2] {
       name="test_interval";
       var_type=T_Int;
       int_val=1;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.programs.gp[4][4]$;
      };
      ProgVar @[3] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
      ProgVar @[4] {
       name="StdInputData";
       var_type=T_Object;
       object_type=DataTable;
       object_val=.data.gp[0][0]$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      Comment @[0] {
       name="Comment_ExecuteOneTrialofBasicTraining";
       desc="== Execute One Trial of Basic Training ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Execute One Trial of Basic Training ==";
      };
      MemberAssign @[1] {
       name="MemberAssign_networktick0";
       desc="always in tick 0 for this -- only one step of processing";
       flags=CAN_REVERT_TO_CODE;
       code_string="network.tick = 0";
       obj=.programs.gp[1].gp[1][0].args[0]$$;
       path="tick";
       expr {
	expr="0";
       };
       update_after=0;
      };
      ProgramCall @[2] {
       name="ProgramCall_BasicTrainnetwor_taupdatenetview";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="BasicTrain(network, StdInputData, update_net_view)";
       prog_args {
	name="prog_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="StdInputData";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="update_net_view";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="update_net_view";
	 };
	};
       };
       target=.programs.gp[2][0]$$;
       targ_ld_init="*BasicTrain*";
      };
      Comment @[3] {
       name="Comment_DoneWithOneTrial";
       desc="== Done With One Trial ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Done With One Trial ==";
      };
      MemberAssign @[4] {
       name="MemberAssign_networktrialnetworktrial1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.trial = network.trial + 1";
       obj=$.programs.gp[1].gp[1][0].args[0]$;
       path="trial";
       expr {
	expr="network.trial + 1";
       };
       update_after=0;
      };
      If @[5] {
       name="If_ifnetworktrialtrialsperepocheff";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.trial >= trials_per_epoch_eff)";
       cond {
	expr="network.trial >= trials_per_epoch_eff";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ProgramCall @[0] {
	 name="ProgramCall_EpochEndnetwork";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochEnd(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.programs.gp[4][7]$$;
	 targ_ld_init="*EpochEnd*";
	};
	If @[1] {
	 name="If_iftestinterval0n_chtestinterval0";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (test_interval > 0 && network.epoch % test_interval == 0)";
	 cond {
	  expr="test_interval > 0 && network.epoch % test_interval == 0";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_TestAllnetwork";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="TestAll(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr="network";
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=.programs.gp[2][2]$$;
	   targ_ld_init="*TestAll*";
	  };
	 };
	};
	MemberAssign @[2] {
	 name="MemberAssign_networkepochnetworkepoch1";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.epoch = network.epoch + 1";
	 obj=$.programs.gp[1].gp[1][0].args[0]$;
	 path="epoch";
	 expr {
	  expr="network.epoch + 1";
	 };
	 update_after=0;
	};
	If @[3] {
	 name="If_ifnetworkepochtrainepochs";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.epoch >= train_epochs)";
	 cond {
	  expr="network.epoch >= train_epochs";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   name="ProgramCall_TrainEndnetwork";
	   desc="calls stop_train and does final training stuff";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="TrainEnd(network)";
	   prog_args {
	    name="prog_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=.programs.gp[4][5]$$;
	   targ_ld_init="*TrainEnd*";
	  };
	  ReturnExpr @[1] {
	   name="ReturnExpr_return";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="return ";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
	ProgramCall @[4] {
	 name="ProgramCall_EpochStartnetwork";
	 desc="time to start a new epoch!";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochStart(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.programs.gp[4][6]$$;
	 targ_ld_init="*EpochStart*";
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
  };
  Program_Group @.gp[2] {
   name="TaskProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][0].doc$$: };
    };
    name="BasicTrain";
    short_nm="BscTrn";
    tags=;
    desc="basic training -- this is a standard Leabra minus-plus trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=2;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     TimeUsed @[0] {name="BasicTrainTime": start={usr=1796: sys=220: tot=149140942226: }: end={usr=1805: sys=221: tot=149140942236: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="basic_train_time";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.programs.gp[2][0].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_basictraintimeResetUsed";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="basic_train_time->ResetUsed()";
      result_var=NULL;
      obj=.programs.gp[2][0].vars[0]$$;
      method=TimeUsed::ResetUsed;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetUsed()";
      meth_desc=" reset time used information";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_basictraintimeStartTimerfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="basic_train_time->StartTimer(false)";
      result_var=NULL;
      obj=$.programs.gp[2][0].vars[0]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     Comment @[1] {
      name="Comment_StartTrial";
      desc="=== Start Trial ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Start Trial ===";
     };
     ProgramCall @[2] {
      name="ProgramCall_TrialStartnetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="TrialStart(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4][8]$$;
      targ_ld_init="*TrialStart*";
     };
     ProgramCall @[3] {
      name="ProgramCall_ChooseNextEventn_rkinputdatatrue";
      desc="pick next event permuted..";
      flags=CAN_REVERT_TO_CODE;
      code_string="ChooseNextEvent(network, input_data, true)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[2] {
	arg_type=bool;
	type="bool";
	name="permuted";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      target=.programs.gp[3][0]$$;
      targ_ld_init="*ChooseNextEvent*";
     };
     ProgramCall @[4] {
      name="ProgramCall_ApplyInputsnetworkinputdata";
      desc="apply std external input activations from the input_data table to the network";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.programs.gp[3][2]$$;
      targ_ld_init="*ApplyInputs*";
     };
     Comment @[5] {
      name="Comment_RunMinusPhase";
      desc="=== Run Minus Phase ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Run Minus Phase ===";
     };
     ProgramCall @[6] {
      name="ProgramCall_SettleMinusnetwork";
      desc="settle for minus phase, using ct_time.minus as fixed number of cycles to run";
      flags=CAN_REVERT_TO_CODE;
      code_string="SettleMinus(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4][10]$$;
      targ_ld_init="*SettleMinus*";
     };
     MethodCall @[7] {
      name="MethodCall_networkComputePhaseStats";
      desc="compute stats appropriate for given phase";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=.programs.gp[2][0].args[0]$$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[8] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[2][0].args[0]$;
      update_var=.programs.gp[2][0].args[2]$$;
     };
     StopStepPoint @[9] {
      name="StopStepPoint_StopStepPoint";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Stop_Step Point";
      cond {
       expr=;
      };
     };
     Comment @[10] {
      name="Comment_RunPlusPhase";
      desc="=== Run Plus Phase ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Run Plus Phase ===";
     };
     MethodCall @[11] {
      name="MethodCall_networkInitInputData";
      desc="only need to re-apply if something is new!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[2][0].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[12] {
      name="ProgramCall_ApplyInputsnetworkinputdata_1";
      desc="only need to re-apply if something is new!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=$.programs.gp[3][2]$;
      targ_ld_init="*ApplyInputs*";
     };
     ProgramCall @[13] {
      name="ProgramCall_SettlePlusnetwork";
      desc="settle for designated plus phase number of cycles";
      flags=CAN_REVERT_TO_CODE;
      code_string="SettlePlus(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4][11]$$;
      targ_ld_init="*Settle*";
     };
     MethodCall @[14] {
      name="MethodCall_networkComputePhaseStats_1";
      desc="compute stats appropriate for given phase";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=$.programs.gp[2][0].args[0]$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[15] {
      name="NetUpdateView_NetUpdateView_1";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[2][0].args[0]$;
      update_var=$.programs.gp[2][0].args[2]$;
     };
     ProgramCall @[16] {
      name="ProgramCall_TrialEndnetwork";
      desc="standard end of trial stuff";
      flags=CAN_REVERT_TO_CODE;
      code_string="TrialEnd(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4][9]$$;
      targ_ld_init="*TrialEnd*";
     };
     MethodCall @[17] {
      name="MethodCall_basictraintimeEndTimer";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="basic_train_time->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[2][0].vars[0]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[18] {
      name="ProgramCall_LeabraTrialMonitornetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraTrialMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4].gp[0][1]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
    };
    step_prog=$.programs.gp[4][14]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=$.programs.gp[2][0].doc$: };
    };
    name="BasicTest";
    short_nm="BscTst";
    tags=;
    desc="basic training -- this is a standard Leabra minus-plus trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=2;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     TimeUsed @[0] {name="BasicTrainTime": start={usr=1817: sys=223: tot=149140942247: }: end={usr=1816: sys=222: tot=149140942246: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="basic_train_time";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.programs.gp[2][1].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_basictraintimeResetUsed";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="basic_train_time->ResetUsed()";
      result_var=NULL;
      obj=.programs.gp[2][1].vars[0]$$;
      method=TimeUsed::ResetUsed;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetUsed()";
      meth_desc=" reset time used information";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_basictraintimeStartTimerfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="basic_train_time->StartTimer(false)";
      result_var=NULL;
      obj=$.programs.gp[2][1].vars[0]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     Comment @[1] {
      name="Comment_StartTrial";
      desc="=== Start Trial ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Start Trial ===";
     };
     ProgramCall @[2] {
      name="ProgramCall_TrialStartnetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="TrialStart(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][8]$;
      targ_ld_init="*TrialStart*";
     };
     ProgramCall @[3] {
      name="ProgramCall_ChooseNextEventn_rkinputdatatrue";
      desc="pick next event permuted..";
      flags=CAN_REVERT_TO_CODE;
      code_string="ChooseNextEvent(network, input_data, true)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[2] {
	arg_type=bool;
	type="bool";
	name="permuted";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      target=$.programs.gp[3][0]$;
      targ_ld_init="*ChooseNextEvent*";
     };
     ProgramCall @[4] {
      name="ProgramCall_ApplyInputsnetworkinputdata";
      desc="apply std external input activations from the input_data table to the network";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=$.programs.gp[3][2]$;
      targ_ld_init="*ApplyInputs*";
     };
     Comment @[5] {
      name="Comment_RunMinusPhase";
      desc="=== Run Minus Phase ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Run Minus Phase ===";
     };
     ProgramCall @[6] {
      name="ProgramCall_SettleMinusnetwork";
      desc="settle for minus phase, using ct_time.minus as fixed number of cycles to run";
      flags=CAN_REVERT_TO_CODE;
      code_string="SettleMinus(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][10]$;
      targ_ld_init="*SettleMinus*";
     };
     MethodCall @[7] {
      name="MethodCall_networkComputePhaseStats";
      desc="compute stats appropriate for given phase";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=.programs.gp[2][1].args[0]$$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[8] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[2][1].args[0]$;
      update_var=.programs.gp[2][1].args[2]$$;
     };
     StopStepPoint @[9] {
      name="StopStepPoint_StopStepPoint";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Stop_Step Point";
      cond {
       expr=;
      };
     };
     Comment @[10] {
      name="Comment_RunPlusPhase";
      desc="=== Run Plus Phase ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Run Plus Phase ===";
     };
     MethodCall @[11] {
      name="MethodCall_networkInitInputData";
      desc="only need to re-apply if something is new!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[2][1].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[12] {
      name="ProgramCall_ApplyInputsnetworkinputdata_1";
      desc="only need to re-apply if something is new!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=$.programs.gp[3][2]$;
      targ_ld_init="*ApplyInputs*";
     };
     ProgramCall @[13] {
      name="ProgramCall_SettlePlusnetwork";
      desc="settle for designated plus phase number of cycles";
      flags=CAN_REVERT_TO_CODE;
      code_string="SettlePlus(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][11]$;
      targ_ld_init="*Settle*";
     };
     MethodCall @[14] {
      name="MethodCall_networkComputePhaseStats_1";
      desc="compute stats appropriate for given phase";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=$.programs.gp[2][1].args[0]$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[15] {
      name="NetUpdateView_NetUpdateView_1";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[2][1].args[0]$;
      update_var=$.programs.gp[2][1].args[2]$;
     };
     ProgramCall @[16] {
      name="ProgramCall_TrialEndnetwork";
      desc="standard end of trial stuff";
      flags=CAN_REVERT_TO_CODE;
      code_string="TrialEnd(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][9]$;
      targ_ld_init="*TrialEnd*";
     };
     MethodCall @[17] {
      name="MethodCall_basictraintimeEndTimer";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="basic_train_time->EndTimer()";
      result_var=NULL;
      obj=$.programs.gp[2][1].vars[0]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[18] {
      name="ProgramCall_LeabraTestTrialMonitornetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraTestTrialMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4].gp[0][3]$$;
      targ_ld_init="*LeabraTestTrialMonitor*";
     };
    };
    step_prog=$.programs.gp[4][14]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[2][2].doc$$: };
    };
    name="TestAll";
    short_nm="TesAll";
    tags="Leabra, Std";
    desc="test all items in a data table and save to a separate monitor";
    version {
     major=8;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="table of patterns to present to the network, one row at a time";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="data_loop_order";
      var_type=T_HardEnum;
      int_val=0;
      object_scope=NULL;
      hard_enum_type=DataLoop::Order;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="controls the order in which events (rows of the input data datatable) are presented to the network
(SEQUENTIAL, PERMUTED, RANDOM)";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="trial";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current trial (event) within the epoch -- increments automatically";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.data.gp[1][2]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="step_on_err";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="when you step at the Epoch level, this will automatically step through to the next point at which an error was made -- you can use the netview history to replay what happend";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="data_loop_index";
      var_type=T_Int;
      int_val=1;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="index counter for the looping over items in the input_data datatable (not always the same as trial counter, depending on distributed memory computation)";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="test_updt_view";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="update display when testing items?";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=.programs.gp[2][2].args[0]$$;
      local_ctr_var=.programs.gp[2][2].vars[2]$$;
      counter=Network::trial;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInittrial";
      desc="initialize trial counter (local variable and in the network)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: trial";
      network_var=$.programs.gp[2][2].args[0]$;
      local_ctr_var=$.programs.gp[2][2].vars[2]$;
      counter=Network::trial;
      update_after=0;
     };
     MethodCall @[1] {
      name="MethodCall_networkInitEpoch";
      desc="added in 8.0: essential for param_seqs";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_Epoch()";
      result_var=NULL;
      obj=$.programs.gp[2][2].args[0]$;
      method=Network::Init_Epoch;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_Epoch()";
      meth_desc=" Initializes network state at the start of a new epoch -- updates parameters according to param_seq for example";
     };
     MethodCall @[2] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[2][2].vars[3]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     NetDataLoop @[3] {
      name="NetDataLoop_NetDataLoopSEQUE_ardatalooporder";
      desc="iterates over the events/rows of input_data, according to data_loop_order variable";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Data Loop (SEQUENTIAL):  table=input_data  index=data_loop_index  order_var=data_loop_order ";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_BasicTestnetwork_atatestupdtview";
	desc="run the trial program, passing network and input_data";
	flags=CAN_REVERT_TO_CODE;
	code_string="BasicTest(network, input_data, test_updt_view)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=DataTable;
	  type="DataTable*";
	  name="input_data";
	  required=1;
	  def_val=;
	  prev_expr="input_data";
	  expr {
	   expr="input_data";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=bool;
	  type="bool";
	  name="update_net_view";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="test_updt_view";
	  };
	 };
	};
	target=$.programs.gp[2][1]$;
	targ_ld_init="*BasicTest*";
       };
       If @[1] {
	name="If_ifsteponerrnetworksse00";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (step_on_err && network.sse > 0.0)";
	cond {
	 expr="step_on_err && network.sse > 0.0";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 StopStepPoint @[0] {
	  name="StopStepPoint_StopStepPoint";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="Stop_Step Point";
	  cond {
	   expr=;
	  };
	 };
	};
       };
      };
      data_var=.programs.gp[2][2].vars[0]$$;
      index_var=.programs.gp[2][2].vars[5]$$;
      order_var=.programs.gp[2][2].vars[1]$$;
      order=SEQUENTIAL;
      update_after=0;
      dmem_nprocs=1;
      dmem_this_proc=0;
      grouped=0;
      group_col 9 0="Group";
      group_index_var=NULL;
      group_order_var=NULL;
      group_order=PERMUTED;
      group_idx_list{       };
     };
     MethodCall @[4] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=$.programs.gp[2][2].args[0]$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more compute epoch-level statistics, including SSE, AvgExtRew and AvgCycles";
     };
     ProgramCall @[5] {
      name="ProgramCall_LeabraTestEpochMonitornetwork";
      desc="run program that records data from network and possibly other sources about the epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraTestEpochMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4].gp[0][4]$$;
      targ_ld_init="*LeabraTestEpochMonitor*";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraEpoch";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraEpoch";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[3] {
   name="EnviroProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][0].doc$$: };
    };
    name="ChooseNextEvent";
    short_nm="ChNxEvt";
    tags="InputData, Permuted, FlexProgs, ApplyInput";
    desc="choose next event in input data in either sequential or permuted order according to its own internal counter-- starts over (re-permutes) when the end is reached -- is automatically dmem compatible for allocating different events to different processors";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=DataTable;
     el_def=0;
     DataTable @[0] {
      name="PermIdxTable";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       int_Data @[0] {
	name="Index";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
       };
      };
      data_flags=AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="Network to which to apply inputs";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="permuted";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="present events in permuted order (otherwise use sequential order)";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cur_idx";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current index into permuted table ";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_idx";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="dmem_rows";
      var_type=T_Int;
      int_val=6;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="perm_idx_table";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.programs.gp[3][0].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="ComputeDmemRows";
      desc="compute target number of rows, based on current dmem settings";
      flags=CAN_REVERT_TO_CODE;
      code_string="ComputeDmemRows() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       If @[1] {
	name="If_iftaMiscdmemnprocs1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (taMisc::dmem_nprocs <= 1)";
	cond {
	 expr="taMisc::dmem_nprocs <= 1";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  name="AssignExpr_dmemrowsinputdatarows";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="dmem_rows = input_data.rows";
	  result_var=.programs.gp[3][0].vars[2]$$;
	  expr {
	   expr="input_data.rows";
	  };
	 };
	};
       };
       Else @[2] {
	name="Else_If_iftaMiscdmemnprocs1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="else";
	cond {
	 expr=;
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  name="AssignExpr_dmemrowsinputdat_aMiscdmemnprocs";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="dmem_rows = input_data.rows / taMisc::dmem_nprocs";
	  result_var=$.programs.gp[3][0].vars[2]$;
	  expr {
	   expr="input_data.rows / taMisc::dmem_nprocs";
	  };
	 };
	 WhileLoop @[1] {
	  name="WhileLoop_whiledmemrowstaM_csinputdatarows";
	  desc="ensure that we cover all the input data";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="while (dmem_rows * taMisc::dmem_nprocs < input_data.rows)";
	  loop_code {
	   name="loop_code";
	   el_typ=ProgCode;
	   el_def=0;
	   VarIncr @[0] {
	    name="VarIncr_dmemrows1";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="dmem_rows += 1";
	    var=$.programs.gp[3][0].vars[2]$;
	    expr {
	     expr="1";
	    };
	   };
	  };
	  test {
	   expr="dmem_rows * taMisc::dmem_nprocs < input_data.rows";
	  };
	 };
	};
       };
      };
     };
     Function @[1] {
      name="PermuteIndexes";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="PermuteIndexes() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       AssignExpr @[1] {
	name="AssignExpr_curidx1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="cur_idx = -1";
	result_var=.programs.gp[3][0].vars[0]$$;
	expr {
	 expr="-1";
	};
       };
       If @[2] {
	name="If_ifpermuted";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (permuted)";
	cond {
	 expr="permuted";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 DataProcCall @[0] {
	  name="DataProcCall_taDataProcPermut_etaMiscdmemproc";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="taDataProc::Permute(perm_idx_table, perm_idx_table, taMisc::dmem_proc)";
	  result_var=NULL;
	  object_type=taDataProc;
	  method=taDataProc::Permute;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=DataTable_ptr;
	    type="DataTable*";
	    name="dest";
	    required=1;
	    def_val=;
	    prev_expr="PermIdxTable";
	    expr {
	     expr="perm_idx_table";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=DataTable_ptr;
	    type="DataTable*";
	    name="src";
	    required=1;
	    def_val=;
	    prev_expr="PermIdxTable";
	    expr {
	     expr="perm_idx_table";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=int;
	    type="int";
	    name="thr_no";
	    required=0;
	    def_val="-1";
	    prev_expr=;
	    expr {
	     expr="taMisc::dmem_proc";
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     Function @[2] {
      name="InitIndexes";
      desc="initialize indexes from current input data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="InitIndexes() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       FunctionCall @[1] {
	name="FunctionCall_ComputeDmemRows";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="ComputeDmemRows()";
	result_var=NULL;
	fun=.programs.gp[3][0].functions[0]$$;
	fun_args {
	 name="fun_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       MethodCall @[2] {
	name="MethodCall_permidxtableEnforceRowsdmemrows";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="perm_idx_table->EnforceRows(dmem_rows)";
	result_var=NULL;
	obj=.programs.gp[3][0].vars[3]$$;
	method=DataTable::EnforceRows;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="n_rows";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="dmem_rows";
	  };
	 };
	};
	meth_sig="void EnforceRows(int n_rows)";
	meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
       };
       MethodCall @[3] {
	name="MethodCall_permidxtableInitValsToRowNo0";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="perm_idx_table->InitValsToRowNo(0)";
	result_var=NULL;
	obj=$.programs.gp[3][0].vars[3]$;
	method=DataTable::InitValsToRowNo;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_Variant_ref;
	  type="Variant&";
	  name="col";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="0";
	  };
	 };
	};
	meth_sig="bool InitValsToRowNo(Variant& col)";
	meth_desc=" initialize all values in given column to be equal to the row number -- only valid for scalar (not matrix) columns -- column can be specified as either integer index or a string that is then used to find the given column name";
       };
       FunctionCall @[4] {
	name="FunctionCall_PermuteIndexes";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="PermuteIndexes()";
	result_var=NULL;
	fun=.programs.gp[3][0].functions[1]$$;
	fun_args {
	 name="fun_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     FunctionCall @[0] {
      name="FunctionCall_InitIndexes";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="InitIndexes()";
      result_var=NULL;
      fun=.programs.gp[3][0].functions[2]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[1] {
      name="AssignExpr_curidx0";
      desc="start at start -- index is incremented AFTER using";
      flags=CAN_REVERT_TO_CODE;
      code_string="cur_idx = 0";
      result_var=$.programs.gp[3][0].vars[0]$;
      expr {
       expr="0";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     FunctionCall @[0] {
      name="FunctionCall_ComputeDmemRows";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ComputeDmemRows()";
      result_var=NULL;
      fun=$.programs.gp[3][0].functions[0]$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[1] {
      name="If_ifdmemrowspermidxtablerows";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (dmem_rows != perm_idx_table.rows)";
      cond {
       expr="dmem_rows != perm_idx_table.rows";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       FunctionCall @[0] {
	name="FunctionCall_InitIndexes";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="InitIndexes()";
	result_var=NULL;
	fun=$.programs.gp[3][0].functions[2]$;
	fun_args {
	 name="fun_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     If @[2] {
      name="If_ifpermuted";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (permuted)";
      cond {
       expr="permuted";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_inputidxpermidxt_leGetVal0curidx";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="input_idx = perm_idx_table->GetVal(0, cur_idx)";
	result_var=.programs.gp[3][0].vars[1]$$;
	obj=$.programs.gp[3][0].vars[3]$;
	method=DataTable::GetVal;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_Variant_ref;
	  type="Variant&";
	  name="col";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="0";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="row";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="cur_idx";
	  };
	 };
	};
	meth_sig="const_Variant GetVal(Variant& col, int row)";
	meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
       };
      };
     };
     Else @[3] {
      name="Else_If_ifpermuted";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="else";
      cond {
       expr=;
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_inputidxcuridx";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="input_idx = cur_idx";
	result_var=$.programs.gp[3][0].vars[1]$;
	expr {
	 expr="cur_idx";
	};
       };
      };
     };
     If @[4] {
      name="If_iftaMiscdmemnprocs1";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_nprocs > 1)";
      cond {
       expr="taMisc::dmem_nprocs > 1";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	name="AssignExpr_inputidxtaMiscdm_mnprocsinputidx";
	desc="for dmem, transform from virtual idx counter into actual row, unique to this processor";
	flags=CAN_REVERT_TO_CODE;
	code_string="input_idx = taMisc::dmem_proc + taMisc::dmem_nprocs * input_idx";
	result_var=$.programs.gp[3][0].vars[1]$;
	expr {
	 expr="taMisc::dmem_proc + taMisc::dmem_nprocs * input_idx";
	};
       };
       If @[1] {
	name="If_ifinputidxinputdatarows";
	desc="choose at random if above actual input data";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (input_idx > input_data.rows)";
	cond {
	 expr="input_idx > input_data.rows";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 RandomCall @[0] {
	  name="RandomCall_inputidxRandomIn_oNinputdatarows";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="input_idx = Random::IntZeroN(input_data.rows, )";
	  result_var=$.programs.gp[3][0].vars[1]$;
	  object_type=Random;
	  method=Random::IntZeroN;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=int;
	    type="int";
	    name="n";
	    required=1;
	    def_val=;
	    prev_expr="input_data.rows";
	    expr {
	     expr="input_data.rows";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=int;
	    type="int";
	    name="thr_no";
	    required=0;
	    def_val="-1";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     MethodCall @[5] {
      name="MethodCall_inputdataReadIteminputidx";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data->ReadItem(input_idx)";
      result_var=NULL;
      obj=.programs.gp[3][0].args[1]$$;
      method=DataTable::ReadItem;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_idx";
	};
       };
      };
      meth_sig="bool ReadItem(int idx)";
      meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
     };
     If @[6] {
      name="If_ifcuridxpermidxtablerows1";
      desc="now increment AFTER using, and wrap around..";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (cur_idx == perm_idx_table.rows -1)";
      cond {
       expr="cur_idx == perm_idx_table.rows -1";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       FunctionCall @[0] {
	name="FunctionCall_PermuteIndexes";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="PermuteIndexes()";
	result_var=NULL;
	fun=$.programs.gp[3][0].functions[1]$;
	fun_args {
	 name="fun_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     Else @[7] {
      name="Else_If_ifcuridxpermidxtablerows1";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="else";
      cond {
       expr=;
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       VarIncr @[0] {
	name="VarIncr_curidx1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="cur_idx += 1";
	var=$.programs.gp[3][0].vars[0]$;
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][1].doc$$: };
    };
    name="ChooseRandomEvent";
    short_nm="ChRndm";
    tags=;
    desc="choose an event at random to present on current trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="event_idx";
      var_type=T_Int;
      int_val=2;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="event to present";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     RandomCall @[0] {
      name="RandomCall_eventidxRandomIn_staMiscdmemproc";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="event_idx = Random::IntZeroN(input_data.rows, taMisc::dmem_proc)";
      result_var=.programs.gp[3][1].vars[0]$$;
      object_type=Random;
      method=Random::IntZeroN;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="n";
	required=1;
	def_val=;
	prev_expr="input_data.rows";
	expr {
	 expr="input_data.rows";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="thr_no";
	required=0;
	def_val="-1";
	prev_expr=;
	expr {
	 expr="taMisc::dmem_proc";
	};
       };
      };
     };
     MethodCall @[1] {
      name="MethodCall_inputdataReadItemeventidx";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data->ReadItem(event_idx)";
      result_var=NULL;
      obj=.programs.gp[3][1].args[0]$$;
      method=DataTable::ReadItem;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="event_idx";
	};
       };
      };
      meth_sig="bool ReadItem(int idx)";
      meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[3][2].doc$$: };
    };
    name="ApplyInputs";
    short_nm="Inputs";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @[0] {
      name="LayerWriter_0";
      data=$.data.gp[0][0]$;
      network=$.networks[0]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	col_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_7": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	col_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="RandomSpec_8": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	col_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="RandomSpec_9": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.data.gp[0][0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="layer_writer_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.programs.gp[3][2].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.programs.gp[3][2].vars[0]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0AutoConfig";
      desc="configure to fit the network and input data -- this may cause spurious warning messages and problems in some cases so just turn it OFF if necessary";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->AutoConfig()";
      result_var=NULL;
      obj=$.programs.gp[3][2].vars[0]$;
      method=LayerWriter::AutoConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="remove_unused";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="void AutoConfig(bool remove_unused = true)";
      meth_desc=" do a 'best guess' configuration of items by matching up like-named data Channels and network Layers -- if remove_unused is true, then layer writer elements that existed previously but were not found in input data and network are removed";
     };
     MethodCall @[2] {
      name="MethodCall_layerwriter0CheckConfigfalse";
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.programs.gp[3][2].vars[0]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_layerwriter0SetD_nputdatanetwork";
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.programs.gp[3][2].vars[0]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      name="MethodCall_layerwriter0ApplyInputData";
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="layer_writer_0->ApplyInputData()";
      result_var=NULL;
      obj=$.programs.gp[3][2].vars[0]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="ApplyInputs";
     full_url="https://grey.colorado.edu/emergent/index.php/ApplyInputs";
     text_size=1;
     text=;
     html_text=;
    };
   };
  };
  Program_Group @.gp[4] {
   name="UtilProgs";
   el_typ=Program;
   el_def=0;
   tags="basic utility programs for doing basic operations shared across multiple programs";
   desc=;
   debug_mode=0;
   Program @[0] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][0].doc$$: };
    };
    name="BatchRndSeed";
    short_nm="BatchSeed";
    tags=;
    desc="select random seed based on network batch number";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     RndSeed_List @[0] {
      name="rnd_seeds";
      seeds {
       name="seeds";
       el_typ=RndSeed;
       el_def=0;
       RndSeed @[0] {
	name="RndSeed_1";
	rnd_seed=2929233146;
       };
       RndSeed @[1] {
	name="RndSeed_2";
	rnd_seed=2929233147;
       };
       RndSeed @[2] {
	name="RndSeed_3";
	rnd_seed=2929233148;
       };
       RndSeed @[3] {
	name="RndSeed_4";
	rnd_seed=2929233149;
       };
       RndSeed @[4] {
	name="RndSeed_5";
	rnd_seed=2929233150;
       };
       RndSeed @[5] {
	name="RndSeed_6";
	rnd_seed=2929233151;
       };
       RndSeed @[6] {
	name="RndSeed_7";
	rnd_seed=2929233152;
       };
       RndSeed @[7] {
	name="RndSeed_8";
	rnd_seed=2929233153;
       };
       RndSeed @[8] {
	name="RndSeed_9";
	rnd_seed=2929233154;
       };
       RndSeed @[9] {
	name="RndSeed_10";
	rnd_seed=2929233155;
       };
       RndSeed @[10] {
	name="RndSeed_11";
	rnd_seed=2929233156;
       };
       RndSeed @[11] {
	name="RndSeed_12";
	rnd_seed=2929233157;
       };
       RndSeed @[12] {
	name="RndSeed_13";
	rnd_seed=2929233158;
       };
       RndSeed @[13] {
	name="RndSeed_14";
	rnd_seed=2929233159;
       };
       RndSeed @[14] {
	name="RndSeed_15";
	rnd_seed=2929233160;
       };
       RndSeed @[15] {
	name="RndSeed_16";
	rnd_seed=2929233161;
       };
       RndSeed @[16] {
	name="RndSeed_17";
	rnd_seed=2929233162;
       };
       RndSeed @[17] {
	name="RndSeed_18";
	rnd_seed=2929233163;
       };
       RndSeed @[18] {
	name="RndSeed_19";
	rnd_seed=2929233164;
       };
       RndSeed @[19] {
	name="RndSeed_20";
	rnd_seed=2929233165;
       };
       RndSeed @[20] {
	name="RndSeed_21";
	rnd_seed=2929233166;
       };
       RndSeed @[21] {
	name="RndSeed_22";
	rnd_seed=2929233167;
       };
       RndSeed @[22] {
	name="RndSeed_23";
	rnd_seed=2929233168;
       };
       RndSeed @[23] {
	name="RndSeed_24";
	rnd_seed=2929233169;
       };
       RndSeed @[24] {
	name="RndSeed_25";
	rnd_seed=2929233170;
       };
      };
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="rnd_seeds";
      var_type=T_Object;
      object_type=RndSeed_List;
      object_val=.programs.gp[4][0].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_rndseedsUseSeedn_dseedsseedssize";
      desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
      flags=CAN_REVERT_TO_CODE;
      code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
      result_var=NULL;
      obj=.programs.gp[4][0].vars[0]$$;
      method=RndSeed_List::UseSeed;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch % rnd_seeds.seeds.size";
	};
       };
      };
      meth_sig="void UseSeed(int idx)";
      meth_desc=" use seed at given index in the list (does OldSeed on it); wraps around (modulus) if idx is > list size (issues warning)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[1] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][1].doc$$: };
    };
    name="ConfigNetwork";
    short_nm="CfgNet";
    tags="Network, Configure";
    desc="configure the network -- basically selectively lesion different parts that are not needed for a given task";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=String_Matrix;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="lesion_layer_groups";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer group names to lesion";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="lesion_layers";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer names to lesion";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="lesion_prjns";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of projections to lesion: synatx is recvlayer.Fm_sendlayer";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="un_lesion_prjns";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of projections to un-lesion: synatx is recvlayer.Fm_sendlayer";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="UnlesionAll";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="UnlesionAll() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars2vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (2 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="laygp";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="lay";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       ForeachLoop @[1] {
	name="ForeachLoop_foreachlaygpinnetworklayersgp";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(laygp in network.layers.gp)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_laygpUnLesionLayers";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp->UnLesionLayers()";
	  result_var=NULL;
	  obj=.programs.gp[4][1].functions[0].fun_code[0].local_vars[0]$$;
	  method=Layer_Group::UnLesionLayers;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void UnLesionLayers()";
	  meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
	 };
	 MethodCall @[1] {
	  name="MethodCall_laygpDeIconifyLayers";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp->DeIconifyLayers()";
	  result_var=NULL;
	  obj=$.programs.gp[4][1].functions[0].fun_code[0].local_vars[0]$;
	  method=Layer_Group::DeIconifyLayers;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void DeIconifyLayers()";
	  meth_desc=" un-set the lesion flag on all the layers within this group";
	 };
	};
	el_var=$.programs.gp[4][1].functions[0].fun_code[0].local_vars[0]$;
	in {
	 expr="network.layers.gp";
	};
       };
       ForeachLoop @[2] {
	name="ForeachLoop_foreachlayinnetworklayers";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(lay in network.layers)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_layUnLesion";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="lay->UnLesion()";
	  result_var=NULL;
	  obj=.programs.gp[4][1].functions[0].fun_code[0].local_vars[1]$$;
	  method=Layer::UnLesion;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void UnLesion()";
	  meth_desc=" un-set the lesion flag on layer -- restores it to engage in normal processing";
	 };
	 MethodCall @[1] {
	  name="MethodCall_layDeIconify";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="lay->DeIconify()";
	  result_var=NULL;
	  obj=$.programs.gp[4][1].functions[0].fun_code[0].local_vars[1]$;
	  method=Layer::DeIconify;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void DeIconify()";
	  meth_desc=" de-iconify this layer in the network display (make full size)";
	 };
	};
	el_var=$.programs.gp[4][1].functions[0].fun_code[0].local_vars[1]$;
	in {
	 expr="network.layers";
	};
       };
      };
     };
     Function @[1] {
      name="LayerGpsOnOff";
      desc="turn layer groups on or off (lesion when lay_gp_on=false)";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerGpsOnOff(String laygps, bool lay_gp_on) returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="laygps";
	var_type=T_String;
	string_val=;
	object_scope=NULL;
	flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="lay_gp_on";
	var_type=T_Bool;
	bool_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars3vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (3 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="les_laygp_mat";
	  var_type=T_Object;
	  object_type=String_Matrix;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="laygp";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[2] {
	  name="laygp_nm";
	  var_type=T_String;
	  string_val=;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       MethodCall @[1] {
	name="MethodCall_leslaygpmatFmDelimStringlaygps";
	desc="get into easier to use matrix format";
	flags=CAN_REVERT_TO_CODE;
	code_string="les_laygp_mat->FmDelimString(laygps, \" \")";
	result_var=NULL;
	obj=.programs.gp[4][1].functions[1].fun_code[0].local_vars[0]$$;
	method=String_Matrix::FmDelimString;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="str";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="laygps";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="delim";
	  required=0;
	  def_val=" ";
	  prev_expr=;
	  expr {
	   expr="\" \"";
	  };
	 };
	};
	meth_sig="void FmDelimString(taString& str, taString& delim =  )";
	meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
       };
       ForeachLoop @[2] {
	name="ForeachLoop_foreachlaygpnminleslaygpmat";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(laygp_nm in les_laygp_mat)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MemberMethodCall @[0] {
	  name="MemberMethodCall_laygpnetworklaye_FindNamelaygpnm";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp = network.layers.gp.FindName(laygp_nm)";
	  obj=.programs.gp[4][1].args[0]$$;
	  path="layers.gp";
	  result_var=.programs.gp[4][1].functions[1].fun_code[0].local_vars[1]$$;
	  method=taGroup_Layer_::FindName;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="item_nm";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="laygp_nm";
	    };
	   };
	  };
	  meth_sig="Layer_ptr FindName(taString& item_nm)";
	  meth_desc=" Find element in top-level list with given name (nm) (NULL = not here)";
	 };
	 If @[1] {
	  name="If_iflaygp";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!laygp)";
	  cond {
	   expr="!laygp";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MiscCall @[0] {
	    name="MiscCall_taMiscErrorlayer_worknetworkname";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	    result_var=NULL;
	    object_type=taMisc;
	    method=taMisc::Error;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="a";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="\"layer group named:\"";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="b";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="laygp_nm";
	      };
	     };
	     ProgArg @[2] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="c";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="\"not found in network:\"";
	      };
	     };
	     ProgArg @[3] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="d";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="network.name";
	      };
	     };
	     ProgArg @[4] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="e";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[5] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="f";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[6] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="g";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[7] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="h";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[8] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="i";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	    };
	   };
	   IfContinue @[1] {
	    name="IfContinue_continue";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="continue";
	    cond {
	     expr=;
	    };
	   };
	  };
	 };
	 If @[2] {
	  name="If_iflaygpon";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!lay_gp_on)";
	  cond {
	   expr="!lay_gp_on";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_laygpLesionLayers";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="laygp->LesionLayers()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[1].fun_code[0].local_vars[1]$;
	    method=Layer_Group::LesionLayers;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void LesionLayers()";
	    meth_desc=" set the lesion flag on all the layers within this group -- removes them from all processing operations";
	   };
	   MethodCall @[1] {
	    name="MethodCall_laygpIconifyLayers";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="laygp->IconifyLayers()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[1].fun_code[0].local_vars[1]$;
	    method=Layer_Group::IconifyLayers;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void IconifyLayers()";
	    meth_desc=" iconi";
	   };
	  };
	 };
	 Else @[3] {
	  name="Else_If_iflaygpon";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="else";
	  cond {
	   expr=;
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_laygpUnLesionLayers";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="laygp->UnLesionLayers()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[1].fun_code[0].local_vars[1]$;
	    method=Layer_Group::UnLesionLayers;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void UnLesionLayers()";
	    meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
	   };
	   MethodCall @[1] {
	    name="MethodCall_laygpDeIconifyLayers";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="laygp->DeIconifyLayers()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[1].fun_code[0].local_vars[1]$;
	    method=Layer_Group::DeIconifyLayers;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void DeIconifyLayers()";
	    meth_desc=" un-set the lesion flag on all the layers within this group";
	   };
	  };
	 };
	};
	el_var=.programs.gp[4][1].functions[1].fun_code[0].local_vars[2]$$;
	in {
	 expr="les_laygp_mat";
	};
       };
      };
     };
     Function @[2] {
      name="LayersOnOff";
      desc="turn layers on or off (lesion when lay_on=false)";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayersOnOff(String lays, bool lay_on) returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="lays";
	var_type=T_String;
	string_val=;
	object_scope=NULL;
	flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="lay_on";
	var_type=T_Bool;
	bool_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars3vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (3 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="les_lays_mat";
	  var_type=T_Object;
	  object_type=String_Matrix;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="lay";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[2] {
	  name="lay_nm";
	  var_type=T_String;
	  string_val=;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       MethodCall @[1] {
	name="MethodCall_leslaysmatFmDelimStringlays";
	desc="get into easier to use matrix format";
	flags=CAN_REVERT_TO_CODE;
	code_string="les_lays_mat->FmDelimString(lays, \" \")";
	result_var=NULL;
	obj=.programs.gp[4][1].functions[2].fun_code[0].local_vars[0]$$;
	method=String_Matrix::FmDelimString;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="str";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="lays";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="delim";
	  required=0;
	  def_val=" ";
	  prev_expr=;
	  expr {
	   expr="\" \"";
	  };
	 };
	};
	meth_sig="void FmDelimString(taString& str, taString& delim =  )";
	meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
       };
       ForeachLoop @[2] {
	name="ForeachLoop_foreachlaynminleslaysmat";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(lay_nm in les_lays_mat)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MemberMethodCall @[0] {
	  name="MemberMethodCall_laynetworklayers_ndLeafNamelaynm";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="lay = network.layers.FindLeafName(lay_nm)";
	  obj=$.programs.gp[4][1].args[0]$;
	  path="layers";
	  result_var=.programs.gp[4][1].functions[2].fun_code[0].local_vars[1]$$;
	  method=taGroup_Layer_::FindLeafName;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="item_nm";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="lay_nm";
	    };
	   };
	  };
	  meth_sig="Layer_ptr FindLeafName(taString& item_nm)";
	  meth_desc=" Find element anywhere in full group and subgroups with given name (item_nm)";
	 };
	 If @[1] {
	  name="If_iflay";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!lay)";
	  cond {
	   expr="!lay";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MiscCall @[0] {
	    name="MiscCall_taMiscErrorlayer_worknetworkname";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="taMisc::Error(\"layer named:\", lay_nm, \"not found in network:\", network.name, , , , , )";
	    result_var=NULL;
	    object_type=taMisc;
	    method=taMisc::Error;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="a";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="\"layer named:\"";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="b";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="lay_nm";
	      };
	     };
	     ProgArg @[2] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="c";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="\"not found in network:\"";
	      };
	     };
	     ProgArg @[3] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="d";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="network.name";
	      };
	     };
	     ProgArg @[4] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="e";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[5] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="f";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[6] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="g";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[7] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="h";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[8] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="i";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	    };
	   };
	   IfContinue @[1] {
	    name="IfContinue_continue";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="continue";
	    cond {
	     expr=;
	    };
	   };
	  };
	 };
	 If @[2] {
	  name="If_iflayon";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!lay_on)";
	  cond {
	   expr="!lay_on";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_layLesion";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="lay->Lesion()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[2].fun_code[0].local_vars[1]$;
	    method=Layer::Lesion;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void Lesion()";
	    meth_desc=" set the lesion flag on layer -- removes it from all processing operations";
	   };
	   MethodCall @[1] {
	    name="MethodCall_layIconify";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="lay->Iconify()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[2].fun_code[0].local_vars[1]$;
	    method=Layer::Iconify;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void Iconify()";
	    meth_desc=" iconify this layer in the network display (shrink to size of 1 unit, and make them invisible if lesioned)";
	   };
	  };
	 };
	 Else @[3] {
	  name="Else_If_iflayon";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="else";
	  cond {
	   expr=;
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MethodCall @[0] {
	    name="MethodCall_layUnLesion";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="lay->UnLesion()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[2].fun_code[0].local_vars[1]$;
	    method=Layer::UnLesion;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void UnLesion()";
	    meth_desc=" un-set the lesion flag on layer -- restores it to engage in normal processing";
	   };
	   MethodCall @[1] {
	    name="MethodCall_layDeIconify";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="lay->DeIconify()";
	    result_var=NULL;
	    obj=$.programs.gp[4][1].functions[2].fun_code[0].local_vars[1]$;
	    method=Layer::DeIconify;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	    };
	    meth_sig="void DeIconify()";
	    meth_desc=" de-iconify this layer in the network display (make full size)";
	   };
	  };
	 };
	};
	el_var=.programs.gp[4][1].functions[2].fun_code[0].local_vars[2]$$;
	in {
	 expr="les_lays_mat";
	};
       };
      };
     };
     Function @[3] {
      name="ProjectionsOnOff";
      desc="turn projections on or off";
      flags=CAN_REVERT_TO_CODE;
      code_string="ProjectionsOnOff(String prjns, bool prjn_on) returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="prjns";
	var_type=T_String;
	string_val=;
	object_scope=NULL;
	flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="prjn_on";
	var_type=T_Bool;
	bool_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars5vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (5 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="les_prjns_mat";
	  var_type=T_Object;
	  object_type=String_Matrix;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="prjn";
	  var_type=T_Object;
	  object_type=Projection;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[2] {
	  name="prjn_nm";
	  var_type=T_String;
	  string_val=;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[3] {
	  name="lay_nm";
	  var_type=T_String;
	  string_val=;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[4] {
	  name="lay";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       MethodCall @[1] {
	name="MethodCall_lesprjnsmatFmDelimStringprjns";
	desc="get into easier to use matrix format";
	flags=CAN_REVERT_TO_CODE;
	code_string="les_prjns_mat->FmDelimString(prjns, \" \")";
	result_var=NULL;
	obj=.programs.gp[4][1].functions[3].fun_code[0].local_vars[0]$$;
	method=String_Matrix::FmDelimString;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="str";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="prjns";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="delim";
	  required=0;
	  def_val=" ";
	  prev_expr=;
	  expr {
	   expr="\" \"";
	  };
	 };
	};
	meth_sig="void FmDelimString(taString& str, taString& delim =  )";
	meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
       };
       ForeachLoop @[2] {
	name="ForeachLoop_foreachprjnnminlesprjnsmat";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(prjn_nm in les_prjns_mat)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 If @[0] {
	  name="If_ifprjnnmcontains";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!prjn_nm.contains(\".\"))";
	  cond {
	   expr="!prjn_nm.contains(\".\")";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MiscCall @[0] {
	    name="MiscCall_taMiscErrorproje_onasFmsendlayer";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="taMisc::Error(\"projection name must include a . between name of layer and name of projection as Fm_sendlayer\", , , , , , , , )";
	    result_var=NULL;
	    object_type=taMisc;
	    method=taMisc::Error;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="a";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="\"projection name must include a . between name of layer and name of projection as Fm_sendlayer\"";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="b";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[2] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="c";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[3] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="d";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[4] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="e";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[5] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="f";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[6] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="g";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[7] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="h";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[8] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="i";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	    };
	   };
	   IfContinue @[1] {
	    name="IfContinue_continue";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="continue";
	    cond {
	     expr=;
	    };
	   };
	  };
	 };
	 MethodCall @[1] {
	  name="MethodCall_laynmprjnnmbefore";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="lay_nm = prjn_nm->before(\".\", )";
	  result_var=.programs.gp[4][1].functions[3].fun_code[0].local_vars[3]$$;
	  obj=.programs.gp[4][1].functions[3].fun_code[0].local_vars[2]$$;
	  method=taString::before;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="x";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\".\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=int;
	    type="int";
	    name="startpos";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	  meth_sig="taString before(taString& x, int startpos = 0)";
	  meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	 };
	 MethodCall @[2] {
	  name="MethodCall_prjnnmprjnnmafter";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="prjn_nm = prjn_nm->after(\".\", )";
	  result_var=$.programs.gp[4][1].functions[3].fun_code[0].local_vars[2]$;
	  obj=$.programs.gp[4][1].functions[3].fun_code[0].local_vars[2]$;
	  method=taString::after;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="x";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\".\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=int;
	    type="int";
	    name="startpos";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	  meth_sig="taString after(taString& x, int startpos = 0)";
	  meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	 };
	 MemberMethodCall @[3] {
	  name="MemberMethodCall_laynetworklayers_ndLeafNamelaynm";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="lay = network.layers.FindLeafName(lay_nm)";
	  obj=$.programs.gp[4][1].args[0]$;
	  path="layers";
	  result_var=.programs.gp[4][1].functions[3].fun_code[0].local_vars[4]$$;
	  method=taGroup_Layer_::FindLeafName;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="item_nm";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="lay_nm";
	    };
	   };
	  };
	  meth_sig="Layer_ptr FindLeafName(taString& item_nm)";
	  meth_desc=" Find element anywhere in full group and subgroups with given name (item_nm)";
	 };
	 If @[4] {
	  name="If_iflay";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!lay)";
	  cond {
	   expr="!lay";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MiscCall @[0] {
	    name="MiscCall_taMiscErrorlayer_worknetworkname";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="taMisc::Error(\"layer named:\", lay_nm, \"not found in network:\", network.name, , , , , )";
	    result_var=NULL;
	    object_type=taMisc;
	    method=taMisc::Error;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="a";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="\"layer named:\"";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="b";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="lay_nm";
	      };
	     };
	     ProgArg @[2] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="c";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="\"not found in network:\"";
	      };
	     };
	     ProgArg @[3] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="d";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="network.name";
	      };
	     };
	     ProgArg @[4] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="e";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[5] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="f";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[6] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="g";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[7] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="h";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[8] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="i";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	    };
	   };
	   IfContinue @[1] {
	    name="IfContinue_continue";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="continue";
	    cond {
	     expr=;
	    };
	   };
	  };
	 };
	 AssignExpr @[5] {
	  name="AssignExpr_prjnlayprojectionsFindNameprjnnm";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="prjn = lay.projections.FindName(prjn_nm)";
	  result_var=.programs.gp[4][1].functions[3].fun_code[0].local_vars[1]$$;
	  expr {
	   expr="lay.projections.FindName(prjn_nm)";
	  };
	 };
	 If @[6] {
	  name="If_ifprjn";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (!prjn)";
	  cond {
	   expr="!prjn";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   MiscCall @[0] {
	    name="MiscCall_taMiscErrorproje_dinlayerlayname";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="taMisc::Error(\"projection named:\", prjn_nm, \"not found in layer:\", lay.name, , , , , )";
	    result_var=NULL;
	    object_type=taMisc;
	    method=taMisc::Error;
	    meth_args {
	     name="meth_args";
	     el_typ=ProgArg;
	     el_def=0;
	     ProgArg @[0] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="a";
	      required=1;
	      def_val=;
	      prev_expr=;
	      expr {
	       expr="\"projection named:\"";
	      };
	     };
	     ProgArg @[1] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="b";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="prjn_nm";
	      };
	     };
	     ProgArg @[2] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="c";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="\"not found in layer:\"";
	      };
	     };
	     ProgArg @[3] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="d";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr="lay.name";
	      };
	     };
	     ProgArg @[4] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="e";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[5] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="f";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[6] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="g";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[7] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="h";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	     ProgArg @[8] {
	      arg_type=const_taString_ref;
	      type="taString&";
	      name="i";
	      required=0;
	      def_val="\"\"";
	      prev_expr=;
	      expr {
	       expr=;
	      };
	     };
	    };
	   };
	   IfContinue @[1] {
	    name="IfContinue_continue";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="continue";
	    cond {
	     expr=;
	    };
	   };
	  };
	 };
	 MemberAssign @[7] {
	  name="MemberAssign_prjnoffprjnon";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="prjn.off = !prjn_on";
	  obj=$.programs.gp[4][1].functions[3].fun_code[0].local_vars[1]$;
	  path="off";
	  expr {
	   expr="!prjn_on";
	  };
	  update_after=1;
	 };
	};
	el_var=$.programs.gp[4][1].functions[3].fun_code[0].local_vars[2]$;
	in {
	 expr="les_prjns_mat";
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars0vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (0 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
      };
     };
     FunctionCall @[1] {
      name="FunctionCall_UnlesionAll";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="UnlesionAll()";
      result_var=NULL;
      fun=.programs.gp[4][1].functions[0]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     FunctionCall @[2] {
      name="FunctionCall_LayerGpsOnOffles_ayergroupsfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerGpsOnOff(lesion_layer_groups, false)";
      result_var=NULL;
      fun=.programs.gp[4][1].functions[1]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="laygps";
	required=1;
	def_val=;
	prev_expr="lesion_layer_groups";
	expr {
	 expr="lesion_layer_groups";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="lay_gp_on";
	required=1;
	def_val=;
	prev_expr="true";
	expr {
	 expr="false";
	};
       };
      };
     };
     FunctionCall @[3] {
      name="FunctionCall_LayersOnOfflesionlayersfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LayersOnOff(lesion_layers, false)";
      result_var=NULL;
      fun=.programs.gp[4][1].functions[2]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="lays";
	required=1;
	def_val=;
	prev_expr="lesion_layers";
	expr {
	 expr="lesion_layers";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="lay_on";
	required=1;
	def_val=;
	prev_expr="true";
	expr {
	 expr="false";
	};
       };
      };
     };
     FunctionCall @[4] {
      name="FunctionCall_ProjectionsOnOfflesionprjnsfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ProjectionsOnOff(lesion_prjns, false)";
      result_var=NULL;
      fun=.programs.gp[4][1].functions[3]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="prjns";
	required=1;
	def_val=;
	prev_expr="lesion_prjns";
	expr {
	 expr="lesion_prjns";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="prjn_on";
	required=1;
	def_val=;
	prev_expr="true";
	expr {
	 expr="false";
	};
       };
      };
     };
     FunctionCall @[5] {
      name="FunctionCall_ProjectionsOnOff_lesionprjnstrue";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ProjectionsOnOff(un_lesion_prjns, true)";
      result_var=NULL;
      fun=$.programs.gp[4][1].functions[3]$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=taString;
	type="String";
	name="prjns";
	required=1;
	def_val=;
	prev_expr="un_lesion_prjns";
	expr {
	 expr="un_lesion_prjns";
	};
       };
       ProgArg @[1] {
	arg_type=bool;
	type="bool";
	name="prjn_on";
	required=1;
	def_val=;
	prev_expr="false";
	expr {
	 expr="true";
	};
       };
      };
     };
     MethodCall @[6] {
      name="MethodCall_networkBuild";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Build()";
      result_var=NULL;
      obj=$.programs.gp[4][1].args[0]$;
      method=Network::Build;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Build()";
      meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
     };
     MethodCall @[7] {
      name="MethodCall_networkUpdtAfterNetMod";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->UpdtAfterNetMod()";
      result_var=NULL;
      obj=$.programs.gp[4][1].args[0]$;
      method=Network::UpdtAfterNetMod;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void UpdtAfterNetMod()";
      meth_desc=" update network after any network modification (calls appropriate functions)";
     };
     PrintExpr @[8] {
      name="PrintExpr_PrintConsnetwork_tsnetworknunits";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print \"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      expr {
       expr="\"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      };
      debug=0;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[2] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][2].doc$$: };
    };
    name="PositionLayersFromTable";
    short_nm="PstLyr";
    tags="Network, Layer, Position";
    desc="positions network layers according to a data table with positions -- can use either absolute or group-relative coordinates, including non-structural groups";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     DataTable @[0] {
      name="LayerLayout";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       String_Data @[0] {
	name="LayerName";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] "Input";"Hidden";"Output";	};
       };
       String_Data @[1] {
	name="LayerGroup";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       String_Data @[2] {
	name="LayoutGroup";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       int_Data @[3] {
	name="X_Abs";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[4] {
	name="Y_Abs";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[5] {
	name="Z_Abs";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
       int_Data @[6] {
	name="X_Rel";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[7] {
	name="Y_Rel";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[8] {
	name="Z_Rel";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [3] 0;1;2;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
     DataTable @[1] {
      name="LayerLayout_previous";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       String_Data @[0] {
	name="LayerName";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] "Input";"Hidden";"Output";	};
       };
       String_Data @[1] {
	name="LayerGroup";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       String_Data @[2] {
	name="LayoutGroup";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=16;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       int_Data @[3] {
	name="X_Abs";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[4] {
	name="Y_Abs";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[5] {
	name="Z_Abs";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
       int_Data @[6] {
	name="X_Rel";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[7] {
	name="Y_Rel";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @[8] {
	name="Z_Rel";
	col_flags=SAVE_DATA|AUTO_WIDTH;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=8;
	matrix_col_width=10;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      row_height=1;
      max_col_width=50;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [3] 0;1;2;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      row_with_hilite=-1;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @[0] {
      name="ActionType";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="GetCurrentPos";
	value=0;
	desc="get current layer positions into table";
       };
       DynEnumItem @[1] {
	name="SetPositions";
	value=1;
	desc="set layer positions based on table";
       };
      };
      bits=0;
     };
     DynEnumType @[1] {
      name="UseGroup";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @[0] {
	name="IgnoreGroup";
	value=0;
	desc="ignore any group information, and just use absolute positions";
       };
       DynEnumItem @[1] {
	name="LayerGroup";
	value=1;
	desc="use layer-group relative positions -- X_Rel etc in table";
       };
       DynEnumItem @[2] {
	name="LayoutGroup";
	value=2;
	desc="use layout groups which are out side the structure of the model -- uses relative positions relative to these layout group offsets";
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="action";
      var_type=T_DynEnum;
      object_scope=NULL;
      dyn_enum_val {
       user_data_=NULL;
       enum_type=.programs.gp[4][2].types[0]$$;
       value=0;
      };
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="use_group";
      var_type=T_DynEnum;
      object_scope=NULL;
      dyn_enum_val {
       user_data_=NULL;
       enum_type=.programs.gp[4][2].types[1]$$;
       value=0;
      };
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="LayerLayout";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.programs.gp[4][2].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="LayerLayout_previous";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.programs.gp[4][2].objs[1]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="GetCurrent";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="GetCurrent() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars4vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (4 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="leaf";
	  var_type=T_Int;
	  int_val=0;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="current_layer";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc="current_layer = NULL (Layer)";
	  init_from=NULL;
	 };
	 ProgVar @[2] {
	  name="net_layers";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[3] {
	  name="layer_group";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       MethodCall @[1] {
	name="MethodCall_LayerLayoutprevi_FromLayerLayout";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LayerLayout_previous->CopyFrom(LayerLayout)";
	result_var=NULL;
	obj=.programs.gp[4][2].vars[1]$$;
	method=taBase::CopyFrom;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taBase_ptr;
	  type="taBase*";
	  name="cpy_from";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="LayerLayout";
	  };
	 };
	};
	meth_sig="bool CopyFrom(taBase* cpy_from)";
	meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
       };
       MethodCall @[2] {
	name="MethodCall_LayerLayoutRemoveAllRows";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LayerLayout->RemoveAllRows()";
	result_var=NULL;
	obj=.programs.gp[4][2].vars[0]$$;
	method=DataTable::RemoveAllRows;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void RemoveAllRows()";
	meth_desc=" remove all of the rows of data, but keep the column structure";
       };
       AssignExpr @[3] {
	name="AssignExpr_netlayersnetworklayers";
	desc="all of the layers";
	flags=CAN_REVERT_TO_CODE;
	code_string="net_layers = network.layers";
	result_var=.programs.gp[4][2].functions[0].fun_code[0].local_vars[2]$$;
	expr {
	 expr="network.layers";
	};
       };
       Comment @[4] {
	name="Comment_firstgetallthelayergroups";
	desc="first get all the layer groups";
	flags=CAN_REVERT_TO_CODE;
	code_string="// first get all the layer groups";
       };
       ForeachLoop @[5] {
	name="ForeachLoop_foreachlayergroupinnetlayersgp";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(layer_group in net_layers.gp)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_LayerLayoutAddBlankRow";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout->AddBlankRow()";
	  result_var=NULL;
	  obj=$.programs.gp[4][2].vars[0]$;
	  method=DataTable::AddBlankRow;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="int AddBlankRow()";
	  meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	 };
	 CssExpr @[1] {
	  name="CssExpr_LayerLayoutLayer_1layergroupname";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"LayerGroup\"][-1] = layer_group.name;";
	  expr {
	   expr="LayerLayout[\"LayerGroup\"][-1] = layer_group.name;";
	  };
	 };
	 CssExpr @[2] {
	  name="CssExpr_LayerLayoutXAbs1layergroupposx";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"X_Abs\"][-1] = layer_group.pos.x;";
	  expr {
	   expr="LayerLayout[\"X_Abs\"][-1] = layer_group.pos.x;";
	  };
	 };
	 CssExpr @[3] {
	  name="CssExpr_LayerLayoutYAbs1layergroupposy";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Y_Abs\"][-1] = layer_group.pos.y;";
	  expr {
	   expr="LayerLayout[\"Y_Abs\"][-1] = layer_group.pos.y;";
	  };
	 };
	 CssExpr @[4] {
	  name="CssExpr_LayerLayoutZAbs1layergroupposz";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Z_Abs\"][-1] = layer_group.pos.z;";
	  expr {
	   expr="LayerLayout[\"Z_Abs\"][-1] = layer_group.pos.z;";
	  };
	 };
	};
	el_var=.programs.gp[4][2].functions[0].fun_code[0].local_vars[3]$$;
	in {
	 expr="net_layers.gp";
	};
       };
       ForLoop @[6] {
	name="ForLoop_forleaf0leafnetlayersleavesleaf";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="for (leaf=0; leaf <net_layers.leaves; leaf++)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_LayerLayoutAddBlankRow";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout->AddBlankRow()";
	  result_var=NULL;
	  obj=$.programs.gp[4][2].vars[0]$;
	  method=DataTable::AddBlankRow;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="int AddBlankRow()";
	  meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	 };
	 AssignExpr @[1] {
	  name="AssignExpr_currentlayernetlayersLeafleaf";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="current_layer = net_layers.Leaf(leaf)";
	  result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[1]$$;
	  expr {
	   expr="net_layers.Leaf(leaf)";
	  };
	 };
	 CssExpr @[2] {
	  name="CssExpr_LayerLayoutLayer_urrentlayername";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"LayerName\"][-1] = current_layer.name;";
	  expr {
	   expr="LayerLayout[\"LayerName\"][-1] = current_layer.name;";
	  };
	 };
	 If @[3] {
	  name="If_ifcurrentlayerInLayerSubGroup";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (current_layer.InLayerSubGroup())";
	  cond {
	   expr="current_layer.InLayerSubGroup()";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   CssExpr @[0] {
	    name="CssExpr_LayerLayoutLayer_yerGetOwnername";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="LayerLayout[\"LayerGroup\"][-1] = current_layer.GetOwner().name;";
	    expr {
	     expr="LayerLayout[\"LayerGroup\"][-1] = current_layer.GetOwner().name;";
	    };
	   };
	  };
	 };
	 CssExpr @[4] {
	  name="CssExpr_LayerLayoutXAbs1_entlayerposabsx";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"X_Abs\"][-1] = current_layer.pos_abs.x;";
	  expr {
	   expr="LayerLayout[\"X_Abs\"][-1] = current_layer.pos_abs.x;";
	  };
	 };
	 CssExpr @[5] {
	  name="CssExpr_LayerLayoutYAbs1_entlayerposabsy";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Y_Abs\"][-1] = current_layer.pos_abs.y;";
	  expr {
	   expr="LayerLayout[\"Y_Abs\"][-1] = current_layer.pos_abs.y;";
	  };
	 };
	 CssExpr @[6] {
	  name="CssExpr_LayerLayoutZAbs1_entlayerposabsz";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Z_Abs\"][-1] = current_layer.pos_abs.z;";
	  expr {
	   expr="LayerLayout[\"Z_Abs\"][-1] = current_layer.pos_abs.z;";
	  };
	 };
	 CssExpr @[7] {
	  name="CssExpr_LayerLayoutXRel1currentlayerposx";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"X_Rel\"][-1] = current_layer.pos.x;";
	  expr {
	   expr="LayerLayout[\"X_Rel\"][-1] = current_layer.pos.x;";
	  };
	 };
	 CssExpr @[8] {
	  name="CssExpr_LayerLayoutYRel1currentlayerposy";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Y_Rel\"][-1] = current_layer.pos.y;";
	  expr {
	   expr="LayerLayout[\"Y_Rel\"][-1] = current_layer.pos.y;";
	  };
	 };
	 CssExpr @[9] {
	  name="CssExpr_LayerLayoutZRel1currentlayerposz";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Z_Rel\"][-1] = current_layer.pos.z;";
	  expr {
	   expr="LayerLayout[\"Z_Rel\"][-1] = current_layer.pos.z;";
	  };
	 };
	};
	init {
	 expr="leaf=0";
	};
	test {
	 expr="leaf <net_layers.leaves";
	};
	iter {
	 expr="leaf++";
	};
       };
      };
     };
     Function @[1] {
      name="SetPos";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="SetPos() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars9vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (9 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @[0] {
	  name="row";
	  var_type=T_Int;
	  int_val=0;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[1] {
	  name="current_layer";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[2] {
	  name="layer_name";
	  var_type=T_String;
	  string_val=;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[3] {
	  name="layer_group";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  object_scope=NULL;
	  objs_ptr=0;
	  flags=LOCAL_VAR|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[4] {
	  name="group_name";
	  var_type=T_String;
	  string_val=;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[5] {
	  name="lgrow";
	  var_type=T_Int;
	  int_val=0;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[6] {
	  name="lg_x";
	  var_type=T_Int;
	  int_val=0;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[7] {
	  name="lg_y";
	  var_type=T_Int;
	  int_val=0;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @[8] {
	  name="lg_z";
	  var_type=T_Int;
	  int_val=0;
	  object_scope=NULL;
	  flags=LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       ForLoop @[1] {
	name="ForLoop_forrow0rowLayerLayoutrowsrow";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="for (row = 0; row <LayerLayout.rows; row++)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  name="AssignExpr_layernameLayerLayoutLayerNamerow";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="layer_name = LayerLayout[\"LayerName\"][row]";
	  result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[2]$$;
	  expr {
	   expr="LayerLayout[\"LayerName\"][row]";
	  };
	 };
	 IfContinue @[1] {
	  name="IfContinue_iflayernameemptycontinue";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if(layer_name.empty()) continue";
	  cond {
	   expr="layer_name.empty()";
	  };
	 };
	 AssignExpr @[2] {
	  name="AssignExpr_currentlayernetw_dLayerlayername";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="current_layer = network.FindLayer(layer_name)";
	  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[1]$;
	  expr {
	   expr="network.FindLayer(layer_name)";
	  };
	 };
	 If @[3] {
	  name="If_ifcurrentlayer";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (current_layer)";
	  cond {
	   expr="current_layer";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   Switch @[0] {
	    name="Switch_switchusegroup";
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="switch(use_group)";
	    switch_var=.programs.gp[4][2].args[1]$$;
	    cases {
	     name="cases";
	     el_typ=CaseBlock;
	     el_def=0;
	     CaseBlock @[0] {
	      name="CaseBlock_caseIgnoreGroup";
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="case: IgnoreGroup";
	      prog_code {
	       name="prog_code";
	       el_typ=ProgCode;
	       el_def=0;
	       MethodCall @[0] {
		name="MethodCall_currentlayerSetA_erLayoutZAbsrow";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="current_layer->SetAbsPos(LayerLayout[\"X_Abs\"][row], LayerLayout[\"Y_Abs\"][row], LayerLayout[\"Z_Abs\"][row])";
		result_var=NULL;
		obj=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[1]$;
		method=Layer::SetAbsPos;
		meth_args {
		 name="meth_args";
		 el_typ=ProgArg;
		 el_def=0;
		 ProgArg @[0] {
		  arg_type=int;
		  type="int";
		  name="x";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="LayerLayout[\"X_Abs\"][row]";
		  };
		 };
		 ProgArg @[1] {
		  arg_type=int;
		  type="int";
		  name="y";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="LayerLayout[\"Y_Abs\"][row]";
		  };
		 };
		 ProgArg @[2] {
		  arg_type=int;
		  type="int";
		  name="z";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="LayerLayout[\"Z_Abs\"][row]";
		  };
		 };
		};
		meth_sig="void SetAbsPos(int x, int y, int z)";
		meth_desc=" set absolute position of layer, regardless of whether it is in a layer group or not - always relative to network 0,0,0";
	       };
	      };
	      case_val {
	       expr="IgnoreGroup";
	      };
	      is_default=0;
	     };
	     CaseBlock @[1] {
	      name="CaseBlock_caseLayerGroup";
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="case: LayerGroup";
	      prog_code {
	       name="prog_code";
	       el_typ=ProgCode;
	       el_def=0;
	       AssignExpr @[0] {
		name="AssignExpr_groupnameLayerLa_utLayerGrouprow";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="group_name = LayerLayout[\"LayerGroup\"][row]";
		result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[4]$$;
		expr {
		 expr="LayerLayout[\"LayerGroup\"][row]";
		};
	       };
	       If @[1] {
		name="If_ifgroupnamenonempty";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="if (group_name.nonempty())";
		cond {
		 expr="group_name.nonempty()";
		};
		true_code {
		 name="true_code";
		 el_typ=ProgCode;
		 el_def=0;
		 MethodCall @[0] {
		  name="MethodCall_lgrowLayerLayout_LayerGroup0true";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lgrow = LayerLayout->FindVal(group_name, \"LayerGroup\", 0, true)";
		  result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[5]$$;
		  obj=$.programs.gp[4][2].vars[0]$;
		  method=DataTable::FindVal;
		  meth_args {
		   name="meth_args";
		   el_typ=ProgArg;
		   el_def=0;
		   ProgArg @[0] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="val";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="group_name";
		    };
		   };
		   ProgArg @[1] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="col";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="\"LayerGroup\"";
		    };
		   };
		   ProgArg @[2] {
		    arg_type=int;
		    type="int";
		    name="st_row";
		    required=0;
		    def_val="0";
		    prev_expr=;
		    expr {
		     expr="0";
		    };
		   };
		   ProgArg @[3] {
		    arg_type=bool;
		    type="bool";
		    name="not_found_err";
		    required=0;
		    def_val="false";
		    prev_expr=;
		    expr {
		     expr="true";
		    };
		   };
		  };
		  meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
		  meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
		 };
		 AssignExpr @[1] {
		  name="AssignExpr_lgxLayerLayoutXAbslgrow";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = LayerLayout[\"X_Abs\"][lgrow]";
		  result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[6]$$;
		  expr {
		   expr="LayerLayout[\"X_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[2] {
		  name="AssignExpr_lgyLayerLayoutYAbslgrow";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = LayerLayout[\"Y_Abs\"][lgrow]";
		  result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[7]$$;
		  expr {
		   expr="LayerLayout[\"Y_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[3] {
		  name="AssignExpr_lgzLayerLayoutZAbslgrow";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = LayerLayout[\"Z_Abs\"][lgrow]";
		  result_var=.programs.gp[4][2].functions[1].fun_code[0].local_vars[8]$$;
		  expr {
		   expr="LayerLayout[\"Z_Abs\"][lgrow]";
		  };
		 };
		};
	       };
	       Else @[2] {
		name="Else_If_ifgroupnamenonempty";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="else";
		cond {
		 expr=;
		};
		true_code {
		 name="true_code";
		 el_typ=ProgCode;
		 el_def=0;
		 AssignExpr @[0] {
		  name="AssignExpr_lgx0";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = 0";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[6]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[1] {
		  name="AssignExpr_lgy0";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = 0";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[7]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[2] {
		  name="AssignExpr_lgz0";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = 0";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[8]$;
		  expr {
		   expr="0";
		  };
		 };
		};
	       };
	       MethodCall @[3] {
		name="MethodCall_currentlayerSetA_erLayoutZRelrow";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="current_layer->SetAbsPos(lg_x + LayerLayout[\"X_Rel\"][row], lg_y + LayerLayout[\"Y_Rel\"][row], lg_z + LayerLayout[\"Z_Rel\"][row])";
		result_var=NULL;
		obj=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[1]$;
		method=Layer::SetAbsPos;
		meth_args {
		 name="meth_args";
		 el_typ=ProgArg;
		 el_def=0;
		 ProgArg @[0] {
		  arg_type=int;
		  type="int";
		  name="x";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_x + LayerLayout[\"X_Rel\"][row]";
		  };
		 };
		 ProgArg @[1] {
		  arg_type=int;
		  type="int";
		  name="y";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_y + LayerLayout[\"Y_Rel\"][row]";
		  };
		 };
		 ProgArg @[2] {
		  arg_type=int;
		  type="int";
		  name="z";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_z + LayerLayout[\"Z_Rel\"][row]";
		  };
		 };
		};
		meth_sig="void SetAbsPos(int x, int y, int z)";
		meth_desc=" set absolute position of layer, regardless of whether it is in a layer group or not - always relative to network 0,0,0";
	       };
	      };
	      case_val {
	       expr="LayerGroup";
	      };
	      is_default=0;
	     };
	     CaseBlock @[2] {
	      name="CaseBlock_caseLayoutGroup";
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="case: LayoutGroup";
	      prog_code {
	       name="prog_code";
	       el_typ=ProgCode;
	       el_def=0;
	       AssignExpr @[0] {
		name="AssignExpr_groupnameLayerLa_tLayoutGrouprow";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="group_name = LayerLayout[\"LayoutGroup\"][row]";
		result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[4]$;
		expr {
		 expr="LayerLayout[\"LayoutGroup\"][row]";
		};
	       };
	       If @[1] {
		name="If_ifgroupnamenonempty";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="if (group_name.nonempty())";
		cond {
		 expr="group_name.nonempty()";
		};
		true_code {
		 name="true_code";
		 el_typ=ProgCode;
		 el_def=0;
		 MethodCall @[0] {
		  name="MethodCall_lgrowLayerLayout_ayoutGroup0true";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lgrow = LayerLayout->FindVal(group_name, \"LayoutGroup\", 0, true)";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[5]$;
		  obj=$.programs.gp[4][2].vars[0]$;
		  method=DataTable::FindVal;
		  meth_args {
		   name="meth_args";
		   el_typ=ProgArg;
		   el_def=0;
		   ProgArg @[0] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="val";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="group_name";
		    };
		   };
		   ProgArg @[1] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="col";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="\"LayoutGroup\"";
		    };
		   };
		   ProgArg @[2] {
		    arg_type=int;
		    type="int";
		    name="st_row";
		    required=0;
		    def_val="0";
		    prev_expr=;
		    expr {
		     expr="0";
		    };
		   };
		   ProgArg @[3] {
		    arg_type=bool;
		    type="bool";
		    name="not_found_err";
		    required=0;
		    def_val="false";
		    prev_expr=;
		    expr {
		     expr="true";
		    };
		   };
		  };
		  meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
		  meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
		 };
		 AssignExpr @[1] {
		  name="AssignExpr_lgxLayerLayoutXAbslgrow";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = LayerLayout[\"X_Abs\"][lgrow]";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[6]$;
		  expr {
		   expr="LayerLayout[\"X_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[2] {
		  name="AssignExpr_lgyLayerLayoutYAbslgrow";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = LayerLayout[\"Y_Abs\"][lgrow]";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[7]$;
		  expr {
		   expr="LayerLayout[\"Y_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[3] {
		  name="AssignExpr_lgzLayerLayoutZAbslgrow";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = LayerLayout[\"Z_Abs\"][lgrow]";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[8]$;
		  expr {
		   expr="LayerLayout[\"Z_Abs\"][lgrow]";
		  };
		 };
		};
	       };
	       Else @[2] {
		name="Else_If_ifgroupnamenonempty";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="else";
		cond {
		 expr=;
		};
		true_code {
		 name="true_code";
		 el_typ=ProgCode;
		 el_def=0;
		 AssignExpr @[0] {
		  name="AssignExpr_lgx0";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = 0";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[6]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[1] {
		  name="AssignExpr_lgy0";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = 0";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[7]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[2] {
		  name="AssignExpr_lgz0";
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = 0";
		  result_var=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[8]$;
		  expr {
		   expr="0";
		  };
		 };
		};
	       };
	       MethodCall @[3] {
		name="MethodCall_currentlayerSetA_erLayoutZRelrow";
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="current_layer->SetAbsPos(lg_x + LayerLayout[\"X_Rel\"][row], lg_y + LayerLayout[\"Y_Rel\"][row], lg_z + LayerLayout[\"Z_Rel\"][row])";
		result_var=NULL;
		obj=$.programs.gp[4][2].functions[1].fun_code[0].local_vars[1]$;
		method=Layer::SetAbsPos;
		meth_args {
		 name="meth_args";
		 el_typ=ProgArg;
		 el_def=0;
		 ProgArg @[0] {
		  arg_type=int;
		  type="int";
		  name="x";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_x + LayerLayout[\"X_Rel\"][row]";
		  };
		 };
		 ProgArg @[1] {
		  arg_type=int;
		  type="int";
		  name="y";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_y + LayerLayout[\"Y_Rel\"][row]";
		  };
		 };
		 ProgArg @[2] {
		  arg_type=int;
		  type="int";
		  name="z";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_z + LayerLayout[\"Z_Rel\"][row]";
		  };
		 };
		};
		meth_sig="void SetAbsPos(int x, int y, int z)";
		meth_desc=" set absolute position of layer, regardless of whether it is in a layer group or not - always relative to network 0,0,0";
	       };
	      };
	      case_val {
	       expr="LayoutGroup";
	      };
	      is_default=0;
	     };
	    };
	   };
	  };
	 };
	};
	init {
	 expr="row = 0";
	};
	test {
	 expr="row <LayerLayout.rows";
	};
	iter {
	 expr="row++";
	};
       };
       MethodCall @[2] {
	name="MethodCall_networkBuild";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	result_var=NULL;
	obj=.programs.gp[4][2].args[2]$$;
	method=LeabraNetwork::Build;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Switch @[0] {
      name="Switch_switchaction";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="switch(action)";
      switch_var=.programs.gp[4][2].args[0]$$;
      cases {
       name="cases";
       el_typ=CaseBlock;
       el_def=0;
       CaseBlock @[0] {
	name="CaseBlock_caseGetCurrentPos";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="case: GetCurrentPos";
	prog_code {
	 name="prog_code";
	 el_typ=ProgCode;
	 el_def=0;
	 FunctionCall @[0] {
	  name="FunctionCall_GetCurrent";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="GetCurrent()";
	  result_var=NULL;
	  fun=.programs.gp[4][2].functions[0]$$;
	  fun_args {
	   name="fun_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	case_val {
	 expr="GetCurrentPos";
	};
	is_default=0;
       };
       CaseBlock @[1] {
	name="CaseBlock_caseSetPositions";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="case: SetPositions";
	prog_code {
	 name="prog_code";
	 el_typ=ProgCode;
	 el_def=0;
	 FunctionCall @[0] {
	  name="FunctionCall_SetPos";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="SetPos()";
	  result_var=NULL;
	  fun=.programs.gp[4][2].functions[1]$$;
	  fun_args {
	   name="fun_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	case_val {
	 expr="SetPositions";
	};
	is_default=0;
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[3] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][3].doc$$: };
    };
    name="NetworkToggleLesion";
    short_nm="NtwTgg";
    tags=;
    desc="toggle lesion status on or off in network -- for dynamic speedup..";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=String_Matrix;
     el_def=0;
     String_Matrix @[0] {
      name="les_lay_mat";
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="lesion_layers";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer group names to lesion or unlesion";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="lesion";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="if true, lesion the layer groups, otherwise unlesion them";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="les_lay_mat";
      var_type=T_Object;
      object_type=String_Matrix;
      object_val=.programs.gp[4][3].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="i";
      var_type=T_Int;
      int_val=4;
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[2] {
      name="laygp_nm";
      var_type=T_String;
      string_val="Head";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="laygp";
      var_type=T_Object;
      object_type=Layer_Group;
      object_val=NULL;
      object_scope=NULL;
      objs_ptr=0;
      flags=SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_leslaymatFmDelim_inglesionlayers";
      desc="get into easier to use matrix format";
      flags=CAN_REVERT_TO_CODE;
      code_string="les_lay_mat->FmDelimString(lesion_layers, \" \")";
      result_var=NULL;
      obj=.programs.gp[4][3].vars[0]$$;
      method=String_Matrix::FmDelimString;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="str";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="lesion_layers";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="delim";
	required=0;
	def_val=" ";
	prev_expr=;
	expr {
	 expr="\" \"";
	};
       };
      };
      meth_sig="void FmDelimString(taString& str, taString& delim =  )";
      meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
     };
     ForLoop @[1] {
      name="ForLoop_fori0ileslaymatsizei";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < les_lay_mat.size; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_laygpnmleslaymatSafeElFlati";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp_nm = les_lay_mat->SafeEl_Flat(i)";
	result_var=.programs.gp[4][3].vars[2]$$;
	obj=$.programs.gp[4][3].vars[0]$;
	method=taMatrixT_taString_::SafeEl_Flat;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="taString_ref SafeEl_Flat(int idx)";
	meth_desc=" (safely) access the matrix as if it were a flat vector, for reading";
       };
       MemberMethodCall @[1] {
	name="MemberMethodCall_laygpnetworklaye_FindNamelaygpnm";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp = network.layers.gp.FindName(laygp_nm)";
	obj=.programs.gp[4][3].args[0]$$;
	path="layers.gp";
	result_var=.programs.gp[4][3].vars[3]$$;
	method=taGroup_Layer_::FindName;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="item_nm";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="laygp_nm";
	  };
	 };
	};
	meth_sig="Layer_ptr FindName(taString& item_nm)";
	meth_desc=" Find element in top-level list with given name (nm) (NULL = not here)";
       };
       If @[2] {
	name="If_iflaygp";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (!laygp)";
	cond {
	 expr="!laygp";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MiscCall @[0] {
	  name="MiscCall_taMiscErrorlayer_worknetworkname";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	  result_var=NULL;
	  object_type=taMisc;
	  method=taMisc::Error;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="a";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\"layer group named:\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="b";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="laygp_nm";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="c";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="\"not found in network:\"";
	    };
	   };
	   ProgArg @[3] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="d";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr="network.name";
	    };
	   };
	   ProgArg @[4] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="e";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[5] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="f";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[6] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="g";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[7] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="h";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[8] {
	    arg_type=const_taString_ref;
	    type="taString&";
	    name="i";
	    required=0;
	    def_val="\"\"";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	 IfContinue @[1] {
	  name="IfContinue_continue";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="continue";
	  cond {
	   expr=;
	  };
	 };
	};
       };
       If @[3] {
	name="If_iflesion";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (lesion)";
	cond {
	 expr="lesion";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_laygpLesionLayers";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp->LesionLayers()";
	  result_var=NULL;
	  obj=$.programs.gp[4][3].vars[3]$;
	  method=Layer_Group::LesionLayers;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void LesionLayers()";
	  meth_desc=" set the lesion flag on all the layers within this group -- removes them from all processing operations";
	 };
	};
       };
       Else @[4] {
	name="Else_If_iflesion";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="else";
	cond {
	 expr=;
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  name="MethodCall_laygpUnLesionLayers";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp->UnLesionLayers()";
	  result_var=NULL;
	  obj=$.programs.gp[4][3].vars[3]$;
	  method=Layer_Group::UnLesionLayers;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void UnLesionLayers()";
	  meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
	 };
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < les_lay_mat.size";
      };
      iter {
       expr="i++";
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkUpdtAfterNetMod";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->UpdtAfterNetMod()";
      result_var=NULL;
      obj=$.programs.gp[4][3].args[0]$;
      method=Network::UpdtAfterNetMod;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void UpdtAfterNetMod()";
      meth_desc=" update network after any network modification (calls appropriate functions)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=0;
     wiki=;
     url="local";
     full_url="local";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[4] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][4].doc$$: };
    };
    name="TrainStart";
    short_nm="TrnStart";
    tags=;
    desc="basic stuff (init weights, load weights etc) at start of training -- also calls EpochStart -- most init progs will call this";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="randy.oreilly@colorado.edu";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     RndSeed @[0] {
      name="dmem_rnd_seed";
      rnd_seed=1439355325;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="dmem_rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.programs.gp[4][4].objs[0]$$;
      object_scope=NULL;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[1] {
      name="load_weights";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="load initial weights from a file (specified in weights_file)";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="weights_file";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="full relative path (from project) of weights file to load -- use CRR: prefix to load from cluster run results directory";
      init_from=NULL;
     };
     ProgVar @[3] {
      name="load_st_epc";
      var_type=T_Int;
      int_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="after loading weights, reset epoch counter to this value (-1 = leave at value from the loaded weights)";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="lrs_step_epochs";
      var_type=T_Int;
      int_val=50;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="learning rate schedule epochs per step of decrease in learning rate";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="lrs_n_steps";
      var_type=T_Int;
      int_val=7;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of steps in the learning rate schedule";
      init_from=NULL;
     };
     ProgVar @[6] {
      name="lrs_bump_step";
      var_type=T_Int;
      int_val=-1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="if positive (3 is typical), then bump up the learning rate at this step in the schedule -- can help improve final performance level";
      init_from=NULL;
     };
     ProgVar @[7] {
      name="LRSConSpec";
      var_type=T_Object;
      object_type=LeabraConSpec;
      object_val=$.networks[0].specs[2]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[8] {
      name="save_log_files_interactive";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="save log files when running interactively?";
      init_from=NULL;
     };
     ProgVar @[9] {
      name="dmem_new_seed";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="when running under dmem (MPI), generate a new random seed for each node after common initialization, to cause each node to have different random events, etc.   It is now possible to add taMisc::dmem_proc to the thr_no args to any random functions, and achieve fully reproducible results without this randomization.";
      init_from=NULL;
     };
     ProgVar @[10] {
      name="train_epochs";
      var_type=T_Int;
      int_val=50;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="number of epochs to train network for";
      init_from=NULL;
     };
     ProgVar @[11] {
      name="trials_per_epoch";
      var_type=T_Int;
      int_val=50;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of trials per epoch";
      init_from=NULL;
     };
     ProgVar @[12] {
      name="trials_per_epoch_eff";
      var_type=T_Int;
      int_val=50;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="effective value, taking into account number of MPI processors";
      init_from=NULL;
     };
     ProgVar @[13] {
      name="test_run";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="is this a testing-only run, no training?";
      init_from=NULL;
     };
     ProgVar @[14] {
      name="test_interval";
      var_type=T_Int;
      int_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc="how frequently (epochs) to run a test during training";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @[0] {
      name="DMemSafeTrialsPerEpoch";
      desc=;
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="DMemSafeTrialsPerEpoch() returns: int";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="args";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="fun_code";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	name="LocalVars_LocalVars0vars";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       AssignExpr @[1] {
	name="AssignExpr_trialsperepochefftrialsperepoch";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="trials_per_epoch_eff = trials_per_epoch";
	result_var=.programs.gp[4][4].vars[12]$$;
	expr {
	 expr="trials_per_epoch";
	};
       };
       If @[2] {
	name="If_iftaMiscdmemnprocs1";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (taMisc::dmem_nprocs > 1)";
	cond {
	 expr="taMisc::dmem_nprocs > 1";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  name="AssignExpr_trialsperepochef_aMiscdmemnprocs";
	  desc="dmem means that each guy does less -- uses randomization to get good mix across processors";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="trials_per_epoch_eff = trials_per_epoch / taMisc::dmem_nprocs";
	  result_var=$.programs.gp[4][4].vars[12]$;
	  expr {
	   expr="trials_per_epoch / taMisc::dmem_nprocs";
	  };
	 };
	 If @[1] {
	  name="If_iftrialsperepoch_strialsperepoch";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (trials_per_epoch_eff * taMisc::dmem_nprocs < trials_per_epoch)";
	  cond {
	   expr="trials_per_epoch_eff * taMisc::dmem_nprocs < trials_per_epoch";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   VarIncr @[0] {
	    name="VarIncr_trialsperepocheff1";
	    desc="round up..";
	    flags=CAN_REVERT_TO_CODE;
	    code_string="trials_per_epoch_eff += 1";
	    var=$.programs.gp[4][4].vars[12]$;
	    expr {
	     expr="1";
	    };
	   };
	  };
	 };
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     FunctionCall @[0] {
      name="FunctionCall_DMemSafeTrialsPerEpoch";
      desc=;
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="DMemSafeTrialsPerEpoch()";
      result_var=NULL;
      fun=.programs.gp[4][4].functions[0]$$;
      fun_args {
       name="fun_args";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     ProgramCall @[1] {
      name="ProgramCall_BatchRndSeednetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="BatchRndSeed(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4][0]$$;
      targ_ld_init="*BatchRndSeed*";
     };
     If @[2] {
      name="If_ifnetworkIsBuiltIntact";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (!network->IsBuiltIntact())";
      cond {
       expr="!network->IsBuiltIntact()";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkBuild";
	desc="needs to have been built by now..";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	result_var=NULL;
	obj=.programs.gp[4][4].args[0]$$;
	method=Network::Build;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
      };
     };
     If @[3] {
      name="If_iftaMiscinteract_ilesinteractive";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (!taMisc::interactive || save_log_files_interactive)";
      cond {
       expr="!taMisc::interactive || save_log_files_interactive";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveLogFilesnetwork";
	desc="save log files for all jobs -- after network is fully built and configed";
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveLogFiles(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4].gp[0][0]$;
	targ_ld_init="*SaveLogFiles*";
       };
      };
     };
     MethodCall @[4] {
      name="MethodCall_networkInitWeights";
      desc="initialize network weights: could also load pre-set weights or something else here";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_Weights()";
      result_var=NULL;
      obj=$.programs.gp[4][4].args[0]$;
      method=Network::Init_Weights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_Weights()";
      meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
     };
     PrintExpr @[5] {
      name="PrintExpr_Printnetworkname_ghtsInitialized";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print network.name << \" Weights Initialized\"";
      expr {
       expr="network.name << \" Weights Initialized\"";
      };
      debug=0;
     };
     If @[6] {
      name="If_ifloadweightsweightsfilenonempty";
      desc="Load  weights if file is specified";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (load_weights && weights_file.nonempty())";
      cond {
       expr="load_weights && weights_file.nonempty()";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkLoadWeigh_eightsfilefalse";
	desc="Load weights from the specified file";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->LoadWeights(weights_file, false)";
	result_var=NULL;
	obj=$.programs.gp[4][4].args[0]$;
	method=Network::LoadWeights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="fname";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="weights_file";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=bool;
	  type="bool";
	  name="quiet";
	  required=0;
	  def_val="false";
	  prev_expr=;
	  expr {
	   expr="false";
	  };
	 };
	};
	meth_sig="bool LoadWeights(taString& fname, bool quiet = false)";
	meth_desc=" read weight values in from a simple ordered list of weights (fmt is read from file) (leave fname empty to pull up file chooser)";
       };
       PrintVar @[1] {
	name="PrintVar_Printloadedweigh_fileweightsfile";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print  \"loaded weights file:\" weights_file";
	message="loaded weights file:";
	print_var=$.programs.gp[4][4].vars[2]$;
	print_var2=NULL;
	print_var3=NULL;
	print_var4=NULL;
	print_var5=NULL;
	print_var6=NULL;
	debug=0;
       };
       If @[2] {
	name="If_ifloadstepc0";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (load_st_epc >= 0)";
	cond {
	 expr="load_st_epc >= 0";
	};
	true_code {
	 name="true_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MemberAssign @[0] {
	  name="MemberAssign_networkepochloadstepc";
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="network.epoch = load_st_epc";
	  obj=$.programs.gp[4][4].args[0]$;
	  path="epoch";
	  expr {
	   expr="load_st_epc";
	  };
	  update_after=1;
	 };
	};
       };
      };
     };
     MethodCall @[7] {
      name="MethodCall_LRSConSpecLogLra_tepslrsbumpstep";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LRSConSpec->LogLrateSched(lrs_step_epochs, lrs_n_steps, lrs_bump_step)";
      result_var=NULL;
      obj=.programs.gp[4][4].vars[7]$$;
      method=LeabraConSpec::LogLrateSched;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="epcs_per_step";
	required=0;
	def_val="50";
	prev_expr="lrs_step_epochs";
	expr {
	 expr="lrs_step_epochs";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="n_steps";
	required=0;
	def_val="5";
	prev_expr="7";
	expr {
	 expr="lrs_n_steps";
	};
       };
       ProgArg @[2] {
	arg_type=int;
	type="int";
	name="bump_step";
	required=0;
	def_val="-1";
	prev_expr=;
	expr {
	 expr="lrs_bump_step";
	};
       };
      };
      meth_sig="void LogLrateSched(int epcs_per_step = 50, int n_steps = 5, int bump_step = -1)";
      meth_desc=" establish a logarithmic learning rate schedule with given total number of steps (including first step at lrate) and epochs per step: numbers go down in sequence: 1, .5, .2, .1, .05, .02, .01, etc.. this is a particularly good lrate schedule for large nets on hard tasks -- if bump_step > 0 (3 is a good default), the lrate bumps back up to 1 and back down to that step level, and then proceeds from there -- this can pop a model out of a local minimum and result in better final performance";
     };
     If @[8] {
      name="If_ifdmemnewseedtaMiscdmemnprocs1";
      desc="if dmem, then from here on out, processors diverge so that lists of objs per processor are different!";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (dmem_new_seed && taMisc::dmem_nprocs > 1)";
      cond {
       expr="dmem_new_seed && taMisc::dmem_nprocs > 1";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_dmemrndseedNewSeed";
	desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
	flags=CAN_REVERT_TO_CODE;
	code_string="dmem_rnd_seed->NewSeed()";
	result_var=NULL;
	obj=.programs.gp[4][4].vars[0]$$;
	method=RndSeed::NewSeed;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void NewSeed()";
	meth_desc=" set the seed to a new random value (based on time and process id)";
       };
      };
     };
     ProgramCall @[9] {
      name="ProgramCall_EpochStartnetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="EpochStart(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][6]$;
      targ_ld_init="*EpochStart*";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrain";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrain";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[5] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][5].doc$$: };
    };
    name="TrainEnd";
    short_nm="TrnEnd";
    tags=;
    desc="end training -- save weights if needed, compute final summary stats -- and set stop_train";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="save_final_wts";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="should final weights after training is complete be saved?";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="Train";
      var_type=T_Object;
      object_type=Program;
      object_val=$.programs.gp[1][1]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_ifsavefinalwts";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (save_final_wts)";
      cond {
       expr="save_final_wts";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveWeightsnetwork";
	desc="Always save weights at the end";
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeights(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.programs.gp[4][15]$$;
	targ_ld_init="*SaveWeights*";
       };
      };
     };
     MethodCall @[1] {
      name="MethodCall_TrainSetVarstoptraintrue";
      desc="stop training!";
      flags=CAN_REVERT_TO_CODE;
      code_string="Train->SetVar(\"stop_train\", true)";
      result_var=NULL;
      obj=.programs.gp[4][5].vars[1]$$;
      method=Program::SetVar;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="var_nm";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\"stop_train\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="value";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="bool SetVar(taString& var_nm, Variant& value)";
      meth_desc=" set the value of a program variable (only top-level variables in vars or args) -- can be called from within a running program";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrain";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrain";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[6] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][6].doc$$: };
    };
    name="EpochStart";
    short_nm="EpcStart";
    tags=;
    desc="Start a new epoch";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.data.gp[1][0]$$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="BasicTrainTime";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.programs.gp[2][0].objs[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      name="MemberAssign_networktrial0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network.trial = 0";
      obj=.programs.gp[4][6].args[0]$$;
      path="trial";
      expr {
       expr="0";
      };
      update_after=0;
     };
     MemberMethodCall @[1] {
      name="MemberMethodCall_networkepochtimeStartTimertrue";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.epoch_time.StartTimer(true)";
      obj=$.programs.gp[4][6].args[0]$;
      path="epoch_time";
      result_var=NULL;
      method=TimeUsed::StartTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[2] {
      name="MethodCall_BasicTrainTimeResetUsed";
      desc="keep other time info on an epoch basis";
      flags=CAN_REVERT_TO_CODE;
      code_string="BasicTrainTime->ResetUsed()";
      result_var=NULL;
      obj=.programs.gp[4][6].vars[1]$$;
      method=TimeUsed::ResetUsed;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetUsed()";
      meth_desc=" reset time used information";
     };
     MethodCall @[3] {
      name="MethodCall_trialmondataResetData";
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.programs.gp[4][6].vars[0]$$;
      method=DataTable::ResetData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
     MethodCall @[4] {
      name="MethodCall_networkInitEpoch";
      desc="added in 8.0: essential for param_seqs";
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="network->Init_Epoch()";
      result_var=NULL;
      obj=$.programs.gp[4][6].args[0]$;
      method=Network::Init_Epoch;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_Epoch()";
      meth_desc=" Initializes network state at the start of a new epoch -- updates parameters according to param_seq for example";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraEpoch";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraEpoch";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[7] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][7].doc$$: };
    };
    name="EpochEnd";
    short_nm="EpcEnd";
    tags=;
    desc="end of epoch -- relnet and basic stats compute, calls only the core standard monitor, save weights if doing that";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=200;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="how frequently (epochs) to save weights during training";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkComputeEpochStats";
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=.programs.gp[4][7].args[0]$$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more compute epoch-level statistics, including SSE, AvgExtRew and AvgCycles";
     };
     MemberMethodCall @[1] {
      name="MemberMethodCall_networkepochtimeEndTimer";
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.epoch_time.EndTimer()";
      obj=$.programs.gp[4][7].args[0]$;
      path="epoch_time";
      result_var=NULL;
      method=TimeUsed::EndTimer;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[2] {
      name="ProgramCall_LeabraEpochMonitornetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraEpochMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.programs.gp[4].gp[0][2]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     If @[3] {
      name="If_ifnetworkepochsa_l0networkepoch0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network->epoch % save_wts_interval == 0 && network->epoch > 0)";
      cond {
       expr="network->epoch % save_wts_interval == 0 && network->epoch > 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_SaveWeightsnetwork";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeights(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4][15]$;
	targ_ld_init="*SaveWeightsSpecs*";
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraEpoch";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraEpoch";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[8] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][8].doc$$: };
    };
    name="TrialStart";
    short_nm="TrStrt";
    tags=;
    desc="start of trial before any input data applied -- prepares for input data to be applied (Init_InputData)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkTrialInit";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      result_var=NULL;
      obj=.programs.gp[4][8].args[0]$$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     If @[1] {
      name="If_ifnetworkCompute_stnetworktrial1";
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="update the weight values -- do this at start so that dwt value is valid at end of trial";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.programs.gp[4][8].args[0]$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkInitInputData";
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.programs.gp[4][8].args[0]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     MemberAssign @[3] {
      name="MemberAssign_networkcycle0";
      desc="start at 0 cycle";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.cycle = 0";
      obj=$.programs.gp[4][8].args[0]$;
      path="cycle";
      expr {
       expr="0";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrial";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrial";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[9] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][9].doc$$: };
    };
    name="TrialEnd";
    short_nm="TrlEnd";
    tags=;
    desc="standard end-of-trial code -- no monitor calls at all";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkTrialFinal";
      desc="after the trial is over, do final computations: Compute_AbsRelNetin";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      result_var=NULL;
      obj=.programs.gp[4][9].args[0]$$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     NetUpdateView @[1] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[4][9].args[0]$;
      update_var=.programs.gp[4][9].vars[0]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrial";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrial";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[10] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][10].doc$$: };
    };
    name="SettleMinus";
    short_nm="SetlMin";
    tags=;
    desc="settle network in the minus phase -- enough different logic in two phases to warrant making them separate";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on settles";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars1vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="qtr";
	var_type=T_Int;
	int_val=1;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     ForLoop @[1] {
      name="ForLoop_forqtr0qtr3qtr";
      desc=;
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="for (qtr = 0; qtr < 3; qtr++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_Quarternetwork";
	desc="run the cycle program, which computes one cycle of activations";
	flags=CAN_REVERT_TO_CODE;
	code_string="Quarter(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.programs.gp[4][13]$$;
	targ_ld_init="*Quarter*";
       };
      };
      init {
       expr="qtr = 0";
      };
      test {
       expr="qtr < 3";
      };
      iter {
       expr="qtr++";
      };
     };
     NetUpdateView @[2] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=.programs.gp[4][10].args[0]$$;
      update_var=.programs.gp[4][10].vars[0]$$;
     };
    };
    step_prog=$.programs.gp[4][14]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrial";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrial";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[11] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][11].doc$$: };
    };
    name="SettlePlus";
    short_nm="SttPls";
    tags=;
    desc="settle network in the minus phase -- enough different logic in two phases to warrant making them separate";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on settles";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars0vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (0 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
      };
     };
     ProgramCall @[1] {
      name="ProgramCall_Quarternetwork";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Quarter(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.programs.gp[4][13]$;
      targ_ld_init="*Quarter*";
     };
     NetUpdateView @[2] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=.programs.gp[4][11].args[0]$$;
      update_var=.programs.gp[4][11].vars[0]$$;
     };
    };
    step_prog=$.programs.gp[4][14]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrial";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrial";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[12] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][12].doc$$: };
    };
    name="Trial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/output event or external information, over a single alpha frequency cycle (100 msec / 10 Hz) -- iterates over gamma-frequency (25 msec / 40 Hz) quarter-trials";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars1vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="qtr";
	var_type=T_Int;
	int_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     If @[1] {
      name="If_ifnetworkCompute_stnetworktrial1";
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	name="MethodCall_networkComputeWeights";
	desc="update weights -- do this at start instead of end, so that dwt is valid";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=.programs.gp[4][12].args[0]$$;
	method=Network::Compute_Weights;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[2] {
      name="MethodCall_networkTrialInit";
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      result_var=NULL;
      obj=$.programs.gp[4][12].args[0]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     Comment @[3] {
      name="Comment_notecanapplyinpu_Quarterasneeded";
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     ForLoop @[4] {
      name="ForLoop_forqtr0qtr4qtr";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (qtr = 0; qtr < 4; qtr++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_Quarternetwork";
	desc="run the quarter program (which iterates over cyles of network activation updating) for each quarter";
	flags=CAN_REVERT_TO_CODE;
	code_string="Quarter(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4][13]$;
	targ_ld_init="*Quarter*";
       };
      };
      init {
       expr="qtr = 0";
      };
      test {
       expr="qtr < 4";
      };
      iter {
       expr="qtr++";
      };
     };
     MethodCall @[5] {
      name="MethodCall_networkTrialFinal";
      desc="after the trial is over, do final computations";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      result_var=NULL;
      obj=$.programs.gp[4][12].args[0]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     NetUpdateView @[6] {
      name="NetUpdateView_NetUpdateView";
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[4][12].args[0]$;
      update_var=$.programs.gp[4][12].vars[0]$;
     };
    };
    step_prog=$.programs.gp[4][14]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraTrial";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrial";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[13] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][13].doc$$: };
    };
    name="Quarter";
    short_nm="Quarter";
    tags="Leabra, Std";
    desc="iterates over cycles of activation updating for a gamma-frequency (25 msec / 40 Hz) quarter of an alpha frequency (100 msec / 10 Hz) trial";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author="Randall C. O'Reilly";
    email="emergent-users@grey.colorado.edu";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @[1] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      name="NetCounterInit_NetCounterInitcycle";
      desc="initialize local cycle counter and corresponding counter on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: cycle";
      network_var=.programs.gp[4][13].args[0]$$;
      local_ctr_var=.programs.gp[4][13].vars[0]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      name="LocalVars_LocalVars2vars";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (2 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @[0] {
	name="cycle_max";
	var_type=T_Int;
	int_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @[1] {
	name="cyc";
	var_type=T_Int;
	int_val=0;
	object_scope=NULL;
	flags=LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     Comment @[1] {
      name="Comment_notecanapplyinpu_Quarterasneeded";
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     MethodCall @[2] {
      name="MethodCall_networkQuarterInit";
      desc="initializes various counters at start of settling";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Init()";
      result_var=NULL;
      obj=$.programs.gp[4][13].args[0]$;
      method=LeabraNetwork::Quarter_Init;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Init()";
      meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
     };
     MethodCall @[3] {
      name="MethodCall_cyclemaxnetworkCycleRunMax";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="cycle_max = network->CycleRunMax()";
      result_var=.programs.gp[4][13].prog_code[0].local_vars[0]$$;
      obj=$.programs.gp[4][13].args[0]$;
      method=LeabraNetwork::CycleRunMax;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int CycleRunMax()";
      meth_desc=" max loop counter for running cycles in a gamma quarter of processing, taking into account the fact that threading can run multiple cycles per Cycle_Run call if quarter flag is set";
     };
     ForLoop @[4] {
      name="ForLoop_forcyc0cyccyclemaxcyc";
      desc="// the main loop over cycles of updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (cyc=0; cyc<cycle_max; cyc++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	name="ProgramCall_Cyclenetwork";
	desc="run the cycle program -- can run multiple cycles at a time due to threading";
	flags=CAN_REVERT_TO_CODE;
	code_string="Cycle(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.programs.gp[4][14]$;
	targ_ld_init="*Cycle*";
       };
       AssignExpr @[1] {
	name="AssignExpr_cyclenetworkcycle";
	desc="grab the updated cycle count";
	flags=CAN_REVERT_TO_CODE;
	code_string="cycle = network.cycle";
	result_var=$.programs.gp[4][13].vars[0]$;
	expr {
	 expr="network.cycle";
	};
       };
      };
      init {
       expr="cyc=0";
      };
      test {
       expr="cyc<cycle_max";
      };
      iter {
       expr="cyc++";
      };
     };
     MethodCall @[5] {
      name="MethodCall_networkQuarterFinal";
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Final()";
      result_var=NULL;
      obj=$.programs.gp[4][13].args[0]$;
      method=LeabraNetwork::Quarter_Final;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Final()";
      meth_desc=" do final processing after each quarter: ";
     };
     NetUpdateView @[6] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[4][13].args[0]$;
      update_var=$.programs.gp[4][13].vars[1]$;
     };
    };
    step_prog=$.programs.gp[4][14]$;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraQuarter";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraQuarter";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[14] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][14].doc$$: };
    };
    name="Cycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      name="MethodCall_networkCycleRun";
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Cycle_Run()";
      result_var=NULL;
      obj=.programs.gp[4][14].args[0]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Cycle_Run()";
      meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
     };
     NetUpdateView @[1] {
      name="NetUpdateView_NetUpdateView";
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      network_var=$.programs.gp[4][14].args[0]$;
      update_var=$.programs.gp[4][14].vars[0]$;
     };
     MemberAssign @[2] {
      name="MemberAssign_networkcyclenetworkcycle1";
      desc="IMPORTANT: Cycle_Run() now updates cycle by itself, and can run multiple cycles!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network.cycle = network.cycle + 1";
      obj=$.programs.gp[4][14].args[0]$;
      path="cycle";
      expr {
       expr="network.cycle + 1";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="LeabraCycle";
     full_url="https://grey.colorado.edu/emergent/index.php/LeabraCycle";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program @[15] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserData_DocLink;
     el_def=0;
     UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4][15].doc$$: };
    };
    name="SaveWeights";
    short_nm="SWghts";
    tags="Weights, Specs";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values

also save specs.";
    version {
     major=0;
     minor=0;
     step=0;
    };
    author=;
    email=;
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.networks[0]$;
      object_scope=NULL;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @[0] {
      name="tag";
      var_type=T_String;
      string_val="__RunMaster_NetMaster";
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="user defined tag (set by startup script)";
      init_from=$.programs.gp[4].gp[0][0]$;
     };
     ProgVar @[1] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      object_scope=NULL;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @[2] {
      name="fname";
      var_type=T_String;
      string_val="/Users/oreilly/emergent/proj_templates/LeabraFlex_RunMaster_NetMaster.00_0050.wts.gz";
      object_scope=NULL;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @[3] {
      name="epoch_str";
      var_type=T_String;
      string_val="0050";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[4] {
      name="batch_str";
      var_type=T_String;
      string_val="00";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @[5] {
      name="final_tag";
      var_type=T_String;
      string_val="_RunMaster_NetMaster.00_0050";
      object_scope=NULL;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      name="If_iftaMiscdmemproc0";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_proc > 0)";
      cond {
       expr="taMisc::dmem_proc > 0";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ReturnExpr @[0] {
	name="ReturnExpr_return";
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="return ";
	expr {
	 expr=;
	};
       };
      };
     };
     MiscCall @[1] {
      name="MiscCall_batchstrtaMiscLe_osnetworkbatch2";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="batch_str = taMisc::LeadingZeros(network.batch, 2)";
      result_var=.programs.gp[4][15].vars[4]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      name="MiscCall_epochstrtaMiscLe_osnetworkepoch4";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_str = taMisc::LeadingZeros(network.epoch, 4)";
      result_var=.programs.gp[4][15].vars[3]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      name="AssignExpr_finaltagtagbatchstrepochstr";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="final_tag = tag + \".\" + batch_str + \"_\" + epoch_str";
      result_var=.programs.gp[4][15].vars[5]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      name="MethodCall_fnamenetworkGetF_gwtssubdirfalse";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="fname = network->GetFileNameFmProject(\".wts.gz\", final_tag, wts_subdir, false)";
      result_var=.programs.gp[4][15].vars[2]$$;
      obj=.programs.gp[4][15].args[0]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="ext";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
      meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
     };
     MethodCall @[5] {
      name="MethodCall_networkSaveWeigh_meNetworkNETFMT";
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->SaveWeights(fname, Network::NET_FMT)";
      result_var=NULL;
      obj=$.programs.gp[4][15].args[0]$;
      method=Network::SaveWeights;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	prev_expr=;
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
      meth_sig="void SaveWeights(taString& fname, Network::WtSaveFormat fmt = NET_FMT)";
      meth_desc=" write weight values out in a simple ordered list of weights (optionally in binary fmt) (leave fname empty to pull up file chooser)";
     };
    };
    step_prog=NULL;
    step_n=1;
    doc {
     name="doc";
     desc=;
     web_doc=1;
     wiki="emergent";
     url="SaveWeights";
     full_url="https://grey.colorado.edu/emergent/index.php/SaveWeights";
     text_size=1;
     text=;
     html_text=;
    };
   };
   Program_Group @.gp[0] {
    name="Monitors";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4].gp[0][0].doc$$: };
     };
     name="SaveLogFiles";
     short_nm="SLFls";
     tags="Leabra, Startup";
     desc="startup args specifically for fixation training parameters";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="tag";
       var_type=T_String;
       string_val="__RunMaster_NetMaster";
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="this is set by MasterStartup or MasterTrain -- is primary source of tag for any other programs (SaveWeights copies from here)";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="log_trials";
       var_type=T_Bool;
       bool_val=0;
       object_scope=NULL;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="should trial-level data be saved to log files?";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="log_dir";
       var_type=T_String;
       string_val=;
       object_scope=NULL;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="log file directory";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="log_file_nm";
       var_type=T_String;
       string_val="/Users/oreilly/emergent/proj_templates/LeabraFlex__RunMaster_NetMaster.trn_epc.dat";
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="name of log file";
       init_from=NULL;
      };
      ProgVar @[4] {
       name="epoch_output_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.data.gp[1][1]$;
       object_scope=$.data.gp[1]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="trial_output_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.data.gp[1][0]$;
       object_scope=$.data.gp[1]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_iftaMiscinteractive";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (taMisc::interactive)";
       cond {
	expr="taMisc::interactive";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_epochoutputdataCloseDataLog";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_output_data->CloseDataLog()";
	 result_var=NULL;
	 obj=.programs.gp[4].gp[0][0].vars[4]$$;
	 method=DataTable::CloseDataLog;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void CloseDataLog()";
	 meth_desc=" close the data log file if it was previously open";
	};
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       name="LocalVars_LocalVars0vars";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       local_vars {
	name="local_vars";
	el_typ=ProgVar;
	el_def=0;
       };
      };
      If @[1] {
       name="If_ifepochoutputdataIsSavingDataLog";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (epoch_output_data.IsSavingDataLog())";
       cond {
	expr="epoch_output_data.IsSavingDataLog()";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ReturnExpr @[0] {
	 name="ReturnExpr_return";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="return ";
	 expr {
	  expr=;
	 };
	};
       };
      };
      MethodCall @[2] {
       name="MethodCall_logfilenmepochou_ttaglogdirfalse";
       desc="last arg is to include dmem proc number";
       flags=CAN_REVERT_TO_CODE;
       code_string="log_file_nm = epoch_output_data->GetFileNameFmProject(\".trn_epc.dat\", tag, log_dir, false)";
       result_var=.programs.gp[4].gp[0][0].vars[3]$$;
       obj=$.programs.gp[4].gp[0][0].vars[4]$;
       method=taBase::GetFileNameFmProject;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ext";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\".trn_epc.dat\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="tag";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="tag";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="subdir";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_dir";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_no";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
       meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
      };
      MethodCall @[3] {
       name="MethodCall_epochoutputdataS_filenmfalsetrue";
       desc="last arg is to restrict log to dmem_proc = 0";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_output_data->SaveDataLog(log_file_nm, false, true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][0].vars[4]$;
       method=DataTable::SaveDataLog;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="append";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_0";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
       meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
      };
      PrintVar @[4] {
       name="PrintVar_PrintSavingepoch_datatologfilenm";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  \"Saving epoch log data to:\" log_file_nm";
       message="Saving epoch log data to:";
       print_var=$.programs.gp[4].gp[0][0].vars[3]$;
       print_var2=NULL;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=0;
      };
      If @[5] {
       name="If_iflogtrials";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (log_trials)";
       cond {
	expr="log_trials";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_logfilenmtrialou_attaglogdirtrue";
	 desc="last arg is to include dmem proc number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="log_file_nm = trial_output_data->GetFileNameFmProject(\".trn_trl.dat\", tag, log_dir, true)";
	 result_var=$.programs.gp[4].gp[0][0].vars[3]$;
	 obj=.programs.gp[4].gp[0][0].vars[5]$$;
	 method=taBase::GetFileNameFmProject;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ext";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\".trn_trl.dat\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="tag";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="tag";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="subdir";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_dir";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_no";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
	 meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
	};
	MethodCall @[1] {
	 name="MethodCall_trialoutputdataS_ilenmfalsefalse";
	 desc="last arg is to restrict log to dmem_proc = 0";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_output_data->SaveDataLog(log_file_nm, false, false)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][0].vars[5]$;
	 method=DataTable::SaveDataLog;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="fname";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_file_nm";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=bool;
	   type="bool";
	   name="append";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_0";
	   required=0;
	   def_val="true";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	 };
	 meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
	 meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
	};
	PrintVar @[2] {
	 name="PrintVar_PrintSavingtrial_datatologfilenm";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  \"Saving trial log data to:\" log_file_nm";
	 message="Saving trial log data to:";
	 print_var=$.programs.gp[4].gp[0][0].vars[3]$;
	 print_var2=NULL;
	 print_var3=NULL;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=0;
      wiki=;
      url="local";
      full_url="local";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4].gp[0][1].doc$$: };
     };
     name="LeabraTrialMonitor";
     short_nm="TrialMon";
     tags="Leabra, Std, Monitor";
     desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author="Randall C. O'Reilly";
     email="emergent-users@grey.colorado.edu";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @[0] {
       name="trial_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	NetMonItem @[0] {
	 name="batch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[1] {
	 name="epoch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[2] {
	 name="train_mode";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="train_mode";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[3] {
	 name="group";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="group";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[4] {
	 name="trial";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[5] {
	 name="tick";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="tick";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[6] {
	 name="time";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="time";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[7] {
	 name="trial_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[8] {
	 name="group_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="group_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[9] {
	 name="output_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="minus_output_name";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[10] {
	 name="rt_cycles";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="rt_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[11] {
	 name="sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[12] {
	 name="norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[13] {
	 name="cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cos_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[14] {
	 name="ext_rew";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[15] {
	 name="lay_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.sse";
	 var_label="lay_sse";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[16] {
	 name="lay_bin_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.bin_err";
	 var_label="lay_bin_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[17] {
	 name="lay_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.norm_err";
	 var_label="lay_norm_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[18] {
	 name="lay_cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.cos_err";
	 var_label="lay_cos_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[19] {
	 name="lay_net_sd";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.net_sd";
	 var_label="lay_net_sd";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[20] {
	 name="net_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cos_diff";
	 var_label="net_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[21] {
	 name="net_trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial_cos_diff";
	 var_label="net_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[22] {
	 name="net_avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_act_diff";
	 var_label="net_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[23] {
	 name="cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.cos_diff";
	 var_label="cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[24] {
	 name="trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.trial_cos_diff";
	 var_label="trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[25] {
	 name="avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_act_diff";
	 var_label="avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.networks[0]$;
       data=$.data.gp[1][0]$;
       rmv_orphan_cols=1;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to record data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.data.gp[1][0]$;
       object_scope=$.data.gp[1]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to record trial-level data to (this program writes new data to this table!)";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="trial_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       object_val=.programs.gp[4].gp[0][1].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="run_already";
       var_type=T_Bool;
       bool_val=0;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_trialnetmonSetDa_lmondatanetwork";
       desc="set the network and datatable for the NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][1].vars[1]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[1] {
       name="MethodCall_trialnetmonCheckConfigfalse";
       desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[1]$;
       method=taBase::CheckConfig;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[2] {
       name="MethodCall_trialnetmonUpdateMonitorstrue";
       desc="update the monitor items and data schema based on current settings of the NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[1]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
      AssignExpr @[3] {
       name="AssignExpr_runalreadyfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="run_already = false";
       result_var=.programs.gp[4].gp[0][1].vars[2]$$;
       expr {
	expr="false";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_ifrunalready";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!run_already)";
       cond {
	expr="!run_already";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_trialnetmonSetDa_lmondatanetwork";
	 desc="set the network and datatable for the NetMonitor";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][1].vars[1]$;
	 method=NetMonitor::SetDataNetwork;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dt";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="trial_mon_data";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=Network_ptr;
	   type="Network*";
	   name="net";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
	 meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
	};
	MethodCall @[1] {
	 name="MethodCall_trialnetmonUpdateMonitorstrue";
	 desc="update the monitor items and data schema based on current settings of the NetMonitor object";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_netmon->UpdateMonitors(true)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][1].vars[1]$;
	 method=NetMonitor::UpdateMonitors;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool;
	   type="bool";
	   name="reset_first";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="void UpdateMonitors(bool reset_first = false)";
	 meth_desc=" old name for UpdateDataTable";
	};
	AssignExpr @[2] {
	 name="AssignExpr_runalreadytrue";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="run_already = true";
	 result_var=$.programs.gp[4].gp[0][1].vars[2]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      MethodCall @[1] {
       name="MethodCall_trialmondataAddBlankRow";
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][1].vars[0]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       name="MethodCall_trialnetmonGetMonVals";
       desc="get the new monitor data from the network and other sources -- this does the main work";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[1]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      MethodCall @[3] {
       name="MethodCall_trialmondataWriteClose";
       desc="update views and other things after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][1].vars[0]$;
       method=DataTable::WriteClose;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      MethodCall @[4] {
       name="MethodCall_networkDMemShare_tatrialmondata1";
       desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][1].args[0]$$;
       method=Network::DMem_ShareTrialData;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="n_rows";
	 required=0;
	 def_val="1";
	 prev_expr=;
	 expr {
	  expr="1";
	 };
	};
       };
       meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
       meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
      };
     };
     step_prog=$.programs.gp[4].gp[0][1]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=1;
      wiki="emergent";
      url="Monitor_Data";
      full_url="https://grey.colorado.edu/emergent/index.php/Monitor_Data";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=.programs.gp[4].gp[0][2].doc$$: };
     };
     name="LeabraEpochMonitor";
     short_nm="EpcMon";
     tags="Leabra, Std, Monitor";
     desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author=;
     email=;
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @[0] {
       name="epoch_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	NetMonItem @[0] {
	 name="batch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[1] {
	 name="epoch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[2] {
	 name="avg_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[3] {
	 name="cnt_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cnt_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[4] {
	 name="pct_cor";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="pct_cor";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[5] {
	 name="pct_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="pct_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[6] {
	 name="avg_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[7] {
	 name="avg_cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cos_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[8] {
	 name="avg_ext_rew";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[9] {
	 name="avg_cycles";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[10] {
	 name="epoch_time_tot";
	 computed=1;
	 object_type=NULL;
	 object=NULL;
	 variable="act";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[11] {
	 name="epoch_time_usr";
	 computed=1;
	 object_type=NULL;
	 object=NULL;
	 variable="act";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[12] {
	 name="lay_avg_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_sse";
	 var_label="lay_avg_sse";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[13] {
	 name="lay_cnt_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.cnt_err";
	 var_label="lay_cnt_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[14] {
	 name="lay_pct_cor";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.pct_cor";
	 var_label="lay_pct_cor";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[15] {
	 name="lay_pct_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.pct_err";
	 var_label="lay_pct_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[16] {
	 name="lay_avg_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_norm_err";
	 var_label="lay_avg_norm_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[17] {
	 name="lay_avg_cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_cos_err";
	 var_label="lay_avg_cos_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[18] {
	 name="net_avg_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cos_diff";
	 var_label="net_avg_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[19] {
	 name="net_avg_trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_trial_cos_diff";
	 var_label="net_avg_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[20] {
	 name="net_avg_avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_avg_act_diff";
	 var_label="net_avg_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[21] {
	 name="avg_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_cos_diff";
	 var_label="avg_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[22] {
	 name="avg_trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_trial_cos_diff";
	 var_label="avg_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[23] {
	 name="avg_avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_avg_act_diff";
	 var_label="avg_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[24] {
	 name="avg_net_sd";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_net_sd";
	 var_label="avg_net_sd";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[25] {
	 name="hog_pct";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.hog_pct";
	 var_label="hog_pct";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[26] {
	 name="dead_pct";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.dead_pct";
	 var_label="dead_pct";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[27] {
	 name="netmax";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_netin.max";
	 var_label="netmax";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[28] {
	 name="avg_act";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable=".layers.acts_p_avg";
	 var_label="avg_act";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[29] {
	 name="netrel";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="prjns.avg_netin_rel";
	 var_label="netrel";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.networks[0]$;
       data=$.data.gp[1][1]$;
       rmv_orphan_cols=1;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to get data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="epoch_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.data.gp[1][1]$;
       object_scope=$.data.gp[1]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to write the epoch data to";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="epoch_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       object_val=.programs.gp[4].gp[0][2].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="network monitor object that contains full specs for what to record and where to get it";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="epoch_timer";
       var_type=T_Object;
       object_type=TimeUsed;
       object_val=.networks[0].epoch_time$$;
       object_scope=NULL;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="run_already";
       var_type=T_Bool;
       bool_val=0;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       name="AssignExpr_epochtimernetworkepochtime";
       desc="get the epoch timer from current network";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_timer = network.epoch_time";
       result_var=.programs.gp[4].gp[0][2].vars[2]$$;
       expr {
	expr="network.epoch_time";
       };
      };
      MethodCall @[1] {
       name="MethodCall_epochnetmonSetDa_hmondatanetwork";
       desc="set data and network on NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][2].vars[1]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[2] {
       name="MethodCall_epochnetmonCheckConfigfalse";
       desc="check configuration and emit errors/warnings for problems";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][2].vars[1]$;
       method=taBase::CheckConfig;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[3] {
       name="MethodCall_epochnetmonUpdateMonitorstrue";
       desc="update the monitor items and data schema based on current settings of NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][2].vars[1]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
      AssignExpr @[4] {
       name="AssignExpr_runalreadyfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="run_already = false";
       result_var=.programs.gp[4].gp[0][2].vars[3]$$;
       expr {
	expr="false";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_ifrunalready";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!run_already)";
       cond {
	expr="!run_already";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_epochnetmonSetDa_hmondatanetwork";
	 desc="set data and network on NetMonitor object";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][2].vars[1]$;
	 method=NetMonitor::SetDataNetwork;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dt";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="epoch_mon_data";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=Network_ptr;
	   type="Network*";
	   name="net";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
	 meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
	};
	MethodCall @[1] {
	 name="MethodCall_epochnetmonUpdateMonitorstrue";
	 desc="update the monitor items and data schema based on current settings of NetMonitor";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_netmon->UpdateMonitors(true)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][2].vars[1]$;
	 method=NetMonitor::UpdateMonitors;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool;
	   type="bool";
	   name="reset_first";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="void UpdateMonitors(bool reset_first = false)";
	 meth_desc=" old name for UpdateDataTable";
	};
	AssignExpr @[2] {
	 name="AssignExpr_runalreadytrue";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="run_already = true";
	 result_var=$.programs.gp[4].gp[0][2].vars[3]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      MethodCall @[1] {
       name="MethodCall_epochmondataAddBlankRow";
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][2].vars[0]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       name="MethodCall_epochnetmonGetMonVals";
       desc="get the new monitor data and stor it into the data table -- this does the main job here";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][2].vars[1]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      AssignExpr @[3] {
       name="AssignExpr_epochtimernetworkepochtime";
       desc="get the epoch timer from current network";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_timer = network.epoch_time";
       result_var=$.programs.gp[4].gp[0][2].vars[2]$;
       expr {
	expr="network.epoch_time";
       };
      };
      MethodCall @[4] {
       name="MethodCall_epochmondataSetV_csepochtimetot1";
       desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][2].vars[0]$;
       method=DataTable::SetValColName;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_timer.used.GetTotSecs()";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"epoch_time_tot\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
      };
      MethodCall @[5] {
       name="MethodCall_epochmondataSetV_csepochtimeusr1";
       desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][2].vars[0]$;
       method=DataTable::SetValColName;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_timer.used.GetUsrSecs()";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"epoch_time_usr\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
      };
      MethodCall @[6] {
       name="MethodCall_epochmondataWriteClose";
       desc="update after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][2].vars[0]$;
       method=DataTable::WriteClose;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      Comment @[7] {
       name="Comment_NOTEifdoingaTest_atablecorrectly";
       desc="NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
       flags=CAN_REVERT_TO_CODE;
       code_string="// NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
      };
     };
     step_prog=$.programs.gp[4].gp[0][2]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=1;
      wiki="emergent";
      url="Monitor_Data";
      full_url="https://grey.colorado.edu/emergent/index.php/Monitor_Data";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=$.programs.gp[4].gp[0][1].doc$: };
     };
     name="LeabraTestTrialMonitor";
     short_nm="TsTrMn";
     tags="Leabra, Std, Monitor";
     desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author="Randall C. O'Reilly";
     email="emergent-users@grey.colorado.edu";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @[0] {
       name="trial_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	NetMonItem @[0] {
	 name="batch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[1] {
	 name="epoch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[2] {
	 name="train_mode";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="train_mode";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[3] {
	 name="group";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="group";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[4] {
	 name="trial";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[5] {
	 name="tick";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="tick";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[6] {
	 name="time";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="time";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[7] {
	 name="trial_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[8] {
	 name="group_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="group_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[9] {
	 name="output_name";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="minus_output_name";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[10] {
	 name="rt_cycles";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="rt_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[11] {
	 name="sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[12] {
	 name="norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[13] {
	 name="cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cos_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[14] {
	 name="ext_rew";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[15] {
	 name="lay_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.sse";
	 var_label="lay_sse";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[16] {
	 name="lay_bin_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.bin_err";
	 var_label="lay_bin_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[17] {
	 name="lay_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.norm_err";
	 var_label="lay_norm_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[18] {
	 name="lay_cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.cos_err";
	 var_label="lay_cos_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[19] {
	 name="lay_net_sd";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.net_sd";
	 var_label="lay_net_sd";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[20] {
	 name="net_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cos_diff";
	 var_label="net_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[21] {
	 name="net_trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="trial_cos_diff";
	 var_label="net_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[22] {
	 name="net_avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_act_diff";
	 var_label="net_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[23] {
	 name="cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.cos_diff";
	 var_label="cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[24] {
	 name="trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.trial_cos_diff";
	 var_label="trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[25] {
	 name="avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_act_diff";
	 var_label="avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.networks[0]$;
       data=$.data.gp[1][2]$;
       rmv_orphan_cols=1;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to record data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="trial_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.data.gp[1][2]$;
       object_scope=$.data.gp[1]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to record trial-level data to (this program writes new data to this table!)";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="trial_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       object_val=.programs.gp[4].gp[0][3].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="run_already";
       var_type=T_Bool;
       bool_val=0;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_trialnetmonSetDa_lmondatanetwork";
       desc="set the network and datatable for the NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][3].vars[1]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[1] {
       name="MethodCall_trialnetmonCheckConfigfalse";
       desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][3].vars[1]$;
       method=taBase::CheckConfig;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[2] {
       name="MethodCall_trialnetmonUpdateMonitorstrue";
       desc="update the monitor items and data schema based on current settings of the NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][3].vars[1]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
      AssignExpr @[3] {
       name="AssignExpr_runalreadyfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="run_already = false";
       result_var=.programs.gp[4].gp[0][3].vars[2]$$;
       expr {
	expr="false";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_ifrunalready";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!run_already)";
       cond {
	expr="!run_already";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_trialnetmonSetDa_lmondatanetwork";
	 desc="set the network and datatable for the NetMonitor";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][3].vars[1]$;
	 method=NetMonitor::SetDataNetwork;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dt";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="trial_mon_data";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=Network_ptr;
	   type="Network*";
	   name="net";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
	 meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
	};
	MethodCall @[1] {
	 name="MethodCall_trialnetmonUpdateMonitorstrue";
	 desc="update the monitor items and data schema based on current settings of the NetMonitor object";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_netmon->UpdateMonitors(true)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][3].vars[1]$;
	 method=NetMonitor::UpdateMonitors;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool;
	   type="bool";
	   name="reset_first";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="void UpdateMonitors(bool reset_first = false)";
	 meth_desc=" old name for UpdateDataTable";
	};
	AssignExpr @[2] {
	 name="AssignExpr_runalreadytrue";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="run_already = true";
	 result_var=$.programs.gp[4].gp[0][3].vars[2]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      MethodCall @[1] {
       name="MethodCall_trialmondataAddBlankRow";
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][3].vars[0]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       name="MethodCall_trialnetmonGetMonVals";
       desc="get the new monitor data from the network and other sources -- this does the main work";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][3].vars[1]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      MethodCall @[3] {
       name="MethodCall_trialmondataWriteClose";
       desc="update views and other things after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][3].vars[0]$;
       method=DataTable::WriteClose;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      MethodCall @[4] {
       name="MethodCall_networkDMemShare_tatrialmondata1";
       desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][3].args[0]$$;
       method=Network::DMem_ShareTrialData;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="n_rows";
	 required=0;
	 def_val="1";
	 prev_expr=;
	 expr {
	  expr="1";
	 };
	};
       };
       meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
       meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
      };
     };
     step_prog=$.programs.gp[4].gp[0][3]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=1;
      wiki="emergent";
      url="Monitor_Data";
      full_url="https://grey.colorado.edu/emergent/index.php/Monitor_Data";
      text_size=1;
      text=;
      html_text=;
     };
    };
    Program @[4] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserData_DocLink;
      el_def=0;
      UserData_DocLink @[0] {name="DocLink": doc=$.programs.gp[4].gp[0][2].doc$: };
     };
     name="LeabraTestEpochMonitor";
     short_nm="TstMnt";
     tags="Leabra, Std, Monitor";
     desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
     version {
      major=0;
      minor=0;
      step=0;
     };
     author="Randall C. O'Reilly";
     email="emergent-users@grey.colorado.edu";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @[0] {
       name="epoch_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	NetMonItem @[0] {
	 name="batch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[1] {
	 name="epoch";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[2] {
	 name="avg_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[3] {
	 name="cnt_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="cnt_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[4] {
	 name="pct_cor";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="pct_cor";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[5] {
	 name="pct_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="pct_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[6] {
	 name="avg_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[7] {
	 name="avg_cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cos_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[8] {
	 name="avg_ext_rew";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[9] {
	 name="avg_cycles";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[10] {
	 name="lay_avg_sse";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_sse";
	 var_label="lay_avg_sse";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[11] {
	 name="lay_cnt_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.cnt_err";
	 var_label="lay_cnt_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[12] {
	 name="lay_pct_cor";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.pct_cor";
	 var_label="lay_pct_cor";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[13] {
	 name="lay_pct_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.pct_err";
	 var_label="lay_pct_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[14] {
	 name="lay_avg_norm_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_norm_err";
	 var_label="lay_avg_norm_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[15] {
	 name="lay_avg_cos_err";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_cos_err";
	 var_label="lay_avg_cos_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[16] {
	 name="net_avg_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_cos_diff";
	 var_label="net_avg_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[17] {
	 name="net_avg_trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_trial_cos_diff";
	 var_label="net_avg_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[18] {
	 name="net_avg_avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="avg_avg_act_diff";
	 var_label="net_avg_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[19] {
	 name="avg_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_cos_diff";
	 var_label="avg_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[20] {
	 name="avg_trial_cos_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_trial_cos_diff";
	 var_label="avg_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[21] {
	 name="avg_avg_act_diff";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_avg_act_diff";
	 var_label="avg_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[22] {
	 name="avg_net_sd";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_net_sd";
	 var_label="avg_net_sd";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[23] {
	 name="netmax";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable="layers.avg_netin.max";
	 var_label="netmax";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @[24] {
	 name="avg_act";
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.networks[0]$;
	 variable=".layers.acts_p_avg";
	 var_label="avg_act";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: val_string="": use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.networks[0]$;
       data=.data.gp[1][3]$$;
       rmv_orphan_cols=1;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       object_val=$.networks[0]$;
       object_scope=NULL;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to get data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="epoch_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.data.gp[1][3]$;
       object_scope=$.data.gp[1]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to write the epoch data to";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="epoch_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       object_val=.programs.gp[4].gp[0][4].objs[0]$$;
       object_scope=NULL;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="network monitor object that contains full specs for what to record and where to get it";
       init_from=NULL;
      };
      ProgVar @[2] {
       name="run_already";
       var_type=T_Bool;
       bool_val=0;
       object_scope=NULL;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_epochnetmonSetDa_hmondatanetwork";
       desc="set data and network on NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][4].vars[1]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[1] {
       name="MethodCall_epochnetmonCheckConfigfalse";
       desc="check configuration and emit errors/warnings for problems";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][4].vars[1]$;
       method=taBase::CheckConfig;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[2] {
       name="MethodCall_epochnetmonUpdateMonitorstrue";
       desc="update the monitor items and data schema based on current settings of NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][4].vars[1]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
      AssignExpr @[3] {
       name="AssignExpr_runalreadyfalse";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="run_already = false";
       result_var=.programs.gp[4].gp[0][4].vars[2]$$;
       expr {
	expr="false";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_ifrunalready";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!run_already)";
       cond {
	expr="!run_already";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_epochnetmonSetDa_hmondatanetwork";
	 desc="set data and network on NetMonitor object";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][4].vars[1]$;
	 method=NetMonitor::SetDataNetwork;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dt";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="epoch_mon_data";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=Network_ptr;
	   type="Network*";
	   name="net";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
	 meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
	};
	MethodCall @[1] {
	 name="MethodCall_epochnetmonUpdateMonitorstrue";
	 desc="update the monitor items and data schema based on current settings of NetMonitor";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_netmon->UpdateMonitors(true)";
	 result_var=NULL;
	 obj=$.programs.gp[4].gp[0][4].vars[1]$;
	 method=NetMonitor::UpdateMonitors;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool;
	   type="bool";
	   name="reset_first";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="void UpdateMonitors(bool reset_first = false)";
	 meth_desc=" old name for UpdateDataTable";
	};
	AssignExpr @[2] {
	 name="AssignExpr_runalreadytrue";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="run_already = true";
	 result_var=$.programs.gp[4].gp[0][4].vars[2]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      MethodCall @[1] {
       name="MethodCall_epochmondataAddBlankRow";
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.programs.gp[4].gp[0][4].vars[0]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       name="MethodCall_epochnetmonGetMonVals";
       desc="get the new monitor data and stor it into the data table -- this does the main job here";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][4].vars[1]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      MethodCall @[3] {
       name="MethodCall_epochmondataWriteClose";
       desc="update after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.programs.gp[4].gp[0][4].vars[0]$;
       method=DataTable::WriteClose;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      Comment @[4] {
       name="Comment_NOTEifdoingaTest_atablecorrectly";
       desc="NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
       flags=CAN_REVERT_TO_CODE;
       code_string="// NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
      };
     };
     step_prog=$.programs.gp[4].gp[0][4]$;
     step_n=1;
     doc {
      name="doc";
      desc=;
      web_doc=1;
      wiki="emergent";
      url="Monitor_Data";
      full_url="https://grey.colorado.edu/emergent/index.php/Monitor_Data";
      text_size=1;
      text=;
      html_text=;
     };
    };
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @[0] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_130";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="view_win_lft": value=0: val_type_fixed=0: };
    UserDataItem @[1] {name="view_win_top": value=0.02973662: val_type_fixed=0: };
    UserDataItem @[2] {name="view_win_wd": value=0.9941552: val_type_fixed=0: };
    UserDataItem @[3] {name="view_win_ht": value=0.7986406: val_type_fixed=0: };
    UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
    UserDataItem @[5] {name="view_splitter_state": value=AAAA/wAAAAEAAAADAAABFwAAAfwAAAKMAf////8BAAAAAQA=: val_type_fixed=0: };
   };
   name="Browser3";
   m_data=.$$;
   cur_font_size=12;
   visible=1;
   win_name=".projects[\"LeabraFlex_10609_v807_nolog_patch1\"] - LeabraFlex_10609_v807_nolog_patch1.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   revert_to_tab_no=-1;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_131";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_visible": value=1: val_type_fixed=0: };
     };
     name="Application";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @[0] {
     name="Navigator";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.$;
    };
    PanelViewer @[1] {
     name="Editor";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
    };
    T3PanelViewer @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_132";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_panel_selected": value=1: val_type_fixed=0: };
     };
     name="Visualizer";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @[0] {
       name="Network_0";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=NetView;
	 el_def=0;
	 NetView @[0] {
	  name="Network_0_View";
	  m_data=$.networks[0]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  display=1;
	  lay_layout=THREE_D;
	  lay_mv=1;
	  net_text=1;
	  show_iconified=0;
	  net_text_xform {scale={x=0.7: y=0.7: z=0.7: }: rotate={x=1: y=0: z=0: rot=1.570796: }: translate={x=0: y=1: z=-1: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  hot_vars{ targ;ext;act;net;bias_wt;bias_dwt;act_eq;act_m;act_p;act_dif;avg_m;avg_l;act_avg;r.wt;r.wt*act;s.wt;r.dwt;s.dwt;	  };
	  unit_src_path=".layers[2].units[0]";
	  con_type=ANY_CON;
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=5: y=5: z=2.333333: };
	  max_size2d {x=5: y=18: z=1: };
	  eff_max_size {x=5: y=5: z=2.333333: };
	  font_sizes {net_name=0.05: net_vals=0.05: layer=0.04: layer_min=0.01: layer_vals=0.03: prjn=0.01: unit=0.02: un_nm_len=3: };
	  view_params {xy_square=0: unit_spacing=0.05: prjn_disp=L_R_B: prjn_name=0: prjn_width=0.002: prjn_trans=0.5: lay_trans=0.4: unit_trans=0.4: laygp_width=1: show_laygp=1: };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.8;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="scale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=0;
	   last_max=0;
	   range=1;
	   zero=0;
	   spec=.colorspecs["C_ColdHot"]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name="scale_ranges";
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    var_name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=0;Hidden=0;Output=0;	  };
	 };
	};
       };
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0.5: y=0.9155772: z=2.325743: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.528059;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @[1] {
       name="EpochOutputData";
       m_data=NULL;
       cur_font_size=12;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	cur_font_size=12;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GraphTableView;
	 el_def=0;
	 GraphTableView @[0] {
	  name="EpochOutputData_Graph";
	  m_data=$.data.gp[1][1]$;
	  cur_font_size=12;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @[0] {
	    name="batch";
	    m_data=.data.gp[1][1].data[0]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[1] {
	    name="epoch";
	    m_data=.data.gp[1][1].data[1]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=32: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[2] {
	    name="avg_sse";
	    m_data=.data.gp[1][1].data[2]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=4.02739: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[3] {
	    name="cnt_err";
	    m_data=.data.gp[1][1].data[3]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=50: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[4] {
	    name="pct_cor";
	    m_data=.data.gp[1][1].data[4]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[5] {
	    name="pct_err";
	    m_data=.data.gp[1][1].data[5]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[6] {
	    name="avg_norm_err";
	    m_data=.data.gp[1][1].data[6]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.54: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[7] {
	    name="avg_cos_err";
	    m_data=.data.gp[1][1].data[7]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[8] {
	    name="avg_ext_rew";
	    m_data=.data.gp[1][1].data[8]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[9] {
	    name="avg_cycles";
	    m_data=.data.gp[1][1].data[9]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[10] {
	    name="epoch_time_tot";
	    m_data=.data.gp[1][1].data[10]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[11] {
	    name="epoch_time_usr";
	    m_data=.data.gp[1][1].data[11]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[12] {
	    name="Output_lay_avg_sse";
	    m_data=.data.gp[1][1].data[12]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[13] {
	    name="Output_lay_cnt_err";
	    m_data=.data.gp[1][1].data[13]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[14] {
	    name="Output_lay_pct_cor";
	    m_data=.data.gp[1][1].data[14]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[15] {
	    name="Output_lay_pct_err";
	    m_data=.data.gp[1][1].data[15]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[16] {
	    name="Output_lay_avg_norm_err";
	    m_data=.data.gp[1][1].data[16]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[17] {
	    name="Output_lay_avg_cos_err";
	    m_data=.data.gp[1][1].data[17]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[18] {
	    name="net_avg_cos_diff";
	    m_data=.data.gp[1][1].data[18]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[19] {
	    name="net_avg_trial_cos_diff";
	    m_data=.data.gp[1][1].data[19]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[20] {
	    name="net_avg_avg_act_diff";
	    m_data=.data.gp[1][1].data[20]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[21] {
	    name="Hidden_avg_cos_diff";
	    m_data=.data.gp[1][1].data[21]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.962046: fix_max=0: max=0.999009: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[22] {
	    name="Output_avg_cos_diff";
	    m_data=.data.gp[1][1].data[22]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[23] {
	    name="Hidden_avg_trial_cos_diff";
	    m_data=.data.gp[1][1].data[23]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[24] {
	    name="Output_avg_trial_cos_diff";
	    m_data=.data.gp[1][1].data[24]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[25] {
	    name="Hidden_avg_avg_act_diff";
	    m_data=.data.gp[1][1].data[25]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[26] {
	    name="Output_avg_avg_act_diff";
	    m_data=.data.gp[1][1].data[26]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[27] {
	    name="Hidden_avg_net_sd";
	    m_data=.data.gp[1][1].data[27]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.281181: fix_max=0: max=0.466438: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[28] {
	    name="Output_avg_net_sd";
	    m_data=.data.gp[1][1].data[28]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[29] {
	    name="Hidden_hog_pct";
	    m_data=.data.gp[1][1].data[29]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[30] {
	    name="Output_hog_pct";
	    m_data=.data.gp[1][1].data[30]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[31] {
	    name="Hidden_dead_pct";
	    m_data=.data.gp[1][1].data[31]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[32] {
	    name="Output_dead_pct";
	    m_data=.data.gp[1][1].data[32]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[33] {
	    name="Hidden_netmax";
	    m_data=.data.gp[1][1].data[33]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[34] {
	    name="Output_netmax";
	    m_data=.data.gp[1][1].data[34]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[35] {
	    name="Input_avg_act";
	    m_data=.data.gp[1][1].data[35]$$;
	    cur_font_size=14;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[36] {
	    name="Hidden_avg_act";
	    m_data=.data.gp[1][1].data[36]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[37] {
	    name="Output_avg_act";
	    m_data=.data.gp[1][1].data[37]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[38] {
	    name="Hidden_Fm_Input_netrel";
	    m_data=.data.gp[1][1].data[38]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[39] {
	    name="Hidden_Fm_Output_netrel";
	    m_data=.data.gp[1][1].data[39]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @[40] {
	    name="Output_Fm_Hidden_netrel";
	    m_data=.data.gp[1][1].data[40]$$;
	    cur_font_size=12;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  page_rows=-8017975;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=1;
	  point_size=0.01;
	  point_spacing=1;
	  solid_lines=0;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis_label_rot=0;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	  };
	  tot_plots=16;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="EpochOutputData_Graph_plot_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="avg_sse";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[1] {
	    name="EpochOutputData_Graph_plot_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="avg_norm_err";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=0;
	   };
	   GraphPlotView @[2] {
	    name="EpochOutputData_Graph_plot_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="cnt_err";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=1;
	   };
	   GraphPlotView @[3] {
	    name="EpochOutputData_Graph_plot_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="Hidden_avg_net_sd";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0.281181: fix_max=0: max=0.466438: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	   };
	   GraphPlotView @[4] {
	    name="EpochOutputData_Graph_plot_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="Hidden_avg_cos_diff";
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0.962046: fix_max=0: max=0.999009: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	   };
	   GraphPlotView @[5] {
	    name="EpochOutputData_Graph_plot_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CROSS;
	    alt_y=0;
	   };
	   GraphPlotView @[6] {
	    name="EpochOutputData_Graph_plot_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=STAR;
	    alt_y=0;
	   };
	   GraphPlotView @[7] {
	    name="EpochOutputData_Graph_plot_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	   };
	   GraphPlotView @[8] {
	    name="EpochOutputData_Graph_plot_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[9] {
	    name="EpochOutputData_Graph_plot_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=SQUARE;
	    alt_y=0;
	   };
	   GraphPlotView @[10] {
	    name="EpochOutputData_Graph_plot_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=DIAMOND;
	    alt_y=0;
	   };
	   GraphPlotView @[11] {
	    name="EpochOutputData_Graph_plot_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	   };
	   GraphPlotView @[12] {
	    name="EpochOutputData_Graph_plot_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=PLUS;
	    alt_y=0;
	   };
	   GraphPlotView @[13] {
	    name="EpochOutputData_Graph_plot_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CROSS;
	    alt_y=0;
	   };
	   GraphPlotView @[14] {
	    name="EpochOutputData_Graph_plot_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=STAR;
	    alt_y=0;
	   };
	   GraphPlotView @[15] {
	    name="EpochOutputData_Graph_plot_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @[0] {
	    name="EpochOutputData_Graph_err_1";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[1] {
	    name="EpochOutputData_Graph_err_2";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[2] {
	    name="EpochOutputData_Graph_err_3";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[3] {
	    name="EpochOutputData_Graph_err_4";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[4] {
	    name="EpochOutputData_Graph_err_5";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[5] {
	    name="EpochOutputData_Graph_err_6";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[6] {
	    name="EpochOutputData_Graph_err_7";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[7] {
	    name="EpochOutputData_Graph_err_8";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[8] {
	    name="EpochOutputData_Graph_err_9";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[9] {
	    name="EpochOutputData_Graph_err_10";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[10] {
	    name="EpochOutputData_Graph_err_11";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[11] {
	    name="EpochOutputData_Graph_err_12";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[12] {
	    name="EpochOutputData_Graph_err_13";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[13] {
	    name="EpochOutputData_Graph_err_14";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[14] {
	    name="EpochOutputData_Graph_err_15";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @[15] {
	    name="EpochOutputData_Graph_err_16";
	    m_data=NULL;
	    cur_font_size=12;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    col_name_good=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    flip=0;
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   cur_font_size=12;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   col_name_good=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   flip=0;
	   n_ticks=10;
	   axis_length=1;
	   labels_on=0;
	   labels_col_name=;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       headlight_intensity=1;
       ambient_light=0;
       camera_params {field_of_view=45: near_distance=0.1: focal=5: far_distance=1000: };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @[0] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.475278: y=0.4989999: z=1.70049: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.71299;
	};
	T3SavedView @[1] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[2] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[3] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[4] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[5] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[6] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[7] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[8] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @[9] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_133";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="view_win_lft": value=0: val_type_fixed=0: };
      UserDataItem @[1] {name="view_win_top": value=0.008496176: val_type_fixed=0: };
      UserDataItem @[2] {name="view_win_wd": value=0.04357067: val_type_fixed=0: };
      UserDataItem @[3] {name="view_win_ht": value=0.7349193: val_type_fixed=0: };
      UserDataItem @[4] {name="view_win_iconified": value=0: val_type_fixed=0: };
      UserDataItem @[5] {name="view_visible": value=1: val_type_fixed=0: };
     };
     name="Tools";
     m_data=NULL;
     cur_font_size=12;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="svn rev: 10514 update startup program";
 tree_state{ .;.patches;.docs;.wizards;.ctrl_panels;.active_params;.active_params.gp[0];.active_params.gp[1];.data;.data.gp[0];.data.gp[1];.data.gp[2];.data.gp[3];.programs;.programs.gp[0];.programs.gp[1];.programs.gp[1].gp[0];.programs.gp[1].gp[1];.programs.gp[2];.programs.gp[3];.programs.gp[4];.programs.gp[4].gp[0];.networks;.networks[0];.networks[0].specs;.networks[0].layers; };
 networks {
  name="networks";
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @[0] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="cos_err": value=1: val_type_fixed=1: };
    UserDataItem @[1] {name="norm_err": value=1: val_type_fixed=1: };
    UserDataItem @[2] {name="ext_rew": value=1: val_type_fixed=1: };
    UserDataItem @[3] {name="minus_output_name": value=1: val_type_fixed=1: };
    UserDataItem @[4] {name="rt_cycles": value=1: val_type_fixed=1: };
    UserDataItem @[5] {name="tot_cycle": value=1: val_type_fixed=1: };
    UserDataItem @[6] {name="phase": value=1: val_type_fixed=1: };
    UserDataItem @[7] {name="quarter": value=1: val_type_fixed=1: };
    UserDataItem @[8] {name="sse": value=1: val_type_fixed=1: };
    UserDataItem @[9] {name="output_name": value=1: val_type_fixed=1: };
    UserDataItem @[10] {name="trial_name": value=1: val_type_fixed=1: };
    UserDataItem @[11] {name="group_name": value=1: val_type_fixed=1: };
    UserDataItem @[12] {name="total_trials": value=1: val_type_fixed=1: };
    UserDataItem @[13] {name="time": value=1: val_type_fixed=1: };
    UserDataItem @[14] {name="cycle": value=1: val_type_fixed=1: };
    UserDataItem @[15] {name="tick": value=1: val_type_fixed=1: };
    UserDataItem @[16] {name="trial": value=1: val_type_fixed=1: };
    UserDataItem @[17] {name="group": value=1: val_type_fixed=1: };
    UserDataItem @[18] {name="epoch": value=1: val_type_fixed=1: };
    UserDataItem @[19] {name="batch": value=1: val_type_fixed=1: };
    UserDataItem @[20] {name="trial_cos_diff": value=1: val_type_fixed=1: };
    UserDataItem @[21] {name="avg_act_diff": value=1: val_type_fixed=1: };
    UserDataItem @[22] {name="cos_diff": value=1: val_type_fixed=1: };
    UserDataItem @[23] {name="minus_cycles": value=1: val_type_fixed=1: };
    UserDataItem @[24] {name="ct_cycle": value=1: val_type_fixed=1: };
    UserDataItem @[25] {name="phase_no": value=1: val_type_fixed=1: };
    UserDataItem @[26] {name="maxda": value=1: val_type_fixed=1: };
   };
   name="Network_0";
   desc=;
   specs {
    name="specs";
    el_typ=LeabraLayerSpec;
    el_def=0;
    LeabraLayerSpec @[0] {
     name="HiddenLayer";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @[0] {
       name="Input_Output";
       is_used=1;
       used_status=USED;
       desc=;
       unique{        };
       children {
	name="children";
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       multi_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       multi_gp_geom {size={x=3: y=3: }: st_off={x=-1: y=-1: }: sub_size={x=1: y=1: }: wrap=1: };
       lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
       avg_act {targ_init=0.15: fixed=0: use_ext_act=0: tau=100: adjust=1: dt=0.01: };
       inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
       inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
       clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
       decay {trial=1: };
       del_inhib {on=0: prv_trl=0: prv_q=0: };
       margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
       lay_lrate=1;
       cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
       lstats {hog_thr=0.3: dead_thr=0.01: };
      };
     };
     lay_inhib {on=1: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     multi_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     multi_gp_geom {size={x=3: y=3: }: st_off={x=-1: y=-1: }: sub_size={x=1: y=1: }: wrap=1: };
     lay_gp_inhib {on=0: gi=1.8: ff=1: fb=1: fb_tau=1.4: max_vs_avg=0: ff0=0.1: fb_dt=0.7142857: };
     avg_act {targ_init=0.15: fixed=0: use_ext_act=0: tau=100: adjust=1: dt=0.01: };
     inhib_adapt {on=0: tol_pct=0.25: trial_interval=100: tau=200: dt=0.005: };
     inhib_misc {net_thr=0: thr_rel=1: self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: avg=0: avg_gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     margin {pct_marg=0.3: avg_tau=100: adapt_tau=500: tol_pct=0.25: avg_act=0.8: low_thr=0.501: med_thr=0.506: hi_thr=0.508: avg_dt=0.01: adapt_dt=0.002: };
     lay_lrate=1;
     cos_diff {avg_tau=100: lrate_mod=0: lrmod_fm_trc=0: lrmod_z_thr=-1.5: set_net_unlrn=0: avg_dt=0.01: avg_dt_c=0.99: };
     lstats {hog_thr=0.3: dead_thr=0.01: };
    };
    LeabraUnitSpec @[1] {
     name="LeabraUnitSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_spec {type=LeabraBiasSpec: spec=.networks[0].specs[2].children[0]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {thr=0.5: gain=20: nvar=0.01: };
     act_misc {rec_nd=1: avg_nd=1: dif_avg=0: net_gain=1: act_max_hz=100: avg_trace=0: lambda=0: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
     spike {rise=0: decay=5: g_gain=9: window=3: eq_gain=8: eq_tau=50: eq_dt=0.02: };
     spike_misc {ex=0: exp_slope=0.02: spk_thr=1.2: vm_r=0.3: t_r=3: clamp_max_p=0.12: clamp_type=REGULAR: eff_spk_thr=0.5: };
     opt_thresh {send=0.1: delta=0.005: xcal_lrn=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=2: range=2: scale=0.5: };
     init {v_m=0.4: act=0: netin=0: };
     dt {integ=1: vm_tau=3.3: net_tau=1.4: fast_cyc=0: vm_dt=0.3030303: net_dt=0.7142857: };
     act_avg {ss_tau=2: s_tau=2: m_tau=10: m_in_s=0.1: ss_dt=0.5: s_dt=0.5: m_dt=0.1: s_in_s=0.9: };
     avg_l {init=0.4: gain=2.5: min=0.2: tau=10: lrn_max=0.5: lrn_min=0.0001: dt=0.1: lrn_fact=0.2173478: };
     avg_l_2 {err_mod=1: err_min=0.01: lay_act_thr=0.01: };
     g_bar {e=1: l=0.1: i=1: };
     e_rev {e=1: l=0.3: i=0.25: };
     adapt {on=0: tau=144: vm_gain=0.04: spike_gain=0.00805: Ei_dyn=1: Ei_gain=0.001: Ei_tau=50: dt=0.006944444: Ei_dt=0.02: };
     stp {on=0: f_r_ratio=0.02: rec_tau=200: p0=0.2: p0_norm=0.2: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=5: };
     syn_delay {on=0: delay=4: };
     deep_raw_qtr=0;
     deep {on=0: role=SUPER: raw_thr_rel=0.1: raw_thr_abs=0.1: mod_min=0.8: mod_thr=0.1: trc_p_only_m=0: trc_thal_gate=0: trc_avg_clamp=0: trc_deep_gain=0.2: mod_range=0.2: trc_std_gain=0.8: };
     da_mod {on=0: minus=0: plus=0.1: };
     noise_type=NO_NOISE;
     noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=1: mode=FIXED_NOISE: };
     noise_sched {
      name="noise_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=1;
     };
    };
    LeabraConSpec @[2] {
     name="LeabraConSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @[0] {
       name="LeabraBiasSpec_0";
       is_used=1;
       used_status=USED;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;learn;       };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: no_plus_net=0: };
       learn=0;
       learn_qtr=Q4;
       lrate=0.04;
       use_lrate_sched=1;
       cur_lrate=0.04;
       lrs_mult=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_zone {on=0: con_norm=1: s_tau=50: l_tau=2: norm_tau=100: gain=2: lrate_mult=3: s_dt=0.02: l_dt=0.5: norm_dt=0.01: };
       wt_bal {on=1: hi_thr=0.4: hi_gain=4: lo_thr=0.2: lo_gain=4: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_l_lrn=0: sign_lrn=0.001: };
       dwt_thresh=0.1;
      };
      LeabraConSpec @[1] {
       name="TopDownCons";
       is_used=1;
       used_status=USED;
       desc="top-down connections from output layers down to hidden etc typically need to be weaker than bottom-up";
       unique{ wt_scale;       };
       children {
	name="children";
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=0.2: no_plus_net=0: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       use_lrate_sched=1;
       cur_lrate=0.04;
       lrs_mult=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: soft_bound=1: };
       dwt_zone {on=0: con_norm=1: s_tau=50: l_tau=2: norm_tau=100: gain=2: lrate_mult=3: s_dt=0.02: l_dt=0.5: norm_dt=0.01: };
       wt_bal {on=1: hi_thr=0.4: hi_gain=4: lo_thr=0.2: lo_gain=4: };
       adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
       slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_l_lrn=0: sign_lrn=0.001: };
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: no_plus_net=0: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.04;
     use_lrate_sched=1;
     cur_lrate=0.04;
     lrs_mult=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1: soft_bound=1: };
     dwt_zone {on=0: con_norm=1: s_tau=50: l_tau=2: norm_tau=100: gain=2: lrate_mult=3: s_dt=0.02: l_dt=0.5: norm_dt=0.01: };
     wt_bal {on=1: hi_thr=0.4: hi_gain=4: lo_thr=0.2: lo_gain=4: };
     adapt_scale {on=0: tau=5000: lo_thr=0.25: hi_thr=0.75: lo_scale=0.01: hi_scale=2: dt=0.0002: };
     slow_wts {on=0: swt_pct=0.8: slow_tau=100: wt_tau=1: fwt_pct=0.2: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
     margin {lrate_mod=0: stable_lrate=0.5: sign_dwt=0: sign_l_lrn=0: sign_lrn=0.001: };
    };
    FullPrjnSpec @[3] {
     name="FullPrjnSpec_0";
     is_used=1;
     used_status=USED;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     set_scale=0;
     init_wt_val=1;
     add_rnd_var=0;
     renorm_wts {on=0: mult_norm=1: avg_wt=0.5: };
    };
   };
   param_seqs {
    name="param_seqs";
    el_typ=ParamSeq;
    el_def=0;
   };
   layers {
    name="layers";
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    pos2d {x=0: y=0: };
    max_disp_size {x=5: y=5: z=3: };
    max_disp_size2d {x=5: y=18: };
    LeabraLayer @[0] {
     name="Input";
     desc=;
     flags=ABS_POS;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     pos_abs {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     pos2d_abs {x=0: y=0: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=5: y=5: n_not_xy=0: n=25: };
     disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     n_recv_prjns=0;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_Group @. = [0] = LeabraPrjn .networks[0].layers[1].projections[0];
     };
     units {
      name="units";
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=.networks[0].specs[1]$$: };
     dist {fm_input=0: fm_output=2: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     acts_m_avg=0.15;
     acts_p_avg=0.15;
     acts_p_avg_eff=0.15;
     spec {type=LeabraLayerSpec: spec=.networks[0].specs[0].children[0]$$: };
     adapt_gi=1;
     margin_low_thr=0.501;
     margin_med_thr=0.506;
     margin_hi_thr=0.508;
     margin_low_avg=0.1875;
     margin_med_avg=0.028125;
     margin_hi_avg=0.13125;
    };
    LeabraLayer @[1] {
     name="Hidden";
     desc=;
     flags=ABS_POS;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=1: };
     pos_abs {x=0: y=0: z=1: };
     pos2d {x=0: y=13: };
     pos2d_abs {x=0: y=13: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=5: y=5: n_not_xy=0: n=25: };
     disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     n_recv_prjns=2;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Input";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=.networks[0].layers[0]$$;
       spec {type=FullPrjnSpec: spec=.networks[0].specs[3]$$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=$.networks[0].specs[2]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @[1] {
       name="Fm_Output";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=.networks[0].layers[2]$$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[3]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=.networks[0].specs[2].children[1]$$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_OUTPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_Group @. = [0] = LeabraPrjn .networks[0].layers[2].projections[0];
     };
     units {
      name="units";
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[1]$: };
     dist {fm_input=1: fm_output=1: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     acts_m_avg=0.15;
     acts_p_avg=0.15;
     acts_p_avg_eff=0.15;
     spec {type=LeabraLayerSpec: spec=.networks[0].specs[0]$$: };
     adapt_gi=1;
     margin_low_thr=0.501;
     margin_med_thr=0.506;
     margin_hi_thr=0.508;
     margin_low_avg=0.1875;
     margin_med_avg=0.028125;
     margin_hi_avg=0.13125;
    };
    LeabraLayer @[2] {
     name="Output";
     desc=;
     flags=ABS_POS;
     layer_type=TARGET;
     pos {x=0: y=0: z=2: };
     pos_abs {x=0: y=0: z=2: };
     pos2d {x=0: y=6: };
     pos2d_abs {x=0: y=6: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=5: y=5: n_not_xy=0: n=25: };
     disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     n_recv_prjns=1;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @[0] {
       name="Fm_Hidden";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=.networks[0].layers[1]$$;
       spec {type=FullPrjnSpec: spec=$.networks[0].specs[3]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=$.networks[0].specs[2]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_Group @. = [0] = LeabraPrjn .networks[0].layers[1].projections[1];
     };
     units {
      name="units";
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.networks[0].specs[1]$: };
     dist {fm_input=2: fm_output=0: };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     acts_m_avg=0.15;
     acts_p_avg=0.15;
     acts_p_avg_eff=0.15;
     spec {type=LeabraLayerSpec: spec=$.networks[0].specs[0].children[0]$: };
     adapt_gi=1;
     margin_low_thr=0.501;
     margin_med_thr=0.506;
     margin_hi_thr=0.508;
     margin_low_avg=0.1875;
     margin_med_avg=0.028125;
     margin_hi_avg=0.13125;
    };
   };
   weights {
    name="weights";
    el_typ=Weights;
    el_def=0;
   };
   flags=MANUAL_POS|ABS_POS|BUILD_INIT_WTS;
   unit_vars_type=LeabraUnitVars;
   con_group_type=LeabraConGroup;
   auto_build=AUTO_BUILD;
   auto_load_wts=NO_AUTO_LOAD;
   auto_load_file=;
   brain_atlas_name=;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   stats {sse_unit_avg=0: sse_sqrt=0: cnt_err_tol=0: prerr=0: };
   threads {run_time={name="TimeUsedHR_6": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: }: sync_time={name="TimeUsedHR_7": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: }: total_time={name="TimeUsedHR_8": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: }: n_wake_in_sync=0: run_time_pct=0: sync_time_pct=0: wake_in_sync_pct=1.216681899864304e+285: };
   cuda {sync_units=0: sync_cons=0: min_threads=32: max_threads=1024: cons_per_thread=2: timers_on=0: n_threads=32: };
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   n_units=76;
   n_cons=1875;
   max_prjns=2;
   max_disp_size {x=5: y=5: z=3: };
   max_disp_size2d {x=5: y=18: };
   times {quarter=25: gate_cyc=18: deep_cyc=5: time_inc=0.001: wt_bal_int=10: minus=75: plus=25: total_cycles=100: current_cycle_gate_cycle=0: };
   lstats {trg_max_act_crit=0.5: off_errs=1: on_errs=1: agg_unlearnable=0: wt_bal=0: };
   net_misc {spike=0: deep=0: bias_learn=0: trial_decay=1: diff_scale_p=0: diff_scale_q1=0: wt_bal=1: lay_gp_inhib=0: inhib_cons=0: };
   deep {on=0: ctxt=0: raw_net=0: mod_net=0: raw_qtr=0: };
   rel_netin {on=1: trl_skip=10: epc_skip=10: };
  };
 };
};

// ta_Dump File v3.0 -- code v7.8.5.0 rev9084
LeabraProject .projects["LeabraFlex"] { 
 Doc_Group @.docs = [1] {
  taDoc @["LeabraFlexProgs"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["user_pinned"] { };
   };
  };
 };

 Wizard_Group @.wizards = [1] {
  LeabraWizard @["LeabraWizard_1"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["NO_CLIP"] { };
   };
  };
 };

 ControlPanel_Group @.ctrl_panels = [2] {
  ControlPanel @["ControlPanel"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["user_pinned"] { };
   };

   EditMbrItem_Group @.mbrs = [5] {
    EditMbrItem @[0] { };
    EditMbrItem @[1] { };
    EditMbrItem @[2] { };
    EditMbrItem @[3] { };
    EditMbrItem @[4] { };
   };

   EditMthItem_Group @.mths = [4] {
    EditMthItem @[0] { };
    EditMthItem @[1] { };
    EditMthItem @[2] { };
    EditMthItem @[3] { };
   };
  };
  ClusterRun @["ClusterRun"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["user_pinned"] { };
   };

   EditMbrItem_Group @.mbrs = [0] {
   };

   EditMthItem_Group @.mths = [0] {
   };

   DataTableCols @.jobs_running.data = [31] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["notes"] { };
    String_Data @["label"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
   };

   DataOpList @.jobs_running.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_running.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_done.data = [31] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["notes"] { };
    String_Data @["label"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
   };

   DataOpList @.jobs_done.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_done.control_panel_cells = [0] {
   };

   DataTableCols @.jobs_archive.data = [31] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["tag"] { };
    String_Data @["status"] { };
    String_Data @["notes"] { };
    String_Data @["label"] { };
    String_Data @["filename"] { };
    String_Data @["params"] { };
    String_Data @["status_info"] { };
    String_Data @["submit_time"] { };
    String_Data @["start_time"] { };
    String_Data @["end_time"] { };
    String_Data @["running_time"] { };
    String_Data @["job_no"] { };
    String_Data @["job_out"] { };
    String_Data @["job_out_file"] { };
    String_Data @["dat_files"] { };
    String_Data @["other_files"] { };
    int_Data @["command_id"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["command"] { };
    String_Data @["repo_url"] { };
    String_Data @["queue"] { };
    String_Data @["run_time"] { };
    int_Data @["ram_gb"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["n_threads"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["mpi_per_node"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_batches"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    int_Data @["pb_nodes"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["NARROW"] { };
     };
    };
    String_Data @["submit_svn"] { };
    String_Data @["submit_job"] { };
   };

   DataOpList @.jobs_archive.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.jobs_archive.control_panel_cells = [0] {
   };

   DataTableCols @.file_list.data = [11] {
    String_Data @["cluster"] { };
    String_Data @["user"] { };
    String_Data @["file_name"] { };
    String_Data @["tag"] { };
    String_Data @["size"] { };
    String_Data @["kind"] { };
    String_Data @["date_modified"] { };
    String_Data @["date_created"] { };
    String_Data @["svn_file_path"] { };
    String_Data @["proj_file_path"] { };
    String_Data @["file_path"] { };
   };

   DataOpList @.file_list.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.file_list.control_panel_cells = [0] {
   };

   DataTableCols @.cluster_info.data = [6] {
    String_Data @["queue"] { };
    String_Data @["job_no"] { };
    String_Data @["user"] { };
    String_Data @["state"] { };
    String_Data @["procs"] { };
    String_Data @["start_time"] { };
   };

   DataOpList @.cluster_info.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.cluster_info.control_panel_cells = [0] {
   };

   ParamSearchAlgo_List @.search_algos = [0] {
   };
  };
 };

 ParamSet_Group @.param_sets = [0] {
 };

 DataTable_Group @.data = [0] {
  DataTable_Group @.gp["InputData"] = [1] { 
   DataTable @["StdInputData"] { 
    DataTableCols @.data = [3] {
     String_Data @["Name"] { };
     float_Data @["Output"] { };
     float_Data @["Input"] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
  DataTable_Group @.gp["OutputData"] = [2] { 
   DataTable @["TrialOutputData"] { 
    DataTableCols @.data = [29] {
     int_Data @["batch"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["epoch"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["train_mode"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["group"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["trial"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["tick"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["time"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["trial_name"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["group_name"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["output_name"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["rt_cycles"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["sse"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["norm_err"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["cos_err"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["ext_rew"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_lay_sse"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_lay_norm_err"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_lay_cos_err"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Hidden_lay_net_sd"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_lay_net_sd"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["net_cos_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["net_trial_cos_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["net_avg_act_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Hidden_cos_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_cos_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Hidden_trial_cos_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_trial_cos_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Hidden_avg_act_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     float_Data @["Output_avg_act_diff"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
   DataTable @["EpochOutputData"] { 
    DataTableCols @.data = [40] {
     int_Data @["batch"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
      };
     };
     int_Data @["epoch"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
      };
     };
     float_Data @["avg_sse"] { };
     float_Data @["cnt_err"] { };
     float_Data @["pct_cor"] { };
     float_Data @["pct_err"] { };
     float_Data @["avg_norm_err"] { };
     float_Data @["avg_cos_err"] { };
     float_Data @["avg_ext_rew"] { };
     float_Data @["avg_cycles"] { };
     float_Data @["epoch_time_tot"] { };
     float_Data @["epoch_time_usr"] { };
     float_Data @["Output_lay_avg_sse"] { };
     float_Data @["Output_lay_cnt_err"] { };
     float_Data @["Output_lay_pct_cor"] { };
     float_Data @["Output_lay_pct_err"] { };
     float_Data @["Output_lay_avg_norm_err"] { };
     float_Data @["Output_lay_avg_cos_err"] { };
     float_Data @["net_avg_cos_diff"] { };
     float_Data @["net_avg_trial_cos_diff"] { };
     float_Data @["net_avg_avg_act_diff"] { };
     float_Data @["Hidden_avg_cos_diff"] { };
     float_Data @["Output_avg_cos_diff"] { };
     float_Data @["Hidden_avg_trial_cos_diff"] { };
     float_Data @["Output_avg_trial_cos_diff"] { };
     float_Data @["Hidden_avg_avg_act_diff"] { };
     float_Data @["Output_avg_avg_act_diff"] { };
     float_Data @["Hidden_avg_net_sd"] { };
     float_Data @["Output_avg_net_sd"] { };
     float_Data @["Hidden_hog_pct"] { };
     float_Data @["Output_hog_pct"] { };
     float_Data @["Hidden_dead_pct"] { };
     float_Data @["Output_dead_pct"] { };
     float_Data @["Hidden_netmax"] { };
     float_Data @["Output_netmax"] { };
     float_Data @["Hidden_avg_act"] { };
     float_Data @["Output_avg_act"] { };
     float_Data @["Hidden_Fm_Input_netrel"] { };
     float_Data @["Hidden_Fm_Output_netrel"] { };
     float_Data @["Output_Fm_Hidden_netrel"] { };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
  DataTable_Group @.gp["AnalysisData"] { 
  };
  DataTable_Group @.gp["ConfigData"] = [1] { 
   DataTable @["ConfigTable"] { 
    DataTableCols @.data = [15] {
     String_Data @["config_id"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["config_desc"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["init_prog"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["run_prog"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["startup_prog"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["train_epochs"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["trials_per_epoch"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["save_final_wts"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["save_wts_interval"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["test_interval"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["log_trials"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["load_weights"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     String_Data @["weights_file"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["load_st_epc"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["view_panel_wd"] { };
      };
     };
     int_Data @["lrs_step_epochs"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["NARROW"] { };
       UserDataItem @["view_panel_wd"] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
 };

 Program_TopGroup @.programs = [1] {
  Program @["MasterStartup"] { 
   ProgObjList @.objs = [0] {
   };

   ProgType_List @.types = [0] {
   };

   ProgVar_List @.args = [1] {
    ProgVar @["network"] { };
   };

   ProgVar_List @.vars = [13] {
    ProgVar @["batch_prog"] { };
    ProgVar @["tag"] { };
    ProgVar @["config_id"] { };
    ProgVar @["param_set"] { };
    ProgVar @["log_dir"] { };
    ProgVar @["log_file_nm"] { };
    ProgVar @["EpochOutputData"] { };
    ProgVar @["Config"] { };
    ProgVar @["batch_str"] { };
    ProgVar @["batch_start"] { };
    ProgVar @["startup_prog"] { };
    ProgVar @["MyClusterRun"] { };
    ProgVar @["param_sets"] { };
   };

   Function_List @.functions = [1] {
    Function @["set_n_units"] { 
     ProgVar_List @.args = [2] {
      ProgVar @["lay"] { };
      ProgVar @["n_units"] { };
     };

     ProgEl_List @.fun_code = [4] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	ReturnExpr @[0] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      PrintExpr @[2] { };
      ReturnExpr @[3] { };
     };
    };
   };

   ProgEl_List @.init_code = [0] {
   };

   ProgEl_List @.prog_code = [30] {
    RegisterArgs @[0] { };
    PrintExpr @[1] { };
    Comment @[2] { };
    ProgVarFmArg @[3] { };
    ProgVarFmArg @[4] { };
    ProgVarFmArg @[5] { };
    ProgVarFmArg @[6] { };
    ProgVarFmArg @[7] { };
    Comment @[8] { };
    ProgVarFmArg @[9] { };
    ProgVarFmArg @[10] { };
    OtherProgramVar @[11] { };
    MethodCall @[12] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ControlPanelsFmArgs @[13] { };
    If @[14] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    Comment @[15] { };
    Comment @[16] { };
    If @[17] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    AssignExpr @[18] { };
    Comment @[19] { };
    DataColsFmArgs @[20] { };
    Comment @[21] { };
    If @[22] { 
     ProgEl_List @.true_code = [4] {
      ProgVarFmArg @[0] { };
      MiscCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      VarIncr @[2] { };
      If @[3] { 
       ProgEl_List @.true_code = [2] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [4] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	  ProgArg @[3] { };
	 };
	};
	MiscCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    Else @[23] { 
     ProgEl_List @.else_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MiscCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    OtherProgramVar @[24] { };
    Comment @[25] { };
    DataVarProg @[26] { };
    ProgramCallVar @[27] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
    PrintExpr @[28] { };
    ProgramCall @[29] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Program_Group @.gp["StartupProgs"] = [1] { 
   Program @["BasicStartup"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["tag"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     Comment @[0] { };
     Comment @[1] { };
    };
   };
  };
  Program_Group @.gp["ConfigProgs"] = [3] { 
   Program @["MasterBatch"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [3] {
     ProgVar @["batch"] { };
     ProgVar @["batch_start"] { };
     ProgVar @["n_batches"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [4] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @["i"] { };
      };
     };
     AssignExpr @[1] { };
     MemberAssign @[2] { };
     ForLoop @[3] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       NetCounterIncr @[1] { };
      };
     };
    };
   };
   Program @["MasterTrain"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [1] {
     DynEnumTableCol @["ConfigOptions"] { 
      DynEnumItem_List @.enums = [1] {
       DynEnumItem @["basic_train"] { };
      };
     };
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [6] {
     ProgVar @["Config"] { };
     ProgVar @["cur_config"] { };
     ProgVar @["config_id"] { };
     ProgVar @["run_prog"] { };
     ProgVar @["init_prog"] { };
     ProgVar @["stop_train"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     AssignExpr @[0] { };
     AssignExpr @[1] { };
     WtInitPrompt @[2] { 
      ProgEl_List @.yes_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       PrintExpr @[2] { };
      };
     };
    };

    ProgEl_List @.prog_code = [5] {
     AssignExpr @[0] { };
     AssignExpr @[1] { };
     DataVarProg @[2] { };
     ProgramCallVar @[3] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     WhileLoop @[4] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [3] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	 ProgArg @[2] { };
	};
       };
      };
     };
    };
   };
   Program @["MasterRun"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [1] {
     DynEnumType @["StopStepGrain"] { 
      DynEnumItem_List @.enums = [4] {
       DynEnumItem @["TRIAL"] { };
       DynEnumItem @["EPOCH"] { };
       DynEnumItem @["ERROR"] { };
       DynEnumItem @["CORRECT"] { };
      };
     };
    };

    ProgVar_List @.args = [3] {
     ProgVar @["network"] { };
     ProgVar @["config_id"] { };
     ProgVar @["run_prog"] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @["Config"] { };
     ProgVar @["stop_step_grain"] { };
    };

    Function_List @.functions = [1] {
     Function @["StopStepTest"] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [2] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       Switch @[1] { 
	ProgEl_List @.cases = [4] {
	 CaseBlock @[0] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	 CaseBlock @[1] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	 CaseBlock @[2] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	 CaseBlock @[3] { 
	  ProgEl_List @.prog_code = [1] {
	   ReturnExpr @[0] { };
	  };
	 };
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     ProgramCallVar @[0] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program_Group @.gp["InitProgs"] = [1] { 
    Program @["BasicInit"] { 
     ProgObjList @.objs = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @["network"] { };
      ProgVar @["config_id"] { };
     };

     ProgVar_List @.vars = [1] {
      ProgVar @["lay_lesion_list"] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [5] {
      ProgramCall @[0] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[1] { 
       ProgArg_List @.prog_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [1] {
	ProgArg @[0] { };
       };
      };
      If @[3] { 
       ProgEl_List @.true_code = [1] {
	MemberAssign @[0] { };
       };
      };
      Else @[4] { 
       ProgEl_List @.else_code = [1] {
	MemberAssign @[0] { };
       };
      };
     };
    };
   };
   Program_Group @.gp["RunProgs"] = [1] { 
    Program @["BasicRun"] { 
     ProgObjList @.objs = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [2] {
      ProgVar @["network"] { };
      ProgVar @["config_id"] { };
     };

     ProgVar_List @.vars = [4] {
      ProgVar @["trials_per_epoch"] { };
      ProgVar @["train_epochs"] { };
      ProgVar @["update_net_view"] { };
      ProgVar @["StdInputData"] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [6] {
      Comment @[0] { };
      MemberAssign @[1] { };
      ProgramCall @[2] { 
       ProgArg_List @.prog_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      Comment @[3] { };
      MemberAssign @[4] { };
      If @[5] { 
       ProgEl_List @.true_code = [4] {
	ProgramCall @[0] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	MemberAssign @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [2] {
	  ProgramCall @[0] { 
	   ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  ReturnExpr @[1] { };
	 };
	};
	ProgramCall @[3] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
   };
  };
  Program_Group @.gp["TaskProgs"] = [1] { 
   Program @["BasicTrain"] { 
    ProgObjList @.objs = [1] {
     TimeUsed @["BasicTrainTime"] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @["network"] { };
     ProgVar @["input_data"] { };
     ProgVar @["update_net_view"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["BasicTrainTime"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };

    ProgEl_List @.prog_code = [19] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     Comment @[1] { };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     ProgramCall @[3] { 
      ProgArg_List @.prog_args = [3] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
      };
     };
     ProgramCall @[4] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     Comment @[5] { };
     ProgramCall @[6] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[7] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[8] { };
     StopStepPoint @[9] { };
     Comment @[10] { };
     MethodCall @[11] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[12] { 
      ProgArg_List @.prog_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ProgramCall @[13] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[14] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[15] { };
     ProgramCall @[16] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[17] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[18] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
  };
  Program_Group @.gp["EnviroProgs"] = [3] { 
   Program @["ChooseNextEvent"] { 
    ProgObjList @.objs = [1] {
     DataTable @["PermIdxTable"] { 
      DataTableCols @.data = [1] {
       int_Data @["Index"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };

      DataTableCell_List @.control_panel_cells = [0] {
      };
     };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @["network"] { };
     ProgVar @["input_data"] { };
     ProgVar @["permuted"] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @["cur_idx"] { };
     ProgVar @["input_idx"] { };
     ProgVar @["dmem_rows"] { };
     ProgVar @["PermIdxTable"] { };
    };

    Function_List @.functions = [3] {
     Function @["ComputeDmemRows"] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 AssignExpr @[0] { };
	};
       };
       Else @[2] { 
	ProgEl_List @.else_code = [2] {
	 AssignExpr @[0] { };
	 WhileLoop @[1] { 
	  ProgEl_List @.loop_code = [1] {
	   VarIncr @[0] { };
	  };
	 };
	};
       };
      };
     };
     Function @["PermuteIndexes"] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       AssignExpr @[1] { };
       If @[2] { 
	ProgEl_List @.true_code = [1] {
	 DataProcCall @[0] { 
	  ProgArg_List @.meth_args = [3] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	  };
	 };
	};
       };
      };
     };
     Function @["InitIndexes"] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [5] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [0] {
	};
       };
       FunctionCall @[1] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MethodCall @[3] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       FunctionCall @[4] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [2] {
     FunctionCall @[0] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     AssignExpr @[1] { };
    };

    ProgEl_List @.prog_code = [8] {
     FunctionCall @[0] { 
      ProgArg_List @.fun_args = [0] {
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       FunctionCall @[0] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
      };
     };
     If @[2] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
      };
     };
     Else @[3] { 
      ProgEl_List @.else_code = [1] {
       AssignExpr @[0] { };
      };
     };
     If @[4] { 
      ProgEl_List @.true_code = [2] {
       AssignExpr @[0] { };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 RandomCall @[0] { 
	  ProgArg_List @.meth_args = [2] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	  };
	 };
	};
       };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     If @[6] { 
      ProgEl_List @.true_code = [1] {
       FunctionCall @[0] { 
	ProgArg_List @.fun_args = [0] {
	};
       };
      };
     };
     Else @[7] { 
      ProgEl_List @.else_code = [1] {
       VarIncr @[0] { };
      };
     };
    };
   };
   Program @["ChooseRandomEvent"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["input_data"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["event_idx"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     RandomCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @["ApplyInputs"] { 
    ProgObjList @.objs = [1] {
     LayerWriter @["LayerWriter_0"] { 
      LayerDataEl_List @.layer_data = [3] {
       LayerWriterEl @[0] { };
       LayerWriterEl @[1] { };
       LayerWriterEl @[2] { };
      };
     };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @["network"] { };
     ProgVar @["input_data"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["LayerWriter_0"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
  };
  Program_Group @.gp["UtilProgs"] = [17] { 
   Program @["StdGlobalsInit"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @["network"] { };
     ProgVar @["config_id"] { };
    };

    ProgVar_List @.vars = [12] {
     ProgVar @["Config"] { };
     ProgVar @["trials_per_epoch"] { };
     ProgVar @["trials_per_epoch_orig"] { };
     ProgVar @["train_epochs"] { };
     ProgVar @["save_final_wts"] { };
     ProgVar @["save_wts_interval"] { };
     ProgVar @["test_interval"] { };
     ProgVar @["log_trials"] { };
     ProgVar @["load_weights"] { };
     ProgVar @["weights_file"] { };
     ProgVar @["load_st_epc"] { };
     ProgVar @["lrs_step_epochs"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     Comment @[0] { };
     DataVarProg @[1] { };
     AssignExpr @[2] { };
     If @[3] { 
      ProgEl_List @.true_code = [2] {
       AssignExpr @[0] { };
       If @[1] { 
	ProgEl_List @.true_code = [1] {
	 VarIncr @[0] { };
	};
       };
      };
     };
    };
   };
   Program @["BatchRndSeed"] { 
    ProgObjList @.objs = [1] {
     RndSeed_List @["rnd_seeds"] { 
      taList @.seeds = [25] {
       RndSeed @["RndSeed_1"] { };
       RndSeed @["RndSeed_2"] { };
       RndSeed @["RndSeed_3"] { };
       RndSeed @["RndSeed_4"] { };
       RndSeed @["RndSeed_5"] { };
       RndSeed @["RndSeed_6"] { };
       RndSeed @["RndSeed_7"] { };
       RndSeed @["RndSeed_8"] { };
       RndSeed @["RndSeed_9"] { };
       RndSeed @["RndSeed_10"] { };
       RndSeed @["RndSeed_11"] { };
       RndSeed @["RndSeed_12"] { };
       RndSeed @["RndSeed_13"] { };
       RndSeed @["RndSeed_14"] { };
       RndSeed @["RndSeed_15"] { };
       RndSeed @["RndSeed_16"] { };
       RndSeed @["RndSeed_17"] { };
       RndSeed @["RndSeed_18"] { };
       RndSeed @["RndSeed_19"] { };
       RndSeed @["RndSeed_20"] { };
       RndSeed @["RndSeed_21"] { };
       RndSeed @["RndSeed_22"] { };
       RndSeed @["RndSeed_23"] { };
       RndSeed @["RndSeed_24"] { };
       RndSeed @["RndSeed_25"] { };
      };
     };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["rnd_seeds"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @["ConfigNetwork"] { 
    ProgObjList @.objs = [1] {
     String_Matrix @["les_lay_mat"] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [2] {
     ProgVar @["network"] { };
     ProgVar @["lesion_layers"] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @["les_lay_mat"] { };
     ProgVar @["i"] { };
     ProgVar @["laygp_nm"] { };
     ProgVar @["laygp"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [8] {
     Comment @[0] { };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [3] {
       MemberMethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     Comment @[2] { };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[4] { 
      ProgEl_List @.loop_code = [5] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MemberMethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 MiscCall @[0] { 
	  ProgArg_List @.meth_args = [9] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	   ProgArg @[3] { };
	   ProgArg @[4] { };
	   ProgArg @[5] { };
	   ProgArg @[6] { };
	   ProgArg @[7] { };
	   ProgArg @[8] { };
	  };
	 };
	 IfContinue @[1] { };
	};
       };
       MethodCall @[3] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       MethodCall @[4] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     PrintExpr @[7] { };
    };
   };
   Program @["PositionLayersFromTable"] { 
    UserDataItem_List @*(.user_data_) {
     UserDataItem @["user_pinned"] { };
    };

    ProgObjList @.objs = [2] {
     DataTable @["LayerLayout"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["user_pinned"] { };
      };

      DataTableCols @.data = [9] {
       String_Data @["LayerName"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       String_Data @["LayerGroup"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       String_Data @["LayoutGroup"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["X_Abs"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Y_Abs"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Z_Abs"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["X_Rel"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Y_Rel"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Z_Rel"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };

      DataTableCell_List @.control_panel_cells = [0] {
      };
     };
     DataTable @["LayerLayout_previous"] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @["user_pinned"] { };
      };

      DataTableCols @.data = [9] {
       String_Data @["LayerName"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       String_Data @["LayerGroup"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       String_Data @["LayoutGroup"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["X_Abs"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Y_Abs"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Z_Abs"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["X_Rel"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Y_Rel"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["NARROW"] { };
	 UserDataItem @["view_panel_wd"] { };
	};
       };
       int_Data @["Z_Rel"] { 
	UserDataItem_List @*(.user_data_) {
	 UserDataItem @["view_panel_wd"] { };
	};
       };
      };

      DataOpList @.last_sort_spec.ops = [0] {
      };

      DataTableCell_List @.control_panel_cells = [0] {
      };
     };
    };

    ProgType_List @.types = [2] {
     DynEnumType @["ActionType"] { 
      DynEnumItem_List @.enums = [2] {
       DynEnumItem @["GetCurrentPos"] { };
       DynEnumItem @["SetPositions"] { };
      };
     };
     DynEnumType @["UseGroup"] { 
      DynEnumItem_List @.enums = [3] {
       DynEnumItem @["IgnoreGroup"] { };
       DynEnumItem @["LayerGroup"] { };
       DynEnumItem @["LayoutGroup"] { };
      };
     };
    };

    ProgVar_List @.args = [3] {
     ProgVar @["action"] { };
     ProgVar @["use_group"] { };
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @["LayerLayout"] { };
     ProgVar @["LayerLayout_previous"] { };
    };

    Function_List @.functions = [2] {
     Function @["GetCurrent"] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [7] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [4] {
	 ProgVar @["leaf"] { };
	 ProgVar @["current_layer"] { };
	 ProgVar @["net_layers"] { };
	 ProgVar @["layer_group"] { };
	};
       };
       MethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
       AssignExpr @[3] { };
       Comment @[4] { };
       ForeachLoop @[5] { 
	ProgEl_List @.loop_code = [5] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 CssExpr @[1] { };
	 CssExpr @[2] { };
	 CssExpr @[3] { };
	 CssExpr @[4] { };
	};
       };
       ForLoop @[6] { 
	ProgEl_List @.loop_code = [10] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	 AssignExpr @[1] { };
	 CssExpr @[2] { };
	 If @[3] { 
	  ProgEl_List @.true_code = [1] {
	   CssExpr @[0] { };
	  };
	 };
	 CssExpr @[4] { };
	 CssExpr @[5] { };
	 CssExpr @[6] { };
	 CssExpr @[7] { };
	 CssExpr @[8] { };
	 CssExpr @[9] { };
	};
       };
      };
     };
     Function @["SetPos"] { 
      ProgVar_List @.args = [0] {
      };

      ProgEl_List @.fun_code = [3] {
       LocalVars @[0] { 
	ProgVar_List @.local_vars = [9] {
	 ProgVar @["row"] { };
	 ProgVar @["current_layer"] { };
	 ProgVar @["layer_name"] { };
	 ProgVar @["layer_group"] { };
	 ProgVar @["group_name"] { };
	 ProgVar @["lgrow"] { };
	 ProgVar @["lg_x"] { };
	 ProgVar @["lg_y"] { };
	 ProgVar @["lg_z"] { };
	};
       };
       ForLoop @[1] { 
	ProgEl_List @.loop_code = [4] {
	 AssignExpr @[0] { };
	 IfContinue @[1] { };
	 AssignExpr @[2] { };
	 If @[3] { 
	  ProgEl_List @.true_code = [1] {
	   Switch @[0] { 
	    ProgEl_List @.cases = [3] {
	     CaseBlock @[0] { 
	      ProgEl_List @.prog_code = [1] {
	       MethodCall @[0] { 
		ProgArg_List @.meth_args = [3] {
		 ProgArg @[0] { };
		 ProgArg @[1] { };
		 ProgArg @[2] { };
		};
	       };
	      };
	     };
	     CaseBlock @[1] { 
	      ProgEl_List @.prog_code = [4] {
	       AssignExpr @[0] { };
	       If @[1] { 
		ProgEl_List @.true_code = [4] {
		 MethodCall @[0] { 
		  ProgArg_List @.meth_args = [4] {
		   ProgArg @[0] { };
		   ProgArg @[1] { };
		   ProgArg @[2] { };
		   ProgArg @[3] { };
		  };
		 };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		 AssignExpr @[3] { };
		};
	       };
	       Else @[2] { 
		ProgEl_List @.else_code = [3] {
		 AssignExpr @[0] { };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		};
	       };
	       MethodCall @[3] { 
		ProgArg_List @.meth_args = [3] {
		 ProgArg @[0] { };
		 ProgArg @[1] { };
		 ProgArg @[2] { };
		};
	       };
	      };
	     };
	     CaseBlock @[2] { 
	      ProgEl_List @.prog_code = [4] {
	       AssignExpr @[0] { };
	       If @[1] { 
		ProgEl_List @.true_code = [4] {
		 MethodCall @[0] { 
		  ProgArg_List @.meth_args = [4] {
		   ProgArg @[0] { };
		   ProgArg @[1] { };
		   ProgArg @[2] { };
		   ProgArg @[3] { };
		  };
		 };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		 AssignExpr @[3] { };
		};
	       };
	       Else @[2] { 
		ProgEl_List @.else_code = [3] {
		 AssignExpr @[0] { };
		 AssignExpr @[1] { };
		 AssignExpr @[2] { };
		};
	       };
	       MethodCall @[3] { 
		ProgArg_List @.meth_args = [3] {
		 ProgArg @[0] { };
		 ProgArg @[1] { };
		 ProgArg @[2] { };
		};
	       };
	      };
	     };
	    };
	   };
	  };
	 };
	};
       };
       MethodCall @[2] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [1] {
     Switch @[0] { 
      ProgEl_List @.cases = [2] {
       CaseBlock @[0] { 
	ProgEl_List @.prog_code = [1] {
	 FunctionCall @[0] { 
	  ProgArg_List @.fun_args = [0] {
	  };
	 };
	};
       };
       CaseBlock @[1] { 
	ProgEl_List @.prog_code = [1] {
	 FunctionCall @[0] { 
	  ProgArg_List @.fun_args = [0] {
	  };
	 };
	};
       };
      };
     };
    };
   };
   Program @["NetworkToggleLesion"] { 
    ProgObjList @.objs = [1] {
     String_Matrix @["les_lay_mat"] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [3] {
     ProgVar @["network"] { };
     ProgVar @["lesion_layers"] { };
     ProgVar @["lesion"] { };
    };

    ProgVar_List @.vars = [4] {
     ProgVar @["les_lay_mat"] { };
     ProgVar @["i"] { };
     ProgVar @["laygp_nm"] { };
     ProgVar @["laygp"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [5] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       MemberMethodCall @[1] { 
	ProgArg_List @.meth_args = [1] {
	 ProgArg @[0] { };
	};
       };
       If @[2] { 
	ProgEl_List @.true_code = [2] {
	 MiscCall @[0] { 
	  ProgArg_List @.meth_args = [9] {
	   ProgArg @[0] { };
	   ProgArg @[1] { };
	   ProgArg @[2] { };
	   ProgArg @[3] { };
	   ProgArg @[4] { };
	   ProgArg @[5] { };
	   ProgArg @[6] { };
	   ProgArg @[7] { };
	   ProgArg @[8] { };
	  };
	 };
	 IfContinue @[1] { };
	};
       };
       If @[3] { 
	ProgEl_List @.true_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
       Else @[4] { 
	ProgEl_List @.else_code = [1] {
	 MethodCall @[0] { 
	  ProgArg_List @.meth_args = [0] {
	  };
	 };
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @["TrainStart"] { 
    ProgObjList @.objs = [1] {
     RndSeed @["dmem_rnd_seed"] { };
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [7] {
     ProgVar @["weights_file"] { };
     ProgVar @["load_weights"] { };
     ProgVar @["load_st_epc"] { };
     ProgVar @["lrs_step_epochs"] { };
     ProgVar @["LRSConSpec"] { };
     ProgVar @["dmem_rnd_seed"] { };
     ProgVar @["dmem_new_seed"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [9] {
     ProgramCall @[0] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     If @[2] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     PrintExpr @[4] { };
     If @[5] { 
      ProgEl_List @.true_code = [3] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [2] {
	 ProgArg @[0] { };
	 ProgArg @[1] { };
	};
       };
       PrintVar @[1] { };
       MemberAssign @[2] { };
      };
     };
     MethodCall @[6] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     If @[7] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     ProgramCall @[8] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
    };
   };
   Program @["TrainEnd"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @["save_final_wts"] { };
     ProgVar @["Train"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     If @[0] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program @["EpochStart"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @["trial_mon_data"] { };
     ProgVar @["BasicTrainTime"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MemberAssign @[0] { };
     MemberMethodCall @[1] { 
      ProgArg_List @.meth_args = [1] {
       ProgArg @[0] { };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
    };
   };
   Program @["EpochEnd"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["save_wts_interval"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MemberMethodCall @[1] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ProgramCall @[2] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     If @[3] { 
      ProgEl_List @.true_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
    };
   };
   Program @["TrialStart"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [0] {
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [4] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MemberAssign @[3] { };
    };
   };
   Program @["TrialEnd"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["update_net_view"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [2] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
    };
   };
   Program @["SettleMinus"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["update_net_view"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @["qtr"] { };
      };
     };
     ForLoop @[1] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     NetUpdateView @[2] { };
    };
   };
   Program @["SettlePlus"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["update_net_view"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [0] {
      };
     };
     ProgramCall @[1] { 
      ProgArg_List @.prog_args = [1] {
       ProgArg @[0] { };
      };
     };
     NetUpdateView @[2] { };
    };
   };
   Program @["Trial"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["update_net_view"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [7] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [1] {
       ProgVar @["qtr"] { };
      };
     };
     If @[1] { 
      ProgEl_List @.true_code = [1] {
       MethodCall @[0] { 
	ProgArg_List @.meth_args = [0] {
	};
       };
      };
     };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     Comment @[3] { };
     ForLoop @[4] { 
      ProgEl_List @.loop_code = [1] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[6] { };
    };
   };
   Program @["Quarter"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [2] {
     ProgVar @["cycle"] { };
     ProgVar @["update_net_view"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [1] {
     NetCounterInit @[0] { };
    };

    ProgEl_List @.prog_code = [7] {
     LocalVars @[0] { 
      ProgVar_List @.local_vars = [2] {
       ProgVar @["cycle_max"] { };
       ProgVar @["cyc"] { };
      };
     };
     Comment @[1] { };
     MethodCall @[2] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     MethodCall @[3] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     ForLoop @[4] { 
      ProgEl_List @.loop_code = [2] {
       ProgramCall @[0] { 
	ProgArg_List @.prog_args = [1] {
	 ProgArg @[0] { };
	};
       };
       AssignExpr @[1] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[6] { };
    };
   };
   Program @["Cycle"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [1] {
     ProgVar @["update_net_view"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [3] {
     MethodCall @[0] { 
      ProgArg_List @.meth_args = [0] {
      };
     };
     NetUpdateView @[1] { };
     MemberAssign @[2] { };
    };
   };
   Program @["SaveWeights"] { 
    ProgObjList @.objs = [0] {
    };

    ProgType_List @.types = [0] {
    };

    ProgVar_List @.args = [1] {
     ProgVar @["network"] { };
    };

    ProgVar_List @.vars = [6] {
     ProgVar @["tag"] { };
     ProgVar @["wts_subdir"] { };
     ProgVar @["fname"] { };
     ProgVar @["epoch_str"] { };
     ProgVar @["batch_str"] { };
     ProgVar @["final_tag"] { };
    };

    Function_List @.functions = [0] {
    };

    ProgEl_List @.init_code = [0] {
    };

    ProgEl_List @.prog_code = [6] {
     IfReturn @[0] { };
     MiscCall @[1] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     MiscCall @[2] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
     AssignExpr @[3] { };
     MethodCall @[4] { 
      ProgArg_List @.meth_args = [4] {
       ProgArg @[0] { };
       ProgArg @[1] { };
       ProgArg @[2] { };
       ProgArg @[3] { };
      };
     };
     MethodCall @[5] { 
      ProgArg_List @.meth_args = [2] {
       ProgArg @[0] { };
       ProgArg @[1] { };
      };
     };
    };
   };
   Program_Group @.gp["Monitors"] = [3] { 
    Program @["SaveLogFiles"] { 
     ProgObjList @.objs = [0] {
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @["network"] { };
     };

     ProgVar_List @.vars = [6] {
      ProgVar @["tag"] { };
      ProgVar @["log_trials"] { };
      ProgVar @["log_dir"] { };
      ProgVar @["log_file_nm"] { };
      ProgVar @["epoch_output_data"] { };
      ProgVar @["trial_output_data"] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [0] {
     };

     ProgEl_List @.prog_code = [6] {
      LocalVars @[0] { 
       ProgVar_List @.local_vars = [0] {
       };
      };
      IfReturn @[1] { };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      PrintVar @[4] { };
      If @[5] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [4] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	  ProgArg @[3] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	PrintVar @[2] { };
       };
      };
     };
    };
    Program @["LeabraTrialMonitor"] { 
     ProgObjList @.objs = [1] {
      NetMonitor @["trial_netmon"] { 
       NetMonItem_List @.items = [25] {
	NetMonItem @["batch"] { };
	NetMonItem @["epoch"] { };
	NetMonItem @["train_mode"] { };
	NetMonItem @["group"] { };
	NetMonItem @["trial"] { };
	NetMonItem @["tick"] { };
	NetMonItem @["time"] { };
	NetMonItem @["trial_name"] { };
	NetMonItem @["group_name"] { };
	NetMonItem @["output_name"] { };
	NetMonItem @["rt_cycles"] { };
	NetMonItem @["sse"] { };
	NetMonItem @["norm_err"] { };
	NetMonItem @["cos_err"] { };
	NetMonItem @["ext_rew"] { };
	NetMonItem @["lay_sse"] { };
	NetMonItem @["lay_norm_err"] { };
	NetMonItem @["lay_cos_err"] { };
	NetMonItem @["lay_net_sd"] { };
	NetMonItem @["net_cos_diff"] { };
	NetMonItem @["net_trial_cos_diff"] { };
	NetMonItem @["net_avg_act_diff"] { };
	NetMonItem @["cos_diff"] { };
	NetMonItem @["trial_cos_diff"] { };
	NetMonItem @["avg_act_diff"] { };
       };
      };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @["network"] { };
     };

     ProgVar_List @.vars = [3] {
      ProgVar @["trial_mon_data"] { };
      ProgVar @["trial_netmon"] { };
      ProgVar @["run_already"] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      AssignExpr @[3] { };
     };

     ProgEl_List @.prog_code = [5] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	AssignExpr @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    Program @["LeabraEpochMonitor"] { 
     ProgObjList @.objs = [1] {
      NetMonitor @["epoch_netmon"] { 
       NetMonItem_List @.items = [30] {
	NetMonItem @["batch"] { };
	NetMonItem @["epoch"] { };
	NetMonItem @["avg_sse"] { };
	NetMonItem @["cnt_err"] { };
	NetMonItem @["pct_cor"] { };
	NetMonItem @["pct_err"] { };
	NetMonItem @["avg_norm_err"] { };
	NetMonItem @["avg_cos_err"] { };
	NetMonItem @["avg_ext_rew"] { };
	NetMonItem @["avg_cycles"] { };
	NetMonItem @["epoch_time_tot"] { };
	NetMonItem @["epoch_time_usr"] { };
	NetMonItem @["lay_avg_sse"] { };
	NetMonItem @["lay_cnt_err"] { };
	NetMonItem @["lay_pct_cor"] { };
	NetMonItem @["lay_pct_err"] { };
	NetMonItem @["lay_avg_norm_err"] { };
	NetMonItem @["lay_avg_cos_err"] { };
	NetMonItem @["net_avg_cos_diff"] { };
	NetMonItem @["net_avg_trial_cos_diff"] { };
	NetMonItem @["net_avg_avg_act_diff"] { };
	NetMonItem @["avg_cos_diff"] { };
	NetMonItem @["avg_trial_cos_diff"] { };
	NetMonItem @["avg_avg_act_diff"] { };
	NetMonItem @["avg_net_sd"] { };
	NetMonItem @["hog_pct"] { };
	NetMonItem @["dead_pct"] { };
	NetMonItem @["netmax"] { };
	NetMonItem @["avg_act"] { };
	NetMonItem @["netrel"] { };
       };
      };
     };

     ProgType_List @.types = [0] {
     };

     ProgVar_List @.args = [1] {
      ProgVar @["network"] { };
     };

     ProgVar_List @.vars = [4] {
      ProgVar @["epoch_mon_data"] { };
      ProgVar @["epoch_netmon"] { };
      ProgVar @["epoch_timer"] { };
      ProgVar @["run_already"] { };
     };

     Function_List @.functions = [0] {
     };

     ProgEl_List @.init_code = [5] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      AssignExpr @[4] { };
     };

     ProgEl_List @.prog_code = [8] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	AssignExpr @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      AssignExpr @[3] { };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[5] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[6] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      Comment @[7] { };
     };
    };
   };
  };
 };

 taViewer_List @.viewers = [1] {
  MainWindowViewer @["Browser3"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["view_win_lft"] { };
    UserDataItem @["view_win_top"] { };
    UserDataItem @["view_win_wd"] { };
    UserDataItem @["view_win_ht"] { };
    UserDataItem @["view_win_iconified"] { };
    UserDataItem @["view_splitter_state"] { };
   };

   ToolBar_List @.toolbars = [1] {
    ToolBar @["Application"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_visible"] { };
     };
    };
   };

   FrameViewer_List @.frames = [3] {
    BrowseViewerTaBase @["Navigator"] { };
    PanelViewer @["Editor"] { };
    T3PanelViewer @["Visualizer"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_frame_selected"] { };
      UserDataItem @["view_panel_selected"] { };
     };

     T3Panel_List @.panels = [2] {
      T3Panel @["Network_0"] { 
       T3DataView_List @.root_view.children = [1] {
	NetView @["Network_0_View"] { 
	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 ScaleRange_List @.scale_ranges = [1] {
	  ScaleRange @[0] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @["Vw_0"] { };
	T3SavedView @["Vw_1"] { };
	T3SavedView @["Vw_2"] { };
	T3SavedView @["Vw_3"] { };
	T3SavedView @["Vw_4"] { };
	T3SavedView @["Vw_5"] { };
	T3SavedView @["Vw_6"] { };
	T3SavedView @["Vw_7"] { };
	T3SavedView @["Vw_8"] { };
	T3SavedView @["Vw_9"] { };
       };
      };
      T3Panel @["EpochOutputData"] { 
       T3DataView_List @.root_view.children = [1] {
	GraphTableView @["EpochOutputData_Graph"] { 
	 T3DataView_List @.children = [40] {
	  GraphColView @["batch"] { };
	  GraphColView @["epoch"] { };
	  GraphColView @["avg_sse"] { };
	  GraphColView @["cnt_err"] { };
	  GraphColView @["pct_cor"] { };
	  GraphColView @["pct_err"] { };
	  GraphColView @["avg_norm_err"] { };
	  GraphColView @["avg_cos_err"] { };
	  GraphColView @["avg_ext_rew"] { };
	  GraphColView @["avg_cycles"] { };
	  GraphColView @["epoch_time_tot"] { };
	  GraphColView @["epoch_time_usr"] { };
	  GraphColView @["Output_lay_avg_sse"] { };
	  GraphColView @["Output_lay_cnt_err"] { };
	  GraphColView @["Output_lay_pct_cor"] { };
	  GraphColView @["Output_lay_pct_err"] { };
	  GraphColView @["Output_lay_avg_norm_err"] { };
	  GraphColView @["Output_lay_avg_cos_err"] { };
	  GraphColView @["net_avg_cos_diff"] { };
	  GraphColView @["net_avg_trial_cos_diff"] { };
	  GraphColView @["net_avg_avg_act_diff"] { };
	  GraphColView @["Hidden_avg_cos_diff"] { };
	  GraphColView @["Output_avg_cos_diff"] { };
	  GraphColView @["Hidden_avg_trial_cos_diff"] { };
	  GraphColView @["Output_avg_trial_cos_diff"] { };
	  GraphColView @["Hidden_avg_avg_act_diff"] { };
	  GraphColView @["Output_avg_avg_act_diff"] { };
	  GraphColView @["Hidden_avg_net_sd"] { };
	  GraphColView @["Output_avg_net_sd"] { };
	  GraphColView @["Hidden_hog_pct"] { };
	  GraphColView @["Output_hog_pct"] { };
	  GraphColView @["Hidden_dead_pct"] { };
	  GraphColView @["Output_dead_pct"] { };
	  GraphColView @["Hidden_netmax"] { };
	  GraphColView @["Output_netmax"] { };
	  GraphColView @["Hidden_avg_act"] { };
	  GraphColView @["Output_avg_act"] { };
	  GraphColView @["Hidden_Fm_Input_netrel"] { };
	  GraphColView @["Hidden_Fm_Output_netrel"] { };
	  GraphColView @["Output_Fm_Hidden_netrel"] { };
	 };

	 T3Annotation_List @.annotations = [0] {
	 };

	 T3DataView_List @.annote_children = [0] {
	 };

	 GraphPlotView_List @.plots = [16] {
	  GraphPlotView @["EpochOutputData_Graph_plot_1"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_2"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_3"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_4"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_5"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_6"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_7"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_8"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_9"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_10"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_11"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_12"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_13"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_14"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_15"] { };
	  GraphPlotView @["EpochOutputData_Graph_plot_16"] { };
	 };

	 GraphPlotView_List @.errbars = [16] {
	  GraphPlotView @["EpochOutputData_Graph_err_1"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_2"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_3"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_4"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_5"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_6"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_7"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_8"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_9"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_10"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_11"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_12"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_13"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_14"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_15"] { };
	  GraphPlotView @["EpochOutputData_Graph_err_16"] { };
	 };
	};
       };

       T3SavedView_List @.saved_views = [10] {
	T3SavedView @["Vw_0"] { };
	T3SavedView @["Vw_1"] { };
	T3SavedView @["Vw_2"] { };
	T3SavedView @["Vw_3"] { };
	T3SavedView @["Vw_4"] { };
	T3SavedView @["Vw_5"] { };
	T3SavedView @["Vw_6"] { };
	T3SavedView @["Vw_7"] { };
	T3SavedView @["Vw_8"] { };
	T3SavedView @["Vw_9"] { };
       };
      };
     };
    };
   };

   DockViewer_List @.docks = [1] {
    ToolBoxDockViewer @["Tools"] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @["view_win_lft"] { };
      UserDataItem @["view_win_top"] { };
      UserDataItem @["view_win_wd"] { };
      UserDataItem @["view_win_ht"] { };
      UserDataItem @["view_win_iconified"] { };
      UserDataItem @["view_visible"] { };
     };
    };
   };
  };
 };

 Network_Group @.networks = [1] {
  LeabraNetwork @["Network_0"] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @["cos_err"] { };
    UserDataItem @["norm_err"] { };
    UserDataItem @["ext_rew"] { };
    UserDataItem @["minus_output_name"] { };
    UserDataItem @["rt_cycles"] { };
    UserDataItem @["tot_cycle"] { };
    UserDataItem @["phase"] { };
    UserDataItem @["quarter"] { };
    UserDataItem @["sse"] { };
    UserDataItem @["output_name"] { };
    UserDataItem @["trial_name"] { };
    UserDataItem @["group_name"] { };
    UserDataItem @["total_trials"] { };
    UserDataItem @["time"] { };
    UserDataItem @["cycle"] { };
    UserDataItem @["tick"] { };
    UserDataItem @["trial"] { };
    UserDataItem @["group"] { };
    UserDataItem @["epoch"] { };
    UserDataItem @["batch"] { };
    UserDataItem @["trial_cos_diff"] { };
    UserDataItem @["avg_act_diff"] { };
    UserDataItem @["cos_diff"] { };
    UserDataItem @["minus_cycles"] { };
    UserDataItem @["ct_cycle"] { };
    UserDataItem @["phase_no"] { };
    UserDataItem @["maxda"] { };
   };

   BaseSpec_Group @.specs = [4] {
    LeabraLayerSpec @["HiddenLayer"] { 
     BaseSpec_Group @.children = [1] {
      LeabraLayerSpec @["Input_Output"] { 
       BaseSpec_Group @.children = [0] {
       };
      };
     };
    };
    LeabraUnitSpec @["LeabraUnitSpec_0"] { 
     BaseSpec_Group @.children = [0] {
     };

     Schedule @.noise_sched = [0] {
     };
    };
    LeabraConSpec @["LeabraConSpec_0"] { 
     BaseSpec_Group @.children = [2] {
      LeabraBiasSpec @["LeabraBiasSpec_0"] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
      LeabraConSpec @["TopDownCons"] { 
       BaseSpec_Group @.children = [0] {
       };

       Schedule @.lrate_sched = [7] {
	SchedItem @[0] { };
	SchedItem @[1] { };
	SchedItem @[2] { };
	SchedItem @[3] { };
	SchedItem @[4] { };
	SchedItem @[5] { };
	SchedItem @[6] { };
       };
      };
     };

     Schedule @.lrate_sched = [7] {
      SchedItem @[0] { };
      SchedItem @[1] { };
      SchedItem @[2] { };
      SchedItem @[3] { };
      SchedItem @[4] { };
      SchedItem @[5] { };
      SchedItem @[6] { };
     };
    };
    FullPrjnSpec @["FullPrjnSpec_0"] { 
     BaseSpec_Group @.children = [0] {
     };
    };
   };

   Layer_Group @.layers = [3] {
    LeabraLayer @["Input"] { 
     Projection_Group @.projections = [0] {
     };

     Unit_Group @.units = [25] {
     };
    };
    LeabraLayer @["Hidden"] { 
     Projection_Group @.projections = [2] {
      LeabraPrjn @["Fm_Input"] { };
      LeabraPrjn @["Fm_Output"] { };
     };

     Unit_Group @.units = [25] {
     };
    };
    LeabraLayer @["Output"] { 
     Projection_Group @.projections = [1] {
      LeabraPrjn @["Fm_Hidden"] { };
     };

     Unit_Group @.units = [25] {
     };
    };
   };

   Weights_List @.weights = [0] {
   };

   NetTiming_List NULL = [3] {
    LeabraNetTiming @[0] { };
    LeabraNetTiming @[1] { };
    LeabraNetTiming @[2] { };
   };
  };
 };
};
LeabraProject .projects["LeabraFlex"] {
 name="LeabraFlex";
 desc="flexible modular framework for Leabra Programs";
 tags="Leabra, flex";
 version {
  major=0;
  minor=1;
  step=15;
 };
 author=;
 email=;
 license {
  owner="Regents of the University of Colorado";
  license=GPLv2;
  org="CCNLab at the University of Colorado Boulder";
  year="2010";
  custom=;
 };
 wiki_url {
  sync=0;
  wiki=;
  url=;
 };
 docs {
  name="docs";
  el_typ=taDoc;
  el_def=0;
  taDoc @["LeabraFlexProgs"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraFlexProgs";
   desc=;
   web_doc=1;
   wiki="emergent";
   url="LeabraFlexProgs";
   full_url="https://grey.colorado.edu/emergent/index.php/LeabraFlexProgs";
   text_size=1;
   text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
   html_text="<!DOCTYPE html><html lang=\"en\" dir=\"ltr\" class=\"client-js\"><head>
<meta charset=\"UTF-8\">
<title>LeabraFlex - emergent</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\\s)client-nojs(\\s|$)/, \"$1client-js$2\" );</script>
<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgCanonicalNamespace\":\"\",\"wgCanonicalSpecialPageName\":!1,\"wgNamespaceNumber\":0,\"wgPageName\":\"LeabraFlex\",\"wgTitle\":\"LeabraFlex\",\"wgCurRevisionId\":11194,\"wgRevisionId\":11194,\"wgArticleId\":2315,\"wgIsArticle\":!0,\"wgIsRedirect\":!1,\"wgAction\":\"view\",\"wgUserName\":null,\"wgUserGroups\":[\"*\"],\"wgCategories\":[],\"wgBreakFrames\":!1,\"wgPageContentLanguage\":\"en\",\"wgPageContentModel\":\"wikitext\",\"wgSeparatorTransformTable\":[\"\",\"\"],\"wgDigitTransformTable\":[\"\",\"\"],\"wgDefaultDateFormat\":\"dmy\",\"wgMonthNames\":[\"\",\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"],\"wgMonthNamesShort\":[\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"],\"wgRelevantPageName\":\"LeabraFlex\",\"wgRelevantArticleId\":2315,\"wgIsProbablyEditable\":!1,\"wgRestrictionEdit\":[],\"wgRestrictionMove\":[],\"wgRedirectedFrom\":\"LeabraFlexProgs\",\"sfgAutocompleteValues\":[],\"sfgAutocompleteOnAllChars\":!1,\"sfgFieldProperties\":[],
\"sfgDependentFields\":[],\"sfgShowOnSelect\":[],\"sfgScriptPath\":\"/emergent/extensions/SemanticForms\",\"htTabIndexes\":[],\"wgSVGEditEditor\":\"http://svg-edit.googlecode.com/svn/trunk/editor/svg-editor.html\",\"wgWikiEditorEnabledModules\":{\"toolbar\":!0,\"dialogs\":!0,\"preview\":!0,\"publish\":!1},\"wgCategoryTreePageCategoryOptions\":\"{\\\"mode\\\":0,\\\"hideprefix\\\":20,\\\"showcount\\\":true,\\\"namespaces\\\":false}\",\"wgInternalRedirectTargetUrl\":\"/emergent/index.php/LeabraFlex\"});mw.loader.implement(\"user.options\",function($,jQuery){mw.user.options.set({\"variant\":\"en\"});});mw.loader.implement(\"user.tokens\",function($,jQuery){mw.user.tokens.set({\"editToken\":\"+\\\\\",\"patrolToken\":\"+\\\\\",\"watchToken\":\"+\\\\\"});});mw.loader.load([\"mediawiki.action.view.redirect\",\"ext.smw.style\",\"ext.smw.tooltips\",\"mediawiki.page.startup\",\"mediawiki.legacy.wikibits\",\"skins.vector.js\"]);
} );</script>
<link rel=\"stylesheet\" href=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cmediawiki.sectionAnchor%7Cmediawiki.skinning.interface%7Cskins.vector.styles&amp;only=styles&amp;skin=vector\">
<link rel=\"stylesheet\" href=\"/emergent/extensions/HeaderTabs/skins-jquery/ext.headertabs.jquery-large.css\">
<meta name=\"ResourceLoaderDynamicStyles\" content=\"\">
<link rel=\"stylesheet\" href=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=vector\">
<style>a:lang(ar),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}</style>
<script async=\"\" src=\"/emergent/load.php?debug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=vector\"></script>
<meta name=\"generator\" content=\"MediaWiki 1.26.0\">
<link rel=\"ExportRDF\" type=\"application/rdf+xml\" title=\"LeabraFlex\" href=\"/emergent/index.php?title=Special:ExportRDF/LeabraFlex&amp;xmlmime=rdf\">
<link rel=\"shortcut icon\" href=\"/emergent/favicon.ico\">
<link rel=\"search\" type=\"application/opensearchdescription+xml\" href=\"/emergent/opensearch_desc.php\" title=\"emergent (en)\">
<link rel=\"EditURI\" type=\"application/rsd+xml\" href=\"https://grey.colorado.edu/emergent/api.php?action=rsd\">
<link rel=\"alternate\" type=\"application/atom+xml\" title=\"emergent Atom feed\" href=\"/emergent/index.php?title=Special:RecentChanges&amp;feed=atom\">
<link rel=\"canonical\" href=\"https://grey.colorado.edu/emergent/index.php/LeabraFlex\">
<!--[if lt IE 7]><style type=\"text/css\">body{behavior:url(\"/emergent/skins/Vector/csshover.min.htc\")}</style><![endif]-->
</head>
<body class=\"mediawiki ltr sitedir-ltr ns-0 ns-subject page-LeabraFlex skin-vector action-view\">
		<div id=\"mw-page-base\" class=\"noprint\"></div>
		<div id=\"mw-head-base\" class=\"noprint\"></div>
		<div id=\"content\" class=\"mw-body\" role=\"main\">
			<a id=\"top\"></a>

						<div class=\"mw-indicators\">
</div>
			<h1 id=\"firstHeading\" class=\"firstHeading\" lang=\"en\">LeabraFlex</h1>
									<div id=\"bodyContent\" class=\"mw-body-content\">
									<div id=\"siteSub\">From emergent</div>
								<div id=\"contentSub\"><span class=\"mw-redirectedfrom\">(Redirected from <a href=\"/emergent/index.php?title=LeabraFlexProgs&amp;redirect=no\" title=\"LeabraFlexProgs\">LeabraFlexProgs</a>)</span></div>
												<div id=\"jump-to-nav\" class=\"mw-jump\">
					Jump to:					<a href=\"#mw-head\">navigation</a>, 					<a href=\"#p-search\">search</a>
				</div>
				<div id=\"mw-content-text\" lang=\"en\" dir=\"ltr\" class=\"mw-content-ltr\"><p>Documentation for the <code>LeabraFlex</code> project template (also avail in <code>demo/leabra/leabra_flex_progs.proj</code>), which provides a different way of configuring the <a href=\"/emergent/index.php/Leabra\" title=\"Leabra\">Leabra</a> programs that is more flexible and modular -- very useful for more complex projects that require extensive novel functionality, including interactive behaviors between the network and the programs that generate inputs to the network, things that happen at different points in the settling process, and supporting multiple different ways of running the model in a more efficient, modular fashion.
</p>
<div id=\"toc\" class=\"toc\"><div id=\"toctitle\"><h2>Contents</h2></div>
<ul>
<li class=\"toclevel-1 tocsection-1\"><a href=\"#ConfigData.2FConfigTable\"><span class=\"tocnumber\">1</span> <span class=\"toctext\">ConfigData/ConfigTable</span></a></li>
<li class=\"toclevel-1 tocsection-2\"><a href=\"#Program_Hierarchy\"><span class=\"tocnumber\">2</span> <span class=\"toctext\">Program Hierarchy</span></a></li>
<li class=\"toclevel-1 tocsection-3\"><a href=\"#UtilProgs\"><span class=\"tocnumber\">3</span> <span class=\"toctext\">UtilProgs</span></a></li>
<li class=\"toclevel-1 tocsection-4\"><a href=\"#DMem_.28MPI.29\"><span class=\"tocnumber\">4</span> <span class=\"toctext\">DMem (MPI)</span></a></li>
</ul>
</div>

<h1><span class=\"mw-headline\" id=\"ConfigData.2FConfigTable\">ConfigData/ConfigTable</span></h1>
<p>The <a href=\"/emergent/index.php/DataTable\" title=\"DataTable\">DataTable</a> in ConfigData/ConfigTable is key for the flex progs -- each row specifies a different configuration, which can call different Init, Run, and even Startup programs, to achieve very different behavior or configurations all within the same project.  This makes it very easy to add new functionality into the system without adding spaghetti or complex conditionals in existing programs -- just add a new config and a new program at the right level, to achieve new functionality.
</p>
<h1><span class=\"mw-headline\" id=\"Program_Hierarchy\">Program Hierarchy</span></h1>
<p>The call sequence is:
</p>
<ul><li> <b>MasterTrain</b></li></ul>
<dl><dd><ul><li> <b>InitProgs[init_prog]</b> (as spec'd in ConfigTable)</li>
<li> loop over <b>MasterRun</b> until stop_train is set to true</li></ul>
<dl><dd><ul><li> <b>RunProgs[run_prog]</b> (as spec'd in ConfigTable)</li></ul>
<dl><dd><ul><li> typically calls one or more <b>TaskProgs</b>, increments counters and does appropriate Epoch and higher-level housekeeping as necessary.</li></ul></dd></dl></dd></dl></dd></dl>
<p>MasterRun now has a <b>stop_step_grain</b> parameter that allows you to Step this program at different grain sizes (e.g., after an Epoch) and for different conditions -- this is completely extensible if you look at the underlying code, and very powerful.
</p>
<h1><span class=\"mw-headline\" id=\"UtilProgs\">UtilProgs</span></h1>
<p>The UtilProgs contain all the basic functionality for training a network and monitoring, etc -- the task programs should consist of calls to these util programs in the desired order to achieve whatever form of processing is required.  The built-in BasicTrain program just does the equivalent of a standard LeabraTrial.
</p>
<h1><span class=\"mw-headline\" id=\"DMem_.28MPI.29\">DMem (MPI)</span></h1>
<p>The most efficient way to use multiple distributed memory (dmem) processors (via MPI) is to split different events across processors.  The standard Leabra programs do this by interleaving trials according to dmem processor (e.g., for 10 processors, proc 0 gets trials 0, 10, 20, ..; proc 1 gets 1, 11, 21, etc..).  For these flex progs, which can have interactive behavior and ill-defined sequences of events, this strategy is not always possible (the <b>ChoosePermutedEvent</b> program in EnviroProgs does implement this behavior however).  Here are some tips:
</p>
<ul><li> After version 8.0, you can add taMisc::dmem_proc to all calls to <a href=\"/emergent/index.php/Random\" title=\"Random\">Random</a> or various Permute etc functions that use random numbers and take a <b>thr_no</b> (thread number) argument -- as documented in <a href=\"/emergent/index.php/MTRnd\" title=\"MTRnd\">MTRnd</a>, this thr_no arg selects different random number sequences that are initialized from a single common seed, and will produce statistically independent sequences.  Thus, you can ensure that each node gets different random inputs and other parameters, as appropriate, without needing to have an entirely different seed for each node.  This also means that results can be fully replicable when starting from the same random seed, and that nodes can also generate the same random numbers as needed (if this is needed, it is a good idea to pass taMisc::dmem_proc + 1 to the Random calls, and reserve 0 for the common shared thread that should only be called identically from all processors -- otherwise it will diverge from the 0'th node relative to the others.</li></ul>
<ul><li> After common weight initialization etc, the <b>TrainStart</b> program has the option to generate a new random seed just before starting the Epoch -- see the <b>dmem_new_seed</b> flag -- each processor at this point will be operating with their own random seed, so any dynamic event generation code that uses random numbers (hint: it should!) will result in different things on different nodes.  However, as a result of this, <b>every run of the simulation will be different</b>, even if using common initial starting seeds.   See first note to alternative that avoids these consequences.</li></ul>
<ul><li> It is <b>essential</b> that the different nodes still end up calling <b>Compute_Weights</b> the same number of times, after roughly the same amount of overall computation -- this is where the weight changes are synchronized across processors -- the simulation will lock up and hang if these do not align.</li></ul>
<ul><li> The <b>epoch_trials</b> value gets divided by dmem_nprocs in StdGlobalsInit, such that each processor runs this reduced number of trials, <i>with the network-&gt;trial counter going from 0 to this lower epoch_trials value</i> -- it does not do the interleaving that is done in the hierarchical programs.  This also means that trial numbers will be duplicated if you merge separate trial log data tables into a single table, which is not necessarily a problem, but you may need to do things a bit differently in analyzing the data.</li></ul>
<ul><li> If you are using a traditional list of events in an input_data table, use ChoosePermutedEvent and it will work properly with dmem, just like the standard programs.  This program maintains its own internal counter, and simply iterates in a permuted order through the events and then repeats -- it does not need to be synchronized with the trial and epoch structure of the programs (to achieve this, simply ensure that the epoch_trials is the same as the number of rows in the input data table).</li></ul>

<!-- 
NewPP limit report
Cached time: 20160121225440
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.017 seconds
Real time usage: 0.020 seconds
Preprocessor visited node count: 15/1000000
Preprocessor generated node count: 20/1000000
Post?expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
-->

<!-- 
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 - -total
-->

<!-- Saved in parser cache with key pdpwiki:pcache:idhash:2315-0!*!0!!en!*!* and timestamp 20160121225440 and revision id 11194
 -->
</div>					<div class=\"printfooter\">
						Retrieved from \"<a dir=\"ltr\" href=\"https://grey.colorado.edu/emergent/index.php?title=LeabraFlex&amp;oldid=11194\">https://grey.colorado.edu/emergent/index.php?title=LeabraFlex&amp;oldid=11194</a>\"					</div>
				<div id=\"catlinks\" class=\"catlinks catlinks-allhidden\"></div>				<div class=\"visualClear\"></div>
							</div>
		</div>
		<div id=\"mw-navigation\">
			<h2>Navigation menu</h2>

			<div id=\"mw-head\">
									<div id=\"p-personal\" role=\"navigation\" class=\"\" aria-labelledby=\"p-personal-label\">
						<h3 id=\"p-personal-label\">Personal tools</h3>
						<ul>
							<li id=\"pt-createaccount\"><a href=\"/emergent/index.php?title=Special:UserLogin&amp;returnto=LeabraFlex&amp;type=signup\" title=\"You are encouraged to create an account and log in; however, it is not mandatory\">Create account</a></li><li id=\"pt-login\"><a href=\"/emergent/index.php?title=Special:UserLogin&amp;returnto=LeabraFlex\" title=\"You are encouraged to log in; however, it is not mandatory [o]\" accesskey=\"o\">Log in</a></li>						</ul>
					</div>
									<div id=\"left-navigation\">
										<div id=\"p-namespaces\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-namespaces-label\">
						<h3 id=\"p-namespaces-label\">Namespaces</h3>
						<ul>
															<li id=\"ca-nstab-main\" class=\"selected\"><span><a href=\"/emergent/index.php/LeabraFlex\" title=\"View the content page [c]\" accesskey=\"c\">Page</a></span></li>
															<li id=\"ca-talk\" class=\"new\"><span><a href=\"/emergent/index.php?title=Talk:LeabraFlex&amp;action=edit&amp;redlink=1\" title=\"Discussion about the content page [t]\" accesskey=\"t\" rel=\"discussion\">Discussion</a></span></li>
													</ul>
					</div>
										<div id=\"p-variants\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-variants-label\">
												<h3 id=\"p-variants-label\">
							<span>Variants</span><a href=\"#\"></a>
						</h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id=\"right-navigation\">
										<div id=\"p-views\" role=\"navigation\" class=\"vectorTabs\" aria-labelledby=\"p-views-label\">
						<h3 id=\"p-views-label\">Views</h3>
						<ul>
															<li id=\"ca-view\" class=\"selected\"><span><a href=\"/emergent/index.php/LeabraFlex\">Read</a></span></li>
															<li id=\"ca-viewsource\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=edit\" title=\"This page is protected.
You can view its source [e]\" accesskey=\"e\">View source</a></span></li>
															<li id=\"ca-history\" class=\"collapsible\"><span><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=history\" title=\"Past revisions of this page [h]\" accesskey=\"h\">View history</a></span></li>
													</ul>
					</div>
										<div id=\"p-cactions\" role=\"navigation\" class=\"vectorMenu emptyPortlet\" aria-labelledby=\"p-cactions-label\">
						<h3 id=\"p-cactions-label\"><span>More</span><a href=\"#\"></a></h3>

						<div class=\"menu\">
							<ul>
															</ul>
						</div>
					</div>
										<div id=\"p-search\" role=\"search\">
						<h3>
							<label for=\"searchInput\">Search</label>
						</h3>

						<form action=\"/emergent/index.php\" id=\"searchform\">
							<div id=\"simpleSearch\">
							<input type=\"search\" name=\"search\" placeholder=\"Search\" title=\"Search emergent [f]\" accesskey=\"f\" id=\"searchInput\"><input type=\"hidden\" value=\"Special:Search\" name=\"title\"><input type=\"submit\" name=\"fulltext\" value=\"Search\" title=\"Search the pages for this text\" id=\"mw-searchButton\" class=\"searchButton mw-fallbackSearchButton\"><input type=\"submit\" name=\"go\" value=\"Go\" title=\"Go to a page with this exact name if it exists\" id=\"searchButton\" class=\"searchButton\">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id=\"mw-panel\">
				<div id=\"p-logo\" role=\"banner\"><a class=\"mw-wiki-logo\" href=\"/emergent/index.php/Main_Page\" title=\"Visit the main page\"></a></div>
						<div class=\"portal\" role=\"navigation\" id=\"p-navigation\" aria-labelledby=\"p-navigation-label\">
			<h3 id=\"p-navigation-label\">Navigation</h3>

			<div class=\"body\">
									<ul>
						<li id=\"n-mainpage-description\"><a href=\"/emergent/index.php/Main_Page\" title=\"Visit the main page [z]\" accesskey=\"z\">Main page</a></li><li id=\"n-recentchanges\"><a href=\"/emergent/index.php/Special:RecentChanges\" title=\"A list of recent changes in the wiki [r]\" accesskey=\"r\">Recent changes</a></li><li id=\"n-Documentation\"><a href=\"/emergent/index.php/User_hub\">Documentation</a></li><li id=\"n-Submit-a-bug\"><a href=\"/emergent/index.php/How_to_submit_a_bug_report\">Submit a bug</a></li><li id=\"n-Bug-tracker\"><a href=\"//grey.colorado.edu/cgi-bin/bugzilla/index.cgi\" rel=\"nofollow\">Bug tracker</a></li><li id=\"n-Mailing-list\"><a href=\"//grey.colorado.edu/cgi-bin/mailman/listinfo/emergent-users\" rel=\"nofollow\">Mailing list</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-tb\" aria-labelledby=\"p-tb-label\">
			<h3 id=\"p-tb-label\">Tools</h3>

			<div class=\"body\">
									<ul>
						<li id=\"t-whatlinkshere\"><a href=\"/emergent/index.php/Special:WhatLinksHere/LeabraFlex\" title=\"A list of all wiki pages that link here [j]\" accesskey=\"j\">What links here</a></li><li id=\"t-recentchangeslinked\"><a href=\"/emergent/index.php/Special:RecentChangesLinked/LeabraFlex\" title=\"Recent changes in pages linked from this page [k]\" accesskey=\"k\">Related changes</a></li><li id=\"t-specialpages\"><a href=\"/emergent/index.php/Special:SpecialPages\" title=\"A list of all special pages [q]\" accesskey=\"q\">Special pages</a></li><li id=\"t-permalink\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;oldid=11194\" title=\"Permanent link to this revision of the page\">Permanent link</a></li><li id=\"t-info\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;action=info\" title=\"More information about this page\">Page information</a></li><li id=\"t-smwbrowselink\"><a href=\"/emergent/index.php/Special:Browse/LeabraFlex\" rel=\"smw-browse\">Browse properties</a></li>					</ul>
							</div>
		</div>
			<div class=\"portal\" role=\"navigation\" id=\"p-coll-print_export\" aria-labelledby=\"p-coll-print_export-label\">
			<h3 id=\"p-coll-print_export-label\">Print/export</h3>

			<div class=\"body\">
									<ul>
						<li id=\"coll-create_a_book\"><a href=\"/emergent/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=LeabraFlex\">Create a book</a></li><li id=\"coll-download-as-rl\"><a href=\"/emergent/index.php?title=Special:Book&amp;bookcmd=render_article&amp;arttitle=LeabraFlex&amp;oldid=11194&amp;writer=rl\">Download as PDF</a></li><li id=\"t-print\"><a href=\"/emergent/index.php?title=LeabraFlex&amp;printable=yes\" title=\"Printable version of this page [p]\" accesskey=\"p\">Printable version</a></li>					</ul>
							</div>
		</div>
				</div>
		</div>
		<div id=\"footer\" role=\"contentinfo\">
							<ul id=\"footer-info\">
											<li id=\"footer-info-lastmod\"> This page was last modified on 4 September 2015, at 01:19.</li>
									</ul>
							<ul id=\"footer-places\">
											<li id=\"footer-places-about\"><a href=\"/emergent/index.php/emergent:About\" title=\"emergent:About\">About emergent</a></li>
									</ul>
										<ul id=\"footer-icons\" class=\"noprint\">
											<li id=\"footer-poweredbyico\">
							<a href=\"//www.mediawiki.org/\"><img src=\"/emergent/resources/assets/poweredby_mediawiki_88x31.png\" alt=\"Powered by MediaWiki\" srcset=\"/emergent/resources/assets/poweredby_mediawiki_132x47.png 1.5x, /emergent/resources/assets/poweredby_mediawiki_176x62.png 2x\" width=\"88\" height=\"31\"></a><a href=\"https://www.semantic-mediawiki.org/wiki/Semantic_MediaWiki\"><img src=\"/emergent/extensions/SemanticMediaWiki/resources/images/smw_button.png\" alt=\"Powered by Semantic MediaWiki\" width=\"88\" height=\"31\"></a>						</li>
									</ul>
						<div style=\"clear:both\"></div>
		</div>
		<script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.loader.state({\"user\":\"ready\",\"user.groups\":\"ready\"});mw.loader.load([\"mediawiki.toc\",\"mediawiki.action.view.postEdit\",\"site\",\"mediawiki.user\",\"mediawiki.hidpi\",\"mediawiki.page.ready\",\"mediawiki.searchSuggest\",\"ext.headertabs\"]);
} );</script><script>window.RLQ = window.RLQ || []; window.RLQ.push( function () {
mw.config.set({\"wgBackendResponseTime\":188});
} );</script>
	

</body></html>";
  };
 };
 wizards {
  name="wizards";
  el_typ=LeabraWizard;
  el_def=0;
  LeabraWizard @["LeabraWizard_1"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["NO_CLIP"] {
     name="NO_CLIP";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="LeabraWizard_1";
  };
 };
 ctrl_panels {
  name="ctrl_panels";
  el_typ=ControlPanel;
  el_def=0;
  ControlPanel @["ControlPanel"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="ControlPanel";
   running_updt=0;
   desc="main control panel for the system";
   mbrs {
    name="mbrs";
    el_typ=EditMbrItem;
    el_def=0;
    EditMbrItem @[0] {
     label="cur_config";
     desc="configuration to run -- selects from configs in the Config data table";
     cust_desc=1;
     base=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["cur_config"].dyn_enum_val$$;
     mbr=DynEnum::value;
     is_numeric=0;
     is_single=1;
     param_search {
      record=0;
      search=0;
      range="0:1:0.1";
     };
     param_set_value {
      saved_value=;
     };
     notes {
      notes=;
     };
    };
    EditMbrItem @[1] {
     label="mstr_run_stop_step_grain";
     desc="what grain to stop / step for the MasterRun program (MstrRun) -- can expand this by editing MasterRun program";
     cust_desc=1;
     base=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterRun"].vars["stop_step_grain"].dyn_enum_val$$;
     mbr=DynEnum::value;
     is_numeric=0;
     is_single=1;
     param_search {
      record=0;
      search=0;
      range="0:1:0.1";
     };
     param_set_value {
      saved_value=;
     };
     notes {
      notes=;
     };
    };
    EditMbrItem @[2] {
     label="cycle_update_net_view";
     desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
     cust_desc=1;
     base=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"].vars["update_net_view"]$$;
     mbr=ProgVar::bool_val;
     is_numeric=0;
     is_single=1;
     param_search {
      record=0;
      search=0;
      range="0:1:0.1";
     };
     param_set_value {
      saved_value=;
     };
     notes {
      notes=;
     };
    };
    EditMbrItem @[3] {
     label="cycle_qtr";
     desc="[Default: true]  one CycleRun runs for a full quarter number of actual cycles -- this greatly speeds up processing by reducing threading overhead, but prevents e.g., interactive viewing at the individual cycle level -- this is not saved -- have to re-engage it when needed, to prevent unintentionally slowing everything down";
     cust_desc=0;
     base=.projects["LeabraFlex"].networks["Network_0"].times$$;
     mbr=LeabraTimes::cycle_qtr;
     is_numeric=0;
     is_single=1;
     param_search {
      record=0;
      search=0;
      range="0:1:0.1";
     };
     param_set_value {
      saved_value=;
     };
     notes {
      notes=;
     };
    };
    EditMbrItem @[4] {
     label="leabra_con_spec_0_lrate";
     desc="[Default: 0.04]  learning rate -- how fast the weights change per experience -- since version 7.8.5, a hidden factor of 2 has been removed, so this should be 2x what you used to use previously (e.g., default used to be .02, now is .04) -- this governs the rate of change for the fastest adapting weights -- see slow_wts for a more slowly adapting factor";
     cust_desc=0;
     base=.projects["LeabraFlex"].networks["Network_0"].specs["LeabraConSpec_0"]$$;
     mbr=LeabraConSpec::lrate;
     is_numeric=1;
     is_single=1;
     param_search {
      record=0;
      search=0;
      range="0:1:0.1";
     };
     param_set_value {
      saved_value=;
     };
     notes {
      notes=;
     };
    };
   };
   mths {
    name="mths";
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
    EditMthItem @[0] {
     label="Init";
     desc=" run init_code, global variables retain current values unless reset in the init_code";
     cust_desc=0;
     base=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$$;
     mth=Program::Init;
    };
    EditMthItem @[1] {
     label="Run";
     desc=" run the program -- if not yet Init, will run Init first";
     cust_desc=0;
     base=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
     mth=Program::Run_Gui;
    };
    EditMthItem @[2] {
     label="Step";
     desc=" step the program at the level of the given program -- if NULL then step_prog default value will be used";
     cust_desc=0;
     base=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
     mth=Program::Step_Gui;
    };
    EditMthItem @[3] {
     label="Stop";
     desc=" stop the current program at its next natural stopping point (i.e., cleanly stopping when appropriate chunks of computation have completed)";
     cust_desc=0;
     base=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
     mth=Program::Stop;
    };
   };
  };
  ClusterRun @["ClusterRun"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["user_pinned"] {
     name="user_pinned";
     value 1 0=1;
     val_type_fixed=0;
    };
   };
   name="ClusterRun";
   running_updt=0;
   desc=;
   mbrs {
    name="mbrs";
    el_typ=EditMbrItem;
    el_def=0;
   };
   mths {
    name="mths";
    el_typ=EditMthItem;
    el_def=0;
    group_type=GT_BUTTONS;
   };
   jobs_running {
    name="jobs_running";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="if doing parallel batch mode, and cluster has by_node policy, then this is the number of nodes to allocate to the overall job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_done {
    name="jobs_done";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="if doing parallel batch mode, and cluster has by_node policy, then this is the number of nodes to allocate to the overall job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   jobs_archive {
    name="jobs_archive";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="name of cluster to run job on";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="unique tag id for this job -- all files etc are named according to this tag";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status"] {
      name="status";
      desc="status of job: REQUESTED, CANCELLED, SUBMITTED, QUEUED, RUNNING, DONE, KILLED";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["notes"] {
      name="notes";
      desc="notes for the job -- describe any specific information about the model configuration etc -- can use this for searching and sorting results";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["label"] {
      name="label";
      desc="label for the job -- a brief description that you can use to label this job's results on your graph";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["filename"] {
      name="filename";
      desc="name of the specific project used for this job -- because multiple versions of a model are often run under the same project name";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["params"] {
      name="params";
      desc="emergent parameters based on currently selected items in the ClusterRun";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["status_info"] {
      name="status_info";
      desc="more detailed information about status";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_time"] {
      name="submit_time";
      desc="when was the job submitted (tracks time from emergent client submission)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="when did the job actually start running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["end_time"] {
      name="end_time";
      desc="when did the job finish running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["running_time"] {
      name="running_time";
      desc="total running time in days/hours/minutes";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number on cluster -- assigned once the job is submitted to the cluster";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out"] {
      name="job_out";
      desc="job output information -- contains (top of) the job standard output and standard error output as the job is running (truncated to top 2048 characters if longer than that) -- full information available in job_out_file";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_out_file"] {
      name="job_out_file";
      desc="job output file -- file name containing full job output information -- file name should be tag.out";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["dat_files"] {
      name="dat_files";
      desc="list of data table output (results) files generated by model (space separated) -- these files have the tag in their name, and end in .dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["other_files"] {
      name="other_files";
      desc="list of other output (results) files generated by model (space separated) -- these files have the tag in their name but do not end in .dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["command_id"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="command_id";
      desc="id for this command, assigned by the search algorithm in an algorithm-specific manner (optional)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["command"] {
      name="command";
      desc="emergent command line, up to point of parameters";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["repo_url"] {
      name="repo_url";
      desc="name of repository to run job on";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["queue"] {
      name="queue";
      desc="if specified, indicate a particular queue on the computing resource";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["run_time"] {
      name="run_time";
      desc="how long will the jobs take to run -- syntax is number followed by unit indicator -- m=minutes, h=hours, d=days -- e.g., 30m, 12h, or 2d -- typically the job will be killed if it exceeds this amount of time, so be sure to not underestimate";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["ram_gb"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="ram_gb";
      desc="how many gigabytes of ram is required?  0 means do not specify this parameter for the job submission -- for large memory jobs, it can be important to specify this to ensure proper allocation of resources";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["n_threads"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="n_threads";
      desc="number of parallel threads to use for running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_nodes";
      desc="number of nodes to use for mpi run -- 0 or -1 means not to use mpi";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["mpi_per_node"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="mpi_per_node";
      desc="number of processes to use per MPI node to use for mpi run - total nodes is mpi_nodes * mpi_per_node";
      col_flags=SAVE_ROWS|SAVE_DATA|READ_ONLY;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_batches"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_batches";
      desc="if > 0, use parallel batch mode with this number of batches";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["pb_nodes"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="pb_nodes";
      desc="if doing parallel batch mode, and cluster has by_node policy, then this is the number of nodes to allocate to the overall job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_svn"] {
      name="submit_svn";
      desc="svn revision for the original job submission";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["submit_job"] {
      name="submit_job";
      desc="index of job number within a given submission -- equal to the row number of the original set of jobs submitted in submit_svn jobs";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   file_list {
    name="file_list";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["cluster"] {
      name="cluster";
      desc="cluster where this job was submitted / run";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user who ran this job";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_name"] {
      name="file_name";
      desc="name of file -- does not include any path information";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["tag"] {
      name="tag";
      desc="job tag associated with this file";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["size"] {
      name="size";
      desc="size of file -- with typical suffixes (K = kilobytes, M = megabytes, G = gigabytes)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["kind"] {
      name="kind";
      desc="type of file";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_modified"] {
      name="date_modified";
      desc="timestamp for when the file was last modified";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["date_created"] {
      name="date_created";
      desc="timestamp for when the file was first created";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["svn_file_path"] {
      name="svn_file_path";
      desc="path to file in SVN repository, relative to root of svn_repo repository";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["proj_file_path"] {
      name="proj_file_path";
      desc="path to file relative to the parent project directory -- e.g., results/filename.dat";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["file_path"] {
      name="file_path";
      desc="full path to file on local file system, including all parent directories and name of file -- takes you directly to the file";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   cluster_info {
    name="cluster_info";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["queue"] {
      name="queue";
      desc="queue that this info relates to";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["job_no"] {
      name="job_no";
      desc="job number or total number of actve jobs";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["user"] {
      name="user";
      desc="user name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["state"] {
      name="state";
      desc="current scheduler state -- or description of global state info";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["procs"] {
      name="procs";
      desc="number of processors for this job or for global state info";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["start_time"] {
      name="start_time";
      desc="timestamp for when the job was submitted or started running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   search_algos {
    name="search_algos";
    el_typ=ParamSearchAlgo;
    el_def=0;
   };
   use_search_algo=0;
   cur_search_algo=NULL;
   set_proj_name=0;
   proj_name=;
   auto_updt_interval=10;
   auto_updt_timeout=30;
   clusters=;
   users=;
   last_submit_time=;
   notes=;
   label=;
   extra_files=;
   svn_repo=;
   repo_url=;
   cluster=;
   queue=;
   run_time=;
   exe_cmd="emergent";
   ram_gb=-1;
   n_threads=2;
   use_mpi=0;
   mpi_nodes=10;
   mpi_per_node=1;
   parallel_batch=0;
   pb_batches=10;
   pb_n_batches_per=1;
   nowin_x=0;
   enable_kill=0;
   enable_load=0;
   enable_notes=1;
  };
 };
 param_sets {
  name="param_sets";
  el_typ=ParamSet;
  el_def=0;
 };
 data {
  name="data";
  el_typ=DataTable;
  el_def=0;
  save_tables=1;
  DataTable_Group @.gp["InputData"] {
   name="InputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @["StdInputData"] {
    name="StdInputData";
    desc="basic input data table";
    data {
     name="data";
     el_typ=float_Data;
     el_def=0;
     String_Data @["Name"] {
      name="Name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{       };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
      ar {
       name="ar";
      [6] "checks";"mitvert";"midhoriz";"rdiag";"ldiag";"random";      };
     };
     float_Data @["Output"] {
      name="Output";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=0;
      ar {
       name="ar";
      [5 5 6] 1;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;1;0;0;1;
1;0;0;0;0;0;0;0;0;0;
      };
     };
     float_Data @["Input"] {
      name="Input";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=1;
      cell_geom{ 5;5;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [2] ;;      };
      width=0;
      ar {
       name="ar";
      [5 5 6] 1;0;0;0;1;0;0;0;0;0;
0;0;1;0;0;0;0;0;0;0;
1;0;0;0;1;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;1;0;0;0;0;1;0;0;
0;0;0;0;0;0;0;0;0;0;
1;1;1;1;1;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;1;
0;0;0;1;0;0;0;1;0;0;
0;1;0;0;0;1;0;0;0;0;
1;0;0;0;0;0;1;0;0;0;
0;0;1;0;0;0;0;0;1;0;
0;0;0;0;1;1;0;0;0;0;
0;0;0;1;0;0;1;0;0;0;
1;0;0;0;1;0;0;0;0;0;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [6] 0;1;2;3;4;5;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
  DataTable_Group @.gp["OutputData"] {
   name="OutputData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @["TrialOutputData"] {
    name="TrialOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @["batch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_109";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["epoch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_110";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["train_mode"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_100";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="train_mode";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["group"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_70";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="group";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["trial"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_111";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="trial";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["tick"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_112";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="tick";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["time"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_101";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="time";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["trial_name"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_102";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="trial_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["group_name"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_103";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="group_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     String_Data @["output_name"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_104";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="output_name";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["rt_cycles"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_105";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="rt_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["sse"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_106";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["norm_err"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_107";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="norm_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["cos_err"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_108";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="cos_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["ext_rew"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_109";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_sse"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_110";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_lay_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_norm_err"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_111";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_lay_norm_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_cos_err"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_112";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_lay_cos_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_lay_net_sd"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_113";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Hidden_lay_net_sd";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_net_sd"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_114";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_lay_net_sd";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["net_cos_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_115";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="net_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["net_trial_cos_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_116";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="net_trial_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["net_avg_act_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_117";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="net_avg_act_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_cos_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_118";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Hidden_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_cos_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_119";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_trial_cos_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_120";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Hidden_trial_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_trial_cos_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_121";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_trial_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_avg_act_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_122";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Hidden_avg_act_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_avg_act_diff"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_123";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 8 0=0.1328021;
	val_type_fixed=0;
       };
      };
      name="Output_avg_act_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   DataTable @["EpochOutputData"] {
    name="EpochOutputData";
    desc=;
    data {
     name="data";
     el_typ=int_Data;
     el_def=0;
     int_Data @["batch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_111";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="batch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     int_Data @["epoch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_112";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["avg_sse"] {
      name="avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["cnt_err"] {
      name="cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["pct_cor"] {
      name="pct_cor";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["pct_err"] {
      name="pct_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["avg_norm_err"] {
      name="avg_norm_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["avg_cos_err"] {
      name="avg_cos_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["avg_ext_rew"] {
      name="avg_ext_rew";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["avg_cycles"] {
      name="avg_cycles";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["epoch_time_tot"] {
      name="epoch_time_tot";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["epoch_time_usr"] {
      name="epoch_time_usr";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_avg_sse"] {
      name="Output_lay_avg_sse";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_cnt_err"] {
      name="Output_lay_cnt_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_pct_cor"] {
      name="Output_lay_pct_cor";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_pct_err"] {
      name="Output_lay_pct_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_avg_norm_err"] {
      name="Output_lay_avg_norm_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_lay_avg_cos_err"] {
      name="Output_lay_avg_cos_err";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["net_avg_cos_diff"] {
      name="net_avg_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["net_avg_trial_cos_diff"] {
      name="net_avg_trial_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["net_avg_avg_act_diff"] {
      name="net_avg_avg_act_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_avg_cos_diff"] {
      name="Hidden_avg_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_avg_cos_diff"] {
      name="Output_avg_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_avg_trial_cos_diff"] {
      name="Hidden_avg_trial_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_avg_trial_cos_diff"] {
      name="Output_avg_trial_cos_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_avg_avg_act_diff"] {
      name="Hidden_avg_avg_act_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_avg_avg_act_diff"] {
      name="Output_avg_avg_act_diff";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_avg_net_sd"] {
      name="Hidden_avg_net_sd";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_avg_net_sd"] {
      name="Output_avg_net_sd";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_hog_pct"] {
      name="Hidden_hog_pct";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_hog_pct"] {
      name="Output_hog_pct";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_dead_pct"] {
      name="Hidden_dead_pct";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_dead_pct"] {
      name="Output_dead_pct";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_netmax"] {
      name="Hidden_netmax";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_netmax"] {
      name="Output_netmax";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_avg_act"] {
      name="Hidden_avg_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_avg_act"] {
      name="Output_avg_act";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_Fm_Input_netrel"] {
      name="Hidden_Fm_Input_netrel";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Hidden_Fm_Output_netrel"] {
      name="Hidden_Fm_Output_netrel";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
     float_Data @["Output_Fm_Hidden_netrel"] {
      name="Output_Fm_Hidden_netrel";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=0;
     };
    };
    data_flags=AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [0]     };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
  DataTable_Group @.gp["AnalysisData"] {
   name="AnalysisData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
  };
  DataTable_Group @.gp["ConfigData"] {
   name="ConfigData";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @["ConfigTable"] {
    name="ConfigTable";
    desc="different configurations of the system";
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @["config_id"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_61";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="config_id";
      desc="identifier for this type of configuration";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] "basic_train";      };
     };
     String_Data @["config_desc"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_62";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="config_desc";
      desc="description of this configuration";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] "default basic training";      };
     };
     String_Data @["init_prog"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_63";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="init_prog";
      desc="program to run to initialize at start of training";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] "BasicInit";      };
     };
     String_Data @["run_prog"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_64";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="run_prog";
      desc="program controlling each step of running";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] "BasicRun";      };
     };
     String_Data @["startup_prog"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_65";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="startup_prog";
      desc="program for handling startup args specific to this environment";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] "BasicStartup";      };
     };
     int_Data @["train_epochs"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_66";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="train_epochs";
      desc="number of total epochs to train for";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 50;      };
     };
     int_Data @["trials_per_epoch"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_67";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="trials_per_epoch";
      desc="number of individual trials per epoch";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 50;      };
     };
     int_Data @["save_final_wts"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_68";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="save_final_wts";
      desc="save final weights after training (1 = yes, 0 = no)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 1;      };
     };
     int_Data @["save_wts_interval"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_69";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="save_wts_interval";
      desc="how frequently to save weights during training (in epochs)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 200;      };
     };
     int_Data @["test_interval"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_70";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="test_interval";
      desc="how frequently to test performance without training -- only applicable to training cases";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 1000;      };
     };
     int_Data @["log_trials"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_71";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="log_trials";
      desc="whether to log trial-level data or not (1 = yes, 0 = no)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 0;      };
     };
     int_Data @["load_weights"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_72";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1791590452194214;
	val_type_fixed=0;
       };
      };
      name="load_weights";
      desc="whether to load weights at start";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=98;
      ar {
       name="ar";
      [1] 0;      };
     };
     String_Data @["weights_file"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.2650822699069977;
	val_type_fixed=0;
       };
      };
      name="weights_file";
      desc="full relative path (from project) to a weights file to load at start of training";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=145;
      ar {
       name="ar";
      [1] ;      };
     };
     int_Data @["load_st_epc"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1151736751198769;
	val_type_fixed=0;
       };
      };
      name="load_st_epc";
      desc="if loading weights, what epoch does it start at?";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=63;
      ar {
       name="ar";
      [1] 1;      };
     };
     int_Data @["lrs_step_epochs"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItemBase;
       el_def=0;
       UserDataItem @["NARROW"] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @["view_panel_wd"] {
	name="view_panel_wd";
	value 6 0=0.1517367511987686;
	val_type_fixed=0;
       };
      };
      name="lrs_step_epochs";
      desc="how many epochs per given step in the lrate schedule: each step drops the lrate roughly in half (log scale)";
      col_flags=SAVE_ROWS|SAVE_DATA;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=83;
      ar {
       name="ar";
      [1] 50;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [1] 0;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
 };
 programs {
  name="programs";
  el_typ=Program;
  el_def=0;
  tags=;
  desc=;
  debug_mode=0;
  Program @["MasterStartup"] {
   name="MasterStartup";
   short_nm="Startup";
   tags="Leabra, Startup";
   desc="run project in the background (replaces leabra_startup.css)

command line is: emergent -nowin -ni -p <project name>.proj [enviro=xxx] [tag=xxx]";
   flags=STARTUP_RUN;
   stop_step_cond {
    expr=;
   };
   objs {
    name="objs";
    el_typ=taNBase;
    el_def=0;
   };
   types {
    name="types";
    el_typ=DynEnumType;
    el_def=0;
   };
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["network"] {
     name="network";
     var_type=T_Object;
     object_type=LeabraNetwork;
     object_val=.projects["LeabraFlex"].networks["Network_0"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
     reference=0;
     desc="network to operate on -- updates batch counter on network and passes it to train program";
     init_from=NULL;
    };
   };
   vars {
    name="vars";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @["batch_prog"] {
     name="batch_prog";
     var_type=T_Object;
     object_type=Program;
     object_val=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="set this to point to your batch process";
     init_from=NULL;
    };
    ProgVar @["tag"] {
     name="tag";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["config_id"] {
     name="config_id";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="selector for config to use";
     init_from=NULL;
    };
    ProgVar @["param_set"] {
     name="param_set";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of saved parameter set to apply at startup";
     init_from=NULL;
    };
    ProgVar @["log_dir"] {
     name="log_dir";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="log file directory";
     init_from=NULL;
    };
    ProgVar @["log_file_nm"] {
     name="log_file_nm";
     var_type=T_String;
     string_val=;
     objs_ptr=0;
     flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="name of log file";
     init_from=NULL;
    };
    ProgVar @["EpochOutputData"] {
     name="EpochOutputData";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["Config"] {
     name="Config";
     var_type=T_Object;
     object_type=DataTable;
     object_val=.projects["LeabraFlex"].data.gp["ConfigData"]["ConfigTable"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["batch_str"] {
     name="batch_str";
     var_type=T_String;
     string_val="00";
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch number as a string (leading zeros)";
     init_from=NULL;
    };
    ProgVar @["batch_start"] {
     name="batch_start";
     var_type=T_Int;
     int_val=0;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc="batch starting number";
     init_from=NULL;
    };
    ProgVar @["startup_prog"] {
     name="startup_prog";
     var_type=T_String;
     string_val="BasicStartup";
     objs_ptr=0;
     flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["MyClusterRun"] {
     name="MyClusterRun";
     var_type=T_Object;
     object_type=ClusterRun;
     object_val=.projects["LeabraFlex"].ctrl_panels["ClusterRun"]$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @["param_sets"] {
     name="param_sets";
     var_type=T_Object;
     object_type=ParamSet_Group;
     object_val=.projects["LeabraFlex"].param_sets$$;
     objs_ptr=0;
     flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   functions {
    name="functions";
    el_typ=Function;
    el_def=0;
    Function @["set_n_units"] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="set_n_units(Layer* lay, int n_units) returns: bool";
     pre_compile_code_string="set_n_units(Layer* lay, int n_units) returns: bool";
     name="set_n_units";
     return_type=T_Bool;
     object_type=taOBase;
     args {
      name=;
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["lay"] {
       name="lay";
       var_type=T_Object;
       object_type=Layer;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["n_units"] {
       name="n_units";
       var_type=T_Int;
       int_val=0;
       objs_ptr=0;
       flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     fun_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (lay->un_geom.n == n_units || n_units <= 0)";
       pre_compile_code_string="if (lay->un_geom.n == n_units || n_units <= 0)";
       cond {
	expr="lay->un_geom.n == n_units || n_units <= 0";
       };
       true_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	ReturnExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="return false";
	 pre_compile_code_string="return false";
	 expr {
	  expr="false";
	 };
	};
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="lay->SetNUnits(n_units)";
       pre_compile_code_string="lay->SetNUnits(n_units)";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs["MasterStartup"].functions["set_n_units"].args["lay"]$$;
       method=Layer::SetNUnits;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="n_units";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="n_units";
	 };
	};
       };
       meth_sig="void SetNUnits(int n_units)";
       meth_desc=" set number of units in layer in the un_geom member -- attempts to lay out geometry in closest to a square that fits all the units evenly, if possible. note: does NOT rebuild the network. also does not make any changes if current number of units is same as arg, or arg <= 0 (e.g., for startup arg, just init n_units to -1 prior to getting arg val so it won't have any effect if arg not passed)";
      };
      PrintExpr @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"layer: \" << lay->name << \" changed to: \" << n_units << \" units, actually: \" << lay->un_geom.n";
       pre_compile_code_string="Print \"layer: \" << lay->name << \" changed to: \" << n_units << \" units, actually: \" << lay->un_geom.n";
       expr {
	expr="\"layer: \" << lay->name << \" changed to: \" << n_units << \" units, actually: \" << lay->un_geom.n";
       };
       debug=0;
      };
      ReturnExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return true";
       pre_compile_code_string="return true";
       expr {
	expr="true";
       };
      };
     };
    };
   };
   init_code {
    name="init_code";
    el_typ=ProgCode;
    el_def=0;
   };
   prog_code {
    name="prog_code";
    el_typ=ProgCode;
    el_def=0;
    RegisterArgs @[0] {
     desc="This is KEY!!! actually processes all args, including those from ProgVarFmArg guys below";
     flags=CAN_REVERT_TO_CODE;
     code_string="Register Args";
     pre_compile_code_string="Register Args";
    };
    PrintExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Loaded project: \" << .projects[0].file_name";
     pre_compile_code_string="Print \"Loaded project: \" << .projects[0].file_name";
     expr {
      expr="\"Loaded project: \" << .projects[0].file_name";
     };
     debug=0;
    };
    Comment @[2] {
     desc="= Std variables in startup program itself =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Std variables in startup program itself =";
     pre_compile_code_string="// = Std variables in startup program itself =";
    };
    ProgVarFmArg @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:tag in Program:MasterStartup from Arg:tag";
     pre_compile_code_string="Set Var:tag in Program:MasterStartup from Arg:tag";
     prog=.projects["LeabraFlex"].programs["MasterStartup"]$$;
     var_name="tag";
     arg_name="tag";
    };
    ProgVarFmArg @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:log_dir in Program:MasterStartup from Arg:log_dir";
     pre_compile_code_string="Set Var:log_dir in Program:MasterStartup from Arg:log_dir";
     prog=$.projects["LeabraFlex"].programs["MasterStartup"]$;
     var_name="log_dir";
     arg_name="log_dir";
    };
    ProgVarFmArg @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:param_set in Program:MasterStartup from Arg:param_set";
     pre_compile_code_string="Set Var:param_set in Program:MasterStartup from Arg:param_set";
     prog=$.projects["LeabraFlex"].programs["MasterStartup"]$;
     var_name="param_set";
     arg_name="param_set";
    };
    ProgVarFmArg @[6] {
     desc="starting batch -- replaces b_start";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="Set Var:batch_start in Program:MasterBatch from Arg:batch_start";
     pre_compile_code_string="Set Var:batch_start in Program:MasterBatch from Arg:batch_start";
     prog=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"]$;
     var_name="batch_start";
     arg_name="batch_start";
    };
    ProgVarFmArg @[7] {
     desc="number of batches to run";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="Set Var:n_batches in Program:MasterBatch from Arg:n_batches";
     pre_compile_code_string="Set Var:n_batches in Program:MasterBatch from Arg:n_batches";
     prog=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"]$;
     var_name="n_batches";
     arg_name="n_batches";
    };
    Comment @[8] {
     desc="add our special args from command line";
     flags=CAN_REVERT_TO_CODE;
     code_string="// add our special args from command line";
     pre_compile_code_string="// add our special args from command line";
    };
    ProgVarFmArg @[9] {
     desc="NOTE: set in MasterTrain and copy from there, so it can use that default!";
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:cur_config in Program:MasterTrain from Arg:config";
     pre_compile_code_string="Set Var:cur_config in Program:MasterTrain from Arg:config";
     prog=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
     var_name="cur_config";
     arg_name="config";
    };
    ProgVarFmArg @[10] {
     desc="NOTE: set in MasterTrain and copy from there, so it can use that default!";
     flags=CAN_REVERT_TO_CODE;
     code_string="Set Var:config_id in Program:MasterTrain from Arg:config";
     pre_compile_code_string="Set Var:config_id in Program:MasterTrain from Arg:config";
     prog=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
     var_name="config_id";
     arg_name="config";
    };
    OtherProgramVar @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Vars Fm:  program=MasterTrain set=from  var_1=config_id  var_2=?  var_3=?  var_4=? ";
     pre_compile_code_string="Vars Fm:  program=MasterTrain set=from  var_1=config_id  var_2=?  var_3=?  var_4=? ";
     other_prog=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
     set_other=0;
     var_1=.projects["LeabraFlex"].programs["MasterStartup"].vars["config_id"]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    MethodCall @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Config->SetCellsFromConfig(\"config_id\", config_id)";
     pre_compile_code_string="Config->SetCellsFromConfig(\"config_id\", config_id)";
     result_var=NULL;
     obj=.projects["LeabraFlex"].programs["MasterStartup"].vars["Config"]$$;
     method=DataTable::SetCellsFromConfig;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="taString";
       name="column_name";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"config_id\"";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="taString";
       name="value";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="config_id";
       };
      };
     };
     meth_sig="void SetCellsFromConfig(taString column_name, taString value)";
     meth_desc=" set the values of table cells in the row with value matching the 'value' arg of column matching 'column_name' arg";
    };
    ControlPanelsFmArgs @[13] {
     desc="sets any arg listed in the control panel";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="CtrlPanel Fm Args: var = MyClusterRun ";
     pre_compile_code_string="CtrlPanel Fm Args: var = MyClusterRun ";
     ctrl_panel_var=.projects["LeabraFlex"].programs["MasterStartup"].vars["MyClusterRun"]$$;
    };
    If @[14] {
     desc="set variables to values stored in a param set";
     flags=CAN_REVERT_TO_CODE;
     code_string="if (param_set.nonempty())";
     pre_compile_code_string="if (param_set.nonempty())";
     cond {
      expr="param_set.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="param_sets->LoadParamSet(param_set)";
       pre_compile_code_string="param_sets->LoadParamSet(param_set)";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs["MasterStartup"].vars["param_sets"]$$;
       method=ParamSet_Group::LoadParamSet;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="set_name";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="param_set";
	 };
	};
       };
       meth_sig="bool LoadParamSet(taString& set_name)";
       meth_desc=;
      };
     };
    };
    Comment @[15] {
     desc="TODO: Add your program comment here (multi-lines ok).";
     flags=CAN_REVERT_TO_CODE;
     code_string="// TODO: Add your program comment here (multi-lines ok).";
     pre_compile_code_string="// TODO: Add your program comment here (multi-lines ok).";
    };
    Comment @[16] {
     desc="= Add args to tag name =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Add args to tag name =";
     pre_compile_code_string="// = Add args to tag name =";
    };
    If @[17] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (config_id.empty())";
     pre_compile_code_string="if (config_id.empty())";
     cond {
      expr="config_id.empty()";
     };
     true_code {
      name=;
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Error(\"lesson_id is empty -- must specify!  bailing\", , , , , , , , )";
       pre_compile_code_string="taMisc::Error(\"lesson_id is empty -- must specify!  bailing\", , , , , , , , )";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"lesson_id is empty -- must specify!  bailing\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="b";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[2] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="c";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[3] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="d";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[4] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="e";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="f";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="g";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="h";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_char_ptr;
	 type="char*";
	 name="i";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    AssignExpr @[18] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="tag = \"_\" +  config_id + tag";
     pre_compile_code_string="tag = \"_\" +  config_id + tag";
     result_var=.projects["LeabraFlex"].programs["MasterStartup"].vars["tag"]$$;
     expr {
      expr="\"_\" +  config_id + tag";
     };
    };
    Comment @[19] {
     desc="set any params from Config";
     flags=CAN_REVERT_TO_CODE;
     code_string="// set any params from Config";
     pre_compile_code_string="// set any params from Config";
    };
    DataColsFmArgs @[20] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Data Cols Fm Args:  table=Config  row_spec=row_val  row_var=config_id ";
     pre_compile_code_string="Data Cols Fm Args:  table=Config  row_spec=row_val  row_var=config_id ";
     data_var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["Config"]$;
     row_spec=ROW_VAL;
     row_var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["config_id"]$;
    };
    Comment @[21] {
     desc="Set log files";
     flags=CAN_REVERT_TO_CODE;
     code_string="// Set log files";
     pre_compile_code_string="// Set log files";
    };
    If @[22] {
     desc="set tag for starting batch (new code in v 8.0)";
     flags=NEW_EL|CAN_REVERT_TO_CODE;
     code_string="if (taMisc::CheckArgByName(\"batch_start\"))";
     pre_compile_code_string="if (taMisc::CheckArgByName(\"batch_start\"))";
     cond {
      expr="taMisc::CheckArgByName(\"batch_start\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ProgVarFmArg @[0] {
       desc="read in the arg to us too, so we can set file names based on it";
       flags=CAN_REVERT_TO_CODE;
       code_string="Set Var:batch_start in Program:MasterStartup from Arg:batch_start";
       pre_compile_code_string="Set Var:batch_start in Program:MasterStartup from Arg:batch_start";
       prog=$.projects["LeabraFlex"].programs["MasterStartup"]$;
       var_name="batch_start";
       arg_name="batch_start";
      };
      MiscCall @[1] {
       desc="string version with leading zeros";
       flags=CAN_REVERT_TO_CODE;
       code_string="batch_str = taMisc::LeadingZeros(batch_start, 2)";
       pre_compile_code_string="batch_str = taMisc::LeadingZeros(batch_start, 2)";
       result_var=.projects["LeabraFlex"].programs["MasterStartup"].vars["batch_str"]$$;
       object_type=taMisc;
       method=taMisc::LeadingZeros;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="num";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="batch_start";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="len";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="2";
	 };
	};
       };
      };
      VarIncr @[2] {
       desc="add to tag for setting log file names";
       flags=CAN_REVERT_TO_CODE;
       code_string="tag += \".\" + batch_str";
       pre_compile_code_string="tag += \".\" + batch_str";
       var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["tag"]$;
       expr {
	expr="\".\" + batch_str";
       };
      };
      If @[3] {
       desc="save startup args: only for first job in parallel batch mode, or this should be 0 otherwise in any case";
       flags=CAN_REVERT_TO_CODE;
       code_string="if (batch_start == 0)";
       pre_compile_code_string="if (batch_start == 0)";
       cond {
	expr="batch_start == 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc="save args to file: last arg is to include dmem proc number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag.before(\".00\",-1), log_dir, false)";
	 pre_compile_code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag.before(\".00\",-1), log_dir, false)";
	 result_var=.projects["LeabraFlex"].programs["MasterStartup"].vars["log_file_nm"]$$;
	 obj=.projects["LeabraFlex"].programs["MasterStartup"].vars["EpochOutputData"]$$;
	 method=taBase::GetFileNameFmProject;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ext";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\".args\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="tag";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="tag.before(\".00\",-1)";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="subdir";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_dir";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_no";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	 };
	 meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
	 meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
	};
	MiscCall @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="taMisc::FullArgStringToFile(log_file_nm)";
	 pre_compile_code_string="taMisc::FullArgStringToFile(log_file_nm)";
	 result_var=NULL;
	 object_type=taMisc;
	 method=taMisc::FullArgStringToFile;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="fname";
	   required=1;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_file_nm";
	   };
	  };
	 };
	};
       };
      };
     };
    };
    Else @[23] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc="save args to file: last arg is to include dmem proc number";
       flags=CAN_REVERT_TO_CODE;
       code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag, log_dir, false)";
       pre_compile_code_string="log_file_nm = EpochOutputData->GetFileNameFmProject(\".args\", tag, log_dir, false)";
       result_var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["log_file_nm"]$;
       obj=$.projects["LeabraFlex"].programs["MasterStartup"].vars["EpochOutputData"]$;
       method=taBase::GetFileNameFmProject;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ext";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\".args\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="tag";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="tag";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="subdir";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_dir";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_no";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
       meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
      };
      MiscCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::FullArgStringToFile(log_file_nm)";
       pre_compile_code_string="taMisc::FullArgStringToFile(log_file_nm)";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::FullArgStringToFile;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
       };
      };
     };
    };
    OtherProgramVar @[24] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Vars To:  program=SaveWeights set=to  var_1=tag  var_2=?  var_3=?  var_4=? ";
     pre_compile_code_string="Vars To:  program=SaveWeights set=to  var_1=tag  var_2=?  var_3=?  var_4=? ";
     other_prog=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"]$$;
     set_other=1;
     var_1=$.projects["LeabraFlex"].programs["MasterStartup"].vars["tag"]$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    Comment @[25] {
     desc="= Call sub-startup programs =";
     flags=CAN_REVERT_TO_CODE;
     code_string="// = Call sub-startup programs =";
     pre_compile_code_string="// = Call sub-startup programs =";
    };
    DataVarProg @[26] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=startup_prog  var_2=?  var_3=?  var_4=? ";
     pre_compile_code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=startup_prog  var_2=?  var_3=?  var_4=? ";
     data_var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["Config"]$;
     row_spec=ROW_VAL;
     row_var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["config_id"]$;
     set_data=0;
     all_matches=0;
     quiet=0;
     var_1=.projects["LeabraFlex"].programs["MasterStartup"].vars["startup_prog"]$$;
     var_2=NULL;
     var_3=NULL;
     var_4=NULL;
    };
    ProgramCallVar @[27] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Call Fm: prog_group=StartupProgs prog_name_var=startup_prog (network)";
     pre_compile_code_string="Call Fm: prog_group=StartupProgs prog_name_var=startup_prog (network)";
     prog_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     prog_group=.projects["LeabraFlex"].programs.gp["StartupProgs"]$$;
     prog_name_var=$.projects["LeabraFlex"].programs["MasterStartup"].vars["startup_prog"]$;
    };
    PrintExpr @[28] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print \"Running: \" << batch_prog.name";
     pre_compile_code_string="Print \"Running: \" << batch_prog.name";
     expr {
      expr="\"Running: \" << batch_prog.name";
     };
     debug=0;
    };
    ProgramCall @[29] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="MasterBatch(network)";
     pre_compile_code_string="MasterBatch(network)";
     prog_args {
      name=;
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=LeabraNetwork;
       type="LeabraNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     target=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"]$;
     targ_ld_init="*MasterBatch*";
    };
   };
   step_prog=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$$;
   step_n=1;
  };
  Program_Group @.gp["StartupProgs"] {
   name="StartupProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @["BasicStartup"] {
    name="BasicStartup";
    short_nm="BsStrt";
    tags="Leabra, Startup";
    desc="startup args specifically for fixation training parameters";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["tag"] {
      name="tag";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL;
      reference=0;
      desc=;
      init_from=$.projects["LeabraFlex"].programs["MasterStartup"]$;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      desc="this can be used for misc startup functions for non-interactive (cluster) jobs";
      flags=CAN_REVERT_TO_CODE;
      code_string="// this can be used for misc startup functions for non-interactive (cluster) jobs";
      pre_compile_code_string="// this can be used for misc startup functions for non-interactive (cluster) jobs";
     };
     Comment @[1] {
      desc="note that saving log files should happen in SaveLogFiles program, after network is configured";
      flags=CAN_REVERT_TO_CODE;
      code_string="// note that saving log files should happen in SaveLogFiles program, after network is configured";
      pre_compile_code_string="// note that saving log files should happen in SaveLogFiles program, after network is configured";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp["ConfigProgs"] {
   name="ConfigProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @["MasterBatch"] {
    name="MasterBatch";
    short_nm="MstBtc";
    tags="Leabra, Std";
    desc="Iterate over training runs (a batch of training runs) -- just a simple loop that calls training program";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["batch"] {
      name="batch";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch counter";
      init_from=NULL;
     };
     ProgVar @["batch_start"] {
      name="batch_start";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch number to start on";
      init_from=NULL;
     };
     ProgVar @["n_batches"] {
      name="n_batches";
      var_type=T_Int;
      int_val=10;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="number of batches to run";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initializes local batch counter and batch field on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: batch";
      pre_compile_code_string="Net Counter Init: batch";
      network_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"].args["network"]$$;
      local_ctr_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"].vars["batch"]$$;
      counter=Network::batch;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      pre_compile_code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @["i"] {
	name="i";
	var_type=T_Int;
	int_val=0;
	objs_ptr=0;
	flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     AssignExpr @[1] {
      desc="start at the start";
      flags=CAN_REVERT_TO_CODE;
      code_string="batch = batch_start";
      pre_compile_code_string="batch = batch_start";
      result_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"].vars["batch"]$;
      expr {
       expr="batch_start";
      };
     };
     MemberAssign @[2] {
      desc="update network";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.batch = batch";
      pre_compile_code_string="network.batch = batch";
      obj=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"].args["network"]$;
      path="batch";
      expr {
       expr="batch";
      };
      update_after=0;
     };
     ForLoop @[3] {
      desc="main loop over training runs";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i=0; i<n_batches; i++)";
      pre_compile_code_string="for (i=0; i<n_batches; i++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the training program -- sets the network and input_data args";
	flags=CAN_REVERT_TO_CODE;
	code_string="MasterTrain(network)";
	pre_compile_code_string="MasterTrain(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
	targ_ld_init="*MasterTrain*";
       };
       NetCounterIncr @[1] {
	desc="increment the local batch counter and copy to network";
	flags=CAN_REVERT_TO_CODE;
	code_string="Net Counter Incr: batch";
	pre_compile_code_string="Net Counter Incr: batch";
	network_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"].args["network"]$;
	local_ctr_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterBatch"].vars["batch"]$;
	counter=Network::batch;
	update_after=0;
       };
      };
      init {
       expr="i=0";
      };
      test {
       expr="i<n_batches";
      };
      iter {
       expr="i++";
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["MasterTrain"] {
    name="MasterTrain";
    short_nm="MstTrn";
    tags=;
    desc="modular event-based train program";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumTableCol @["ConfigOptions"] {
      name="ConfigOptions";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @["basic_train"] {
	name="basic_train";
	value=0;
	desc=;
       };
      };
      bits=0;
      src_table=$.projects["LeabraFlex"].data.gp["ConfigData"]["ConfigTable"]$;
      src_column="config_id";
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["Config"] {
      name="Config";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["ConfigData"]["ConfigTable"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["cur_config"] {
      name="cur_config";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].types["ConfigOptions"]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["config_id"] {
      name="config_id";
      var_type=T_String;
      string_val="basic_train";
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="configuration to use -- auto set from cur_config -- lookup in Config table";
      init_from=NULL;
     };
     ProgVar @["run_prog"] {
      name="run_prog";
      var_type=T_String;
      string_val="BasicRun";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of run program from the Config table";
      init_from=NULL;
     };
     ProgVar @["init_prog"] {
      name="init_prog";
      var_type=T_String;
      string_val="BasicInit";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="name of init program from the Config table";
      init_from=NULL;
     };
     ProgVar @["stop_train"] {
      name="stop_train";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="set this var from any other program to stop training";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="stop_train = false";
      pre_compile_code_string="stop_train = false";
      result_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["stop_train"]$$;
      expr {
       expr="false";
      };
     };
     AssignExpr @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="config_id = cur_config";
      pre_compile_code_string="config_id = cur_config";
      result_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["config_id"]$$;
      expr {
       expr="cur_config";
      };
     };
     WtInitPrompt @[2] {
      desc="don't initialize weights without checking";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (gui && \"Do you want to Initialize Network Weights\")";
      pre_compile_code_string="if (gui && \"Do you want to Initialize Network Weights\")";
      prompt="Do you want to Initialize Network Weights";
      yes_label="Yes";
      no_label="No";
      yes_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="need to have built network by now in any case, so do it here to make double sure -- prevents errs when loading project with startup program";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	pre_compile_code_string="network->Build()";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].args["network"]$$;
	method=Network::Build;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
       MethodCall @[1] {
	desc="initialize network weights: could also load pre-set weights or something else here";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Init_Weights()";
	pre_compile_code_string="network->Init_Weights()";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].args["network"]$;
	method=Network::Init_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Init_Weights()";
	meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
       };
       PrintExpr @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print network.name << \" Weights Initialized\"";
	pre_compile_code_string="Print network.name << \" Weights Initialized\"";
	expr {
	 expr="network.name << \" Weights Initialized\"";
	};
	debug=0;
       };
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     AssignExpr @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="stop_train = false";
      pre_compile_code_string="stop_train = false";
      result_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["stop_train"]$;
      expr {
       expr="false";
      };
     };
     AssignExpr @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="config_id = cur_config";
      pre_compile_code_string="config_id = cur_config";
      result_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["config_id"]$;
      expr {
       expr="cur_config";
      };
     };
     DataVarProg @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=init_prog  var_2=run_prog  var_3=?  var_4=? ";
      pre_compile_code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=false  var_1=init_prog  var_2=run_prog  var_3=?  var_4=? ";
      data_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["Config"]$$;
      row_spec=ROW_VAL;
      row_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["config_id"]$;
      set_data=0;
      all_matches=0;
      quiet=0;
      var_1=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["init_prog"]$$;
      var_2=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["run_prog"]$$;
      var_3=NULL;
      var_4=NULL;
     };
     ProgramCallVar @[3] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Call Fm: prog_group=InitProgs prog_name_var=init_prog (network, config_id)";
      pre_compile_code_string="Call Fm: prog_group=InitProgs prog_name_var=init_prog (network, config_id)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="config_id";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="config_id";
	};
       };
      };
      prog_group=.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["InitProgs"]$$;
      prog_name_var=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"].vars["init_prog"]$;
     };
     WhileLoop @[4] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="while (!stop_train)";
      pre_compile_code_string="while (!stop_train)";
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="MasterRun(network, config_id, run_prog)";
	pre_compile_code_string="MasterRun(network, config_id, run_prog)";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=taString;
	  type="String";
	  name="config_id";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="config_id";
	  };
	 };
	 ProgArg @[2] {
	  arg_type=taString;
	  type="String";
	  name="run_prog";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="run_prog";
	  };
	 };
	};
	target=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterRun"]$$;
	targ_ld_init="*MasterRun*";
       };
      };
      test {
       expr="!stop_train";
      };
     };
    };
    step_prog=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterRun"]$;
    step_n=1;
   };
   Program @["MasterRun"] {
    name="MasterRun";
    short_nm="MstrRn";
    tags=;
    desc="modular run code -- forks off to RunProgs based on run_prog -- only neccessary to provide common step point for all run progs";
    flags=0;
    stop_step_cond {
     expr="StopStepTest()";
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @["StopStepGrain"] {
      name="StopStepGrain";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @["TRIAL"] {
	name="TRIAL";
	value=0;
	desc="stop / step after each time through the master run program, which generally corresponds to a trial";
       };
       DynEnumItem @["EPOCH"] {
	name="EPOCH";
	value=1;
	desc="stop / step after an entire epoch of processing (when network.trial is reset back to 0)";
       };
       DynEnumItem @["ERROR"] {
	name="ERROR";
	value=2;
	desc="stop /step after there is an error (sse > 0)";
       };
       DynEnumItem @["CORRECT"] {
	name="CORRECT";
	value=3;
	desc="stop /step after there is a correct trial (sse == 0)";
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
     ProgVar @["config_id"] {
      name="config_id";
      var_type=T_String;
      string_val="basic_train";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="configuration to use -- lookup in Config table";
      init_from=NULL;
     };
     ProgVar @["run_prog"] {
      name="run_prog";
      var_type=T_String;
      string_val="BasicRun";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="name of run program from the Config table";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["Config"] {
      name="Config";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["ConfigData"]["ConfigTable"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["stop_step_grain"] {
      name="stop_step_grain";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterRun"].types["StopStepGrain"]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @["StopStepTest"] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="StopStepTest() returns: bool";
      pre_compile_code_string="StopStepTest() returns: bool";
      name="StopStepTest";
      return_type=T_Bool;
      object_type=taOBase;
      args {
       name="ProgVar_List_1";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="ProgEl_List_248";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	pre_compile_code_string="LocalVars (0 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       Switch @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="switch(stop_step_grain)";
	pre_compile_code_string="switch(stop_step_grain)";
	switch_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterRun"].vars["stop_step_grain"]$$;
	cases {
	 name="cases";
	 el_typ=CaseBlock;
	 el_def=0;
	 CaseBlock @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: TRIAL";
	  pre_compile_code_string="case: TRIAL";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return true";
	    pre_compile_code_string="return true";
	    expr {
	     expr="true";
	    };
	   };
	  };
	  case_val {
	   expr="TRIAL";
	  };
	  is_default=0;
	 };
	 CaseBlock @[1] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: EPOCH";
	  pre_compile_code_string="case: EPOCH";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return (network->trial == 0)";
	    pre_compile_code_string="return (network->trial == 0)";
	    expr {
	     expr="(network->trial == 0)";
	    };
	   };
	  };
	  case_val {
	   expr="EPOCH";
	  };
	  is_default=0;
	 };
	 CaseBlock @[2] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: ERROR";
	  pre_compile_code_string="case: ERROR";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return (network->sse > 0.0f)";
	    pre_compile_code_string="return (network->sse > 0.0f)";
	    expr {
	     expr="(network->sse > 0.0f)";
	    };
	   };
	  };
	  case_val {
	   expr="ERROR";
	  };
	  is_default=0;
	 };
	 CaseBlock @[3] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="case: CORRECT";
	  pre_compile_code_string="case: CORRECT";
	  prog_code {
	   name="prog_code";
	   el_typ=ProgCode;
	   el_def=0;
	   ReturnExpr @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="return (network->sse == 0.0f)";
	    pre_compile_code_string="return (network->sse == 0.0f)";
	    expr {
	     expr="(network->sse == 0.0f)";
	    };
	   };
	  };
	  case_val {
	   expr="CORRECT";
	  };
	  is_default=0;
	 };
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     ProgramCallVar @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Call Fm: prog_group=RunProgs prog_name_var=run_prog (network, config_id)";
      pre_compile_code_string="Call Fm: prog_group=RunProgs prog_name_var=run_prog (network, config_id)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=taString;
	type="String";
	name="config_id";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="config_id";
	};
       };
      };
      prog_group=.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["RunProgs"]$$;
      prog_name_var=.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterRun"].args["run_prog"]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program_Group @.gp["InitProgs"] {
    name="InitProgs";
    el_typ=Program;
    el_def=0;
    tags=;
    desc="contains specific Init programs called at start of running by RobotInit";
    debug_mode=0;
    Program @["BasicInit"] {
     name="BasicInit";
     short_nm="BaseInit";
     tags=;
     desc="initialization for basic training";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["network"] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @["config_id"] {
       name="config_id";
       var_type=T_String;
       string_val="basic_train";
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["lay_lesion_list"] {
       name="lay_lesion_list";
       var_type=T_String;
       string_val=;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="layers to lesion for this run";
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      ProgramCall @[0] {
       desc="always do std globals init";
       flags=CAN_REVERT_TO_CODE;
       code_string="StdGlobalsInit(network, config_id)";
       pre_compile_code_string="StdGlobalsInit(network, config_id)";
       prog_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="config_id";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="config_id";
	 };
	};
       };
       target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$$;
       targ_ld_init="*StdGlobalsInit*";
      };
      ProgramCall @[1] {
       desc="get rid of all non-essential layers";
       flags=CAN_REVERT_TO_CODE;
       code_string="ConfigNetwork(network, lay_lesion_list)";
       pre_compile_code_string="ConfigNetwork(network, lay_lesion_list)";
       prog_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="lesion_layers";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="lay_lesion_list";
	 };
	};
       };
       target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"]$$;
       targ_ld_init="*ConfigNetwork*";
      };
      ProgramCall @[2] {
       desc="standard init of training";
       flags=CAN_REVERT_TO_CODE;
       code_string="TrainStart(network)";
       pre_compile_code_string="TrainStart(network)";
       prog_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"]$$;
       targ_ld_init="*TrainStart*";
      };
      If @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (config_id.contains(\"_test\"))";
       pre_compile_code_string="if (config_id.contains(\"_test\"))";
       cond {
	expr="config_id.contains(\"_test\")";
       };
       true_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TEST";
	 pre_compile_code_string="network.train_mode = LeabraNetwork::TEST";
	 obj=.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["InitProgs"]["BasicInit"].args["network"]$$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TEST";
	 };
	 update_after=0;
	};
       };
      };
      Else @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	MemberAssign @[0] {
	 desc="set network to training mode";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.train_mode = LeabraNetwork::TRAIN";
	 pre_compile_code_string="network.train_mode = LeabraNetwork::TRAIN";
	 obj=$.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["InitProgs"]["BasicInit"].args["network"]$;
	 path="train_mode";
	 expr {
	  expr="LeabraNetwork::TRAIN";
	 };
	 update_after=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
    };
   };
   Program_Group @.gp["RunProgs"] {
    name="RunProgs";
    el_typ=Program;
    el_def=0;
    tags="contains individual Run programs for specific environments -- called by RobotRun";
    desc=;
    debug_mode=0;
    Program @["BasicRun"] {
     name="BasicRun";
     short_nm="BaseRun";
     tags=;
     desc="run basic training -- does ";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["network"] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
      ProgVar @["config_id"] {
       name="config_id";
       var_type=T_String;
       string_val="basic_train";
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="configuration to use -- lookup in Config table";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["trials_per_epoch"] {
       name="trials_per_epoch";
       var_type=T_Int;
       int_val=50;
       objs_ptr=0;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
      };
      ProgVar @["train_epochs"] {
       name="train_epochs";
       var_type=T_Int;
       int_val=50;
       objs_ptr=0;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
      };
      ProgVar @["update_net_view"] {
       name="update_net_view";
       var_type=T_Bool;
       bool_val=1;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="if true, will update network views at end of settling";
       init_from=NULL;
      };
      ProgVar @["StdInputData"] {
       name="StdInputData";
       var_type=T_Object;
       object_type=DataTable;
       object_val=.projects["LeabraFlex"].data.gp["InputData"]["StdInputData"]$$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      Comment @[0] {
       desc="== Execute One Trial of Basic Training ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Execute One Trial of Basic Training ==";
       pre_compile_code_string="// == Execute One Trial of Basic Training ==";
      };
      MemberAssign @[1] {
       desc="always in tick 0 for this -- only one step of processing";
       flags=CAN_REVERT_TO_CODE;
       code_string="network.tick = 0";
       pre_compile_code_string="network.tick = 0";
       obj=.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["RunProgs"]["BasicRun"].args["network"]$$;
       path="tick";
       expr {
	expr="0";
       };
       update_after=0;
      };
      ProgramCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="BasicTrain(network, StdInputData, update_net_view)";
       pre_compile_code_string="BasicTrain(network, StdInputData, update_net_view)";
       prog_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=LeabraNetwork;
	 type="LeabraNetwork*";
	 name="network";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="input_data";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="StdInputData";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="update_net_view";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="update_net_view";
	 };
	};
       };
       target=.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"]$$;
       targ_ld_init="*BasicTrain*";
      };
      Comment @[3] {
       desc="== Done With One Trial ==";
       flags=CAN_REVERT_TO_CODE;
       code_string="// == Done With One Trial ==";
       pre_compile_code_string="// == Done With One Trial ==";
      };
      MemberAssign @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="network.trial = network.trial + 1";
       pre_compile_code_string="network.trial = network.trial + 1";
       obj=$.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["RunProgs"]["BasicRun"].args["network"]$;
       path="trial";
       expr {
	expr="network.trial + 1";
       };
       update_after=0;
      };
      If @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (network.trial >= trials_per_epoch)";
       pre_compile_code_string="if (network.trial >= trials_per_epoch)";
       cond {
	expr="network.trial >= trials_per_epoch";
       };
       true_code {
	name=;
	el_typ=ProgCode;
	el_def=0;
	ProgramCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochEnd(network)";
	 pre_compile_code_string="EpochEnd(network)";
	 prog_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochEnd"]$$;
	 targ_ld_init="*EpochEnd*";
	};
	MemberAssign @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="network.epoch = network.epoch + 1";
	 pre_compile_code_string="network.epoch = network.epoch + 1";
	 obj=$.projects["LeabraFlex"].programs.gp["ConfigProgs"].gp["RunProgs"]["BasicRun"].args["network"]$;
	 path="epoch";
	 expr {
	  expr="network.epoch + 1";
	 };
	 update_after=0;
	};
	If @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (network.epoch >= train_epochs)";
	 pre_compile_code_string="if (network.epoch >= train_epochs)";
	 cond {
	  expr="network.epoch >= train_epochs";
	 };
	 true_code {
	  name=;
	  el_typ=ProgCode;
	  el_def=0;
	  ProgramCall @[0] {
	   desc="calls stop_train and does final training stuff";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="TrainEnd(network)";
	   pre_compile_code_string="TrainEnd(network)";
	   prog_args {
	    name=;
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=LeabraNetwork;
	     type="LeabraNetwork*";
	     name="network";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="network";
	     };
	    };
	   };
	   target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainEnd"]$$;
	   targ_ld_init="*TrainEnd*";
	  };
	  ReturnExpr @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="return ";
	   pre_compile_code_string="return ";
	   expr {
	    expr=;
	   };
	  };
	 };
	};
	ProgramCall @[3] {
	 desc="time to start a new epoch!";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="EpochStart(network)";
	 pre_compile_code_string="EpochStart(network)";
	 prog_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=LeabraNetwork;
	   type="LeabraNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochStart"]$$;
	 targ_ld_init="*EpochStart*";
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
    };
   };
  };
  Program_Group @.gp["TaskProgs"] {
   name="TaskProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @["BasicTrain"] {
    name="BasicTrain";
    short_nm="BscTrn";
    tags=;
    desc="basic training -- this is a standard Leabra minus-plus trial";
    flags=2;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     TimeUsed @["BasicTrainTime"] {name="BasicTrainTime": start={usr=5248: sys=1861: tot=144040474071: }: end={usr=5248: sys=1861: tot=144040474071: }: used={usr=0: sys=0: tot=0: }: s_used=0: n_used=0: };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["InputData"]["StdInputData"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["BasicTrainTime"] {
      name="BasicTrainTime";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].objs["BasicTrainTime"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="BasicTrainTime->ResetUsed()";
      pre_compile_code_string="BasicTrainTime->ResetUsed()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].vars["BasicTrainTime"]$$;
      method=TimeUsed::ResetUsed;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetUsed()";
      meth_desc=" reset time used information";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="BasicTrainTime->StartTimer(false)";
      pre_compile_code_string="BasicTrainTime->StartTimer(false)";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].vars["BasicTrainTime"]$;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     Comment @[1] {
      desc="=== Start Trial ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Start Trial ===";
      pre_compile_code_string="// === Start Trial ===";
     };
     ProgramCall @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="TrialStart(network)";
      pre_compile_code_string="TrialStart(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialStart"]$$;
      targ_ld_init="*TrialStart*";
     };
     ProgramCall @[3] {
      desc="pick next event permuted..";
      flags=CAN_REVERT_TO_CODE;
      code_string="ChooseNextEvent(network, input_data, true)";
      pre_compile_code_string="ChooseNextEvent(network, input_data, true)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[2] {
	arg_type=bool;
	type="bool";
	name="permuted";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"]$$;
      targ_ld_init="*ChooseNextEvent*";
     };
     ProgramCall @[4] {
      desc="apply std external input activations from the input_data table to the network";
      flags=CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      pre_compile_code_string="ApplyInputs(network, input_data)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"]$$;
      targ_ld_init="*ApplyInputs*";
     };
     Comment @[5] {
      desc="=== Run Minus Phase ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Run Minus Phase ===";
      pre_compile_code_string="// === Run Minus Phase ===";
     };
     ProgramCall @[6] {
      desc="settle for minus phase, using ct_time.minus as fixed number of cycles to run";
      flags=CAN_REVERT_TO_CODE;
      code_string="SettleMinus(network)";
      pre_compile_code_string="SettleMinus(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SettleMinus"]$$;
      targ_ld_init="*SettleMinus*";
     };
     MethodCall @[7] {
      desc="compute stats appropriate for given phase";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      pre_compile_code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["network"]$$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[8] {
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["network"]$;
      update_var=.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["update_net_view"]$$;
     };
     StopStepPoint @[9] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Stop/Step Point";
      pre_compile_code_string="Stop/Step Point";
      cond {
       expr=;
      };
     };
     Comment @[10] {
      desc="=== Run Plus Phase ===";
      flags=CAN_REVERT_TO_CODE;
      code_string="// === Run Plus Phase ===";
      pre_compile_code_string="// === Run Plus Phase ===";
     };
     MethodCall @[11] {
      desc="only need to re-apply if something is new!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      pre_compile_code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["network"]$;
      method=Network::Init_InputData;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     ProgramCall @[12] {
      desc="only need to re-apply if something is new!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="ApplyInputs(network, input_data)";
      pre_compile_code_string="ApplyInputs(network, input_data)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
      };
      target=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"]$;
      targ_ld_init="*ApplyInputs*";
     };
     ProgramCall @[13] {
      desc="settle for designated plus phase number of cycles";
      flags=CAN_REVERT_TO_CODE;
      code_string="SettlePlus(network)";
      pre_compile_code_string="SettlePlus(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SettlePlus"]$$;
      targ_ld_init="*Settle*";
     };
     MethodCall @[14] {
      desc="compute stats appropriate for given phase";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_PhaseStats()";
      pre_compile_code_string="network->Compute_PhaseStats()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["network"]$;
      method=LeabraNetwork::Compute_PhaseStats;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_PhaseStats()";
      meth_desc=" compute MinusStats at the end of the minus phase, and PlusStats at the end of the plus phase -- this is preferred over the previous implementation of calling TrialStats only at the end of the minus phase, which required targets to be present in the minus phase, which is not always the case";
     };
     NetUpdateView @[15] {
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["network"]$;
      update_var=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].args["update_net_view"]$;
     };
     ProgramCall @[16] {
      desc="standard end of trial stuff";
      flags=CAN_REVERT_TO_CODE;
      code_string="TrialEnd(network)";
      pre_compile_code_string="TrialEnd(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialEnd"]$$;
      targ_ld_init="*TrialEnd*";
     };
     MethodCall @[17] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="BasicTrainTime->EndTimer()";
      pre_compile_code_string="BasicTrainTime->EndTimer()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].vars["BasicTrainTime"]$;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[18] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraTrialMonitor(network)";
      pre_compile_code_string="LeabraTrialMonitor(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"]$$;
      targ_ld_init="*LeabraTrialMonitor*";
     };
    };
    step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$;
    step_n=1;
   };
  };
  Program_Group @.gp["EnviroProgs"] {
   name="EnviroProgs";
   el_typ=Program;
   el_def=0;
   tags=;
   desc=;
   debug_mode=0;
   Program @["ChooseNextEvent"] {
    name="ChooseNextEvent";
    short_nm="ChNxEvt";
    tags="InputData, Permuted, FlexProgs, ApplyInput";
    desc="choose next event in input data in either sequential or permuted order according to its own internal counter-- starts over (re-permutes) when the end is reached -- is automatically dmem compatible for allocating different events to different processors";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=DataTable;
     el_def=0;
     DataTable @["PermIdxTable"] {
      name="PermIdxTable";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       int_Data @["Index"] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_455";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	};
	name="Index";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=0;
       };
      };
      data_flags=AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [0]       };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      control_panel_cells {
       name="control_panel_cells";
       el_typ=DataTableCell;
       el_def=0;
      };
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="Network to which to apply inputs";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["InputData"]["StdInputData"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
     ProgVar @["permuted"] {
      name="permuted";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="present events in permuted order (otherwise use sequential order)";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["cur_idx"] {
      name="cur_idx";
      var_type=T_Int;
      int_val=-1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current index into permuted table ";
      init_from=NULL;
     };
     ProgVar @["input_idx"] {
      name="input_idx";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["dmem_rows"] {
      name="dmem_rows";
      var_type=T_Int;
      int_val=6;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["PermIdxTable"] {
      name="PermIdxTable";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].objs["PermIdxTable"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @["ComputeDmemRows"] {
      desc="compute target number of rows, based on current dmem settings";
      flags=CAN_REVERT_TO_CODE;
      code_string="ComputeDmemRows() returns: int";
      pre_compile_code_string="ComputeDmemRows() returns: int";
      name="ComputeDmemRows";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="ProgVar_List_0";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="ProgEl_List_1374";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	pre_compile_code_string="LocalVars (0 vars)";
	local_vars {
	 name="ProgVar_List_0";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       If @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (taMisc::dmem_nprocs <= 1)";
	pre_compile_code_string="if (taMisc::dmem_nprocs <= 1)";
	cond {
	 expr="taMisc::dmem_nprocs <= 1";
	};
	true_code {
	 name="ProgEl_List_1376";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="dmem_rows = input_data.rows";
	  pre_compile_code_string="dmem_rows = input_data.rows";
	  result_var=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["dmem_rows"]$$;
	  expr {
	   expr="input_data.rows";
	  };
	 };
	};
       };
       Else @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="else";
	pre_compile_code_string="else";
	else_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="dmem_rows = input_data.rows / taMisc::dmem_nprocs";
	  pre_compile_code_string="dmem_rows = input_data.rows / taMisc::dmem_nprocs";
	  result_var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["dmem_rows"]$;
	  expr {
	   expr="input_data.rows / taMisc::dmem_nprocs";
	  };
	 };
	 WhileLoop @[1] {
	  desc="ensure that we cover all the input data";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="while (dmem_rows * taMisc::dmem_nprocs < input_data.rows)";
	  pre_compile_code_string="while (dmem_rows * taMisc::dmem_nprocs < input_data.rows)";
	  loop_code {
	   name="ProgEl_List_1382";
	   el_typ=ProgCode;
	   el_def=0;
	   VarIncr @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="dmem_rows += 1";
	    pre_compile_code_string="dmem_rows += 1";
	    var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["dmem_rows"]$;
	    expr {
	     expr="1";
	    };
	   };
	  };
	  test {
	   expr="dmem_rows * taMisc::dmem_nprocs < input_data.rows";
	  };
	 };
	};
       };
      };
     };
     Function @["PermuteIndexes"] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="PermuteIndexes() returns: int";
      pre_compile_code_string="PermuteIndexes() returns: int";
      name="PermuteIndexes";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="ProgVar_List_0";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="ProgEl_List_1375";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	pre_compile_code_string="LocalVars (0 vars)";
	local_vars {
	 name="ProgVar_List_0";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       AssignExpr @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="cur_idx = -1";
	pre_compile_code_string="cur_idx = -1";
	result_var=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["cur_idx"]$$;
	expr {
	 expr="-1";
	};
       };
       If @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (permuted)";
	pre_compile_code_string="if (permuted)";
	cond {
	 expr="permuted";
	};
	true_code {
	 name="ProgEl_List_205";
	 el_typ=ProgCode;
	 el_def=0;
	 DataProcCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="taDataProc::Permute(PermIdxTable, PermIdxTable, taMisc::dmem_proc)";
	  pre_compile_code_string="taDataProc::Permute(PermIdxTable, PermIdxTable, taMisc::dmem_proc)";
	  result_var=NULL;
	  object_type=taDataProc;
	  method=taDataProc::Permute;
	  meth_args {
	   name="ProgArg_List_0";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=DataTable_ptr;
	    type="DataTable*";
	    name="dest";
	    required=1;
	    def_val=;
	    prev_expr="PermIdxTable";
	    expr {
	     expr="PermIdxTable";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=DataTable_ptr;
	    type="DataTable*";
	    name="src";
	    required=1;
	    def_val=;
	    prev_expr="PermIdxTable";
	    expr {
	     expr="PermIdxTable";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=int;
	    type="int";
	    name="thr_no";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="taMisc::dmem_proc";
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     Function @["InitIndexes"] {
      desc="initialize indexes from current input data table";
      flags=CAN_REVERT_TO_CODE;
      code_string="InitIndexes() returns: int";
      pre_compile_code_string="InitIndexes() returns: int";
      name="InitIndexes";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="ProgVar_List_0";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="ProgEl_List_1370";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (0 vars)";
	pre_compile_code_string="LocalVars (0 vars)";
	local_vars {
	 name="ProgVar_List_0";
	 el_typ=ProgVar;
	 el_def=0;
	};
       };
       FunctionCall @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="ComputeDmemRows()";
	pre_compile_code_string="ComputeDmemRows()";
	result_var=NULL;
	fun=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].functions["ComputeDmemRows"]$$;
	fun_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
       MethodCall @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="PermIdxTable->EnforceRows(dmem_rows)";
	pre_compile_code_string="PermIdxTable->EnforceRows(dmem_rows)";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["PermIdxTable"]$$;
	method=DataTable::EnforceRows;
	meth_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="n_rows";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="dmem_rows";
	  };
	 };
	};
	meth_sig="void EnforceRows(int n_rows)";
	meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
       };
       MethodCall @[3] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="PermIdxTable->InitValsToRowNo(0)";
	pre_compile_code_string="PermIdxTable->InitValsToRowNo(0)";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["PermIdxTable"]$;
	method=DataTable::InitValsToRowNo;
	meth_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_Variant_ref;
	  type="Variant&";
	  name="col";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="0";
	  };
	 };
	};
	meth_sig="bool InitValsToRowNo(Variant& col)";
	meth_desc=" initialize all values in given column to be equal to the row number -- only valid for scalar (not matrix) columns -- column can be specified as either integer index or a string that is then used to find the given column name";
       };
       FunctionCall @[4] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="PermuteIndexes()";
	pre_compile_code_string="PermuteIndexes()";
	result_var=NULL;
	fun=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].functions["PermuteIndexes"]$$;
	fun_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     FunctionCall @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="InitIndexes()";
      pre_compile_code_string="InitIndexes()";
      result_var=NULL;
      fun=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].functions["InitIndexes"]$$;
      fun_args {
       name="ProgArg_List_0";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     AssignExpr @[1] {
      desc="start at start -- index is incremented AFTER using";
      flags=CAN_REVERT_TO_CODE;
      code_string="cur_idx = 0";
      pre_compile_code_string="cur_idx = 0";
      result_var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["cur_idx"]$;
      expr {
       expr="0";
      };
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     FunctionCall @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="ComputeDmemRows()";
      pre_compile_code_string="ComputeDmemRows()";
      result_var=NULL;
      fun=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].functions["ComputeDmemRows"]$;
      fun_args {
       name="ProgArg_List_0";
       el_typ=ProgArg;
       el_def=0;
      };
     };
     If @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (dmem_rows != PermIdxTable.rows)";
      pre_compile_code_string="if (dmem_rows != PermIdxTable.rows)";
      cond {
       expr="dmem_rows != PermIdxTable.rows";
      };
      true_code {
       name="ProgEl_List_1372";
       el_typ=ProgCode;
       el_def=0;
       FunctionCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="InitIndexes()";
	pre_compile_code_string="InitIndexes()";
	result_var=NULL;
	fun=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].functions["InitIndexes"]$;
	fun_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     If @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (permuted)";
      pre_compile_code_string="if (permuted)";
      cond {
       expr="permuted";
      };
      true_code {
       name="ProgEl_List_207";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="input_idx = PermIdxTable->GetVal(0, cur_idx)";
	pre_compile_code_string="input_idx = PermIdxTable->GetVal(0, cur_idx)";
	result_var=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["input_idx"]$$;
	obj=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["PermIdxTable"]$;
	method=DataTable::GetVal;
	meth_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_Variant_ref;
	  type="Variant&";
	  name="col";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="0";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=int;
	  type="int";
	  name="row";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="cur_idx";
	  };
	 };
	};
	meth_sig="const_Variant GetVal(Variant& col, int row)";
	meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
       };
      };
     };
     Else @[3] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="else";
      pre_compile_code_string="else";
      else_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="input_idx = cur_idx";
	pre_compile_code_string="input_idx = cur_idx";
	result_var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["input_idx"]$;
	expr {
	 expr="cur_idx";
	};
       };
      };
     };
     If @[4] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_nprocs > 1)";
      pre_compile_code_string="if (taMisc::dmem_nprocs > 1)";
      cond {
       expr="taMisc::dmem_nprocs > 1";
      };
      true_code {
       name="ProgEl_List_1378";
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	desc="for dmem, transform from virtual idx counter into actual row, unique to this processor";
	flags=CAN_REVERT_TO_CODE;
	code_string="input_idx = taMisc::dmem_proc + taMisc::dmem_nprocs * input_idx";
	pre_compile_code_string="input_idx = taMisc::dmem_proc + taMisc::dmem_nprocs * input_idx";
	result_var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["input_idx"]$;
	expr {
	 expr="taMisc::dmem_proc + taMisc::dmem_nprocs * input_idx";
	};
       };
       If @[1] {
	desc="choose at random if above actual input data";
	flags=CAN_REVERT_TO_CODE;
	code_string="if (input_idx > input_data.rows)";
	pre_compile_code_string="if (input_idx > input_data.rows)";
	cond {
	 expr="input_idx > input_data.rows";
	};
	true_code {
	 name="ProgEl_List_1381";
	 el_typ=ProgCode;
	 el_def=0;
	 RandomCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="input_idx = Random::IntZeroN(input_data.rows, )";
	  pre_compile_code_string="input_idx = Random::IntZeroN(input_data.rows, )";
	  result_var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["input_idx"]$;
	  object_type=Random;
	  method=Random::IntZeroN;
	  meth_args {
	   name="ProgArg_List_0";
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=int;
	    type="int";
	    name="n";
	    required=1;
	    def_val=;
	    prev_expr="input_data.rows";
	    expr {
	     expr="input_data.rows";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=int;
	    type="int";
	    name="thr_no";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	};
       };
      };
     };
     MethodCall @[5] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data->ReadItem(input_idx)";
      pre_compile_code_string="input_data->ReadItem(input_idx)";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].args["input_data"]$$;
      method=DataTable::ReadItem;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_idx";
	};
       };
      };
      meth_sig="bool ReadItem(int idx)";
      meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
     };
     If @[6] {
      desc="now increment AFTER using, and wrap around..";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (cur_idx == PermIdxTable.rows -1)";
      pre_compile_code_string="if (cur_idx == PermIdxTable.rows -1)";
      cond {
       expr="cur_idx == PermIdxTable.rows -1";
      };
      true_code {
       name="ProgEl_List_1374";
       el_typ=ProgCode;
       el_def=0;
       FunctionCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="PermuteIndexes()";
	pre_compile_code_string="PermuteIndexes()";
	result_var=NULL;
	fun=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].functions["PermuteIndexes"]$;
	fun_args {
	 name="ProgArg_List_0";
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
     };
     Else @[7] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="else";
      pre_compile_code_string="else";
      else_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       VarIncr @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="cur_idx += 1";
	pre_compile_code_string="cur_idx += 1";
	var=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseNextEvent"].vars["cur_idx"]$;
	expr {
	 expr="1";
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["ChooseRandomEvent"] {
    name="ChooseRandomEvent";
    short_nm="ChRndm";
    tags=;
    desc="choose an event at random to present on current trial";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["InputData"]["StdInputData"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["event_idx"] {
      name="event_idx";
      var_type=T_Int;
      int_val=2;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="event to present";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     RandomCall @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="event_idx = Random::IntZeroN(input_data.rows, taMisc::dmem_proc)";
      pre_compile_code_string="event_idx = Random::IntZeroN(input_data.rows, taMisc::dmem_proc)";
      result_var=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseRandomEvent"].vars["event_idx"]$$;
      object_type=Random;
      method=Random::IntZeroN;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="n";
	required=1;
	def_val=;
	prev_expr="input_data.rows";
	expr {
	 expr="input_data.rows";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="thr_no";
	required=0;
	def_val="0";
	prev_expr=;
	expr {
	 expr="taMisc::dmem_proc";
	};
       };
      };
     };
     MethodCall @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="input_data->ReadItem(event_idx)";
      pre_compile_code_string="input_data->ReadItem(event_idx)";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ChooseRandomEvent"].args["input_data"]$$;
      method=DataTable::ReadItem;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="event_idx";
	};
       };
      };
      meth_sig="bool ReadItem(int idx)";
      meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["ApplyInputs"] {
    name="ApplyInputs";
    short_nm="Inputs";
    tags="Network, InputData, Apply";
    desc="apply the current input data to the network as external input and target values";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=LayerWriter;
     el_def=0;
     LayerWriter @["LayerWriter_0"] {
      name="LayerWriter_0";
      data=$.projects["LeabraFlex"].data.gp["InputData"]["StdInputData"]$;
      network=$.projects["LeabraFlex"].networks["Network_0"]$;
      layer_data {
       name="layer_data";
       el_typ=LayerWriterEl;
       el_def=0;
       LayerWriterEl @[0] {
	col_name="Input";
	net_target=LAYER;
	layer_name="Input";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=EXT;
	noise {name="RandomSpec_7": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[1] {
	col_name="Output";
	net_target=LAYER;
	layer_name="Output";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=TARG;
	noise {name="RandomSpec_8": type=NONE: mean=0: var=0.5: par=1: };
       };
       LayerWriterEl @[2] {
	col_name="Name";
	net_target=TRIAL_NAME;
	layer_name="Name";
	offset {x=0: y=0: };
	use_layer_type=1;
	quiet=0;
	na_by_range=0;
	ext_flags=0;
	noise {name="RandomSpec_9": type=NONE: mean=0: var=0.5: par=1: };
       };
      };
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=Network;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to apply inputs to -- typically set by calling program";
      init_from=NULL;
     };
     ProgVar @["input_data"] {
      name="input_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["InputData"]["StdInputData"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="input datatable containing input/output patterns";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["LayerWriter_0"] {
      name="LayerWriter_0";
      var_type=T_Object;
      object_type=LayerWriter;
      object_val=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"].objs["LayerWriter_0"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="this is a pointer to the LayerWriter object in objs -- edit that object to determine how information is presented to the network";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerWriter_0->SetDataNetwork(input_data, network)";
      pre_compile_code_string="LayerWriter_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"].vars["LayerWriter_0"]$$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      desc="configure to fit the network and input data -- this may cause spurious warning messages and problems in some cases so just turn it OFF if necessary";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerWriter_0->AutoConfig()";
      pre_compile_code_string="LayerWriter_0->AutoConfig()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=LayerWriter::AutoConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="remove_unused";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr=;
	};
       };
      };
      meth_sig="void AutoConfig(bool remove_unused = true)";
      meth_desc=" do a 'best guess' configuration of items by matching up like-named data Channels and network Layers -- if remove_unused is true, then layer writer elements that existed previously but were not found in input data and network are removed";
     };
     MethodCall @[2] {
      desc="check the configuration of the layer writer -- will emit warnings and errors for missing or misconfigured items";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerWriter_0->CheckConfig(false)";
      pre_compile_code_string="LayerWriter_0->CheckConfig(false)";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=taList_impl::CheckConfig;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="quiet";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="bool CheckConfig(bool quiet = false)";
      meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="sets the datatable and network for the layer writer, so it knows what to write to";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerWriter_0->SetDataNetwork(input_data, network)";
      pre_compile_code_string="LayerWriter_0->SetDataNetwork(input_data, network)";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=LayerWriter::SetDataNetwork;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=DataTable_ptr;
	type="DataTable*";
	name="db";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="input_data";
	};
       };
       ProgArg @[1] {
	arg_type=Network_ptr;
	type="Network*";
	name="net";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      meth_sig="void SetDataNetwork(DataTable* db, Network* net)";
      meth_desc=" set the data table and network pointers -- convenience function for programs ";
     };
     MethodCall @[1] {
      desc="apply inputs to the network!  layer writer has all the key specs";
      flags=CAN_REVERT_TO_CODE;
      code_string="LayerWriter_0->ApplyInputData()";
      pre_compile_code_string="LayerWriter_0->ApplyInputData()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["EnviroProgs"]["ApplyInputs"].vars["LayerWriter_0"]$;
      method=LayerWriter::ApplyInputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="bool ApplyInputData()";
      meth_desc=" apply data to the layers, using the network's current context settings (TEST,TRAIN,etc) -- returns success";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
  };
  Program_Group @.gp["UtilProgs"] {
   name="UtilProgs";
   el_typ=Program;
   el_def=0;
   tags="basic utility programs for doing basic operations shared across multiple programs";
   desc=;
   debug_mode=0;
   Program @["StdGlobalsInit"] {
    name="StdGlobalsInit";
    short_nm="GlobInit";
    tags=;
    desc="initialize standard global params, which live here too -- set other programs to init_from these guys";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
     ProgVar @["config_id"] {
      name="config_id";
      var_type=T_String;
      string_val="basic_train";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="configuration to use -- lookup in Config table";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["Config"] {
      name="Config";
      var_type=T_Object;
      object_type=DataTable;
      object_val=$.projects["LeabraFlex"].data.gp["ConfigData"]["ConfigTable"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["trials_per_epoch"] {
      name="trials_per_epoch";
      var_type=T_Int;
      int_val=50;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["trials_per_epoch_orig"] {
      name="trials_per_epoch_orig";
      var_type=T_Int;
      int_val=50;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="original specification from Config";
      init_from=NULL;
     };
     ProgVar @["train_epochs"] {
      name="train_epochs";
      var_type=T_Int;
      int_val=50;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["save_final_wts"] {
      name="save_final_wts";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["save_wts_interval"] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["test_interval"] {
      name="test_interval";
      var_type=T_Int;
      int_val=1000;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["log_trials"] {
      name="log_trials";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["load_weights"] {
      name="load_weights";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["weights_file"] {
      name="weights_file";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["load_st_epc"] {
      name="load_st_epc";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["lrs_step_epochs"] {
      name="lrs_step_epochs";
      var_type=T_Int;
      int_val=50;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      desc="== Grab Global Params from Config Table for current config_id ==";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == Grab Global Params from Config Table for current config_id ==";
      pre_compile_code_string="// == Grab Global Params from Config Table for current config_id ==";
     };
     DataVarProg @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=true ";
      pre_compile_code_string="Data From:  table=Config  row_spec=row_val  row_var=config_id  set=from  all_matches=true ";
      data_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"].vars["Config"]$$;
      row_spec=ROW_VAL;
      row_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"].args["config_id"]$$;
      set_data=0;
      all_matches=1;
      quiet=0;
      var_1=NULL;
      var_2=NULL;
      var_3=NULL;
      var_4=NULL;
     };
     AssignExpr @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="trials_per_epoch_orig = trials_per_epoch";
      pre_compile_code_string="trials_per_epoch_orig = trials_per_epoch";
      result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"].vars["trials_per_epoch_orig"]$$;
      expr {
       expr="trials_per_epoch";
      };
     };
     If @[3] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (taMisc::dmem_nprocs > 1)";
      pre_compile_code_string="if (taMisc::dmem_nprocs > 1)";
      cond {
       expr="taMisc::dmem_nprocs > 1";
      };
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       AssignExpr @[0] {
	desc="dmem means that each guy does less -- uses randomization to get good mix across processors";
	flags=CAN_REVERT_TO_CODE;
	code_string="trials_per_epoch = trials_per_epoch / taMisc::dmem_nprocs";
	pre_compile_code_string="trials_per_epoch = trials_per_epoch / taMisc::dmem_nprocs";
	result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"].vars["trials_per_epoch"]$$;
	expr {
	 expr="trials_per_epoch / taMisc::dmem_nprocs";
	};
       };
       If @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (trials_per_epoch * taMisc::dmem_nprocs < trials_per_epoch_orig)";
	pre_compile_code_string="if (trials_per_epoch * taMisc::dmem_nprocs < trials_per_epoch_orig)";
	cond {
	 expr="trials_per_epoch * taMisc::dmem_nprocs < trials_per_epoch_orig";
	};
	true_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 VarIncr @[0] {
	  desc="round up..";
	  flags=CAN_REVERT_TO_CODE;
	  code_string="trials_per_epoch += 1";
	  pre_compile_code_string="trials_per_epoch += 1";
	  var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"].vars["trials_per_epoch"]$;
	  expr {
	   expr="1";
	  };
	 };
	};
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["BatchRndSeed"] {
    name="BatchRndSeed";
    short_nm="BatchSeed";
    tags=;
    desc="select random seed based on network batch number";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     RndSeed_List @["rnd_seeds"] {
      name="rnd_seeds";
      seeds {
       name="seeds";
       el_typ=RndSeed;
       el_def=0;
       RndSeed @["RndSeed_1"] {
	name="RndSeed_1";
	rnd_seed=2929233146;
       };
       RndSeed @["RndSeed_2"] {
	name="RndSeed_2";
	rnd_seed=2929233147;
       };
       RndSeed @["RndSeed_3"] {
	name="RndSeed_3";
	rnd_seed=2929233148;
       };
       RndSeed @["RndSeed_4"] {
	name="RndSeed_4";
	rnd_seed=2929233149;
       };
       RndSeed @["RndSeed_5"] {
	name="RndSeed_5";
	rnd_seed=2929233150;
       };
       RndSeed @["RndSeed_6"] {
	name="RndSeed_6";
	rnd_seed=2929233151;
       };
       RndSeed @["RndSeed_7"] {
	name="RndSeed_7";
	rnd_seed=2929233152;
       };
       RndSeed @["RndSeed_8"] {
	name="RndSeed_8";
	rnd_seed=2929233153;
       };
       RndSeed @["RndSeed_9"] {
	name="RndSeed_9";
	rnd_seed=2929233154;
       };
       RndSeed @["RndSeed_10"] {
	name="RndSeed_10";
	rnd_seed=2929233155;
       };
       RndSeed @["RndSeed_11"] {
	name="RndSeed_11";
	rnd_seed=2929233156;
       };
       RndSeed @["RndSeed_12"] {
	name="RndSeed_12";
	rnd_seed=2929233157;
       };
       RndSeed @["RndSeed_13"] {
	name="RndSeed_13";
	rnd_seed=2929233158;
       };
       RndSeed @["RndSeed_14"] {
	name="RndSeed_14";
	rnd_seed=2929233159;
       };
       RndSeed @["RndSeed_15"] {
	name="RndSeed_15";
	rnd_seed=2929233160;
       };
       RndSeed @["RndSeed_16"] {
	name="RndSeed_16";
	rnd_seed=2929233161;
       };
       RndSeed @["RndSeed_17"] {
	name="RndSeed_17";
	rnd_seed=2929233162;
       };
       RndSeed @["RndSeed_18"] {
	name="RndSeed_18";
	rnd_seed=2929233163;
       };
       RndSeed @["RndSeed_19"] {
	name="RndSeed_19";
	rnd_seed=2929233164;
       };
       RndSeed @["RndSeed_20"] {
	name="RndSeed_20";
	rnd_seed=2929233165;
       };
       RndSeed @["RndSeed_21"] {
	name="RndSeed_21";
	rnd_seed=2929233166;
       };
       RndSeed @["RndSeed_22"] {
	name="RndSeed_22";
	rnd_seed=2929233167;
       };
       RndSeed @["RndSeed_23"] {
	name="RndSeed_23";
	rnd_seed=2929233168;
       };
       RndSeed @["RndSeed_24"] {
	name="RndSeed_24";
	rnd_seed=2929233169;
       };
       RndSeed @["RndSeed_25"] {
	name="RndSeed_25";
	rnd_seed=2929233170;
       };
      };
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["rnd_seeds"] {
      name="rnd_seeds";
      var_type=T_Object;
      object_type=RndSeed_List;
      object_val=.projects["LeabraFlex"].programs.gp["UtilProgs"]["BatchRndSeed"].objs["rnd_seeds"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
      flags=CAN_REVERT_TO_CODE;
      code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
      pre_compile_code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["BatchRndSeed"].vars["rnd_seeds"]$$;
      method=RndSeed_List::UseSeed;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="idx";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch % rnd_seeds.seeds.size";
	};
       };
      };
      meth_sig="void UseSeed(int idx)";
      meth_desc=" use seed at given index in the list (does OldSeed on it); wraps around (modulus) if idx is > list size (issues warning)";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["ConfigNetwork"] {
    name="ConfigNetwork";
    short_nm="CfgNet";
    tags=;
    desc="configure the network -- basically selectively lesion different parts that are not needed for a given task";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=String_Matrix;
     el_def=0;
     String_Matrix @["les_lay_mat"] {
      name="les_lay_mat";
     [0]      };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
     ProgVar @["lesion_layers"] {
      name="lesion_layers";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer group names to lesion";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["les_lay_mat"] {
      name="les_lay_mat";
      var_type=T_Object;
      object_type=String_Matrix;
      object_val=.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].objs["les_lay_mat"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["i"] {
      name="i";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["laygp_nm"] {
      name="laygp_nm";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["laygp"] {
      name="laygp";
      var_type=T_Object;
      object_type=Layer_Group;
      object_val=NULL;
      objs_ptr=0;
      flags=SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Comment @[0] {
      desc="== first unlesion everything ==";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == first unlesion everything ==";
      pre_compile_code_string="// == first unlesion everything ==";
     };
     ForLoop @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < network.layers.gp.size; i++)";
      pre_compile_code_string="for (i = 0; i < network.layers.gp.size; i++)";
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MemberMethodCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp = network.layers.gp.SafeEl(i)";
	pre_compile_code_string="laygp = network.layers.gp.SafeEl(i)";
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].args["network"]$$;
	path="layers.gp";
	result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp"]$$;
	method=taGroup_Layer_::SafeEl;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="Layer_ptr SafeEl(int idx)";
	meth_desc=" get element at index";
       };
       MethodCall @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->UnLesionLayers()";
	pre_compile_code_string="laygp->UnLesionLayers()";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp"]$;
	method=Layer_Group::UnLesionLayers;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void UnLesionLayers()";
	meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
       };
       MethodCall @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->DeIconifyLayers()";
	pre_compile_code_string="laygp->DeIconifyLayers()";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp"]$;
	method=Layer_Group::DeIconifyLayers;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void DeIconifyLayers()";
	meth_desc=" un-set the lesion flag on all the layers within this group";
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < network.layers.gp.size";
      };
      iter {
       expr="i++";
      };
     };
     Comment @[2] {
      desc="== then lesion named ones ==";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == then lesion named ones ==";
      pre_compile_code_string="// == then lesion named ones ==";
     };
     MethodCall @[3] {
      desc="get into easier to use matrix format";
      flags=CAN_REVERT_TO_CODE;
      code_string="les_lay_mat->FmDelimString(lesion_layers, \" \")";
      pre_compile_code_string="les_lay_mat->FmDelimString(lesion_layers, \" \")";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["les_lay_mat"]$$;
      method=String_Matrix::FmDelimString;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="str";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="lesion_layers";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="delim";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\" \"";
	};
       };
      };
      meth_sig="void FmDelimString(taString& str, taString& delim)";
      meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
     };
     ForLoop @[4] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < les_lay_mat.size; i++)";
      pre_compile_code_string="for (i = 0; i < les_lay_mat.size; i++)";
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp_nm = les_lay_mat->SafeEl_Flat(i)";
	pre_compile_code_string="laygp_nm = les_lay_mat->SafeEl_Flat(i)";
	result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp_nm"]$$;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["les_lay_mat"]$;
	method=taMatrixT_taString_::SafeEl_Flat;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="const_taString_ref SafeEl_Flat(int idx)";
	meth_desc=" (safely) access the matrix as if it were a flat vector, for reading";
       };
       MemberMethodCall @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp = network.layers.gp.FindName(laygp_nm)";
	pre_compile_code_string="laygp = network.layers.gp.FindName(laygp_nm)";
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].args["network"]$;
	path="layers.gp";
	result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp"]$;
	method=taGroup_Layer_::FindName;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="item_nm";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="laygp_nm";
	  };
	 };
	};
	meth_sig="Layer_ptr FindName(taString& item_nm)";
	meth_desc=" Find element in top-level list with given name (nm) (NULL = not here)";
       };
       If @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (!laygp)";
	pre_compile_code_string="if (!laygp)";
	cond {
	 expr="!laygp";
	};
	true_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 MiscCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	  pre_compile_code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	  result_var=NULL;
	  object_type=taMisc;
	  method=taMisc::Error;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="a";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\"layer group named:\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="b";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="laygp_nm";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="c";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="\"not found in network:\"";
	    };
	   };
	   ProgArg @[3] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="d";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="network.name";
	    };
	   };
	   ProgArg @[4] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="e";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[5] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="f";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[6] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="g";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[7] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="h";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[8] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="i";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	 IfContinue @[1] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="continue";
	  pre_compile_code_string="continue";
	  cond {
	   expr=;
	  };
	 };
	};
       };
       MethodCall @[3] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->LesionLayers()";
	pre_compile_code_string="laygp->LesionLayers()";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp"]$;
	method=Layer_Group::LesionLayers;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void LesionLayers()";
	meth_desc=" set the lesion flag on all the layers within this group -- removes them from all processing operations";
       };
       MethodCall @[4] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp->IconifyLayers()";
	pre_compile_code_string="laygp->IconifyLayers()";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].vars["laygp"]$;
	method=Layer_Group::IconifyLayers;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void IconifyLayers()";
	meth_desc=" iconi";
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < les_lay_mat.size";
      };
      iter {
       expr="i++";
      };
     };
     MethodCall @[5] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Build()";
      pre_compile_code_string="network->Build()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].args["network"]$;
      method=Network::Build;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Build()";
      meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
     };
     MethodCall @[6] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->UpdtAfterNetMod()";
      pre_compile_code_string="network->UpdtAfterNetMod()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["ConfigNetwork"].args["network"]$;
      method=Network::UpdtAfterNetMod;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void UpdtAfterNetMod()";
      meth_desc=" update network after any network modification (calls appropriate functions)";
     };
     PrintExpr @[7] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print \"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      pre_compile_code_string="Print \"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      expr {
       expr="\"Cons: \" << network.n_cons << \" Units: \" << network.n_units";
      };
      debug=0;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["PositionLayersFromTable"] {
    UserDataItem_List @*(.user_data_) {
     name=;
     el_typ=UserDataItem;
     el_def=0;
     UserDataItem @["user_pinned"] {
      name="user_pinned";
      value 1 0=1;
      val_type_fixed=0;
     };
    };
    name="PositionLayersFromTable";
    short_nm="PstLyr";
    tags="Network, Layer, Position";
    desc="positions network layers according to a data table with positions -- can use either absolute or group-relative coordinates, including non-structural groups";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     DataTable @["LayerLayout"] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_896";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["user_pinned"] {
	name="user_pinned";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="LayerLayout";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       String_Data @["LayerName"] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_969";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1500664;
	  val_type_fixed=0;
	 };
	};
	name="LayerName";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=113;
	ar {
	 name="ar";
	[3] "Input";"Hidden";"Output";	};
       };
       String_Data @["LayerGroup"] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_85";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1487384;
	  val_type_fixed=0;
	 };
	};
	name="LayerGroup";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=112;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       String_Data @["LayoutGroup"] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_88";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1500664;
	  val_type_fixed=0;
	 };
	};
	name="LayoutGroup";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=113;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       int_Data @["X_Abs"] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_966";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.09561753;
	  val_type_fixed=0;
	 };
	};
	name="X_Abs";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Y_Abs"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.09561753;
	  val_type_fixed=0;
	 };
	};
	name="Y_Abs";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Z_Abs"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.09561753;
	  val_type_fixed=0;
	 };
	};
	name="Z_Abs";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
       int_Data @["X_Rel"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.09561753;
	  val_type_fixed=0;
	 };
	};
	name="X_Rel";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Y_Rel"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.09561753;
	  val_type_fixed=0;
	 };
	};
	name="Y_Rel";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Z_Rel"] {
	UserDataItem_List @*(.user_data_) {
	 name="UserDataItem_List_90";
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.09030545;
	  val_type_fixed=0;
	 };
	};
	name="Z_Rel";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=68;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [3] 0;1;2;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      control_panel_cells {
       name="control_panel_cells";
       el_typ=DataTableCell;
       el_def=0;
      };
     };
     DataTable @["LayerLayout_previous"] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @["user_pinned"] {
	name="user_pinned";
	value 1 0=1;
	val_type_fixed=0;
       };
      };
      name="LayerLayout_previous";
      desc=;
      data {
       name="data";
       el_typ=int_Data;
       el_def=0;
       String_Data @["LayerName"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1671598;
	  val_type_fixed=0;
	 };
	};
	name="LayerName";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=113;
	ar {
	 name="ar";
	[3] "Input";"Hidden";"Output";	};
       };
       String_Data @["LayerGroup"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1656805;
	  val_type_fixed=0;
	 };
	};
	name="LayerGroup";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=112;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       String_Data @["LayoutGroup"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1671598;
	  val_type_fixed=0;
	 };
	};
	name="LayoutGroup";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=113;
	ar {
	 name="ar";
	[3] ;;;	};
       };
       int_Data @["X_Abs"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1065089;
	  val_type_fixed=0;
	 };
	};
	name="X_Abs";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Y_Abs"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1065089;
	  val_type_fixed=0;
	 };
	};
	name="Y_Abs";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Z_Abs"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1065089;
	  val_type_fixed=0;
	 };
	};
	name="Z_Abs";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
       int_Data @["X_Rel"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1065089;
	  val_type_fixed=0;
	 };
	};
	name="X_Rel";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Y_Rel"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["NARROW"] {
	  name="NARROW";
	  value 1 0=1;
	  val_type_fixed=0;
	 };
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1065089;
	  val_type_fixed=0;
	 };
	};
	name="Y_Rel";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=72;
	ar {
	 name="ar";
	[3] 0;0;0;	};
       };
       int_Data @["Z_Rel"] {
	UserDataItem_List @*(.user_data_) {
	 name=;
	 el_typ=UserDataItem;
	 el_def=0;
	 UserDataItem @["view_panel_wd"] {
	  name="view_panel_wd";
	  value 8 0=0.1005917;
	  val_type_fixed=0;
	 };
	};
	name="Z_Rel";
	col_flags=SAVE_ROWS|SAVE_DATA;
	is_matrix=0;
	cell_geom{ 1;	};
	calc_expr {
	 expr=;
	};
	dim_names {
	 name="dim_names";
	[0] 	};
	width=68;
	ar {
	 name="ar";
	[3] 0;1;2;	};
       };
      };
      data_flags=SAVE_ROWS|AUTO_CALC;
      auto_load=NO_AUTO_LOAD;
      auto_load_file=;
      keygen 4 0=0;
      row_indexes {
       name="row_indexes";
      [3] 0;1;2;      };
      last_sort_spec {
       name="last_sort_spec";
       ops {
	name="ops";
	el_typ=DataSortEl;
	el_def=0;
       };
      };
      control_panel_cells {
       name="control_panel_cells";
       el_typ=DataTableCell;
       el_def=0;
      };
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
     DynEnumType @["ActionType"] {
      name="ActionType";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @["GetCurrentPos"] {
	name="GetCurrentPos";
	value=0;
	desc="get current layer positions into table";
       };
       DynEnumItem @["SetPositions"] {
	name="SetPositions";
	value=1;
	desc="set layer positions based on table";
       };
      };
      bits=0;
     };
     DynEnumType @["UseGroup"] {
      name="UseGroup";
      desc=;
      enums {
       name="enums";
       el_typ=DynEnumItem;
       el_def=0;
       DynEnumItem @["IgnoreGroup"] {
	name="IgnoreGroup";
	value=0;
	desc="ignore any group information, and just use absolute positions";
       };
       DynEnumItem @["LayerGroup"] {
	name="LayerGroup";
	value=1;
	desc="use layer-group relative positions -- X_Rel etc in table";
       };
       DynEnumItem @["LayoutGroup"] {
	name="LayoutGroup";
	value=2;
	desc="use layout groups which are out side the structure of the model -- uses relative positions relative to these layout group offsets";
       };
      };
      bits=0;
     };
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["action"] {
      name="action";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].types["ActionType"]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["use_group"] {
      name="use_group";
      var_type=T_DynEnum;
      dyn_enum_val {
       enum_type=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].types["UseGroup"]$$;
       value=0;
      };
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["LayerLayout"] {
      name="LayerLayout";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].objs["LayerLayout"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["LayerLayout_previous"] {
      name="LayerLayout_previous";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].objs["LayerLayout_previous"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
     Function @["GetCurrent"] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="GetCurrent() returns: int";
      pre_compile_code_string="GetCurrent() returns: int";
      name="GetCurrent";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="ProgVar_List_1";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="ProgEl_List_62";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (4 vars)";
	pre_compile_code_string="LocalVars (4 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @["leaf"] {
	  name="leaf";
	  var_type=T_Int;
	  int_val=0;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["current_layer"] {
	  name="current_layer";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc="current_layer = NULL (Layer)";
	  init_from=NULL;
	 };
	 ProgVar @["net_layers"] {
	  name="net_layers";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["layer_group"] {
	  name="layer_group";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       MethodCall @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LayerLayout_previous->CopyFrom(LayerLayout)";
	pre_compile_code_string="LayerLayout_previous->CopyFrom(LayerLayout)";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].vars["LayerLayout_previous"]$$;
	method=taBase::CopyFrom;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=taBase_ptr;
	  type="taBase*";
	  name="cpy_from";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="LayerLayout";
	  };
	 };
	};
	meth_sig="bool CopyFrom(taBase* cpy_from)";
	meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
       };
       MethodCall @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LayerLayout->RemoveAllRows()";
	pre_compile_code_string="LayerLayout->RemoveAllRows()";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].vars["LayerLayout"]$$;
	method=DataTable::RemoveAllRows;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void RemoveAllRows()";
	meth_desc=" remove all of the rows of data, but keep the column structure";
       };
       AssignExpr @[3] {
	desc="all of the layers";
	flags=CAN_REVERT_TO_CODE;
	code_string="net_layers = network.layers";
	pre_compile_code_string="net_layers = network.layers";
	result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["GetCurrent"].fun_code[0].local_vars["net_layers"]$$;
	expr {
	 expr="network.layers";
	};
       };
       Comment @[4] {
	desc="first get all the layer groups";
	flags=CAN_REVERT_TO_CODE;
	code_string="// first get all the layer groups";
	pre_compile_code_string="// first get all the layer groups";
       };
       ForeachLoop @[5] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="foreach(layer_group in net_layers.gp)";
	pre_compile_code_string="foreach(layer_group in net_layers.gp)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout->AddBlankRow()";
	  pre_compile_code_string="LayerLayout->AddBlankRow()";
	  result_var=NULL;
	  obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].vars["LayerLayout"]$;
	  method=DataTable::AddBlankRow;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="int AddBlankRow()";
	  meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	 };
	 CssExpr @[1] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"LayerGroup\"][-1] = layer_group.name;";
	  pre_compile_code_string="LayerLayout[\"LayerGroup\"][-1] = layer_group.name;";
	  expr {
	   expr="LayerLayout[\"LayerGroup\"][-1] = layer_group.name;";
	  };
	 };
	 CssExpr @[2] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"X_Abs\"][-1] = layer_group.pos.x;";
	  pre_compile_code_string="LayerLayout[\"X_Abs\"][-1] = layer_group.pos.x;";
	  expr {
	   expr="LayerLayout[\"X_Abs\"][-1] = layer_group.pos.x;";
	  };
	 };
	 CssExpr @[3] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Y_Abs\"][-1] = layer_group.pos.y;";
	  pre_compile_code_string="LayerLayout[\"Y_Abs\"][-1] = layer_group.pos.y;";
	  expr {
	   expr="LayerLayout[\"Y_Abs\"][-1] = layer_group.pos.y;";
	  };
	 };
	 CssExpr @[4] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Z_Abs\"][-1] = layer_group.pos.z;";
	  pre_compile_code_string="LayerLayout[\"Z_Abs\"][-1] = layer_group.pos.z;";
	  expr {
	   expr="LayerLayout[\"Z_Abs\"][-1] = layer_group.pos.z;";
	  };
	 };
	};
	el_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["GetCurrent"].fun_code[0].local_vars["layer_group"]$$;
	in {
	 expr="net_layers.gp";
	};
       };
       ForLoop @[6] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="for (leaf=0; leaf <net_layers.leaves; leaf++)";
	pre_compile_code_string="for (leaf=0; leaf <net_layers.leaves; leaf++)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout->AddBlankRow()";
	  pre_compile_code_string="LayerLayout->AddBlankRow()";
	  result_var=NULL;
	  obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].vars["LayerLayout"]$;
	  method=DataTable::AddBlankRow;
	  meth_args {
	   name="meth_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="int AddBlankRow()";
	  meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	 };
	 AssignExpr @[1] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="current_layer = net_layers.Leaf(leaf)";
	  pre_compile_code_string="current_layer = net_layers.Leaf(leaf)";
	  result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["current_layer"]$$;
	  expr {
	   expr="net_layers.Leaf(leaf)";
	  };
	 };
	 CssExpr @[2] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"LayerName\"][-1] = current_layer.name;";
	  pre_compile_code_string="LayerLayout[\"LayerName\"][-1] = current_layer.name;";
	  expr {
	   expr="LayerLayout[\"LayerName\"][-1] = current_layer.name;";
	  };
	 };
	 If @[3] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (current_layer.InLayerSubGroup())";
	  pre_compile_code_string="if (current_layer.InLayerSubGroup())";
	  cond {
	   expr="current_layer.InLayerSubGroup()";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   CssExpr @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="LayerLayout[\"LayerGroup\"][-1] = current_layer.GetOwner().name;";
	    pre_compile_code_string="LayerLayout[\"LayerGroup\"][-1] = current_layer.GetOwner().name;";
	    expr {
	     expr="LayerLayout[\"LayerGroup\"][-1] = current_layer.GetOwner().name;";
	    };
	   };
	  };
	 };
	 CssExpr @[4] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"X_Abs\"][-1] = current_layer.pos_abs.x;";
	  pre_compile_code_string="LayerLayout[\"X_Abs\"][-1] = current_layer.pos_abs.x;";
	  expr {
	   expr="LayerLayout[\"X_Abs\"][-1] = current_layer.pos_abs.x;";
	  };
	 };
	 CssExpr @[5] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Y_Abs\"][-1] = current_layer.pos_abs.y;";
	  pre_compile_code_string="LayerLayout[\"Y_Abs\"][-1] = current_layer.pos_abs.y;";
	  expr {
	   expr="LayerLayout[\"Y_Abs\"][-1] = current_layer.pos_abs.y;";
	  };
	 };
	 CssExpr @[6] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Z_Abs\"][-1] = current_layer.pos_abs.z;";
	  pre_compile_code_string="LayerLayout[\"Z_Abs\"][-1] = current_layer.pos_abs.z;";
	  expr {
	   expr="LayerLayout[\"Z_Abs\"][-1] = current_layer.pos_abs.z;";
	  };
	 };
	 CssExpr @[7] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"X_Rel\"][-1] = current_layer.pos.x;";
	  pre_compile_code_string="LayerLayout[\"X_Rel\"][-1] = current_layer.pos.x;";
	  expr {
	   expr="LayerLayout[\"X_Rel\"][-1] = current_layer.pos.x;";
	  };
	 };
	 CssExpr @[8] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Y_Rel\"][-1] = current_layer.pos.y;";
	  pre_compile_code_string="LayerLayout[\"Y_Rel\"][-1] = current_layer.pos.y;";
	  expr {
	   expr="LayerLayout[\"Y_Rel\"][-1] = current_layer.pos.y;";
	  };
	 };
	 CssExpr @[9] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="LayerLayout[\"Z_Rel\"][-1] = current_layer.pos.z;";
	  pre_compile_code_string="LayerLayout[\"Z_Rel\"][-1] = current_layer.pos.z;";
	  expr {
	   expr="LayerLayout[\"Z_Rel\"][-1] = current_layer.pos.z;";
	  };
	 };
	};
	init {
	 expr="leaf=0";
	};
	test {
	 expr="leaf <net_layers.leaves";
	};
	iter {
	 expr="leaf++";
	};
       };
      };
     };
     Function @["SetPos"] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="SetPos() returns: int";
      pre_compile_code_string="SetPos() returns: int";
      name="SetPos";
      return_type=T_Int;
      object_type=taOBase;
      args {
       name="ProgVar_List_1";
       el_typ=ProgVar;
       el_def=0;
      };
      fun_code {
       name="ProgEl_List_66";
       el_typ=ProgCode;
       el_def=0;
       LocalVars @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="LocalVars (9 vars)";
	pre_compile_code_string="LocalVars (9 vars)";
	local_vars {
	 name="local_vars";
	 el_typ=ProgVar;
	 el_def=0;
	 ProgVar @["row"] {
	  name="row";
	  var_type=T_Int;
	  int_val=0;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["current_layer"] {
	  name="current_layer";
	  var_type=T_Object;
	  object_type=Layer;
	  object_val=NULL;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["layer_name"] {
	  name="layer_name";
	  var_type=T_String;
	  string_val=;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["layer_group"] {
	  name="layer_group";
	  var_type=T_Object;
	  object_type=Layer_Group;
	  object_val=NULL;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["group_name"] {
	  name="group_name";
	  var_type=T_String;
	  string_val=;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["lgrow"] {
	  name="lgrow";
	  var_type=T_Int;
	  int_val=0;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["lg_x"] {
	  name="lg_x";
	  var_type=T_Int;
	  int_val=0;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["lg_y"] {
	  name="lg_y";
	  var_type=T_Int;
	  int_val=0;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	 ProgVar @["lg_z"] {
	  name="lg_z";
	  var_type=T_Int;
	  int_val=0;
	  objs_ptr=0;
	  flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	  reference=0;
	  desc=;
	  init_from=NULL;
	 };
	};
       };
       ForLoop @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="for (row = 0; row <LayerLayout.rows; row++)";
	pre_compile_code_string="for (row = 0; row <LayerLayout.rows; row++)";
	loop_code {
	 name="loop_code";
	 el_typ=ProgCode;
	 el_def=0;
	 AssignExpr @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="layer_name = LayerLayout[\"LayerName\"][row]";
	  pre_compile_code_string="layer_name = LayerLayout[\"LayerName\"][row]";
	  result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["layer_name"]$$;
	  expr {
	   expr="LayerLayout[\"LayerName\"][row]";
	  };
	 };
	 IfContinue @[1] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if(layer_name.empty()) continue";
	  pre_compile_code_string="if(layer_name.empty()) continue";
	  cond {
	   expr="layer_name.empty()";
	  };
	 };
	 AssignExpr @[2] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="current_layer = network.FindLayer(layer_name)";
	  pre_compile_code_string="current_layer = network.FindLayer(layer_name)";
	  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["current_layer"]$;
	  expr {
	   expr="network.FindLayer(layer_name)";
	  };
	 };
	 If @[3] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="if (current_layer)";
	  pre_compile_code_string="if (current_layer)";
	  cond {
	   expr="current_layer";
	  };
	  true_code {
	   name="true_code";
	   el_typ=ProgCode;
	   el_def=0;
	   Switch @[0] {
	    desc=;
	    flags=CAN_REVERT_TO_CODE;
	    code_string="switch(use_group)";
	    pre_compile_code_string="switch(use_group)";
	    switch_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].args["use_group"]$$;
	    cases {
	     name="cases";
	     el_typ=CaseBlock;
	     el_def=0;
	     CaseBlock @[0] {
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="case: IgnoreGroup";
	      pre_compile_code_string="case: IgnoreGroup";
	      prog_code {
	       name="prog_code";
	       el_typ=ProgCode;
	       el_def=0;
	       MethodCall @[0] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="current_layer->SetAbsPos(LayerLayout[\"X_Abs\"][row], LayerLayout[\"Y_Abs\"][row], LayerLayout[\"Z_Abs\"][row])";
		pre_compile_code_string="current_layer->SetAbsPos(LayerLayout[\"X_Abs\"][row], LayerLayout[\"Y_Abs\"][row], LayerLayout[\"Z_Abs\"][row])";
		result_var=NULL;
		obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["current_layer"]$;
		method=Layer::SetAbsPos;
		meth_args {
		 name="meth_args";
		 el_typ=ProgArg;
		 el_def=0;
		 ProgArg @[0] {
		  arg_type=int;
		  type="int";
		  name="x";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="LayerLayout[\"X_Abs\"][row]";
		  };
		 };
		 ProgArg @[1] {
		  arg_type=int;
		  type="int";
		  name="y";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="LayerLayout[\"Y_Abs\"][row]";
		  };
		 };
		 ProgArg @[2] {
		  arg_type=int;
		  type="int";
		  name="z";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="LayerLayout[\"Z_Abs\"][row]";
		  };
		 };
		};
		meth_sig="void SetAbsPos(int x, int y, int z)";
		meth_desc=" set absolute position of layer, regardless of whether it is in a layer group or not - always relative to network 0,0,0";
	       };
	      };
	      case_val {
	       expr="IgnoreGroup";
	      };
	      is_default=0;
	     };
	     CaseBlock @[1] {
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="case: LayerGroup";
	      pre_compile_code_string="case: LayerGroup";
	      prog_code {
	       name="prog_code";
	       el_typ=ProgCode;
	       el_def=0;
	       AssignExpr @[0] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="group_name = LayerLayout[\"LayerGroup\"][row]";
		pre_compile_code_string="group_name = LayerLayout[\"LayerGroup\"][row]";
		result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["group_name"]$$;
		expr {
		 expr="LayerLayout[\"LayerGroup\"][row]";
		};
	       };
	       If @[1] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="if (group_name.nonempty())";
		pre_compile_code_string="if (group_name.nonempty())";
		cond {
		 expr="group_name.nonempty()";
		};
		true_code {
		 name="true_code";
		 el_typ=ProgCode;
		 el_def=0;
		 MethodCall @[0] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lgrow = LayerLayout->FindVal(group_name, \"LayerGroup\", 0, true)";
		  pre_compile_code_string="lgrow = LayerLayout->FindVal(group_name, \"LayerGroup\", 0, true)";
		  result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lgrow"]$$;
		  obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].vars["LayerLayout"]$;
		  method=DataTable::FindVal;
		  meth_args {
		   name="meth_args";
		   el_typ=ProgArg;
		   el_def=0;
		   ProgArg @[0] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="val";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="group_name";
		    };
		   };
		   ProgArg @[1] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="col";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="\"LayerGroup\"";
		    };
		   };
		   ProgArg @[2] {
		    arg_type=int;
		    type="int";
		    name="st_row";
		    required=0;
		    def_val="0";
		    prev_expr=;
		    expr {
		     expr="0";
		    };
		   };
		   ProgArg @[3] {
		    arg_type=bool;
		    type="bool";
		    name="not_found_err";
		    required=0;
		    def_val="false";
		    prev_expr=;
		    expr {
		     expr="true";
		    };
		   };
		  };
		  meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
		  meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
		 };
		 AssignExpr @[1] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = LayerLayout[\"X_Abs\"][lgrow]";
		  pre_compile_code_string="lg_x = LayerLayout[\"X_Abs\"][lgrow]";
		  result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_x"]$$;
		  expr {
		   expr="LayerLayout[\"X_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[2] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = LayerLayout[\"Y_Abs\"][lgrow]";
		  pre_compile_code_string="lg_y = LayerLayout[\"Y_Abs\"][lgrow]";
		  result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_y"]$$;
		  expr {
		   expr="LayerLayout[\"Y_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[3] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = LayerLayout[\"Z_Abs\"][lgrow]";
		  pre_compile_code_string="lg_z = LayerLayout[\"Z_Abs\"][lgrow]";
		  result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_z"]$$;
		  expr {
		   expr="LayerLayout[\"Z_Abs\"][lgrow]";
		  };
		 };
		};
	       };
	       Else @[2] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="else";
		pre_compile_code_string="else";
		else_code {
		 name="else_code";
		 el_typ=ProgCode;
		 el_def=0;
		 AssignExpr @[0] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = 0";
		  pre_compile_code_string="lg_x = 0";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_x"]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[1] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = 0";
		  pre_compile_code_string="lg_y = 0";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_y"]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[2] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = 0";
		  pre_compile_code_string="lg_z = 0";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_z"]$;
		  expr {
		   expr="0";
		  };
		 };
		};
	       };
	       MethodCall @[3] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="current_layer->SetAbsPos(lg_x + LayerLayout[\"X_Rel\"][row], lg_y + LayerLayout[\"Y_Rel\"][row], lg_z + LayerLayout[\"Z_Rel\"][row])";
		pre_compile_code_string="current_layer->SetAbsPos(lg_x + LayerLayout[\"X_Rel\"][row], lg_y + LayerLayout[\"Y_Rel\"][row], lg_z + LayerLayout[\"Z_Rel\"][row])";
		result_var=NULL;
		obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["current_layer"]$;
		method=Layer::SetAbsPos;
		meth_args {
		 name="meth_args";
		 el_typ=ProgArg;
		 el_def=0;
		 ProgArg @[0] {
		  arg_type=int;
		  type="int";
		  name="x";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_x + LayerLayout[\"X_Rel\"][row]";
		  };
		 };
		 ProgArg @[1] {
		  arg_type=int;
		  type="int";
		  name="y";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_y + LayerLayout[\"Y_Rel\"][row]";
		  };
		 };
		 ProgArg @[2] {
		  arg_type=int;
		  type="int";
		  name="z";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_z + LayerLayout[\"Z_Rel\"][row]";
		  };
		 };
		};
		meth_sig="void SetAbsPos(int x, int y, int z)";
		meth_desc=" set absolute position of layer, regardless of whether it is in a layer group or not - always relative to network 0,0,0";
	       };
	      };
	      case_val {
	       expr="LayerGroup";
	      };
	      is_default=0;
	     };
	     CaseBlock @[2] {
	      desc=;
	      flags=CAN_REVERT_TO_CODE;
	      code_string="case: LayoutGroup";
	      pre_compile_code_string="case: LayoutGroup";
	      prog_code {
	       name="prog_code";
	       el_typ=ProgCode;
	       el_def=0;
	       AssignExpr @[0] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="group_name = LayerLayout[\"LayoutGroup\"][row]";
		pre_compile_code_string="group_name = LayerLayout[\"LayoutGroup\"][row]";
		result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["group_name"]$;
		expr {
		 expr="LayerLayout[\"LayoutGroup\"][row]";
		};
	       };
	       If @[1] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="if (group_name.nonempty())";
		pre_compile_code_string="if (group_name.nonempty())";
		cond {
		 expr="group_name.nonempty()";
		};
		true_code {
		 name="true_code";
		 el_typ=ProgCode;
		 el_def=0;
		 MethodCall @[0] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lgrow = LayerLayout->FindVal(group_name, \"LayoutGroup\", 0, true)";
		  pre_compile_code_string="lgrow = LayerLayout->FindVal(group_name, \"LayoutGroup\", 0, true)";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lgrow"]$;
		  obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].vars["LayerLayout"]$;
		  method=DataTable::FindVal;
		  meth_args {
		   name="meth_args";
		   el_typ=ProgArg;
		   el_def=0;
		   ProgArg @[0] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="val";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="group_name";
		    };
		   };
		   ProgArg @[1] {
		    arg_type=const_Variant_ref;
		    type="Variant&";
		    name="col";
		    required=1;
		    def_val=;
		    prev_expr=;
		    expr {
		     expr="\"LayoutGroup\"";
		    };
		   };
		   ProgArg @[2] {
		    arg_type=int;
		    type="int";
		    name="st_row";
		    required=0;
		    def_val="0";
		    prev_expr=;
		    expr {
		     expr="0";
		    };
		   };
		   ProgArg @[3] {
		    arg_type=bool;
		    type="bool";
		    name="not_found_err";
		    required=0;
		    def_val="false";
		    prev_expr=;
		    expr {
		     expr="true";
		    };
		   };
		  };
		  meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
		  meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
		 };
		 AssignExpr @[1] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = LayerLayout[\"X_Abs\"][lgrow]";
		  pre_compile_code_string="lg_x = LayerLayout[\"X_Abs\"][lgrow]";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_x"]$;
		  expr {
		   expr="LayerLayout[\"X_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[2] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = LayerLayout[\"Y_Abs\"][lgrow]";
		  pre_compile_code_string="lg_y = LayerLayout[\"Y_Abs\"][lgrow]";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_y"]$;
		  expr {
		   expr="LayerLayout[\"Y_Abs\"][lgrow]";
		  };
		 };
		 AssignExpr @[3] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = LayerLayout[\"Z_Abs\"][lgrow]";
		  pre_compile_code_string="lg_z = LayerLayout[\"Z_Abs\"][lgrow]";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_z"]$;
		  expr {
		   expr="LayerLayout[\"Z_Abs\"][lgrow]";
		  };
		 };
		};
	       };
	       Else @[2] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="else";
		pre_compile_code_string="else";
		else_code {
		 name="else_code";
		 el_typ=ProgCode;
		 el_def=0;
		 AssignExpr @[0] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_x = 0";
		  pre_compile_code_string="lg_x = 0";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_x"]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[1] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_y = 0";
		  pre_compile_code_string="lg_y = 0";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_y"]$;
		  expr {
		   expr="0";
		  };
		 };
		 AssignExpr @[2] {
		  desc=;
		  flags=CAN_REVERT_TO_CODE;
		  code_string="lg_z = 0";
		  pre_compile_code_string="lg_z = 0";
		  result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["lg_z"]$;
		  expr {
		   expr="0";
		  };
		 };
		};
	       };
	       MethodCall @[3] {
		desc=;
		flags=CAN_REVERT_TO_CODE;
		code_string="current_layer->SetAbsPos(lg_x + LayerLayout[\"X_Rel\"][row], lg_y + LayerLayout[\"Y_Rel\"][row], lg_z + LayerLayout[\"Z_Rel\"][row])";
		pre_compile_code_string="current_layer->SetAbsPos(lg_x + LayerLayout[\"X_Rel\"][row], lg_y + LayerLayout[\"Y_Rel\"][row], lg_z + LayerLayout[\"Z_Rel\"][row])";
		result_var=NULL;
		obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"].fun_code[0].local_vars["current_layer"]$;
		method=Layer::SetAbsPos;
		meth_args {
		 name="meth_args";
		 el_typ=ProgArg;
		 el_def=0;
		 ProgArg @[0] {
		  arg_type=int;
		  type="int";
		  name="x";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_x + LayerLayout[\"X_Rel\"][row]";
		  };
		 };
		 ProgArg @[1] {
		  arg_type=int;
		  type="int";
		  name="y";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_y + LayerLayout[\"Y_Rel\"][row]";
		  };
		 };
		 ProgArg @[2] {
		  arg_type=int;
		  type="int";
		  name="z";
		  required=1;
		  def_val=;
		  prev_expr=;
		  expr {
		   expr="lg_z + LayerLayout[\"Z_Rel\"][row]";
		  };
		 };
		};
		meth_sig="void SetAbsPos(int x, int y, int z)";
		meth_desc=" set absolute position of layer, regardless of whether it is in a layer group or not - always relative to network 0,0,0";
	       };
	      };
	      case_val {
	       expr="LayoutGroup";
	      };
	      is_default=0;
	     };
	    };
	   };
	  };
	 };
	};
	init {
	 expr="row = 0";
	};
	test {
	 expr="row <LayerLayout.rows";
	};
	iter {
	 expr="row++";
	};
       };
       MethodCall @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Build()";
	pre_compile_code_string="network->Build()";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].args["network"]$$;
	method=LeabraNetwork::Build;
	meth_args {
	 name="meth_args";
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Build()";
	meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
       };
      };
     };
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     Switch @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="switch(action)";
      pre_compile_code_string="switch(action)";
      switch_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].args["action"]$$;
      cases {
       name="cases";
       el_typ=CaseBlock;
       el_def=0;
       CaseBlock @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="case: GetCurrentPos";
	pre_compile_code_string="case: GetCurrentPos";
	prog_code {
	 name="prog_code";
	 el_typ=ProgCode;
	 el_def=0;
	 FunctionCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="GetCurrent()";
	  pre_compile_code_string="GetCurrent()";
	  result_var=NULL;
	  fun=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["GetCurrent"]$$;
	  fun_args {
	   name="fun_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	case_val {
	 expr="GetCurrentPos";
	};
	is_default=0;
       };
       CaseBlock @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="case: SetPositions";
	pre_compile_code_string="case: SetPositions";
	prog_code {
	 name="prog_code";
	 el_typ=ProgCode;
	 el_def=0;
	 FunctionCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="SetPos()";
	  pre_compile_code_string="SetPos()";
	  result_var=NULL;
	  fun=.projects["LeabraFlex"].programs.gp["UtilProgs"]["PositionLayersFromTable"].functions["SetPos"]$$;
	  fun_args {
	   name="fun_args";
	   el_typ=ProgArg;
	   el_def=0;
	  };
	 };
	};
	case_val {
	 expr="SetPositions";
	};
	is_default=0;
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["NetworkToggleLesion"] {
    name="NetworkToggleLesion";
    short_nm="NtwTgg";
    tags=;
    desc="toggle lesion status on or off in network -- for dynamic speedup..";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=String_Matrix;
     el_def=0;
     String_Matrix @["les_lay_mat"] {
      name="les_lay_mat";
     [4] "V1Low";"SC";"Eye";"Head";     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="required for the batch counter";
      init_from=NULL;
     };
     ProgVar @["lesion_layers"] {
      name="lesion_layers";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="a space delimited list of layer group names to lesion or unlesion";
      init_from=NULL;
     };
     ProgVar @["lesion"] {
      name="lesion";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="if true, lesion the layer groups, otherwise unlesion them";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["les_lay_mat"] {
      name="les_lay_mat";
      var_type=T_Object;
      object_type=String_Matrix;
      object_val=.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].objs["les_lay_mat"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["i"] {
      name="i";
      var_type=T_Int;
      int_val=4;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["laygp_nm"] {
      name="laygp_nm";
      var_type=T_String;
      string_val="Head";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["laygp"] {
      name="laygp";
      var_type=T_Object;
      object_type=Layer_Group;
      object_val=NULL;
      objs_ptr=0;
      flags=SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="get into easier to use matrix format";
      flags=CAN_REVERT_TO_CODE;
      code_string="les_lay_mat->FmDelimString(lesion_layers, \" \")";
      pre_compile_code_string="les_lay_mat->FmDelimString(lesion_layers, \" \")";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].vars["les_lay_mat"]$$;
      method=String_Matrix::FmDelimString;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="str";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="lesion_layers";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="delim";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="\" \"";
	};
       };
      };
      meth_sig="void FmDelimString(taString& str, taString& delim)";
      meth_desc=" fill this matrix by parsing given string using given delimiter separating strings -- increases size as necessary to fit everything";
     };
     ForLoop @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (i = 0; i < les_lay_mat.size; i++)";
      pre_compile_code_string="for (i = 0; i < les_lay_mat.size; i++)";
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp_nm = les_lay_mat->SafeEl_Flat(i)";
	pre_compile_code_string="laygp_nm = les_lay_mat->SafeEl_Flat(i)";
	result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].vars["laygp_nm"]$$;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].vars["les_lay_mat"]$;
	method=taMatrixT_taString_::SafeEl_Flat;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=int;
	  type="int";
	  name="idx";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="i";
	  };
	 };
	};
	meth_sig="const_taString_ref SafeEl_Flat(int idx)";
	meth_desc=" (safely) access the matrix as if it were a flat vector, for reading";
       };
       MemberMethodCall @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="laygp = network.layers.gp.FindName(laygp_nm)";
	pre_compile_code_string="laygp = network.layers.gp.FindName(laygp_nm)";
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].args["network"]$$;
	path="layers.gp";
	result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].vars["laygp"]$$;
	method=taGroup_Layer_::FindName;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="item_nm";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="laygp_nm";
	  };
	 };
	};
	meth_sig="Layer_ptr FindName(taString& item_nm)";
	meth_desc=" Find element in top-level list with given name (nm) (NULL = not here)";
       };
       If @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (!laygp)";
	pre_compile_code_string="if (!laygp)";
	cond {
	 expr="!laygp";
	};
	true_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 MiscCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	  pre_compile_code_string="taMisc::Error(\"layer group named:\", laygp_nm, \"not found in network:\", network.name, , , , , )";
	  result_var=NULL;
	  object_type=taMisc;
	  method=taMisc::Error;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	   ProgArg @[0] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="a";
	    required=1;
	    def_val=;
	    prev_expr=;
	    expr {
	     expr="\"layer group named:\"";
	    };
	   };
	   ProgArg @[1] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="b";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="laygp_nm";
	    };
	   };
	   ProgArg @[2] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="c";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="\"not found in network:\"";
	    };
	   };
	   ProgArg @[3] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="d";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr="network.name";
	    };
	   };
	   ProgArg @[4] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="e";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[5] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="f";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[6] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="g";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[7] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="h";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	   ProgArg @[8] {
	    arg_type=const_char_ptr;
	    type="char*";
	    name="i";
	    required=0;
	    def_val="0";
	    prev_expr=;
	    expr {
	     expr=;
	    };
	   };
	  };
	 };
	 IfContinue @[1] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="continue";
	  pre_compile_code_string="continue";
	  cond {
	   expr=;
	  };
	 };
	};
       };
       If @[3] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="if (lesion)";
	pre_compile_code_string="if (lesion)";
	cond {
	 expr="lesion";
	};
	true_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp->LesionLayers()";
	  pre_compile_code_string="laygp->LesionLayers()";
	  result_var=NULL;
	  obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].vars["laygp"]$;
	  method=Layer_Group::LesionLayers;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void LesionLayers()";
	  meth_desc=" set the lesion flag on all the layers within this group -- removes them from all processing operations";
	 };
	};
       };
       Else @[4] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="else";
	pre_compile_code_string="else";
	else_code {
	 name=;
	 el_typ=ProgCode;
	 el_def=0;
	 MethodCall @[0] {
	  desc=;
	  flags=CAN_REVERT_TO_CODE;
	  code_string="laygp->UnLesionLayers()";
	  pre_compile_code_string="laygp->UnLesionLayers()";
	  result_var=NULL;
	  obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].vars["laygp"]$;
	  method=Layer_Group::UnLesionLayers;
	  meth_args {
	   name=;
	   el_typ=ProgArg;
	   el_def=0;
	  };
	  meth_sig="void UnLesionLayers()";
	  meth_desc=" un-set the lesion flag on all the layers within this group -- restores them to engage in normal processing";
	 };
	};
       };
      };
      init {
       expr="i = 0";
      };
      test {
       expr="i < les_lay_mat.size";
      };
      iter {
       expr="i++";
      };
     };
     MethodCall @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->UpdtAfterNetMod()";
      pre_compile_code_string="network->UpdtAfterNetMod()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["NetworkToggleLesion"].args["network"]$;
      method=Network::UpdtAfterNetMod;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void UpdtAfterNetMod()";
      meth_desc=" update network after any network modification (calls appropriate functions)";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["TrainStart"] {
    name="TrainStart";
    short_nm="TrnStart";
    tags=;
    desc="basic stuff (init weights, load weights etc) at start of training -- also calls EpochStart -- most init progs will call this";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
     RndSeed @["dmem_rnd_seed"] {
      name="dmem_rnd_seed";
      rnd_seed=1439355325;
     };
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["weights_file"] {
      name="weights_file";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
     };
     ProgVar @["load_weights"] {
      name="load_weights";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
     };
     ProgVar @["load_st_epc"] {
      name="load_st_epc";
      var_type=T_Int;
      int_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
     };
     ProgVar @["lrs_step_epochs"] {
      name="lrs_step_epochs";
      var_type=T_Int;
      int_val=50;
      objs_ptr=0;
      flags=CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc="fm enviro";
      init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
     };
     ProgVar @["LRSConSpec"] {
      name="LRSConSpec";
      var_type=T_Object;
      object_type=LeabraConSpec;
      object_val=$.projects["LeabraFlex"].networks["Network_0"].specs["LeabraConSpec_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["dmem_rnd_seed"] {
      name="dmem_rnd_seed";
      var_type=T_Object;
      object_type=RndSeed;
      object_val=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].objs["dmem_rnd_seed"]$$;
      objs_ptr=1;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["dmem_new_seed"] {
      name="dmem_new_seed";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="when running under dmem (MPI), generate a new random seed for each node after common initialization, to cause each node to have different random events, etc.   It is now possible to add taMisc::dmem_proc to the thr_no args to any random functions, and achieve fully reproducible results without this randomization.";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     ProgramCall @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="BatchRndSeed(network)";
      pre_compile_code_string="BatchRndSeed(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["BatchRndSeed"]$$;
      targ_ld_init="*BatchRndSeed*";
     };
     MethodCall @[1] {
      desc="needs to have been built by now..";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Build()";
      pre_compile_code_string="network->Build()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].args["network"]$$;
      method=Network::Build;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Build()";
      meth_desc=" Build the network units and Connect them (calls CheckSpecs/BuildLayers/Units/Prjns and Connect)";
     };
     If @[2] {
      desc="save log files for background, non-interactive jobs -- after network is fully configured and built";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (!taMisc::interactive)";
      pre_compile_code_string="if (!taMisc::interactive)";
      cond {
       expr="!taMisc::interactive";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveLogFiles(network)";
	pre_compile_code_string="SaveLogFiles(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"]$$;
	targ_ld_init="*SaveLogFiles*";
       };
      };
     };
     MethodCall @[3] {
      desc="initialize network weights: could also load pre-set weights or something else here";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_Weights()";
      pre_compile_code_string="network->Init_Weights()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].args["network"]$;
      method=Network::Init_Weights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_Weights()";
      meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
     };
     PrintExpr @[4] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Print network.name << \" Weights Initialized\"";
      pre_compile_code_string="Print network.name << \" Weights Initialized\"";
      expr {
       expr="network.name << \" Weights Initialized\"";
      };
      debug=0;
     };
     If @[5] {
      desc="Load  weights if file is specified";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (load_weights && weights_file.nonempty())";
      pre_compile_code_string="if (load_weights && weights_file.nonempty())";
      cond {
       expr="load_weights && weights_file.nonempty()";
      };
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="Load weights from the specified file";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->LoadWeights(weights_file, false)";
	pre_compile_code_string="network->LoadWeights(weights_file, false)";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].args["network"]$;
	method=Network::LoadWeights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=const_taString_ref;
	  type="taString&";
	  name="fname";
	  required=0;
	  def_val="\"\"";
	  prev_expr=;
	  expr {
	   expr="weights_file";
	  };
	 };
	 ProgArg @[1] {
	  arg_type=bool;
	  type="bool";
	  name="quiet";
	  required=0;
	  def_val="false";
	  prev_expr=;
	  expr {
	   expr="false";
	  };
	 };
	};
	meth_sig="bool LoadWeights(taString& fname, bool quiet = false)";
	meth_desc=" read weight values in from a simple ordered list of weights (fmt is read from file) (leave fname empty to pull up file chooser)";
       };
       PrintVar @[1] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="Print  \"loaded weights file:\" weights_file";
	pre_compile_code_string="Print  \"loaded weights file:\" weights_file";
	message="loaded weights file:";
	print_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].vars["weights_file"]$$;
	print_var2=NULL;
	print_var3=NULL;
	print_var4=NULL;
	print_var5=NULL;
	print_var6=NULL;
	debug=0;
       };
       MemberAssign @[2] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="network.epoch = load_st_epc";
	pre_compile_code_string="network.epoch = load_st_epc";
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].args["network"]$;
	path="epoch";
	expr {
	 expr="load_st_epc";
	};
	update_after=1;
       };
      };
     };
     MethodCall @[6] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LRSConSpec->LogLrateSched(lrs_step_epochs, 7)";
      pre_compile_code_string="LRSConSpec->LogLrateSched(lrs_step_epochs, 7)";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].vars["LRSConSpec"]$$;
      method=LeabraConSpec::LogLrateSched;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="epcs_per_step";
	required=0;
	def_val="50";
	prev_expr=;
	expr {
	 expr="lrs_step_epochs";
	};
       };
       ProgArg @[1] {
	arg_type=float;
	type="float";
	name="n_steps";
	required=0;
	def_val="7";
	prev_expr=;
	expr {
	 expr="7";
	};
       };
      };
      meth_sig="void LogLrateSched(int epcs_per_step = 50, float n_steps = 7)";
      meth_desc=" establish a logarithmic learning rate schedule with given total number of steps (including first step at lrate) and epochs per step: numbers go down in sequence: 1, .5, .2, .1, .05, .02, .01, etc.. this is a particularly good lrate schedule for large nets on hard tasks";
     };
     If @[7] {
      desc="if dmem, then from here on out, processors diverge so that lists of objs per processor are different!";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (dmem_new_seed && taMisc::dmem_nprocs > 1)";
      pre_compile_code_string="if (dmem_new_seed && taMisc::dmem_nprocs > 1)";
      cond {
       expr="dmem_new_seed && taMisc::dmem_nprocs > 1";
      };
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
	flags=CAN_REVERT_TO_CODE;
	code_string="dmem_rnd_seed->NewSeed()";
	pre_compile_code_string="dmem_rnd_seed->NewSeed()";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainStart"].vars["dmem_rnd_seed"]$$;
	method=RndSeed::NewSeed;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void NewSeed()";
	meth_desc=" set the seed to a new random value (based on time and process id)";
       };
      };
     };
     ProgramCall @[8] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="EpochStart(network)";
      pre_compile_code_string="EpochStart(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochStart"]$;
      targ_ld_init="*EpochStart*";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["TrainEnd"] {
    name="TrainEnd";
    short_nm="TrnEnd";
    tags=;
    desc="end training -- save weights if needed, compute final summary stats -- and set stop_train";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["save_final_wts"] {
      name="save_final_wts";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc=;
      init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
     };
     ProgVar @["Train"] {
      name="Train";
      var_type=T_Object;
      object_type=Program;
      object_val=$.projects["LeabraFlex"].programs.gp["ConfigProgs"]["MasterTrain"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     If @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (save_final_wts)";
      pre_compile_code_string="if (save_final_wts)";
      cond {
       expr="save_final_wts";
      };
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="Always save weights at the end";
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeights(network)";
	pre_compile_code_string="SaveWeights(network)";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"]$;
	targ_ld_init="*SaveWeights*";
       };
      };
     };
     MethodCall @[1] {
      desc="stop training!";
      flags=CAN_REVERT_TO_CODE;
      code_string="Train->SetVar(\"stop_train\", true)";
      pre_compile_code_string="Train->SetVar(\"stop_train\", true)";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrainEnd"].vars["Train"]$$;
      method=Program::SetVar;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="var_nm";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\"stop_train\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_Variant_ref;
	type="Variant&";
	name="value";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="bool SetVar(taString& var_nm, Variant& value)";
      meth_desc=" set the value of a program variable (only top-level variables in vars or args) -- can be called from within a running program";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["EpochStart"] {
    name="EpochStart";
    short_nm="EpcStart";
    tags=;
    desc="Start a new epoch";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["trial_mon_data"] {
      name="trial_mon_data";
      var_type=T_Object;
      object_type=DataTable;
      object_val=.projects["LeabraFlex"].data.gp["OutputData"]["TrialOutputData"]$$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
      init_from=NULL;
     };
     ProgVar @["BasicTrainTime"] {
      name="BasicTrainTime";
      var_type=T_Object;
      object_type=TimeUsed;
      object_val=$.projects["LeabraFlex"].programs.gp["TaskProgs"]["BasicTrain"].objs["BasicTrainTime"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MemberAssign @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network.trial = 0";
      pre_compile_code_string="network.trial = 0";
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochStart"].args["network"]$$;
      path="trial";
      expr {
       expr="0";
      };
      update_after=0;
     };
     MemberMethodCall @[1] {
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.epoch_time.StartTimer(true)";
      pre_compile_code_string="network.epoch_time.StartTimer(true)";
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochStart"].args["network"]$;
      path="epoch_time";
      result_var=NULL;
      method=TimeUsed::StartTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=bool;
	type="bool";
	name="reset_used";
	required=0;
	def_val="true";
	prev_expr=;
	expr {
	 expr="true";
	};
       };
      };
      meth_sig="void StartTimer(bool reset_used = true)";
      meth_desc=" record the current time as the starting time, and optionally reset the time used information";
     };
     MethodCall @[2] {
      desc="keep other time info on an epoch basis";
      flags=CAN_REVERT_TO_CODE;
      code_string="BasicTrainTime->ResetUsed()";
      pre_compile_code_string="BasicTrainTime->ResetUsed()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochStart"].vars["BasicTrainTime"]$$;
      method=TimeUsed::ResetUsed;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetUsed()";
      meth_desc=" reset time used information";
     };
     MethodCall @[3] {
      desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn flags OFF to accumulate trial data across entire training run)";
      flags=CAN_REVERT_TO_CODE;
      code_string="trial_mon_data->ResetData()";
      pre_compile_code_string="trial_mon_data->ResetData()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochStart"].vars["trial_mon_data"]$$;
      method=DataTable::ResetData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void ResetData()";
      meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["EpochEnd"] {
    name="EpochEnd";
    short_nm="EpcEnd";
    tags=;
    desc="end of epoch -- relnet and basic stats compute, calls only the core standard monitor, save weights if doing that";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["save_wts_interval"] {
      name="save_wts_interval";
      var_type=T_Int;
      int_val=200;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
      reference=0;
      desc=;
      init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="network accumulates some core statistics over the epoch -- this finalizes that process and computes summary stats";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Compute_EpochStats()";
      pre_compile_code_string="network->Compute_EpochStats()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochEnd"].args["network"]$$;
      method=LeabraNetwork::Compute_EpochStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Compute_EpochStats()";
      meth_desc=" compute epoch-level statistics; calls DMem_ComputeAggs (if dmem) and EpochSSE -- specific algos may add more compute epoch-level statistics, including SSE, AvgExtRew and AvgCycles";
     };
     MemberMethodCall @[1] {
      desc="start the epoch timer to record computation time per epoch";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.epoch_time.EndTimer()";
      pre_compile_code_string="network.epoch_time.EndTimer()";
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["EpochEnd"].args["network"]$;
      path="epoch_time";
      result_var=NULL;
      method=TimeUsed::EndTimer;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void EndTimer()";
      meth_desc=" record the current time as the ending time, and compute difference as the time used";
     };
     ProgramCall @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LeabraEpochMonitor(network)";
      pre_compile_code_string="LeabraEpochMonitor(network)";
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=Network;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"]$$;
      targ_ld_init="*LeabraEpochMonitor*";
     };
     If @[3] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network->epoch % save_wts_interval == 0 && network->epoch > 0)";
      pre_compile_code_string="if (network->epoch % save_wts_interval == 0 && network->epoch > 0)";
      cond {
       expr="network->epoch % save_wts_interval == 0 && network->epoch > 0";
      };
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc=;
	flags=CAN_REVERT_TO_CODE;
	code_string="SaveWeights(network)";
	pre_compile_code_string="SaveWeights(network)";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"]$;
	targ_ld_init="*SaveWeightsSpecs*";
       };
      };
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["TrialStart"] {
    name="TrialStart";
    short_nm="TrStrt";
    tags=;
    desc="start of trial before any input data applied -- prepares for input data to be applied (Init_InputData)";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- updates batch counter on network and passes it to train program";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      pre_compile_code_string="network->Trial_Init()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialStart"].args["network"]$$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     If @[1] {
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      pre_compile_code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name="true_code";
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="update the weight values -- do this at start so that dwt value is valid at end of trial";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	pre_compile_code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialStart"].args["network"]$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[2] {
      desc="resets input data, before getting new external inputs data from apply inputs call";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Init_InputData()";
      pre_compile_code_string="network->Init_InputData()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialStart"].args["network"]$;
      method=Network::Init_InputData;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Init_InputData()";
      meth_desc=" Initializes external and target inputs";
     };
     MemberAssign @[3] {
      desc="start at 0 cycle";
      flags=CAN_REVERT_TO_CODE;
      code_string="network.cycle = 0";
      pre_compile_code_string="network.cycle = 0";
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialStart"].args["network"]$;
      path="cycle";
      expr {
       expr="0";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["TrialEnd"] {
    name="TrialEnd";
    short_nm="TrlEnd";
    tags=;
    desc="standard end-of-trial code -- no monitor calls at all";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="after the trial is over, do final computations: Compute_AbsRelNetin";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      pre_compile_code_string="network->Trial_Final()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialEnd"].args["network"]$$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     NetUpdateView @[1] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialEnd"].args["network"]$;
      update_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["TrialEnd"].vars["update_net_view"]$$;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["SettleMinus"] {
    name="SettleMinus";
    short_nm="SetlMin";
    tags=;
    desc="settle network in the minus phase -- enough different logic in two phases to warrant making them separate";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on settles";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      pre_compile_code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @["qtr"] {
	name="qtr";
	var_type=T_Int;
	int_val=1;
	objs_ptr=0;
	flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     ForLoop @[1] {
      desc=;
      flags=NEW_EL|CAN_REVERT_TO_CODE;
      code_string="for (qtr = 0; qtr < 3; qtr++)";
      pre_compile_code_string="for (qtr = 0; qtr < 3; qtr++)";
      loop_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program, which computes one cycle of activations";
	flags=CAN_REVERT_TO_CODE;
	code_string="Quarter(network)";
	pre_compile_code_string="Quarter(network)";
	prog_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	};
	target=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"]$$;
	targ_ld_init="*Quarter*";
       };
      };
      init {
       expr="qtr = 0";
      };
      test {
       expr="qtr < 3";
      };
      iter {
       expr="qtr++";
      };
     };
     NetUpdateView @[2] {
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SettleMinus"].args["network"]$$;
      update_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SettleMinus"].vars["update_net_view"]$$;
     };
    };
    step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$;
    step_n=1;
   };
   Program @["SettlePlus"] {
    name="SettlePlus";
    short_nm="SttPls";
    tags=;
    desc="settle network in the minus phase -- enough different logic in two phases to warrant making them separate";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on settles";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (0 vars)";
      pre_compile_code_string="LocalVars (0 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
      };
     };
     ProgramCall @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="Quarter(network)";
      pre_compile_code_string="Quarter(network)";
      prog_args {
       name="prog_args";
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network";
	};
       };
      };
      target=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"]$;
      targ_ld_init="*Quarter*";
     };
     NetUpdateView @[2] {
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SettlePlus"].args["network"]$$;
      update_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SettlePlus"].vars["update_net_view"]$$;
     };
    };
    step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$;
    step_n=1;
   };
   Program @["Trial"] {
    name="Trial";
    short_nm="Trial";
    tags="Leabra, Std";
    desc="Leabra processing of a single input/output event or external information, over a single alpha frequency cycle (100 msec / 10 Hz) -- iterates over gamma-frequency (25 msec / 40 Hz) quarter-trials";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc="network to operate on -- typically set by higher-level calling programs";
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether to update any network view displays after trial is completed";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (1 vars)";
      pre_compile_code_string="LocalVars (1 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @["qtr"] {
	name="qtr";
	var_type=T_Int;
	int_val=0;
	objs_ptr=0;
	flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     If @[1] {
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=CAN_REVERT_TO_CODE;
      code_string="if (network.Compute_Weights_Test(network.trial+1))";
      pre_compile_code_string="if (network.Compute_Weights_Test(network.trial+1))";
      cond {
       expr="network.Compute_Weights_Test(network.trial+1)";
      };
      true_code {
       name=;
       el_typ=ProgCode;
       el_def=0;
       MethodCall @[0] {
	desc="update weights -- do this at start instead of end, so that dwt is valid";
	flags=CAN_REVERT_TO_CODE;
	code_string="network->Compute_Weights()";
	pre_compile_code_string="network->Compute_Weights()";
	result_var=NULL;
	obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Trial"].args["network"]$$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
	meth_sig="void Compute_Weights()";
	meth_desc=" update weights for whole net: calls DMem_SumDWts before doing update if in dmem mode";
       };
      };
     };
     MethodCall @[2] {
      desc="initializes various counters at start of trial";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Init()";
      pre_compile_code_string="network->Trial_Init()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Trial"].args["network"]$;
      method=LeabraNetwork::Trial_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Init()";
      meth_desc=" initialize at start of trial (init specs, Decay state)";
     };
     Comment @[3] {
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      pre_compile_code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     ForLoop @[4] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="for (qtr = 0; qtr < 4; qtr++)";
      pre_compile_code_string="for (qtr = 0; qtr < 4; qtr++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the quarter program (which iterates over cyles of network activation updating) for each quarter";
	flags=CAN_REVERT_TO_CODE;
	code_string="Quarter(network)";
	pre_compile_code_string="Quarter(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr="network";
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"]$;
	targ_ld_init="*Quarter*";
       };
      };
      init {
       expr="qtr = 0";
      };
      test {
       expr="qtr < 4";
      };
      iter {
       expr="qtr++";
      };
     };
     MethodCall @[5] {
      desc="after the trial is over, do final computations";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Trial_Final()";
      pre_compile_code_string="network->Trial_Final()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Trial"].args["network"]$;
      method=LeabraNetwork::Trial_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Trial_Final()";
      meth_desc=" do final processing after trial: Compute_AbsRelNetin";
     };
     NetUpdateView @[6] {
      desc="update the network view(s) (only if update_net_view is true)";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Trial"].args["network"]$;
      update_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Trial"].vars["update_net_view"]$$;
     };
    };
    step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$;
    step_n=1;
   };
   Program @["Quarter"] {
    name="Quarter";
    short_nm="Quarter";
    tags="Leabra, Std";
    desc="iterates over cycles of activation updating for a gamma-frequency (25 msec / 40 Hz) quarter of an alpha frequency (100 msec / 10 Hz) trial";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["cycle"] {
      name="cycle";
      var_type=T_Int;
      int_val=0;
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="current cycle of settling (local loop counter)";
      init_from=NULL;
     };
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="if true, will update network views at end of settling";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
     NetCounterInit @[0] {
      desc="initialize local cycle counter and corresponding counter on network";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Counter Init: cycle";
      pre_compile_code_string="Net Counter Init: cycle";
      network_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].args["network"]$$;
      local_ctr_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].vars["cycle"]$$;
      counter=Network::cycle;
      update_after=0;
     };
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     LocalVars @[0] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="LocalVars (2 vars)";
      pre_compile_code_string="LocalVars (2 vars)";
      local_vars {
       name="local_vars";
       el_typ=ProgVar;
       el_def=0;
       ProgVar @["cycle_max"] {
	name="cycle_max";
	var_type=T_Int;
	int_val=0;
	objs_ptr=0;
	flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
       ProgVar @["cyc"] {
	name="cyc";
	var_type=T_Int;
	int_val=0;
	objs_ptr=0;
	flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
	reference=0;
	desc=;
	init_from=NULL;
       };
      };
     };
     Comment @[1] {
      desc="== note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      flags=CAN_REVERT_TO_CODE;
      code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
      pre_compile_code_string="// == note: can apply inputs once at start of trial, or at finer grain within LeabraQuarter, as needed";
     };
     MethodCall @[2] {
      desc="initializes various counters at start of settling";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Init()";
      pre_compile_code_string="network->Quarter_Init()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].args["network"]$;
      method=LeabraNetwork::Quarter_Init;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Init()";
      meth_desc=" initialize network for quarter-level processing (hard clamp, netscale)";
     };
     MethodCall @[3] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="cycle_max = network->CycleRunMax()";
      pre_compile_code_string="cycle_max = network->CycleRunMax()";
      result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].prog_code[0].local_vars["cycle_max"]$$;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].args["network"]$;
      method=LeabraNetwork::CycleRunMax;
      meth_args {
       name="meth_args";
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="int CycleRunMax()";
      meth_desc=" max loop counter for running cycles in a gamma quarter of processing, taking into account the fact that threading can run multiple cycles per Cycle_Run call if quarter flag is set";
     };
     ForLoop @[4] {
      desc="// the main loop over cycles of updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="for (cyc=0; cyc<cycle_max; cyc++)";
      pre_compile_code_string="for (cyc=0; cyc<cycle_max; cyc++)";
      loop_code {
       name="loop_code";
       el_typ=ProgCode;
       el_def=0;
       ProgramCall @[0] {
	desc="run the cycle program -- can run multiple cycles at a time due to threading";
	flags=CAN_REVERT_TO_CODE;
	code_string="Cycle(network)";
	pre_compile_code_string="Cycle(network)";
	prog_args {
	 name="prog_args";
	 el_typ=ProgArg;
	 el_def=0;
	 ProgArg @[0] {
	  arg_type=LeabraNetwork;
	  type="LeabraNetwork*";
	  name="network";
	  required=1;
	  def_val=;
	  prev_expr=;
	  expr {
	   expr="network";
	  };
	 };
	};
	target=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$;
	targ_ld_init="*Cycle*";
       };
       AssignExpr @[1] {
	desc="grab the updated cycle count";
	flags=CAN_REVERT_TO_CODE;
	code_string="cycle = network.cycle";
	pre_compile_code_string="cycle = network.cycle";
	result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].vars["cycle"]$;
	expr {
	 expr="network.cycle";
	};
       };
      };
      init {
       expr="cyc=0";
      };
      test {
       expr="cyc<cycle_max";
      };
      iter {
       expr="cyc++";
      };
     };
     MethodCall @[5] {
      desc="perform final operations at end of settling (storing final activations, etc)";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Quarter_Final()";
      pre_compile_code_string="network->Quarter_Final()";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].args["network"]$;
      method=LeabraNetwork::Quarter_Final;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Quarter_Final()";
      meth_desc=" do final processing after each quarter: ";
     };
     NetUpdateView @[6] {
      desc="update network views, if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].args["network"]$;
      update_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Quarter"].vars["update_net_view"]$$;
     };
    };
    step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"]$;
    step_n=1;
   };
   Program @["Cycle"] {
    name="Cycle";
    short_nm="Cycle";
    tags="Leabra, Std";
    desc="runs one cycle of leabra processing (updating net inputs and activations)";
    flags=0;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["update_net_view"] {
      name="update_net_view";
      var_type=T_Bool;
      bool_val=1;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="determines whether network views will be updated on a cycle-by-cycle basis (slow, but often quite useful for seeing how processing is proceeding)";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     MethodCall @[0] {
      desc="this does all the standard leabra processing for one cycle of activation updating";
      flags=CAN_REVERT_TO_CODE;
      code_string="network->Cycle_Run()";
      pre_compile_code_string="network->Cycle_Run()";
      result_var=NULL;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"].args["network"]$$;
      method=LeabraNetwork::Cycle_Run;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
      meth_sig="void Cycle_Run()";
      meth_desc=" compute cycle(s) of updating: netinput, inhibition, activations -- multiple cycles can be run depending on lthreads.n_cycles setting and whether multiple threads are actually being used -- see lthreads.n_threads_act";
     };
     NetUpdateView @[1] {
      desc="update network views if update_net_view == true";
      flags=CAN_REVERT_TO_CODE;
      code_string="Net Update View";
      pre_compile_code_string="Net Update View";
      network_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"].args["network"]$;
      update_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"].vars["update_net_view"]$;
     };
     MemberAssign @[2] {
      desc="IMPORTANT: Cycle_Run() now updates cycle by itself, and can run multiple cycles!";
      flags=OFF|CAN_REVERT_TO_CODE;
      code_string="network.cycle = network.cycle + 1";
      pre_compile_code_string="network.cycle = network.cycle + 1";
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["Cycle"].args["network"]$;
      path="cycle";
      expr {
       expr="network.cycle + 1";
      };
      update_after=0;
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program @["SaveWeights"] {
    name="SaveWeights";
    short_nm="SWghts";
    tags="Weights, Specs";
    desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values

also save specs.";
    flags=NO_STOP_STEP;
    stop_step_cond {
     expr=;
    };
    objs {
     name="objs";
     el_typ=taNBase;
     el_def=0;
    };
    types {
     name="types";
     el_typ=DynEnumType;
     el_def=0;
    };
    args {
     name="args";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["network"] {
      name="network";
      var_type=T_Object;
      object_type=LeabraNetwork;
      object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
      reference=0;
      desc=;
      init_from=NULL;
     };
    };
    vars {
     name="vars";
     el_typ=ProgVar;
     el_def=0;
     ProgVar @["tag"] {
      name="tag";
      var_type=T_String;
      string_val="_gui";
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="user defined tag (set by startup script)";
      init_from=NULL;
     };
     ProgVar @["wts_subdir"] {
      name="wts_subdir";
      var_type=T_String;
      string_val=;
      objs_ptr=0;
      flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="subdirectory to save weights in";
      init_from=NULL;
     };
     ProgVar @["fname"] {
      name="fname";
      var_type=T_String;
      string_val="/Users/oreilly/emergent/proj_templates/LeabraFlex_gui.00_0050.wts.gz";
      objs_ptr=0;
      flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc=;
      init_from=NULL;
     };
     ProgVar @["epoch_str"] {
      name="epoch_str";
      var_type=T_String;
      string_val="0050";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of epoch with leading zeros";
      init_from=NULL;
     };
     ProgVar @["batch_str"] {
      name="batch_str";
      var_type=T_String;
      string_val="00";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="string rep of batch with leading zeros";
      init_from=NULL;
     };
     ProgVar @["final_tag"] {
      name="final_tag";
      var_type=T_String;
      string_val="_gui.00_0050";
      objs_ptr=0;
      flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
      reference=0;
      desc="batch + epoch";
      init_from=NULL;
     };
    };
    functions {
     name="functions";
     el_typ=Function;
     el_def=0;
    };
    init_code {
     name="init_code";
     el_typ=ProgCode;
     el_def=0;
    };
    prog_code {
     name="prog_code";
     el_typ=ProgCode;
     el_def=0;
     IfReturn @[0] {
      desc="do not save if not first dmem processor";
      flags=CAN_REVERT_TO_CODE;
      code_string="if(taMisc::dmem_proc > 0) return";
      pre_compile_code_string="if(taMisc::dmem_proc > 0) return";
      cond {
       expr="taMisc::dmem_proc > 0";
      };
     };
     MiscCall @[1] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="batch_str = taMisc::LeadingZeros(network.batch, 2)";
      pre_compile_code_string="batch_str = taMisc::LeadingZeros(network.batch, 2)";
      result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"].vars["batch_str"]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.batch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="2";
	};
       };
      };
     };
     MiscCall @[2] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="epoch_str = taMisc::LeadingZeros(network.epoch, 4)";
      pre_compile_code_string="epoch_str = taMisc::LeadingZeros(network.epoch, 4)";
      result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"].vars["epoch_str"]$$;
      object_type=taMisc;
      method=taMisc::LeadingZeros;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=int;
	type="int";
	name="num";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="network.epoch";
	};
       };
       ProgArg @[1] {
	arg_type=int;
	type="int";
	name="len";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="4";
	};
       };
      };
     };
     AssignExpr @[3] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="final_tag = tag + \".\" + batch_str + \"_\" + epoch_str";
      pre_compile_code_string="final_tag = tag + \".\" + batch_str + \"_\" + epoch_str";
      result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"].vars["final_tag"]$$;
      expr {
       expr="tag + \".\" + batch_str + \"_\" + epoch_str";
      };
     };
     MethodCall @[4] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="fname = network->GetFileNameFmProject(\".wts.gz\", final_tag, wts_subdir, false)";
      pre_compile_code_string="fname = network->GetFileNameFmProject(\".wts.gz\", final_tag, wts_subdir, false)";
      result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"].vars["fname"]$$;
      obj=.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"].args["network"]$$;
      method=taBase::GetFileNameFmProject;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="ext";
	required=1;
	def_val=;
	prev_expr=;
	expr {
	 expr="\".wts.gz\"";
	};
       };
       ProgArg @[1] {
	arg_type=const_taString_ref;
	type="taString&";
	name="tag";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="final_tag";
	};
       };
       ProgArg @[2] {
	arg_type=const_taString_ref;
	type="taString&";
	name="subdir";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="wts_subdir";
	};
       };
       ProgArg @[3] {
	arg_type=bool;
	type="bool";
	name="dmem_proc_no";
	required=0;
	def_val="false";
	prev_expr=;
	expr {
	 expr="false";
	};
       };
      };
      meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
      meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
     };
     MethodCall @[5] {
      desc=;
      flags=CAN_REVERT_TO_CODE;
      code_string="network->SaveWeights(fname, Network::NET_FMT)";
      pre_compile_code_string="network->SaveWeights(fname, Network::NET_FMT)";
      result_var=NULL;
      obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["SaveWeights"].args["network"]$;
      method=Network::SaveWeights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=const_taString_ref;
	type="taString&";
	name="fname";
	required=0;
	def_val="\"\"";
	prev_expr=;
	expr {
	 expr="fname";
	};
       };
       ProgArg @[1] {
	arg_type=Network::WtSaveFormat;
	type="Network::WtSaveFormat";
	name="fmt";
	required=0;
	def_val="Network::NET_FMT";
	prev_expr=;
	expr {
	 expr="Network::NET_FMT";
	};
       };
      };
      meth_sig="void SaveWeights(taString& fname, Network::WtSaveFormat fmt = NET_FMT)";
      meth_desc=" write weight values out in a simple ordered list of weights (optionally in binary fmt) (leave fname empty to pull up file chooser)";
     };
    };
    step_prog=NULL;
    step_n=1;
   };
   Program_Group @.gp["Monitors"] {
    name="Monitors";
    el_typ=Program;
    el_def=0;
    tags=;
    desc=;
    debug_mode=0;
    Program @["SaveLogFiles"] {
     name="SaveLogFiles";
     short_nm="SLFls";
     tags="Leabra, Startup";
     desc="startup args specifically for fixation training parameters";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=taNBase;
      el_def=0;
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["network"] {
       name="network";
       var_type=T_Object;
       object_type=LeabraNetwork;
       object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to operate on -- updates batch counter on network and passes it to train program";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["tag"] {
       name="tag";
       var_type=T_String;
       string_val=;
       objs_ptr=0;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.projects["LeabraFlex"].programs["MasterStartup"]$;
      };
      ProgVar @["log_trials"] {
       name="log_trials";
       var_type=T_Bool;
       bool_val=0;
       objs_ptr=0;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
       reference=0;
       desc=;
       init_from=$.projects["LeabraFlex"].programs.gp["UtilProgs"]["StdGlobalsInit"]$;
      };
      ProgVar @["log_dir"] {
       name="log_dir";
       var_type=T_String;
       string_val=;
       objs_ptr=0;
       flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="log file directory";
       init_from=NULL;
      };
      ProgVar @["log_file_nm"] {
       name="log_file_nm";
       var_type=T_String;
       string_val=;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="name of log file";
       init_from=NULL;
      };
      ProgVar @["epoch_output_data"] {
       name="epoch_output_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @["trial_output_data"] {
       name="trial_output_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.projects["LeabraFlex"].data.gp["OutputData"]["TrialOutputData"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      LocalVars @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LocalVars (0 vars)";
       pre_compile_code_string="LocalVars (0 vars)";
       local_vars {
	name="local_vars";
	el_typ=ProgVar;
	el_def=0;
       };
      };
      IfReturn @[1] {
       desc="don't re-run if already saving!";
       flags=CAN_REVERT_TO_CODE;
       code_string="if(epoch_output_data.IsSavingDataLog()) return";
       pre_compile_code_string="if(epoch_output_data.IsSavingDataLog()) return";
       cond {
	expr="epoch_output_data.IsSavingDataLog()";
       };
      };
      MethodCall @[2] {
       desc="last arg is to include dmem proc number";
       flags=CAN_REVERT_TO_CODE;
       code_string="log_file_nm = epoch_output_data->GetFileNameFmProject(\".trn_epc.dat\", tag, log_dir, false)";
       pre_compile_code_string="log_file_nm = epoch_output_data->GetFileNameFmProject(\".trn_epc.dat\", tag, log_dir, false)";
       result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["log_file_nm"]$$;
       obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["epoch_output_data"]$$;
       method=taBase::GetFileNameFmProject;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ext";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\".trn_epc.dat\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="tag";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="tag";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="subdir";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_dir";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_no";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
       meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
      };
      MethodCall @[3] {
       desc="last arg is to restrict log to dmem_proc = 0";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_output_data->SaveDataLog(log_file_nm, false, true)";
       pre_compile_code_string="epoch_output_data->SaveDataLog(log_file_nm, false, true)";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["epoch_output_data"]$;
       method=DataTable::SaveDataLog;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="fname";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="log_file_nm";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="append";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="dmem_proc_0";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
       meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
      };
      PrintVar @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  \"Saving epoch log data to:\" log_file_nm";
       pre_compile_code_string="Print  \"Saving epoch log data to:\" log_file_nm";
       message="Saving epoch log data to:";
       print_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["log_file_nm"]$;
       print_var2=NULL;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=0;
      };
      If @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (log_trials)";
       pre_compile_code_string="if (log_trials)";
       cond {
	expr="log_trials";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc="last arg is to include dmem proc number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="log_file_nm = trial_output_data->GetFileNameFmProject(\".trn_trl.dat\", tag, log_dir, true)";
	 pre_compile_code_string="log_file_nm = trial_output_data->GetFileNameFmProject(\".trn_trl.dat\", tag, log_dir, true)";
	 result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["log_file_nm"]$;
	 obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["trial_output_data"]$$;
	 method=taBase::GetFileNameFmProject;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ext";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\".trn_trl.dat\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="tag";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="tag";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="subdir";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_dir";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_no";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="taString GetFileNameFmProject(taString& ext, taString& tag, taString& subdir, bool dmem_proc_no = false)";
	 meth_desc=" get file name from project file name -- useful for saving files associated with the project; ext = extension; tag = additional tag; subdir = additional directory after any existing in project name; fname = proj->base_name (subdir) + tag + ext; if dmem_proc_no, add dmem proc no to file name. empty if project not found";
	};
	MethodCall @[1] {
	 desc="last arg is to restrict log to dmem_proc = 0";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_output_data->SaveDataLog(log_file_nm, false, false)";
	 pre_compile_code_string="trial_output_data->SaveDataLog(log_file_nm, false, false)";
	 result_var=NULL;
	 obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["trial_output_data"]$;
	 method=DataTable::SaveDataLog;
	 meth_args {
	  name=;
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="fname";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="log_file_nm";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=bool;
	   type="bool";
	   name="append";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=bool;
	   type="bool";
	   name="dmem_proc_0";
	   required=0;
	   def_val="true";
	   prev_expr=;
	   expr {
	    expr="false";
	   };
	  };
	 };
	 meth_sig="void SaveDataLog(taString& fname, bool append = false, bool dmem_proc_0 = true)";
	 meth_desc=" incrementally save each new row of data that is written to the datatable (at WriteClose()) to given file. writes the header first if not appending to existing file. if running under demem, dmem_proc_0 determines if only the first processor writes to the log file, or if all processors write";
	};
	PrintVar @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  \"Saving trial log data to:\" log_file_nm";
	 pre_compile_code_string="Print  \"Saving trial log data to:\" log_file_nm";
	 message="Saving trial log data to:";
	 print_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["SaveLogFiles"].vars["log_file_nm"]$;
	 print_var2=NULL;
	 print_var3=NULL;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=0;
	};
       };
      };
     };
     step_prog=NULL;
     step_n=1;
    };
    Program @["LeabraTrialMonitor"] {
     name="LeabraTrialMonitor";
     short_nm="TrialMon";
     tags="Leabra, Std, Monitor";
     desc="monitor trial-level data from the network (and potentially other sources) -- stores results in datatable (TrialOutputData typically) that can be used for graph/grid views and further analysis ";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @["trial_netmon"] {
       name="trial_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	NetMonItem @["batch"] {
	 name="batch";
	 monitor=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["epoch"] {
	 name="epoch";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["train_mode"] {
	 name="train_mode";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="train_mode";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["group"] {
	 name="group";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="group";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["trial"] {
	 name="trial";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="trial";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["tick"] {
	 name="tick";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="tick";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["time"] {
	 name="time";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="time";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["trial_name"] {
	 name="trial_name";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="trial_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["group_name"] {
	 name="group_name";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="group_name";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["output_name"] {
	 name="output_name";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="minus_output_name";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["rt_cycles"] {
	 name="rt_cycles";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="rt_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["sse"] {
	 name="sse";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["norm_err"] {
	 name="norm_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["cos_err"] {
	 name="cos_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="cos_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["ext_rew"] {
	 name="ext_rew";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_sse"] {
	 name="lay_sse";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.sse";
	 var_label="lay_sse";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_norm_err"] {
	 name="lay_norm_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.norm_err";
	 var_label="lay_norm_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_cos_err"] {
	 name="lay_cos_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.cos_err";
	 var_label="lay_cos_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_net_sd"] {
	 name="lay_net_sd";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.net_sd";
	 var_label="lay_net_sd";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["net_cos_diff"] {
	 name="net_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="cos_diff";
	 var_label="net_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["net_trial_cos_diff"] {
	 name="net_trial_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="trial_cos_diff";
	 var_label="net_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["net_avg_act_diff"] {
	 name="net_avg_act_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_act_diff";
	 var_label="net_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["cos_diff"] {
	 name="cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.cos_diff";
	 var_label="cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["trial_cos_diff"] {
	 name="trial_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.trial_cos_diff";
	 var_label="trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_act_diff"] {
	 name="avg_act_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_act_diff";
	 var_label="avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.projects["LeabraFlex"].networks["Network_0"]$;
       data=$.projects["LeabraFlex"].data.gp["OutputData"]["TrialOutputData"]$;
       rmv_orphan_cols=1;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["network"] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to record data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["trial_mon_data"] {
       name="trial_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.projects["LeabraFlex"].data.gp["OutputData"]["TrialOutputData"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to record trial-level data to (this program writes new data to this table!)";
       init_from=NULL;
      };
      ProgVar @["trial_netmon"] {
       name="trial_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       object_val=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].objs["trial_netmon"]$;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the NetMonitor object in objs secton of this program that contains configuration for what to record and where to get it";
       init_from=NULL;
      };
      ProgVar @["run_already"] {
       name="run_already";
       var_type=T_Bool;
       bool_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc="set the network and datatable for the NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
       pre_compile_code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_netmon"]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[1] {
       desc="check the configuration of the network monitor -- will emit warnings and errors for misconfigurations";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->CheckConfig(false)";
       pre_compile_code_string="trial_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
       method=taBase::CheckConfig;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[2] {
       desc="update the monitor items and data schema based on current settings of the NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->UpdateMonitors(true)";
       pre_compile_code_string="trial_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
      AssignExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="run_already = false";
       pre_compile_code_string="run_already = false";
       result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["run_already"]$$;
       expr {
	expr="false";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!run_already)";
       pre_compile_code_string="if (!run_already)";
       cond {
	expr="!run_already";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc="set the network and datatable for the NetMonitor";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
	 pre_compile_code_string="trial_netmon->SetDataNetwork(trial_mon_data, network)";
	 result_var=NULL;
	 obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
	 method=NetMonitor::SetDataNetwork;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dt";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="trial_mon_data";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=Network_ptr;
	   type="Network*";
	   name="net";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
	 meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
	};
	MethodCall @[1] {
	 desc="update the monitor items and data schema based on current settings of the NetMonitor object";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="trial_netmon->UpdateMonitors(true)";
	 pre_compile_code_string="trial_netmon->UpdateMonitors(true)";
	 result_var=NULL;
	 obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
	 method=NetMonitor::UpdateMonitors;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool;
	   type="bool";
	   name="reset_first";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="void UpdateMonitors(bool reset_first = false)";
	 meth_desc=" old name for UpdateDataTable";
	};
	AssignExpr @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="run_already = true";
	 pre_compile_code_string="run_already = true";
	 result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["run_already"]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      MethodCall @[1] {
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->AddBlankRow()";
       pre_compile_code_string="trial_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_mon_data"]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       desc="get the new monitor data from the network and other sources -- this does the main work";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_netmon->GetMonVals()";
       pre_compile_code_string="trial_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_netmon"]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      MethodCall @[3] {
       desc="update views and other things after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="trial_mon_data->WriteClose()";
       pre_compile_code_string="trial_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].vars["trial_mon_data"]$;
       method=DataTable::WriteClose;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      MethodCall @[4] {
       desc="only functional for dmem projects: synchronizes trial data across processes so that all distributed memory processors have the same trial-level data, despite having run only a subset of them each";
       flags=CAN_REVERT_TO_CODE;
       code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
       pre_compile_code_string="network->DMem_ShareTrialData(trial_mon_data, 1)";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"].args["network"]$$;
       method=Network::DMem_ShareTrialData;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trial_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="n_rows";
	 required=0;
	 def_val="1";
	 prev_expr=;
	 expr {
	  expr="1";
	 };
	};
       };
       meth_sig="void DMem_ShareTrialData(DataTable* dt, int n_rows = 1)";
       meth_desc=" share trial data from given datatable across the trial-level dmem communicator (outer loop) -- each processor gets data from all other processors; if called every trial with n_rows = 1, data will be identical to non-dmem; if called at end of epoch with n_rows = -1 data will be grouped by processor but this is more efficient";
      };
     };
     step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraTrialMonitor"]$;
     step_n=1;
    };
    Program @["LeabraEpochMonitor"] {
     name="LeabraEpochMonitor";
     short_nm="EpcMon";
     tags="Leabra, Std, Monitor";
     desc="monitor epoch-level data from the network to a datatable (EpochOutputData typically) for use in graphing and viewing and further analysis";
     flags=NO_STOP_STEP;
     stop_step_cond {
      expr=;
     };
     objs {
      name="objs";
      el_typ=NetMonitor;
      el_def=0;
      NetMonitor @["epoch_netmon"] {
       name="epoch_netmon";
       items {
	name="items";
	el_typ=NetMonItem;
	el_def=0;
	NetMonItem @["batch"] {
	 name="batch";
	 monitor=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="batch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["epoch"] {
	 name="epoch";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="epoch";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_sse"] {
	 name="avg_sse";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_sse";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["cnt_err"] {
	 name="cnt_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="cnt_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["pct_cor"] {
	 name="pct_cor";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="pct_cor";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["pct_err"] {
	 name="pct_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="pct_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_norm_err"] {
	 name="avg_norm_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_norm_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_cos_err"] {
	 name="avg_cos_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_cos_err";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_ext_rew"] {
	 name="avg_ext_rew";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_ext_rew";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_cycles"] {
	 name="avg_cycles";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_cycles";
	 var_label=;
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["epoch_time_tot"] {
	 name="epoch_time_tot";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=1;
	 object_type=NULL;
	 object=NULL;
	 variable="act";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["epoch_time_usr"] {
	 name="epoch_time_usr";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=1;
	 object_type=NULL;
	 object=NULL;
	 variable="act";
	 var_label=;
	 name_style=MY_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_avg_sse"] {
	 name="lay_avg_sse";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_sse";
	 var_label="lay_avg_sse";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_cnt_err"] {
	 name="lay_cnt_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.cnt_err";
	 var_label="lay_cnt_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_pct_cor"] {
	 name="lay_pct_cor";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.pct_cor";
	 var_label="lay_pct_cor";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_pct_err"] {
	 name="lay_pct_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.pct_err";
	 var_label="lay_pct_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_avg_norm_err"] {
	 name="lay_avg_norm_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_norm_err";
	 var_label="lay_avg_norm_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["lay_avg_cos_err"] {
	 name="lay_avg_cos_err";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_cos_err";
	 var_label="lay_avg_cos_err";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name="agg_col";
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name="select_spec";
	  name="select_spec_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["net_avg_cos_diff"] {
	 name="net_avg_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_cos_diff";
	 var_label="net_avg_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["net_avg_trial_cos_diff"] {
	 name="net_avg_trial_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_trial_cos_diff";
	 var_label="net_avg_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["net_avg_avg_act_diff"] {
	 name="net_avg_avg_act_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="avg_avg_act_diff";
	 var_label="net_avg_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=INPUT_LAYERS|HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_cos_diff"] {
	 name="avg_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_cos_diff";
	 var_label="avg_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_trial_cos_diff"] {
	 name="avg_trial_cos_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_trial_cos_diff";
	 var_label="avg_trial_cos_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_avg_act_diff"] {
	 name="avg_avg_act_diff";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_avg_act_diff";
	 var_label="avg_avg_act_diff";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_net_sd"] {
	 name="avg_net_sd";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_net_sd";
	 var_label="avg_net_sd";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["hog_pct"] {
	 name="hog_pct";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.hog_pct";
	 var_label="hog_pct";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["dead_pct"] {
	 name="dead_pct";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.dead_pct";
	 var_label="dead_pct";
	 name_style=AUTO_NAME;
	 max_name_len=8;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 0 1;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["netmax"] {
	 name="netmax";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="layers.avg_netin.max";
	 var_label="netmax";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["avg_act"] {
	 name="avg_act";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable=".layers.acts_p_avg";
	 var_label="avg_act";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
	NetMonItem @["netrel"] {
	 name="netrel";
	 monitor=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
	 computed=0;
	 object_type=LeabraNetwork;
	 object=$.projects["LeabraFlex"].networks["Network_0"]$;
	 variable="prjns.avg_netin_rel";
	 var_label="netrel";
	 name_style=AUTO_NAME;
	 max_name_len=6;
	 options=HIDDEN_LAYERS|OUTPUT_LAYERS|TARGET_LAYERS;
	 val_type=VT_FLOAT;
	 matrix=0;
	 matrix_geom{ 	 };
	 data_agg=0;
	 data_src=NULL;
	 agg_col {
	  col_name=;
	 };
	 agg {name="agg": op=NONE: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
	 select_rows=0;
	 select_spec {
	  col_name=;
	  name="_EQUAL_";
	  on=1;
	  rel=EQUAL;
	  use_var=0;
	  cmp 2 0=0;
	  var=NULL;
	  enable_var=NULL;
	 };
	 pre_proc_1 {name="pre_proc_1": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_2 {name="pre_proc_2": opr=NONE: arg=0: lw=-1: hi=1: };
	 pre_proc_3 {name="pre_proc_3": opr=NONE: arg=0: lw=-1: hi=1: };
	};
       };
       network=$.projects["LeabraFlex"].networks["Network_0"]$;
       data=$.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"]$;
       rmv_orphan_cols=1;
      };
     };
     types {
      name="types";
      el_typ=DynEnumType;
      el_def=0;
     };
     args {
      name="args";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["network"] {
       name="network";
       var_type=T_Object;
       object_type=Network;
       object_val=$.projects["LeabraFlex"].networks["Network_0"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
       reference=0;
       desc="network to get data from";
       init_from=NULL;
      };
     };
     vars {
      name="vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @["epoch_mon_data"] {
       name="epoch_mon_data";
       var_type=T_Object;
       object_type=DataTable;
       object_val=$.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"]$;
       objs_ptr=0;
       flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="data table to write the epoch data to";
       init_from=NULL;
      };
      ProgVar @["epoch_netmon"] {
       name="epoch_netmon";
       var_type=T_Object;
       object_type=NetMonitor;
       object_val=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].objs["epoch_netmon"]$;
       objs_ptr=1;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="network monitor object that contains full specs for what to record and where to get it";
       init_from=NULL;
      };
      ProgVar @["epoch_timer"] {
       name="epoch_timer";
       var_type=T_Object;
       object_type=TimeUsed;
       object_val=.projects["LeabraFlex"].networks["Network_0"].epoch_time$$;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc="pointer to the network's epoch-level timer, to record how long it took to process an epoch";
       init_from=NULL;
      };
      ProgVar @["run_already"] {
       name="run_already";
       var_type=T_Bool;
       bool_val=0;
       objs_ptr=0;
       flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
     functions {
      name="functions";
      el_typ=Function;
      el_def=0;
     };
     init_code {
      name="init_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc="get the epoch timer from current network";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_timer = network.epoch_time";
       pre_compile_code_string="epoch_timer = network.epoch_time";
       result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_timer"]$$;
       expr {
	expr="network.epoch_time";
       };
      };
      MethodCall @[1] {
       desc="set data and network on NetMonitor object";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
       pre_compile_code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_netmon"]$$;
       method=NetMonitor::SetDataNetwork;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_mon_data";
	 };
	};
	ProgArg @[1] {
	 arg_type=Network_ptr;
	 type="Network*";
	 name="net";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="network";
	 };
	};
       };
       meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
       meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
      };
      MethodCall @[2] {
       desc="check configuration and emit errors/warnings for problems";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->CheckConfig(false)";
       pre_compile_code_string="epoch_netmon->CheckConfig(false)";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
       method=taBase::CheckConfig;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="bool CheckConfig(bool quiet = false)";
       meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
      };
      MethodCall @[3] {
       desc="update the monitor items and data schema based on current settings of NetMonitor";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->UpdateMonitors(true)";
       pre_compile_code_string="epoch_netmon->UpdateMonitors(true)";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
       method=NetMonitor::UpdateMonitors;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool;
	 type="bool";
	 name="reset_first";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="void UpdateMonitors(bool reset_first = false)";
       meth_desc=" old name for UpdateDataTable";
      };
      AssignExpr @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="run_already = false";
       pre_compile_code_string="run_already = false";
       result_var=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["run_already"]$$;
       expr {
	expr="false";
       };
      };
     };
     prog_code {
      name="prog_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!run_already)";
       pre_compile_code_string="if (!run_already)";
       cond {
	expr="!run_already";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc="set data and network on NetMonitor object";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
	 pre_compile_code_string="epoch_netmon->SetDataNetwork(epoch_mon_data, network)";
	 result_var=NULL;
	 obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
	 method=NetMonitor::SetDataNetwork;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=DataTable_ptr;
	   type="DataTable*";
	   name="dt";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="epoch_mon_data";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=Network_ptr;
	   type="Network*";
	   name="net";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 meth_sig="void SetDataNetwork(DataTable* dt, Network* net)";
	 meth_desc=" set both the data table and network -- convenient for programs -- calls ResetDataTableCols too -- don't call if columns are manually added or this is adding additional rows to a table";
	};
	MethodCall @[1] {
	 desc="update the monitor items and data schema based on current settings of NetMonitor";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="epoch_netmon->UpdateMonitors(true)";
	 pre_compile_code_string="epoch_netmon->UpdateMonitors(true)";
	 result_var=NULL;
	 obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
	 method=NetMonitor::UpdateMonitors;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool;
	   type="bool";
	   name="reset_first";
	   required=0;
	   def_val="false";
	   prev_expr=;
	   expr {
	    expr="true";
	   };
	  };
	 };
	 meth_sig="void UpdateMonitors(bool reset_first = false)";
	 meth_desc=" old name for UpdateDataTable";
	};
	AssignExpr @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="run_already = true";
	 pre_compile_code_string="run_already = true";
	 result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["run_already"]$;
	 expr {
	  expr="true";
	 };
	};
       };
      };
      MethodCall @[1] {
       desc="add a new blank row to the data";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->AddBlankRow()";
       pre_compile_code_string="epoch_mon_data->AddBlankRow()";
       result_var=NULL;
       obj=.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$$;
       method=DataTable::AddBlankRow;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       desc="get the new monitor data and stor it into the data table -- this does the main job here";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_netmon->GetMonVals()";
       pre_compile_code_string="epoch_netmon->GetMonVals()";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_netmon"]$;
       method=NetMonitor::GetMonVals;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void GetMonVals()";
       meth_desc=" get all the values and store in current row of data table -- call in program to get new data";
      };
      AssignExpr @[3] {
       desc="get the epoch timer from current network";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_timer = network.epoch_time";
       pre_compile_code_string="epoch_timer = network.epoch_time";
       result_var=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_timer"]$;
       expr {
	expr="network.epoch_time";
       };
      };
      MethodCall @[4] {
       desc="set the total time to compute the epoch (epoch_time_tot -- wall clock time) to time used data from network timer";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
       pre_compile_code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\", -1, )";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$;
       method=DataTable::SetValColName;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_timer.used.GetTotSecs()";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"epoch_time_tot\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
      };
      MethodCall @[5] {
       desc="set the user process time (cpu time for this process, epoch_time_usr) to time used data from network timer";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
       pre_compile_code_string="epoch_mon_data->SetValColName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\", -1, )";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$;
       method=DataTable::SetValColName;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_timer.used.GetUsrSecs()";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"epoch_time_usr\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValColName(Variant& val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column name, row; returns 'true' if valid access and set is successful -- quiet = fail quietly";
      };
      MethodCall @[6] {
       desc="update after writing new data to monitor data table";
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_mon_data->WriteClose()";
       pre_compile_code_string="epoch_mon_data->WriteClose()";
       result_var=NULL;
       obj=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"].vars["epoch_mon_data"]$;
       method=DataTable::WriteClose;
       meth_args {
	name=;
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void WriteClose()";
       meth_desc=" closes up a write operation -- call when done writing data -- performs any post-writing cleanup/closing of files, etc";
      };
      Comment @[7] {
       desc="NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
       flags=CAN_REVERT_TO_CODE;
       code_string="// NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
       pre_compile_code_string="// NOTE: if doing a TestEpoch and wanting to include test results in this train epoch log, then see these instructions:
http://grey.colorado.edu/emergent/index.php/Test_Programs
quick summary here:
* Add computed, data_agg, op = LAST items to epoch_netmon to grab from the EpochTestOutputData table.
* duplicate this program, call the new one LeabraEpochMonitor_postest, remove all netmon items for training, leaving only test,
  turn off rmv_orphan_cols flag, and set arg for UpdateMonitors in init_code to false
* in original LeabraEpochMonitor, click OFF flag for WriteClose() line
* in LeabraEpoch add call to LeabraEpochTest, then _posttest after the first LeabraEpochMonitor call.
This will ensure that training data is monitored first, right after the training epoch, and then the test epoch is run,
and the testing data is updated.  The first epoch monitor should have all the items, so that it formats the data table correctly.
 
";
      };
     };
     step_prog=$.projects["LeabraFlex"].programs.gp["UtilProgs"].gp["Monitors"]["LeabraEpochMonitor"]$;
     step_n=1;
    };
   };
  };
 };
 viewers {
  name="viewers";
  el_typ=MainWindowViewer;
  el_def=0;
  MainWindowViewer @["Browser3"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["view_win_lft"] {
     name="view_win_lft";
     value 8 0=0.002087683;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_top"] {
     name="view_win_top";
     value 8 0=0.03568394;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_wd"] {
     name="view_win_wd";
     value 8 0=0.9953027;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_ht"] {
     name="view_win_ht";
     value 8 0=0.797791;
     val_type_fixed=0;
    };
    UserDataItem @["view_win_iconified"] {
     name="view_win_iconified";
     value 1 0=0;
     val_type_fixed=0;
    };
    UserDataItem @["view_splitter_state"] {
     name="view_splitter_state";
     value 9 0="AAAA/wAAAAEAAAADAAABJQAAAvEAAALdAQAAAAcBAAAAAQE=";
     val_type_fixed=0;
    };
   };
   name="Browser3";
   m_data=.projects["LeabraFlex"]$$;
   visible=1;
   win_name=".projects[\"LeabraFlex\"] - LeabraFlex.proj";
   m_is_root=0;
   m_is_viewer_xor_browser=0;
   m_is_proj_viewer=1;
   m_is_dialog=0;
   toolbars {
    name="toolbars";
    el_typ=ToolBar;
    el_def=0;
    ToolBar @["Application"] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_visible"] {
       name="view_win_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Application";
     m_data=NULL;
     visible=0;
     lft=0;
     top=0;
     o=Horizontal;
    };
   };
   frames {
    name="frames";
    el_typ=BrowseViewerTaBase;
    el_def=0;
    BrowseViewerTaBase @["Navigator"] {
     name="Navigator";
     m_data=NULL;
     visible=1;
     root_typ=LeabraProject;
     root_md=NULL;
     m_root=$.projects["LeabraFlex"]$;
    };
    PanelViewer @["Editor"] {
     name="Editor";
     m_data=NULL;
     visible=1;
    };
    T3PanelViewer @["Visualizer"] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_frame_selected"] {
       name="view_frame_selected";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @["view_panel_selected"] {
       name="view_panel_selected";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Visualizer";
     m_data=NULL;
     visible=1;
     panels {
      name="panels";
      el_typ=T3Panel;
      el_def=0;
      T3Panel @["Network_0"] {
       name="Network_0";
       m_data=NULL;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=NetView;
	 el_def=0;
	 NetView @["Network_0_View"] {
	  name="Network_0_View";
	  m_data=$.projects["LeabraFlex"].networks["Network_0"]$;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=1: y=0: z=0: rot=0.35: }: translate={x=0: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  display=1;
	  lay_layout=THREE_D;
	  lay_mv=1;
	  net_text=1;
	  show_iconified=0;
	  net_text_xform {scale={x=0.7: y=0.7: z=0.7: }: rotate={x=1: y=0: z=0: rot=1.570796: }: translate={x=0: y=1: z=-1: }: };
	  net_text_rot=-90;
	  cur_unit_vals{ act;	  };
	  unit_src_path=".layers[2].units[0]";
	  con_type=ANY_CON;
	  hist_idx=0;
	  hist_save=1;
	  hist_max=100;
	  hist_ff=5;
	  unit_disp_mode=UDM_BLOCK;
	  unit_text_disp=UTD_NONE;
	  max_size {x=5: y=5: z=2.333333: };
	  max_size2d {x=5: y=18: z=1: };
	  eff_max_size {x=5: y=5: z=2.333333: };
	  font_sizes {
	   net_name=0.05;
	   net_vals=0.05;
	   layer=0.04;
	   layer_min=0.01;
	   layer_vals=0.03;
	   prjn=0.01;
	   unit=0.02;
	   un_nm_len=3;
	  };
	  view_params {
	   xy_square=0;
	   unit_spacing=0.05;
	   prjn_disp=L_R_B;
	   prjn_name=0;
	   prjn_width=0.002;
	   prjn_trans=0.5;
	   lay_trans=0.5;
	   unit_trans=0.6;
	   laygp_width=1;
	   show_laygp=1;
	  };
	  wt_line_disp=0;
	  wt_line_width=4;
	  wt_line_thr=0.8;
	  wt_line_swt=0;
	  wt_prjn_k_un=4;
	  wt_prjn_k_gp=1;
	  wt_prjn_lay=NULL;
	  snap_bord_disp=0;
	  snap_bord_width=4;
	  scale {
	   name="scale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=0;
	   last_max=0;
	   range=1;
	   zero=0;
	   spec=.colorspecs["C_ColdHot"]$$<ColorScaleSpec,C_ColdHot>;
	   auto_scale=0;
	  };
	  scale_ranges {
	   name="scale_ranges";
	   el_typ=ScaleRange;
	   el_def=0;
	   ScaleRange @[0] {
	    var_name="act";
	    auto_scale=0;
	    min=-1;
	    max=1;
	   };
	  };
	  lay_disp_modes{ Input=-1;Hidden=-1;Output=-1;	  };
	 };
	};
       };
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       camera_params {
	field_of_view=45;
	near=0.1;
	focal=5;
	far=1000;
       };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["Vw_0"] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=0.5: y=0.9155772: z=2.325743: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=2.528059;
	};
	T3SavedView @["Vw_1"] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_2"] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_3"] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_4"] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_5"] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_6"] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_7"] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_8"] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_9"] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
      T3Panel @["EpochOutputData"] {
       name="EpochOutputData";
       m_data=NULL;
       visible=1;
       root_view {
	name="root_view";
	m_data=NULL;
	m_transform=NULL;
	children {
	 name="children";
	 el_typ=GraphTableView;
	 el_def=0;
	 GraphTableView @["EpochOutputData_Graph"] {
	  name="EpochOutputData_Graph";
	  m_data=$.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"]$;
taTransform @*(.m_transform) {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  children {
	   name="children";
	   el_typ=GraphColView;
	   el_def=0;
	   GraphColView @["batch"] {
	    name="batch";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["batch"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["epoch"] {
	    name="epoch";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["epoch"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=29: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["avg_sse"] {
	    name="avg_sse";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["avg_sse"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=4.52558: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["cnt_err"] {
	    name="cnt_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["cnt_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=50: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["pct_cor"] {
	    name="pct_cor";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["pct_cor"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["pct_err"] {
	    name="pct_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["pct_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["avg_norm_err"] {
	    name="avg_norm_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["avg_norm_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0.586: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["avg_cos_err"] {
	    name="avg_cos_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["avg_cos_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["avg_ext_rew"] {
	    name="avg_ext_rew";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["avg_ext_rew"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["avg_cycles"] {
	    name="avg_cycles";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["avg_cycles"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["epoch_time_tot"] {
	    name="epoch_time_tot";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["epoch_time_tot"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["epoch_time_usr"] {
	    name="epoch_time_usr";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["epoch_time_usr"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_lay_avg_sse"] {
	    name="Output_lay_avg_sse";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_lay_avg_sse"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_lay_cnt_err"] {
	    name="Output_lay_cnt_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_lay_cnt_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_lay_pct_cor"] {
	    name="Output_lay_pct_cor";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_lay_pct_cor"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_lay_pct_err"] {
	    name="Output_lay_pct_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_lay_pct_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_lay_avg_norm_err"] {
	    name="Output_lay_avg_norm_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_lay_avg_norm_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_lay_avg_cos_err"] {
	    name="Output_lay_avg_cos_err";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_lay_avg_cos_err"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["net_avg_cos_diff"] {
	    name="net_avg_cos_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["net_avg_cos_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["net_avg_trial_cos_diff"] {
	    name="net_avg_trial_cos_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["net_avg_trial_cos_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["net_avg_avg_act_diff"] {
	    name="net_avg_avg_act_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["net_avg_avg_act_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_avg_cos_diff"] {
	    name="Hidden_avg_cos_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_avg_cos_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.962046: fix_max=0: max=0.999009: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_avg_cos_diff"] {
	    name="Output_avg_cos_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_avg_cos_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_avg_trial_cos_diff"] {
	    name="Hidden_avg_trial_cos_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_avg_trial_cos_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_avg_trial_cos_diff"] {
	    name="Output_avg_trial_cos_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_avg_trial_cos_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_avg_avg_act_diff"] {
	    name="Hidden_avg_avg_act_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_avg_avg_act_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_avg_avg_act_diff"] {
	    name="Output_avg_avg_act_diff";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_avg_avg_act_diff"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_avg_net_sd"] {
	    name="Hidden_avg_net_sd";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_avg_net_sd"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0.281181: fix_max=0: max=0.466438: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_avg_net_sd"] {
	    name="Output_avg_net_sd";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_avg_net_sd"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_hog_pct"] {
	    name="Hidden_hog_pct";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_hog_pct"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_hog_pct"] {
	    name="Output_hog_pct";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_hog_pct"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_dead_pct"] {
	    name="Hidden_dead_pct";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_dead_pct"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_dead_pct"] {
	    name="Output_dead_pct";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_dead_pct"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_netmax"] {
	    name="Hidden_netmax";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_netmax"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_netmax"] {
	    name="Output_netmax";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_netmax"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_avg_act"] {
	    name="Hidden_avg_act";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_avg_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_avg_act"] {
	    name="Output_avg_act";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_avg_act"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_Fm_Input_netrel"] {
	    name="Hidden_Fm_Input_netrel";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_Fm_Input_netrel"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Hidden_Fm_Output_netrel"] {
	    name="Hidden_Fm_Output_netrel";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Hidden_Fm_Output_netrel"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	   GraphColView @["Output_Fm_Hidden_netrel"] {
	    name="Output_Fm_Hidden_netrel";
	    m_data=.projects["LeabraFlex"].data.gp["OutputData"]["EpochOutputData"].data["Output_Fm_Hidden_netrel"]$$;
	    m_transform=NULL;
	    visible=1;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    data_range {min=0: max=0: };
	   };
	  };
	  main_xform {scale={x=1: y=1: z=1: }: rotate={x=0: y=0: z=1: rot=0: }: translate={x=1: y=0: z=0: }: };
	  annotations {
	   name="annotations";
	   el_typ=T3Annotation;
	   el_def=0;
	  };
	  annote_children {
	   name="annote_children";
	   el_typ=T3DataView;
	   el_def=0;
	  };
	  view_rows=10000;
	  view_range {min=0: max=-1: };
	  page_rows=-8017975;
	  display_on=1;
	  manip_ctrl_on=1;
	  graph_type=XY;
	  plot_style=LINE;
	  negative_draw=0;
	  negative_draw_z=1;
	  line_width=2;
	  point_size=0.01;
	  point_spacing=1;
	  bar_space=0.2;
	  bar_depth=0.01;
	  label_spacing=-1;
	  width=1;
	  depth=1;
	  axis_font_size=0.05;
	  label_font_size=0.04;
	  x_axis {
	   name="x_axis";
	   m_data=NULL;
	   m_transform=NULL;
	   on=1;
	   axis=X;
	   col_name="epoch";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  z_axis {
	   name="z_axis";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Z;
	   col_name="batch";
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  tot_plots=16;
	  plots {
	   name="plots";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @["EpochOutputData_Graph_plot_1"] {
	    name="EpochOutputData_Graph_plot_1";
	    m_data=NULL;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="avg_sse";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=1: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_2"] {
	    name="EpochOutputData_Graph_plot_2";
	    m_data=NULL;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="avg_norm_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=SQUARE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_3"] {
	    name="EpochOutputData_Graph_plot_3";
	    m_data=NULL;
	    m_transform=NULL;
	    on=1;
	    axis=Y;
	    col_name="cnt_err";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=1: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=DIAMOND;
	    alt_y=1;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_4"] {
	    name="EpochOutputData_Graph_plot_4";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="Hidden_avg_net_sd";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0.281181: fix_max=0: max=0.466438: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_5"] {
	    name="EpochOutputData_Graph_plot_5";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name="Hidden_avg_cos_diff";
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0.962046: fix_max=0: max=0.999009: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=PLUS;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_6"] {
	    name="EpochOutputData_Graph_plot_6";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CROSS;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_7"] {
	    name="EpochOutputData_Graph_plot_7";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=STAR;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_8"] {
	    name="EpochOutputData_Graph_plot_8";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_9"] {
	    name="EpochOutputData_Graph_plot_9";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_10"] {
	    name="EpochOutputData_Graph_plot_10";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="red": r=1: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=SQUARE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_11"] {
	    name="EpochOutputData_Graph_plot_11";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="blue": r=0: g=0: b=1: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=DIAMOND;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_12"] {
	    name="EpochOutputData_Graph_plot_12";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="green3": r=0: g=0.8039216: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_UP;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_13"] {
	    name="EpochOutputData_Graph_plot_13";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="purple": r=0.627451: g=0.1254902: b=0.9411765: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=PLUS;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_14"] {
	    name="EpochOutputData_Graph_plot_14";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="orange": r=1: g=0.6470588: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=CROSS;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_15"] {
	    name="EpochOutputData_Graph_plot_15";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="brown": r=0.6470588: g=0.1647059: b=0.1647059: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=STAR;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_plot_16"] {
	    name="EpochOutputData_Graph_plot_16";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="chartreuse": r=0.4980392: g=1: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=DOT;
	    point_style=TRIANGLE_DN;
	    alt_y=0;
	   };
	  };
	  errbars {
	   name="errbars";
	   el_typ=GraphPlotView;
	   el_def=0;
	   GraphPlotView @["EpochOutputData_Graph_err_1"] {
	    name="EpochOutputData_Graph_err_1";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_2"] {
	    name="EpochOutputData_Graph_err_2";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_3"] {
	    name="EpochOutputData_Graph_err_3";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_4"] {
	    name="EpochOutputData_Graph_err_4";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=1;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_5"] {
	    name="EpochOutputData_Graph_err_5";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_6"] {
	    name="EpochOutputData_Graph_err_6";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_7"] {
	    name="EpochOutputData_Graph_err_7";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_8"] {
	    name="EpochOutputData_Graph_err_8";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_9"] {
	    name="EpochOutputData_Graph_err_9";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_10"] {
	    name="EpochOutputData_Graph_err_10";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_11"] {
	    name="EpochOutputData_Graph_err_11";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_12"] {
	    name="EpochOutputData_Graph_err_12";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_13"] {
	    name="EpochOutputData_Graph_err_13";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_14"] {
	    name="EpochOutputData_Graph_err_14";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_15"] {
	    name="EpochOutputData_Graph_err_15";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	   GraphPlotView @["EpochOutputData_Graph_err_16"] {
	    name="EpochOutputData_Graph_err_16";
	    m_data=NULL;
	    m_transform=NULL;
	    on=0;
	    axis=Y;
	    col_name=;
	    is_string=0;
	    is_matrix=0;
	    n_cells=1;
	    matrix_cell=0;
	    fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	    show_axis_label=1;
	    show_alt_axis_label=1;
	    color {name="black": r=0: g=0: b=0: a=1: desc="": };
	    n_ticks=10;
	    axis_length=1;
	    line_style=SOLID;
	    point_style=CIRCLE;
	    alt_y=0;
	   };
	  };
	  err_spacing=1;
	  err_bar_width=0.02;
	  color_mode=FIXED;
	  color_axis {
	   name="color_axis";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  colorscale {
	   name="colorscale";
	   chunks=133;
	   min=-1;
	   max=1;
	   last_min=-1;
	   last_max=1;
	   range=0;
	   zero=0;
	   spec=$.colorspecs["C_ColdHot"]$;
	   auto_scale=0;
	  };
	  raster_axis {
	   name="raster_axis";
	   m_data=NULL;
	   m_transform=NULL;
	   on=0;
	   axis=Y;
	   col_name=;
	   is_string=0;
	   is_matrix=0;
	   n_cells=1;
	   matrix_cell=0;
	   fixed_range {fix_min=0: min=0: fix_max=0: max=0: };
	   show_axis_label=1;
	   show_alt_axis_label=1;
	   color {name="black": r=0: g=0: b=0: a=1: desc="": };
	   n_ticks=10;
	   axis_length=1;
	   row_num=0;
	  };
	  thresh=0.5;
	  thr_line_len=0.48;
	  matrix_mode=SEP_GRAPHS;
	  mat_layout=BOT_ZERO;
	  mat_odd_vert=1;
	  two_d_font=0;
	  two_d_font_scale=350;
	 };
	};
       };
       bg_color {r=1: g=1: b=1: a=1: };
       text_color {r=0: g=0: b=0: a=1: };
       headlight_on=1;
       camera_params {
	field_of_view=45;
	near=0.1;
	focal=5;
	far=1000;
       };
       stereo_view=STEREO_NONE;
       saved_views {
	name="saved_views";
	el_typ=T3SavedView;
	el_def=0;
	T3SavedView @["Vw_0"] {
	 name="Vw_0";
	 view_saved=1;
	 pos {x=1.475278: y=0.4989999: z=1.70049: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=1.71299;
	};
	T3SavedView @["Vw_1"] {
	 name="Vw_1";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_2"] {
	 name="Vw_2";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_3"] {
	 name="Vw_3";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_4"] {
	 name="Vw_4";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_5"] {
	 name="Vw_5";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_6"] {
	 name="Vw_6";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_7"] {
	 name="Vw_7";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_8"] {
	 name="Vw_8";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
	T3SavedView @["Vw_9"] {
	 name="Vw_9";
	 view_saved=0;
	 pos {x=0: y=0: z=0: };
	 orient {x=0: y=0: z=1: rot=0: };
	 focal_dist=0;
	};
       };
      };
     };
    };
   };
   docks {
    name="docks";
    el_typ=ToolBoxDockViewer;
    el_def=0;
    ToolBoxDockViewer @["Tools"] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @["view_win_lft"] {
       name="view_win_lft";
       value 8 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_top"] {
       name="view_win_top";
       value 8 0=0.02463891;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_wd"] {
       name="view_win_wd";
       value 8 0=0.04279749;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_ht"] {
       name="view_win_ht";
       value 8 0=0.7179269;
       val_type_fixed=0;
      };
      UserDataItem @["view_win_iconified"] {
       name="view_win_iconified";
       value 1 0=0;
       val_type_fixed=0;
      };
      UserDataItem @["view_visible"] {
       name="view_visible";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="Tools";
     m_data=NULL;
     visible=1;
     win_name=;
     dock_flags=DV_MOVABLE|DV_FLOATABLE;
     dock_area=1;
    };
   };
  };
 };
 save_view=1;
 save_as_only=0;
 auto_name=1;
 last_change_desc="* everything is now in Layer_Groups and spec groups, for portability between projects

* integrated highvis model for objrec, with separate img filtering pathways, etc

* two 'ticks' per trial: fixate, then recognize -- RobotTrial coordinates -- other progs conditionalize on network.tick

* objs_per_epc in lesson -- only present a limited # of objects per epoch repeatedly over the lesson -- makes the carousel much more efficient

  this is all impl in the new Build_Presentation_Robot

* need to change camera fov for objrec -- not enough resolution for fovea otherwise

* added load_0_epc in lesson -- reinit network.epoch after loading weights -- we load pretrained eye weights, but want to start counter over..

";
 networks {
  name="networks";
  el_typ=LeabraNetwork;
  el_def=0;
  LeabraNetwork @["Network_0"] {
   UserDataItem_List @*(.user_data_) {
    name=;
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @["cos_err"] {
     name="cos_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["norm_err"] {
     name="norm_err";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["ext_rew"] {
     name="ext_rew";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["minus_output_name"] {
     name="minus_output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["rt_cycles"] {
     name="rt_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["tot_cycle"] {
     name="tot_cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["phase"] {
     name="phase";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["quarter"] {
     name="quarter";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["sse"] {
     name="sse";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["output_name"] {
     name="output_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["trial_name"] {
     name="trial_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["group_name"] {
     name="group_name";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["total_trials"] {
     name="total_trials";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["time"] {
     name="time";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["cycle"] {
     name="cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["tick"] {
     name="tick";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["trial"] {
     name="trial";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["group"] {
     name="group";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["epoch"] {
     name="epoch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["batch"] {
     name="batch";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["trial_cos_diff"] {
     name="trial_cos_diff";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["avg_act_diff"] {
     name="avg_act_diff";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["cos_diff"] {
     name="cos_diff";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["minus_cycles"] {
     name="minus_cycles";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["ct_cycle"] {
     name="ct_cycle";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["phase_no"] {
     name="phase_no";
     value 1 0=1;
     val_type_fixed=1;
    };
    UserDataItem @["maxda"] {
     name="maxda";
     value 1 0=1;
     val_type_fixed=1;
    };
   };
   name="Network_0";
   desc=;
   specs {
    name="specs";
    el_typ=LeabraLayerSpec;
    el_def=0;
    LeabraLayerSpec @["HiddenLayer"] {
     name="HiddenLayer";
     is_used=1;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=LeabraLayerSpec;
      el_def=0;
      LeabraLayerSpec @["Input_Output"] {
       name="Input_Output";
       is_used=1;
       desc=;
       unique{        };
       children {
	name="children";
	el_typ=LeabraLayerSpec;
	el_def=0;
       };
       lay_inhib {on=1: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
       unit_gp_inhib {on=0: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
       multi_gp_inhib {on=0: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
       multi_gp_geom {size={x=3: y=3: }: st_off={x=-1: y=-1: }: sub_size={x=1: y=1: }: wrap=1: };
       lay_gp_inhib {on=0: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
       avg_act {init=0.1: fixed=0: tau=100: adjust=1: dt=0.01: };
       inhib_misc {self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
       clamp {hard=1: gain=0.2: };
       decay {trial=1: };
       del_inhib {on=0: prv_trl=0: prv_q=0: };
       lstats {
	cos_diff_avg_tau=100;
	hog_thr=0.3;
	dead_thr=0.01;
	cos_diff_avg_dt=0.01;
       };
       lay_lrate=1;
      };
     };
     lay_inhib {on=1: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
     unit_gp_inhib {on=0: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
     multi_gp_inhib {on=0: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
     multi_gp_geom {size={x=3: y=3: }: st_off={x=-1: y=-1: }: sub_size={x=1: y=1: }: wrap=1: };
     lay_gp_inhib {on=0: gi=2: ff=1: ff_max_vs_avg=0: fb=0.5: fb_max_vs_avg=0: fb_tau=1.4: ff0=0.1: fb_dt=0.7142857: };
     avg_act {init=0.1: fixed=0: tau=100: adjust=1: dt=0.01: };
     inhib_misc {self_fb=0: self_tau=1.4: fb_up_immed=0: self_dt=0.7142857: };
     clamp {hard=1: gain=0.2: };
     decay {trial=1: };
     del_inhib {on=0: prv_trl=0: prv_q=0: };
     lstats {
      cos_diff_avg_tau=100;
      hog_thr=0.3;
      dead_thr=0.01;
      cos_diff_avg_dt=0.01;
     };
     lay_lrate=1;
    };
    LeabraUnitSpec @["LeabraUnitSpec_0"] {
     name="LeabraUnitSpec_0";
     is_used=1;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=LeabraUnitSpec;
      el_def=0;
     };
     act_range {min=0: max=1: range=1: scale=1: };
     bias_spec {type=LeabraBiasSpec: spec=.projects["LeabraFlex"].networks["Network_0"].specs["LeabraConSpec_0"].children["LeabraBiasSpec_0"]$$: };
     sse_tol=0.5;
     act_fun=NOISY_XX1;
     act {thr=0.5: gain=100: nvar=0.005: };
     act_misc {rec_nd=1: avg_nd=1: net_gain=1: act_max_hz=100: avg_tau=200: avg_init=0.15: avg_dt=0.005: };
     spike {rise=0: decay=5: g_gain=9: window=3: eq_gain=8: eq_tau=50: eq_dt=0.02: };
     spike_misc {
      ex=0;
      exp_slope=0.02;
      spk_thr=1.2;
      vm_r=0.3;
      t_r=3;
      clamp_max_p=0.12;
      clamp_type=REGULAR;
      eff_spk_thr=0.5;
     };
     opt_thresh {send=0.1: delta=0.005: xcal_lrn=0.01: };
     clamp_range {min=0: max=0.95: range=0.95: scale=1.052632: };
     vm_range {min=0: max=2: range=2: scale=0.5: };
     init {v_m=0.4: act=0: netin=0: };
     dt {integ=1: vm_tau=3.3: net_tau=1.4: fast_cyc=0: vm_dt=0.3030303: net_dt=0.7142857: };
     act_avg {ss_tau=2: s_tau=2: m_tau=10: m_in_s=0.1: s_in_s=0.9: ss_dt=0.5: s_dt=0.5: m_dt=0.1: };
     avg_l {init=0.4: max=1.5: min=0.2: tau=10: lrn_max=0.05: lrn_min=0.005: dt=0.1: lrn_fact=0.03461539: };
     avg_l_2 {err_mod=1: err_min=0.01: act_thr=0.2: lay_act_thr=0.01: };
     g_bar {e=1: l=0.1: i=1: };
     e_rev {e=1: l=0.3: i=0.25: };
     adapt {
      on=0;
      tau=144;
      vm_gain=0.04;
      spike_gain=0.00805;
      Ei_dyn=1;
      Ei_gain=0.001;
      Ei_tau=50;
      dt=0.006944444;
      Ei_dt=0.02;
     };
     stp {on=0: f_r_ratio=0.02: rec_tau=200: p0=0.3: p0_norm=0.4: kre_tau=100: kre=0.002: fac_tau=4: fac=0.3: rec_dt=0.005: fac_dt=0.25: kre_dt=0.01: oneo_p0_norm=2.5: };
     syn_delay {
      on=0;
      delay=4;
     };
     r_lrate {
      on=0;
      base=0.5;
      act_thr=0.2;
     };
     deep_raw_qtr=0;
     deep {on=0: role=SUPER: raw_thr_rel=0.2: raw_thr_abs=0.2: mod_min=0.7: trc_p_only_m=0: trc_thal_gate=0: trc_trace=0: mod_range=0.3: };
     da_mod {on=0: minus=0: plus=0.1: };
     noise_type=NO_NOISE;
     noise {name="noise": type=GAUSSIAN: mean=0: var=0.001: par=1: };
     noise_adapt {trial_fixed=1: drop_thr=0.1: mode=FIXED_NOISE: };
     noise_sched {
      name="noise_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=1;
     };
    };
    LeabraConSpec @["LeabraConSpec_0"] {
     name="LeabraConSpec_0";
     is_used=1;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=LeabraConSpec;
      el_def=0;
      LeabraBiasSpec @["LeabraBiasSpec_0"] {
       name="LeabraBiasSpec_0";
       is_used=1;
       desc=;
       unique{ rnd;wt_limits;wt_scale;wt_scale_init;       };
       children {
	name="children";
	el_typ=LeabraBiasSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0: var=0: par=1: };
       wt_limits {type=NONE: min=-1: max=5: sym=0: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=1: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       use_lrate_sched=1;
       cur_lrate=0.08;
       lrs_mult=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: dwt_norm=0: rugp_wt_sync=0: };
       slow_wts {on=0: swt_pct=0.5: slow_tau=100: cont_swt=1: wt_tau=1: fwt_pct=0.5: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
       dwt_thresh=0.1;
      };
      LeabraConSpec @["TopDownCons"] {
       name="TopDownCons";
       is_used=1;
       desc="top-down connections from output layers down to hidden etc typically need to be weaker than bottom-up";
       unique{ wt_scale;       };
       children {
	name="children";
	el_typ=LeabraConSpec;
	el_def=0;
       };
       rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
       wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
       inhib=0;
       wt_scale {abs=1: rel=0.2: };
       learn=1;
       learn_qtr=Q4;
       lrate=0.04;
       use_lrate_sched=1;
       cur_lrate=0.08;
       lrs_mult=1;
       lrate_sched {
	name="lrate_sched";
	el_typ=SchedItem;
	el_def=0;
	default_val=1;
	interpolate=0;
	SchedItem @[0] {
	 start_ctr=0;
	 start_val=1;
	 duration=50;
	 step=-0.01;
	};
	SchedItem @[1] {
	 start_ctr=50;
	 start_val=0.5;
	 duration=50;
	 step=-0.006;
	};
	SchedItem @[2] {
	 start_ctr=100;
	 start_val=0.2;
	 duration=50;
	 step=-0.002;
	};
	SchedItem @[3] {
	 start_ctr=150;
	 start_val=0.1;
	 duration=50;
	 step=-0.001;
	};
	SchedItem @[4] {
	 start_ctr=200;
	 start_val=0.05;
	 duration=50;
	 step=-0.0006;
	};
	SchedItem @[5] {
	 start_ctr=250;
	 start_val=0.02;
	 duration=50;
	 step=-0.0002;
	};
	SchedItem @[6] {
	 start_ctr=300;
	 start_val=0.01;
	 duration=1;
	 step=1;
	};
       };
       use_unlearnable=1;
       xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
       wt_sig {gain=6: off=1: dwt_norm=0: rugp_wt_sync=0: };
       slow_wts {on=0: swt_pct=0.5: slow_tau=100: cont_swt=1: wt_tau=1: fwt_pct=0.5: slow_dt=0.01: wt_dt=1: };
       deep {on=0: bg_lrate=1: fg_lrate=0: };
      };
     };
     rnd {name="rnd": type=UNIFORM: mean=0.5: var=0.25: par=1: };
     wt_limits {type=MIN_MAX: min=0: max=1: sym=1: sym_fm_top=0: };
     inhib=0;
     wt_scale {abs=1: rel=1: };
     learn=1;
     learn_qtr=Q4;
     lrate=0.04;
     use_lrate_sched=1;
     cur_lrate=0.08;
     lrs_mult=1;
     lrate_sched {
      name="lrate_sched";
      el_typ=SchedItem;
      el_def=0;
      default_val=1;
      interpolate=0;
      SchedItem @[0] {
       start_ctr=0;
       start_val=1;
       duration=50;
       step=-0.01;
      };
      SchedItem @[1] {
       start_ctr=50;
       start_val=0.5;
       duration=50;
       step=-0.006;
      };
      SchedItem @[2] {
       start_ctr=100;
       start_val=0.2;
       duration=50;
       step=-0.002;
      };
      SchedItem @[3] {
       start_ctr=150;
       start_val=0.1;
       duration=50;
       step=-0.001;
      };
      SchedItem @[4] {
       start_ctr=200;
       start_val=0.05;
       duration=50;
       step=-0.0006;
      };
      SchedItem @[5] {
       start_ctr=250;
       start_val=0.02;
       duration=50;
       step=-0.0002;
      };
      SchedItem @[6] {
       start_ctr=300;
       start_val=0.01;
       duration=1;
       step=1;
      };
     };
     use_unlearnable=1;
     xcal {m_lrn=1: set_l_lrn=0: l_lrn=1: d_rev=0.1: d_thr=0.0001: d_rev_ratio=-9: };
     wt_sig {gain=6: off=1: dwt_norm=0: rugp_wt_sync=0: };
     slow_wts {on=0: swt_pct=0.5: slow_tau=100: cont_swt=1: wt_tau=1: fwt_pct=0.5: slow_dt=0.01: wt_dt=1: };
     deep {on=0: bg_lrate=1: fg_lrate=0: };
    };
    FullPrjnSpec @["FullPrjnSpec_0"] {
     name="FullPrjnSpec_0";
     is_used=1;
     desc=;
     unique{      };
     children {
      name="children";
      el_typ=FullPrjnSpec;
      el_def=0;
     };
     self_con=0;
     init_wts=0;
     set_scale=0;
     add_rnd_var=0;
    };
   };
   layers {
    name="layers";
    el_typ=LeabraLayer;
    el_def=0;
    pos {x=0: y=0: z=0: };
    pos2d {x=0: y=0: };
    max_disp_size {x=5: y=5: z=3: };
    max_disp_size2d {x=5: y=18: };
    LeabraLayer @["Input"] {
     name="Input";
     desc=;
     flags=ABS_POS;
     layer_type=INPUT;
     pos {x=0: y=0: z=0: };
     pos_abs {x=0: y=0: z=0: };
     pos2d {x=0: y=0: };
     pos2d_abs {x=0: y=0: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=5: y=5: n_not_xy=0: n=25: };
     disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_disp_geom {x=5: y=5: n_not_xy=0: n=1: };
     n_recv_prjns=0;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_Group @. = [0] = LeabraPrjn .projects["LeabraFlex"].networks["Network_0"].layers["Hidden"].projections["Fm_Input"];
     };
     units {
      name="units";
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=.projects["LeabraFlex"].networks["Network_0"].specs["LeabraUnitSpec_0"]$$: };
     dist {
      fm_input=0;
      fm_output=2;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     acts_m_avg=0.1;
     acts_p_avg=0.1;
     acts_p_avg_eff=0.1;
     spec {type=LeabraLayerSpec: spec=.projects["LeabraFlex"].networks["Network_0"].specs["HiddenLayer"].children["Input_Output"]$$: };
    };
    LeabraLayer @["Hidden"] {
     name="Hidden";
     desc=;
     flags=ABS_POS;
     layer_type=HIDDEN;
     pos {x=0: y=0: z=1: };
     pos_abs {x=0: y=0: z=1: };
     pos2d {x=0: y=13: };
     pos2d_abs {x=0: y=13: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=5: y=5: n_not_xy=0: n=25: };
     disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_disp_geom {x=5: y=5: n_not_xy=0: n=1: };
     n_recv_prjns=2;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @["Fm_Input"] {
       name="Fm_Input";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=.projects["LeabraFlex"].networks["Network_0"].layers["Input"]$$;
       spec {type=FullPrjnSpec: spec=.projects["LeabraFlex"].networks["Network_0"].specs["FullPrjnSpec_0"]$$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["LeabraConSpec_0"]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
      LeabraPrjn @["Fm_Output"] {
       name="Fm_Output";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=.projects["LeabraFlex"].networks["Network_0"].layers["Output"]$$;
       spec {type=FullPrjnSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["FullPrjnSpec_0"]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=.projects["LeabraFlex"].networks["Network_0"].specs["LeabraConSpec_0"].children["TopDownCons"]$$: };
       recv_idx=1;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_OUTPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_Group @. = [0] = LeabraPrjn .projects["LeabraFlex"].networks["Network_0"].layers["Output"].projections["Fm_Hidden"];
     };
     units {
      name="units";
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["LeabraUnitSpec_0"]$: };
     dist {
      fm_input=1;
      fm_output=1;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     acts_m_avg=0.1;
     acts_p_avg=0.1;
     acts_p_avg_eff=0.1;
     spec {type=LeabraLayerSpec: spec=.projects["LeabraFlex"].networks["Network_0"].specs["HiddenLayer"]$$: };
    };
    LeabraLayer @["Output"] {
     name="Output";
     desc=;
     flags=ABS_POS;
     layer_type=TARGET;
     pos {x=0: y=0: z=2: };
     pos_abs {x=0: y=0: z=2: };
     pos2d {x=0: y=6: };
     pos2d_abs {x=0: y=6: };
     disp_scale=1;
     un_geom {x=5: y=5: n_not_xy=0: n=25: };
     unit_groups=0;
     virt_groups=1;
     gp_geom {x=1: y=1: n_not_xy=0: n=1: };
     gp_spc {x=1: y=1: };
     flat_geom {x=5: y=5: n_not_xy=0: n=25: };
     disp_geom {x=5: y=5: n_not_xy=0: n=25: };
     scaled_disp_geom {x=5: y=5: n_not_xy=0: n=1: };
     n_recv_prjns=1;
     n_send_prjns=1;
     projections {
      name="projections";
      el_typ=LeabraPrjn;
      el_def=0;
      LeabraPrjn @["Fm_Hidden"] {
       name="Fm_Hidden";
       off=0;
       disp=1;
       from_type=CUSTOM;
       from=.projects["LeabraFlex"].networks["Network_0"].layers["Hidden"]$$;
       spec {type=FullPrjnSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["FullPrjnSpec_0"]$: };
       con_type=LeabraCon;
       con_spec {type=LeabraConSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["LeabraConSpec_0"]$: };
       recv_idx=0;
       send_idx=0;
       recv_n=1;
       send_n=1;
       projected=1;
       dir_fixed=0;
       direction=FM_INPUT;
       prjn_clr {r=1: g=0.9: b=0.5: a=1: };
      };
     };
     send_prjns {
      name="send_prjns";
      el_typ=LeabraPrjn;
      el_def=0;
      Projection_Group @. = [0] = LeabraPrjn .projects["LeabraFlex"].networks["Network_0"].layers["Hidden"].projections["Fm_Output"];
     };
     units {
      name="units";
      el_typ=LeabraUnit;
      el_def=0;
      pos {x=0: y=0: z=0: };
      output_name=;
     };
     unit_spec {type=LeabraUnitSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["LeabraUnitSpec_0"]$: };
     dist {
      fm_input=2;
      fm_output=0;
     };
     units_lesioned=0;
     gp_unit_names_4d=0;
     brain_area=;
     voxel_fill_pct=1;
     acts_m_avg=0.1;
     acts_p_avg=0.1;
     acts_p_avg_eff=0.1;
     spec {type=LeabraLayerSpec: spec=$.projects["LeabraFlex"].networks["Network_0"].specs["HiddenLayer"].children["Input_Output"]$: };
    };
   };
   weights {
    name="weights";
    el_typ=Weights;
    el_def=0;
   };
   flags=MANUAL_POS|ABS_POS|BUILD_INIT_WTS;
   unit_vars_type=LeabraUnitVars;
   con_group_type=LeabraConGroup;
   auto_build=AUTO_BUILD;
   auto_load_wts=NO_AUTO_LOAD;
   auto_load_file=;
   brain_atlas_name=;
   train_mode=TRAIN;
   wt_update=ON_LINE;
   small_batch_n=10;
   stats {
    sse_unit_avg=0;
    sse_sqrt=0;
    cnt_err_tol=0;
    prerr=0;
   };
   threads {
    run_time {name="TimeUsedHR_6": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
    sync_time {name="TimeUsedHR_7": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
    total_time {name="TimeUsedHR_8": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
    n_wake_in_sync=0;
    run_time_pct=0;
    sync_time_pct=0;
    wake_in_sync_pct=1.216681899864304e+285;
   };
   net_timing {
    name="net_timing";
    el_typ=LeabraNetTiming;
    el_def=0;
    LeabraNetTiming @[0] {
     netin {name="netin": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     act {name="act": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     dwt {name="dwt": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     wt {name="wt": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     netin_integ {name="netin_integ": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     netin_stats {name="netin_stats": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     inhib {name="inhib": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     act_post {name="act_post": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     cycstats {name="cycstats": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
    };
    LeabraNetTiming @[1] {
     netin {name="netin": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     act {name="act": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     dwt {name="dwt": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     wt {name="wt": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     netin_integ {name="netin_integ": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     netin_stats {name="netin_stats": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     inhib {name="inhib": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     act_post {name="act_post": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     cycstats {name="cycstats": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
    };
    LeabraNetTiming @[2] {
     netin {name="netin": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     act {name="act": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     dwt {name="dwt": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     wt {name="wt": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     netin_integ {name="netin_integ": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     netin_stats {name="netin_stats": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     inhib {name="inhib": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     act_post {name="act_post": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
     cycstats {name="cycstats": s_used=0: n_used=0: avg_used={avg=0: sum=0: n=0: }: };
    };
   };
   usr1_save_fmt=FULL_NET;
   wt_save_fmt=TEXT;
   n_units=76;
   n_cons=1875;
   max_prjns=2;
   max_disp_size {x=5: y=5: z=3: };
   max_disp_size2d {x=5: y=18: };
   cuda {
    min_threads=32;
    max_threads=1024;
    cons_per_thread=2;
    timers_on=0;
   };
   times {
    quarter=25;
    gate_cyc=18;
    deep_cyc=5;
    time_inc=0.001;
    minus=75;
    plus=25;
    total_cycles=100;
   };
   lstats {
    trg_max_act_crit=0.5;
    off_errs=1;
    on_errs=1;
    cos_err_lrn_thr=-1;
   };
   net_misc {
    spike=0;
    deep=0;
    bias_learn=1;
    trial_decay=1;
    diff_scale_p=0;
    diff_scale_q1=0;
    dwt_norm=0;
    rugp_wt_sync=0;
    lay_gp_inhib=0;
    inhib_cons=0;
   };
   deep {
    on=0;
    ctxt=0;
    raw_net=0;
    mod_net=0;
    raw_qtr=0;
   };
   rel_netin {
    on=1;
    trl_skip=10;
    epc_skip=10;
   };
  };
 };
};

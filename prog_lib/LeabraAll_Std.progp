// ta_Dump File v2.0
Program_Group .projects[0].programs.gp[0] { 
  Program_Group .projects[0].programs.gp[0] = [10] {
    Program @[0] { 
      ProgVar_List @.args = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      ProgVar_List @.vars = [1] {
	ProgVar @[0] { };
      };

      ProgEl_List @.init_code = [1] {
	NetCounterInit @[0] { };
      };

      ProgEl_List @.prog_code = [2] {
	NetCounterInit @[0] { };
	WhileLoop @[1] { 
	  ProgEl_List @.loop_code = [2] {
	    ProgramCall @[0] { 
	      ProgArg_List @.prog_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    NetCounterIncr @[1] { };
	  };
	};
      };
    };
    Program @[1] { 
      ProgObjList @.objs = [1] {
	RndSeed @[0] { };
      };

      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [6] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
      };

      ProgEl_List @.init_code = [5] {
	MethodCall @[0] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	AssignExpr @[1] { };
	NetCounterInit @[2] { };
	MethodCall @[3] { };
	MethodCall @[4] { };
      };

      ProgEl_List @.prog_code = [7] {
	AssignExpr @[0] { };
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	NetCounterInit @[2] { };
	UserScript @[3] { };
	MethodCall @[4] { };
	WhileLoop @[5] { 
	  ProgEl_List @.loop_code = [3] {
	    ProgramCall @[0] { 
	      ProgArg_List @.prog_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    NetCounterIncr @[1] { };
	    IfBreak @[2] { };
	  };
	};
	MethodCall @[6] { };
      };
    };
    Program @[2] { 
      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [4] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
      };

      ProgEl_List @.init_code = [2] {
	NetCounterInit @[0] { };
	AssignExpr @[1] { };
      };

      ProgEl_List @.prog_code = [9] {
	NetCounterInit @[0] { };
	AssignExpr @[1] { };
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	MethodCall @[3] { };
	BasicDataLoop @[4] { 
	  ProgEl_List @.loop_code = [3] {
	    UserScript @[0] { };
	    ProgramCall @[1] { 
	      ProgArg_List @.prog_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    IfElse @[2] { 
	      ProgEl_List @.true_code = [1] {
		MethodCall @[0] { };
	      };
	    };
	  };
	};
	IfElse @[5] { 
	  ProgEl_List @.true_code = [1] {
	    MethodCall @[0] { };
	  };
	};
	MethodCall @[6] { };
	MethodCall @[7] { };
	ProgramCall @[8] { 
	  ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	  };
	};
      };
    };
    Program @[3] { 
      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgEl_List @.init_code = [1] {
	NetCounterInit @[0] { };
      };

      ProgEl_List @.prog_code = [6] {
	NetCounterInit @[0] { };
	MethodCall @[1] { };
	WhileLoop @[2] { 
	  ProgEl_List @.loop_code = [3] {
	    ProgramCall @[0] { 
	      ProgArg_List @.prog_args = [2] {
		ProgArg @[0] { };
		ProgArg @[1] { };
	      };
	    };
	    NetCounterIncr @[1] { };
	    MethodCall @[2] { };
	  };
	};
	MethodCall @[3] { };
	ProgramCall @[4] { 
	  ProgArg_List @.prog_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	NetUpdateView @[5] { };
      };
    };
    Program @[4] { 
      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      ProgEl_List @.init_code = [1] {
	NetCounterInit @[0] { };
      };

      ProgEl_List @.prog_code = [10] {
	NetCounterInit @[0] { };
	MethodCall @[1] { };
	ProgramCall @[2] { 
	  ProgArg_List @.prog_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[3] { };
	UserScript @[4] { };
	WhileLoop @[5] { 
	  ProgEl_List @.loop_code = [4] {
	    ProgramCall @[0] { 
	      ProgArg_List @.prog_args = [1] {
		ProgArg @[0] { };
	      };
	    };
	    NetCounterIncr @[1] { };
	    IfContinue @[2] { };
	    IfBreak @[3] { };
	  };
	};
	MethodCall @[6] { };
	IfElse @[7] { 
	  ProgEl_List @.true_code = [1] {
	    MethodCall @[0] { };
	  };
	};
	IfElse @[8] { 
	  ProgEl_List @.true_code = [1] {
	    MethodCall @[0] { };
	  };
	};
	NetUpdateView @[9] { };
      };
    };
    Program @[5] { 
      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [1] {
	ProgVar @[0] { };
      };

      ProgEl_List @.prog_code = [2] {
	MethodCall @[0] { };
	NetUpdateView @[1] { };
      };
    };
    Program @[6] { 
      ProgObjList @.objs = [1] {
	LayerWriter @[0] { 
	  LayerDataEl_List @.layer_data = [3] {
	    LayerWriterEl @[0] { };
	    LayerWriterEl @[1] { };
	    LayerWriterEl @[2] { };
	  };
	};
      };

      ProgVar_List @.args = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgVar_List @.vars = [1] {
	ProgVar @[0] { };
      };

      ProgEl_List @.init_code = [2] {
	MethodCall @[0] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
      };

      ProgEl_List @.prog_code = [1] {
	MethodCall @[0] { };
      };
    };
    Program @[7] { 
      ProgObjList @.objs = [1] {
	NetMonitor @[0] { 
	  NetMonItem_List @.items = [9] {
	    NetMonItem @[0] { };
	    NetMonItem @[1] { };
	    NetMonItem @[2] { };
	    NetMonItem @[3] { };
	    NetMonItem @[4] { };
	    NetMonItem @[5] { };
	    NetMonItem @[6] { };
	    NetMonItem @[7] { };
	    NetMonItem @[8] { };
	  };
	};
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [2] {
	ProgVar @[0] { };
	ProgVar @[1] { };
      };

      ProgEl_List @.init_code = [3] {
	MethodCall @[0] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
      };

      ProgEl_List @.prog_code = [4] {
	MethodCall @[0] { };
	MethodCall @[1] { };
	MethodCall @[2] { };
	MethodCall @[3] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
      };
    };
    Program @[8] { 
      ProgObjList @.objs = [1] {
	NetMonitor @[0] { 
	  NetMonItem_List @.items = [8] {
	    NetMonItem @[0] { };
	    NetMonItem @[1] { };
	    NetMonItem @[2] { };
	    NetMonItem @[3] { };
	    NetMonItem @[4] { };
	    NetMonItem @[5] { };
	    NetMonItem @[6] { };
	    NetMonItem @[7] { };
	  };
	};
      };

      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [3] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
      };

      ProgEl_List @.init_code = [4] {
	AssignExpr @[0] { };
	MethodCall @[1] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MethodCall @[2] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
	MethodCall @[3] { 
	  ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	  };
	};
      };

      ProgEl_List @.prog_code = [5] {
	MethodCall @[0] { };
	MethodCall @[1] { };
	AssignExpr @[2] { };
	UserScript @[3] { };
	MethodCall @[4] { };
      };
    };
    Program @[9] { 
      ProgVar_List @.args = [1] {
	ProgVar @[0] { };
      };

      ProgVar_List @.vars = [6] {
	ProgVar @[0] { };
	ProgVar @[1] { };
	ProgVar @[2] { };
	ProgVar @[3] { };
	ProgVar @[4] { };
	ProgVar @[5] { };
      };

      ProgEl_List @.prog_code = [6] {
	IfElse @[0] { 
	  ProgEl_List @.true_code = [1] {
	    UserScript @[0] { };
	  };
	};
	MiscCall @[1] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	MiscCall @[2] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
	AssignExpr @[3] { };
	MethodCall @[4] { 
	  ProgArg_List @.meth_args = [4] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	  };
	};
	MethodCall @[5] { 
	  ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	  };
	};
      };
    };
  };
};
Program_Group .projects[0].programs.gp[0] {
 name="LeabraAll_Std";
 el_typ=Program;
 el_def=0;
 step_prog=.projects[0].programs.gp[0][4]$0$;
 desc="The full set of programs for training a standard Leabra network";
 Program @[0] {
  name="LeabraBatch";
  desc="Iterate over training runs";
  flags=;
  objs {
   name=;
   el_typ=taOBase;
   el_def=0;
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=.projects[0].networks[0]$1$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="input_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=.projects[0].data.gp[0][0]$2$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[2] {
    name="max_batch";
    var_type=T_Int;
    int_val=10;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="batch";
    var_type=T_Int;
    int_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="batch counter";
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=NetCounterInit;
   el_def=0;
   NetCounterInit @[0] {
    desc=;
    flags=;
    network_var=.projects[0].programs.gp[0][0].args[0]$3$;
    local_ctr_var=.projects[0].programs.gp[0][0].vars[0]$4$;
    counter=Network::batch;
   };
  };
  prog_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
   NetCounterInit @[0] {
    desc=;
    flags=;
    network_var=$3$;
    local_ctr_var=$4$;
    counter=Network::batch;
   };
   WhileLoop @[1] {
    desc=;
    flags=;
    loop_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     ProgramCall @[0] {
      desc=;
      flags=;
      target=.projects[0].programs.gp[0][1]$5$;
      targ_ld_init="*LeabraTrain*";
      call_init=0;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	expr {
	 expr="input_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ input_data;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     NetCounterIncr @[1] {
      desc=;
      flags=;
      network_var=$3$;
      local_ctr_var=$4$;
      counter=Network::batch;
     };
    };
    test {
     expr="batch < max_batch";
     flags=;
     var_expr="$#0#$ < $#1#$";
     vars {
     };
     var_names{ batch;max_batch;     };
     bad_vars{      };
    };
   };
  };
 };
 Program @[1] {
  name="LeabraTrain";
  desc="A complete training run of a Leabra network: iterating over epochs until the network has learned the task";
  flags=;
  objs {
   name=;
   el_typ=RndSeed;
   el_def=0;
   RndSeed @[0] {
    name="rnd_seed";
    seed{ 897248114;-1259630319;-1954705695;-2086433643;-1705562578;-246166775;142172280;-1066196830;649876912;-363601797;-1551220787;-201998924;984813377;-1929982005;1866720504;1737535582;-2064818913;-596409631;-537210356;-394821123;-1176302275;-1088439095;390472553;1002483428;-644065336;-93234492;-249392311;1955837623;486322880;268723693;-1316990013;-1148081097;1053267338;-194887551;722894185;-1796145741;-419870710;-744395548;-2126350183;-1623934615;-1975558537;-1109580724;1457379925;952758326;-932820647;-793678521;622734178;-1116891631;992844023;348717466;1162608598;-2078137647;-402129645;-523610230;-892508948;-545793120;1897913877;280270467;-1694155315;294983543;-1251003482;-1650029695;-1335161250;-843867016;1576969605;-260969840;-224140684;1265137246;954732510;2064975050;-1145863940;-1435022393;-1859029257;1513712809;985631399;417291160;-2038587757;-1933156114;888379733;1446724555;-464909414;-1706911051;-1159096460;-1791674743;-147343083;960690226;682596297;1099430942;359127508;311504974;93962501;-1671326033;632618192;-885562045;1179982281;-1505675969;1344906533;-1418551925;1622092278;1701084792;242471559;-1984251903;-1568971862;-1063520265;1591722069;-1959097976;-1601150455;-874166212;-889564662;717605003;-1582378599;-1301052667;1211123575;485189748;-182999148;374766658;1150697026;-738165078;-390496439;960351772;-332421139;71115877;-1747551486;-288197538;2067393244;-402841323;168191432;698976579;-691346957;454158309;419567441;-1655444926;1843518827;-1387150657;-1775972895;1209349907;1737084105;-273997764;2063222132;-629133755;1321145195;-340980602;-64855207;836106865;-384606302;857100345;-616134379;-1192753754;-1534913223;1646103447;-337508797;-104008340;1371554336;1910014402;1731164243;157488784;-1230766726;1651230814;-1801393009;1853249886;-1909629469;-2064890998;-586605120;1029458265;-1567764431;-569878997;-1071722633;1842759325;1870815306;1275367738;-2047480342;699437794;-2078020834;2120915280;1609487567;715455530;-1961002406;-1366381474;1214551640;1682680277;1866914062;-1438763676;1522254727;410589237;1882867230;-2066414372;335577213;-1969515802;-2079897542;1101145964;-914546306;-578950040;-399253994;-1096753521;-660660212;-1198578643;1339175923;-781551297;-1839371394;1105332893;-1928816742;-400816250;1655921312;-452260989;2002840327;447789431;319958765;-658015714;-2019202134;-1586612048;-137582258;706769011;1101838665;827045450;599553857;-2145445088;244597783;1487421271;1630555190;-344172316;-1830139429;-1553867370;-156727033;-755056810;-2131860048;-494346652;1852068823;91308896;725609566;-1111505690;-982815291;1292267944;1836226774;-810066908;-496780978;202956912;603675823;637918661;-10943404;552199869;1297990249;-1519144401;-1727998742;1493519921;-1227758025;-860568373;2118867559;1126222143;-1549971275;-1469719981;-370967157;-1094842937;2081077388;-1045858167;-179155018;-384518151;905350287;-1851803717;571620219;760498291;-480881197;-973785647;838212682;340510526;510321855;-801267485;-852016520;1774211485;39420368;537777206;2107097314;1618664461;210916571;-423959548;631482818;-1040919263;-279241335;-892903760;497369428;1334556795;-290177741;-620998078;1723791759;253979182;2098469877;2033083432;2025527244;-556275368;-1153759308;1554310973;-2109179006;1594713042;-1652347925;-1896234258;1399293819;-1212915145;264979477;2035769098;-26264659;816116738;-1472777223;-1886895409;579752040;1987550252;850378084;-592526232;228677599;-1282752773;-3264037;1636907752;554996081;10747923;1856021975;150743074;1441285143;-284865308;64061770;547700487;2007963302;-518601320;717968026;-1887063740;-1161755710;654757340;624448862;1095845326;1219653475;1112960789;540367258;1430941426;-1573264900;842324047;-1866598839;672477326;-834606497;456739053;2014938441;1820294365;-1127769538;237909957;778195458;-320898672;-493131725;374332760;1492882317;244532839;1469335464;813662131;1904048850;1828753335;1969748325;1462812563;773013089;1263710334;6222118;1806899780;-1306665146;695150693;1034369820;-410885147;-2065109159;-21981403;1688153775;-1834763828;-2034905187;-868895926;-2040902706;760295113;705437415;-801989522;-327259983;340256932;1639347777;676478214;-868392127;-2126595595;1085040460;-101711712;1181203896;-1177629723;1052562025;-385800214;-2127578499;-247860261;-210619237;-1285411717;-1501642238;-1370695642;-901640534;-1139102088;-1435816006;2062624444;733280257;-325264040;815916517;1806401640;106587238;222094010;-1348528385;297616670;-861761020;117428779;2046490308;1520601476;1774880419;2117307057;709856479;658783300;-1019651996;1857641166;-1623434894;-1466106812;1764750271;337867896;1769011978;1878580541;-337505063;55931846;657238908;1968152816;-169076117;-975001150;-619957198;463669432;-1908341507;-643594058;-2026430605;1348524010;-730896925;454931916;416148985;-1578791134;-739712940;-1725329931;204101311;-1062609662;-1691773722;860783264;946450304;1161241387;207536058;3478215;923381087;-305329130;-1353819564;48467194;-497866365;-1191262819;1442954968;-408984143;934531440;1843513070;-1086308879;585900848;-1977125474;-643228730;1005419111;430194483;1169789286;892875109;-1732318651;-897476207;416658129;2090816327;-186559977;-187909452;1699611428;132945605;1386154990;-1021089733;1553010825;1685237703;1771892687;-1665309430;-1471203233;408978895;-1985168698;-1461014828;-475885929;-149644797;184461852;-1631733780;-113049057;1929365839;-1841043271;755994780;1384891379;-572376242;-1822728640;527993133;536302677;-728200547;-1916517795;401821920;777687226;634513383;938837982;-1741204308;-712292839;-888158003;-989731250;1070351745;-997999887;-1220926516;-477621207;-668502217;432615022;341097247;-1817216444;-1580909839;1073812924;-1037427637;-421491456;-2071807233;419582815;835099779;-300811050;1008848942;-622226245;1119083448;2015783992;374250496;417956216;70961961;-1285132279;1021911943;1585993281;1118486430;-946608452;-1704284523;1344252873;908115709;2135579935;636192621;-776174384;533471998;586778067;-154978136;1359740759;1629951629;-1733015859;2121954041;2104107711;-295897115;1345244080;-1738577645;-559564224;1033955967;-1763695458;250221436;-693902564;1091788545;927707887;-712040796;1439001997;1595609215;1364606826;661845780;-755815374;-2034931863;1346096804;-2074100882;-1065691144;654888208;1007146357;778226326;1410374083;1808044267;239070962;-300943249;1387420801;914251343;580430497;1404608152;117575915;1513662704;256310634;-569005681;-1678005121;-1445134348;2053633677;2025466731;-1577911340;-1278866808;-623511374;-1672074119;45321757;1247003680;1061170196;1198754894;-104913407;2054118989;-1781862918;1530368638;-226966082;-707276305;1591871350;331461390;608113940;235882513;-2046843672;-1075932011;-1894925926;1648301914;1170547429;1665497643;-1251944432;-1796010764;-73953480;788544378;1090859788;-1128050928;-145143834;594707390;-728801566;-252193318;1890915838;-834826210;602694736;1275821290;-2078563303;-1397408457;-343458496;1558647263;    };
    mti=156;
   };
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="input_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$2$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="max_epoch";
    var_type=T_Int;
    int_val=500;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="train_mode";
    var_type=T_HardEnum;
    int_val=1;
    hard_enum_type=Network::TrainMode;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[2] {
    name="epoch";
    var_type=T_Int;
    int_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[3] {
    name="err_stopcrit";
    var_type=T_Real;
    real_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[4] {
    name="rnd_seed";
    var_type=T_Object;
    object_type=RndSeed;
    object_val=.projects[0].programs.gp[0][1].objs[0]$6$;
    objs_ptr=1;
    flags=NULL_CHECK;
    desc=;
   };
   ProgVar @[5] {
    name="train_timer";
    var_type=T_Object;
    object_type=TimeUsed;
    object_val=.projects[0].networks[0].train_time$7$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc=;
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][1].args[0]$8$;
    method=taBase::CheckConfig;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=NULL;
      type="bool";
      name="quiet";
      expr {
       expr="false";
       flags=;
       var_expr="false";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   AssignExpr @[1] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][1].vars[5]$9$;
    expr {
     expr="network.train_time";
     flags=;
     var_expr="$#0#$.train_time";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
   };
   NetCounterInit @[2] {
    desc="initialize epoch counter ";
    flags=;
    network_var=$8$;
    local_ctr_var=.projects[0].programs.gp[0][1].vars[2]$10$;
    counter=Network::epoch;
   };
   MethodCall @[3] {
    desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][1].vars[4]$11$;
    method=RndSeed::OldSeed;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   MethodCall @[4] {
    desc="this initializes the weights every time user presses Init -- could turn this off for large nets (init is also in prog_code)";
    flags=;
    result_var=NULL;
    obj=$8$;
    method=Network::Init_Weights;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   AssignExpr @[0] {
    desc=;
    flags=;
    result_var=$9$;
    expr {
     expr="network.train_time";
     flags=;
     var_expr="$#0#$.train_time";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
   };
   MethodCall @[1] {
    desc="keeps track of how long it takes to run entire training run";
    flags=;
    result_var=NULL;
    obj=$9$;
    method=TimeUsed::StartTimer;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="reset_used";
      expr {
       expr="true";
       flags=;
       var_expr="true";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   NetCounterInit @[2] {
    desc="initialize epoch counter ";
    flags=;
    network_var=$8$;
    local_ctr_var=$10$;
    counter=Network::epoch;
   };
   UserScript @[3] {
    desc="update network's train mode to be same as ours";
    flags=;
    script {
     expr="network.train_mode = train_mode;";
     flags=NO_VAR_ERRS;
     var_expr="$#0#$.train_mode = $#1#$;";
     vars {
     };
     var_names{ network;train_mode;     };
     bad_vars{      };
    };
   };
   MethodCall @[4] {
    desc="initialize network weights: could also load pre-set weights or something else here";
    flags=;
    result_var=NULL;
    obj=$8$;
    method=Network::Init_Weights;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   WhileLoop @[5] {
    desc=;
    flags=;
    loop_code {
     name=;
     el_typ=ProgramCall;
     el_def=0;
     ProgramCall @[0] {
      desc=;
      flags=;
      target=.projects[0].programs.gp[0][2]$12$;
      targ_ld_init="*LeabraEpoch*";
      call_init=0;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	expr {
	 expr="input_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ input_data;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     NetCounterIncr @[1] {
      desc="increment the epoch counter";
      flags=;
      network_var=$8$;
      local_ctr_var=$10$;
      counter=Network::epoch;
     };
     IfBreak @[2] {
      desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here too)";
      flags=;
      cond {
       expr="network.cnt_err <= err_stopcrit";
       flags=;
       var_expr="$#0#$.cnt_err <= $#1#$";
       vars {
       };
       var_names{ network;err_stopcrit;       };
       bad_vars{        };
      };
     };
    };
    test {
     expr="epoch < max_epoch";
     flags=;
     var_expr="$#0#$ < $#1#$";
     vars {
     };
     var_names{ epoch;max_epoch;     };
     bad_vars{      };
    };
   };
   MethodCall @[6] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$9$;
    method=TimeUsed::EndTimer;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
  };
 };
 Program @[2] {
  name="LeabraEpoch";
  desc="iterates over all of the items in a data table and calls LeabraTrial process on them";
  flags=;
  objs {
   name=;
   el_typ=taOBase;
   el_def=0;
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="input_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$2$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="table of patterns to present to the network, one row at a time";
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="data_loop_order";
    var_type=T_HardEnum;
    int_val=1;
    hard_enum_type=BasicDataLoop::Order;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="controls the order in which events (rows of the input data datatable) are presented to the network";
   };
   ProgVar @[1] {
    name="trial";
    var_type=T_Int;
    int_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="current trial (event) within the epoch -- increments automatically";
   };
   ProgVar @[2] {
    name="trial_mon_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=.projects[0].data.gp[1][0]$13$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="trial-level output data -- we reset it every epoch by default, so it just contains last epoch of data";
   };
   ProgVar @[3] {
    name="epoch_timer";
    var_type=T_Object;
    object_type=TimeUsed;
    object_val=.projects[0].networks[0].epoch_time$14$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=NetCounterInit;
   el_def=0;
   NetCounterInit @[0] {
    desc="initialize trial counter: note also needs to do this in regular running program";
    flags=;
    network_var=.projects[0].programs.gp[0][2].args[0]$15$;
    local_ctr_var=.projects[0].programs.gp[0][2].vars[1]$16$;
    counter=Network::trial;
   };
   AssignExpr @[1] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][2].vars[3]$17$;
    expr {
     expr="network.epoch_time";
     flags=;
     var_expr="$#0#$.epoch_time";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
   };
  };
  prog_code {
   name=;
   el_typ=NetCounterInit;
   el_def=0;
   NetCounterInit @[0] {
    desc="initialize trial counter";
    flags=;
    network_var=$15$;
    local_ctr_var=$16$;
    counter=Network::trial;
   };
   AssignExpr @[1] {
    desc=;
    flags=;
    result_var=$17$;
    expr {
     expr="network.epoch_time";
     flags=;
     var_expr="$#0#$.epoch_time";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
   };
   MethodCall @[2] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$17$;
    method=TimeUsed::StartTimer;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="reset_used";
      expr {
       expr="true";
       flags=;
       var_expr="true";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[3] {
    desc="reset trial-level monitor data every epoch, so it reflects only the most recent epoch's worth of data (turn OFF if not wanted)";
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][2].vars[2]$18$;
    method=DataTable::ResetData;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   BasicDataLoop @[4] {
    desc=;
    flags=;
    loop_code {
     name=;
     el_typ=ProgramCall;
     el_def=0;
     UserScript @[0] {
      desc="set trial to list_idx of data loop -- for dmem code this is the correct trial number";
      flags=;
      script {
       expr="trial = list_idx; network.trial = list_idx;";
       flags=NO_VAR_ERRS;
       var_expr="$#0#$ = list_idx; $#1#$.trial = list_idx;";
       vars {
       };
       var_names{ trial;network;       };
       bad_vars{ list_idx;       };
      };
     };
     ProgramCall @[1] {
      desc=;
      flags=;
      target=.projects[0].programs.gp[0][3]$19$;
      targ_ld_init="*LeabraTrial*";
      call_init=0;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	expr {
	 expr="input_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ input_data;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     IfElse @[2] {
      desc="test if it is time to update the weight values from delta weights (dWt) computed over trials";
      flags=;
      cond {
       expr="network.Compute_Weights_Test(trial+1)";
       flags=;
       var_expr="$#0#$.Compute_Weights_Test($#1#$+1)";
       vars {
       };
       var_names{ network;trial;       };
       bad_vars{        };
      };
      true_code {
       name=;
       el_typ=MethodCall;
       el_def=0;
       MethodCall @[0] {
	desc=;
	flags=;
	result_var=NULL;
	obj=$15$;
	method=Network::Compute_Weights;
	meth_args {
	 name=;
	 el_typ=ProgArg;
	 el_def=0;
	};
       };
      };
      false_code {
       name=;
       el_typ=ProgEl;
       el_def=0;
      };
     };
    };
    data_var=.projects[0].programs.gp[0][2].args[1]$20$;
    order_var=.projects[0].programs.gp[0][2].vars[0]$21$;
    order=PERMUTED;
    item_idx_list{ 5;4;2;1;0;3;    };
    dmem_nprocs=1;
    dmem_this_proc=0;
   };
   IfElse @[5] {
    desc="if full batch mode, update only at end of epoch";
    flags=;
    cond {
     expr="network.wt_update == Network::BATCH";
     flags=;
     var_expr="$#0#$.wt_update == Network::BATCH";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
    true_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$15$;
      method=Network::Compute_Weights;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    false_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
   };
   MethodCall @[6] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$15$;
    method=LeabraNetwork::Compute_EpochStats;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   MethodCall @[7] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$17$;
    method=TimeUsed::EndTimer;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   ProgramCall @[8] {
    desc=;
    flags=;
    target=.projects[0].programs.gp[0][8]$22$;
    targ_ld_init="*LeabraEpochMonitor*";
    call_init=0;
    prog_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=Network;
      type="LeabraNetwork*";
      name="network";
      expr {
       expr="network";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
   };
  };
 };
 Program @[3] {
  name="LeabraTrial";
  desc="Leabra processing of a single input/toutput event or external information: typically runs a minus and a plus phase, then learns (unless testing)";
  flags=;
  objs {
   name=;
   el_typ=taOBase;
   el_def=0;
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="input_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$2$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="phase_no";
    var_type=T_Int;
    int_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="update_net_view";
    var_type=T_Bool;
    bool_val=1;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=NetCounterInit;
   el_def=0;
   NetCounterInit @[0] {
    desc=;
    flags=;
    network_var=.projects[0].programs.gp[0][3].args[0]$23$;
    local_ctr_var=.projects[0].programs.gp[0][3].vars[0]$24$;
    counter=LeabraNetwork::phase_no;
   };
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   NetCounterInit @[0] {
    desc=;
    flags=;
    network_var=$23$;
    local_ctr_var=$24$;
    counter=LeabraNetwork::phase_no;
   };
   MethodCall @[1] {
    desc="initializes various counters at start of trial";
    flags=;
    result_var=NULL;
    obj=$23$;
    method=LeabraNetwork::Trial_Init;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   WhileLoop @[2] {
    desc=;
    flags=;
    loop_code {
     name=;
     el_typ=ProgramCall;
     el_def=0;
     ProgramCall @[0] {
      desc=;
      flags=;
      target=$0$;
      targ_ld_init="*LeabraSettle*";
      call_init=0;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
       ProgArg @[1] {
	arg_type=DataTable;
	type="DataTable*";
	name="input_data";
	expr {
	 expr="input_data";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ input_data;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     NetCounterIncr @[1] {
      desc=;
      flags=;
      network_var=$23$;
      local_ctr_var=$24$;
      counter=LeabraNetwork::phase_no;
     };
     MethodCall @[2] {
      desc="increments phase_no and other phase state";
      flags=;
      result_var=NULL;
      obj=$23$;
      method=LeabraNetwork::Trial_UpdatePhase;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    test {
     expr="phase_no < network.phase_max";
     flags=;
     var_expr="$#0#$ < $#1#$.phase_max";
     vars {
     };
     var_names{ phase_no;network;     };
     bad_vars{      };
    };
   };
   MethodCall @[3] {
    desc="does Compute_dWt etc";
    flags=;
    result_var=NULL;
    obj=$23$;
    method=LeabraNetwork::Trial_Final;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   ProgramCall @[4] {
    desc="monitor data on a trial level";
    flags=;
    target=.projects[0].programs.gp[0][7]$25$;
    targ_ld_init="*LeabraTrialMonitor*";
    call_init=0;
    prog_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=Network;
      type="LeabraNetwork*";
      name="network";
      expr {
       expr="network";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
   };
   NetUpdateView @[5] {
    desc=;
    flags=;
    network_var=$23$;
    update_var=.projects[0].programs.gp[0][3].vars[1]$26$;
   };
  };
 };
 Program @[4] {
  name="LeabraSettle";
  desc="iterates over cycles of updating until network has settled into a stable state, or output activations have exceeded a threshold";
  flags=;
  objs {
   name=;
   el_typ=taOBase;
   el_def=0;
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="input_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$2$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="cycle";
    var_type=T_Int;
    int_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="min_cycles";
    var_type=T_Int;
    int_val=15;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[2] {
    name="update_net_view";
    var_type=T_Bool;
    bool_val=1;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=NetCounterInit;
   el_def=0;
   NetCounterInit @[0] {
    desc=;
    flags=;
    network_var=.projects[0].programs.gp[0][4].args[0]$27$;
    local_ctr_var=.projects[0].programs.gp[0][4].vars[0]$28$;
    counter=Network::cycle;
   };
  };
  prog_code {
   name=;
   el_typ=NetCounterInit;
   el_def=0;
   NetCounterInit @[0] {
    desc=;
    flags=;
    network_var=$27$;
    local_ctr_var=$28$;
    counter=Network::cycle;
   };
   MethodCall @[1] {
    desc="resets input data, before getting new external inputs data from apply inputs call";
    flags=;
    result_var=NULL;
    obj=$27$;
    method=Network::Init_InputData;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   ProgramCall @[2] {
    desc="this program can be extended to do arbitrary things to generate data and apply it to network layers";
    flags=;
    target=.projects[0].programs.gp[0][6]$29$;
    targ_ld_init="*ApplyInputs*";
    call_init=0;
    prog_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=LeabraNetwork;
      type="LeabraNetwork*";
      name="network";
      expr {
       expr="network";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=DataTable;
      type="DataTable*";
      name="input_data";
      expr {
       expr="input_data";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ input_data;       };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[3] {
    desc="initializes various counters at start of settling";
    flags=;
    result_var=NULL;
    obj=$27$;
    method=LeabraNetwork::Settle_Init;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   UserScript @[4] {
    desc="get min cycles";
    flags=;
    script {
     expr="if(network.phase_no <= 1) min_cycles = network.min_cycles;
else min_cycles = network.min_cycles_phase2;

";
     flags=NO_VAR_ERRS;
     var_expr="if($#0#$.phase_no <= 1) $#1#$ = $#0#$.min_cycles;
else $#1#$ = $#0#$.min_cycles_phase2;


";
     vars {
     };
     var_names{ network;min_cycles;     };
     bad_vars{ if;else;     };
    };
   };
   WhileLoop @[5] {
    desc=;
    flags=;
    loop_code {
     name=;
     el_typ=ProgramCall;
     el_def=0;
     ProgramCall @[0] {
      desc=;
      flags=;
      target=.projects[0].programs.gp[0][5]$30$;
      targ_ld_init="*LeabraCycle*";
      call_init=0;
      prog_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
       ProgArg @[0] {
	arg_type=LeabraNetwork;
	type="LeabraNetwork*";
	name="network";
	expr {
	 expr="network";
	 flags=;
	 var_expr="$#0#$";
	 vars {
	 };
	 var_names{ network;	 };
	 bad_vars{ 	 };
	};
       };
      };
     };
     NetCounterIncr @[1] {
      desc=;
      flags=;
      network_var=$27$;
      local_ctr_var=$28$;
      counter=Network::cycle;
     };
     IfContinue @[2] {
      desc="avoid subsequent stopping criteria";
      flags=;
      cond {
       expr="cycle < min_cycles";
       flags=;
       var_expr="$#0#$ < $#1#$";
       vars {
       };
       var_names{ cycle;min_cycles;       };
       bad_vars{        };
      };
     };
     IfBreak @[3] {
      desc="stopping criterion for settling";
      flags=;
      cond {
       expr="(network.maxda < network.maxda_stopcrit) ||
 (network.trg_max_act > network.trg_max_act_stopcrit)";
       flags=;
       var_expr="($#0#$.maxda < $#0#$.maxda_stopcrit) ||
 ($#0#$.trg_max_act > $#0#$.trg_max_act_stopcrit)";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
    test {
     expr="cycle < network.cycle_max";
     flags=;
     var_expr="$#0#$ < $#1#$.cycle_max";
     vars {
     };
     var_names{ cycle;network;     };
     bad_vars{      };
    };
   };
   MethodCall @[6] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$27$;
    method=LeabraNetwork::Settle_Final;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   IfElse @[7] {
    desc="only run sse in minus phase";
    flags=;
    cond {
     expr="network.phase == LeabraNetwork::MINUS_PHASE";
     flags=;
     var_expr="$#0#$.phase == LeabraNetwork::MINUS_PHASE";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
    true_code {
     name=;
     el_typ=MethodCall;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$27$;
      method=LeabraNetwork::Compute_TrialStats;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    false_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
   };
   IfElse @[8] {
    desc="this stat must be called in plus phase when reward information is avail";
    flags=;
    cond {
     expr="network.phase_no == 1";
     flags=;
     var_expr="$#0#$.phase_no == 1";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
    true_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     MethodCall @[0] {
      desc=;
      flags=;
      result_var=NULL;
      obj=$27$;
      method=LeabraNetwork::Compute_ExtRew;
      meth_args {
       name=;
       el_typ=ProgArg;
       el_def=0;
      };
     };
    };
    false_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
   };
   NetUpdateView @[9] {
    desc=;
    flags=;
    network_var=$27$;
    update_var=.projects[0].programs.gp[0][4].vars[2]$31$;
   };
  };
 };
 Program @[5] {
  name="LeabraCycle";
  desc="runs one cycle of leabra processing (updating net inputs and activations)";
  flags=;
  objs {
   name=;
   el_typ=taOBase;
   el_def=0;
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="update_net_view";
    var_type=T_Bool;
    bool_val=0;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc="this does all the standard leabra processing for one cycle of activation updating";
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][5].args[0]$32$;
    method=LeabraNetwork::Cycle_Run;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   NetUpdateView @[1] {
    desc=;
    flags=;
    network_var=$32$;
    update_var=.projects[0].programs.gp[0][5].vars[0]$33$;
   };
  };
 };
 Program @[6] {
  name="ApplyInputs";
  desc="apply the current input data to the network as external input and target values";
  flags=NO_USER_RUN;
  objs {
   name=;
   el_typ=LayerWriter;
   el_def=0;
   LayerWriter @[0] {
    name="LayerWriter_0";
    data=$2$;
    network=$1$;
    layer_data {
     name=;
     el_typ=LayerWriterEl;
     el_def=0;
     LayerWriterEl @[0] {
      chan_name="Input";
      net_target=LAYER;
      layer_name="Input";
      offset {x=0: y=0: };
      use_layer_type=1;
      ext_flags=EXT;
      noise {type=NONE: mean=0: var=0.5: par=1: };
      value_names{ ;;;;;;;;;;;;;;;;;;;;;;;;;      };
     };
     LayerWriterEl @[1] {
      chan_name="Output";
      net_target=LAYER;
      layer_name="Output";
      offset {x=0: y=0: };
      use_layer_type=1;
      ext_flags=TARG;
      noise {type=NONE: mean=0: var=0.5: par=1: };
      value_names{ ;;;;;;;;;;;;;;;;;;;;;;;;;      };
     };
     LayerWriterEl @[2] {
      chan_name="Name";
      net_target=TRIAL_NAME;
      layer_name="Name";
      offset {x=0: y=0: };
      use_layer_type=1;
      ext_flags=;
      noise {type=NONE: mean=0: var=0.5: par=1: };
      value_names{       };
     };
    };
   };
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="input_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$2$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="LayerWriter_0";
    var_type=T_Object;
    object_type=LayerWriter;
    object_val=.projects[0].programs.gp[0][6].objs[0]$34$;
    objs_ptr=1;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc=;
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][6].vars[0]$35$;
    method=LayerWriter::SetDataNetwork;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=DataBlock_ptr;
      type="DataBlock*";
      name="db";
      expr {
       expr="input_data";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ input_data;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=Network_ptr;
      type="Network*";
      name="net";
      expr {
       expr="network";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[1] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$35$;
    method=taList_impl::CheckConfig;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="quiet";
      expr {
       expr="false";
       flags=;
       var_expr="false";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc="apply inputs to the network!  layer writer has all the key specs";
    flags=;
    result_var=NULL;
    obj=$35$;
    method=LayerWriter::ApplyInputData;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
  };
 };
 Program @[7] {
  name="LeabraTrialMonitor";
  desc="monitor trial-level data from the network";
  flags=;
  objs {
   name=;
   el_typ=NetMonitor;
   el_def=0;
   NetMonitor @[0] {
    name="trial_netmon";
    items {
     name=;
     el_typ=NetMonItem;
     el_def=0;
     NetMonItem @[0] {
      name="batch";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="batch";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[1] {
      name="epoch";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="epoch";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[2] {
      name="trial";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="trial";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[3] {
      name="trial_name";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="trial_name";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[4] {
      name="group_name";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="group_name";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[5] {
      name="phase_no";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="phase_no";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[6] {
      name="cycle";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="minus_cycles";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[7] {
      name="sse";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="sse";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[8] {
      name="ext_rew";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="ext_rew";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
    };
    network=$1$;
    data=$13$;
    rmv_orphan_cols=1;
   };
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=Network;
    object_val=$1$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="trial_mon_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$13$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="trial_netmon";
    var_type=T_Object;
    object_type=NetMonitor;
    object_val=.projects[0].programs.gp[0][7].objs[0]$36$;
    objs_ptr=1;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc=;
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][7].vars[1]$37$;
    method=NetMonitor::SetDataNetwork;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=DataTable_ptr;
      type="DataTable*";
      name="dt";
      expr {
       expr="trial_mon_data";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ trial_mon_data;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=Network_ptr;
      type="Network*";
      name="net";
      expr {
       expr="network";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[1] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$37$;
    method=taBase::CheckConfig;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="quiet";
      expr {
       expr="false";
       flags=;
       var_expr="false";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[2] {
    desc="update the monitor items and data schema";
    flags=;
    result_var=NULL;
    obj=$37$;
    method=NetMonitor::UpdateMonitors;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="reset_first";
      expr {
       expr="true";
       flags=;
       var_expr="true";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc="add a new blank row to the data";
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][7].vars[0]$38$;
    method=DataTable::AddBlankRow;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   MethodCall @[1] {
    desc="get the new monitor data.";
    flags=;
    result_var=NULL;
    obj=$37$;
    method=NetMonitor::GetMonVals;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   MethodCall @[2] {
    desc="update after writing new data to monitor data table";
    flags=;
    result_var=NULL;
    obj=$38$;
    method=DataBlock::WriteClose;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   MethodCall @[3] {
    desc="only functional for dmem projects: synchronizes trial data across processes";
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][7].args[0]$39$;
    method=Network::DMem_ShareTrialData;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=DataTable_ptr;
      type="DataTable*";
      name="dt";
      expr {
       expr="trial_mon_data";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ trial_mon_data;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=int;
      type="int";
      name="n_rows";
      expr {
       expr="1";
       flags=;
       var_expr="1";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
  };
 };
 Program @[8] {
  name="LeabraEpochMonitor";
  desc="monitor epoch-level data from the network";
  flags=;
  objs {
   name=;
   el_typ=NetMonitor;
   el_def=0;
   NetMonitor @[0] {
    name="epoch_netmon";
    items {
     name=;
     el_typ=NetMonItem;
     el_def=0;
     NetMonItem @[0] {
      name="batch";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="batch";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[1] {
      name="epoch";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="epoch";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[2] {
      name="avg_sse";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="avg_sse";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[3] {
      name="cnt_err";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="cnt_err";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[4] {
      name="avg_ext_rew";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="avg_ext_rew";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[5] {
      name="avg_cycles";
      computed=0;
      object_type=LeabraNetwork;
      object=$1$;
      variable="avg_cycles";
      var_label=;
      name_style=AUTO_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[6] {
      name="epoch_time_tot";
      computed=1;
      object_type=NULL;
      object=NULL;
      variable="act";
      var_label=;
      name_style=MY_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
     NetMonItem @[7] {
      name="epoch_time_usr";
      computed=1;
      object_type=NULL;
      object=NULL;
      variable="act";
      var_label=;
      name_style=MY_NAME;
      max_name_len=6;
      val_type=VT_FLOAT;
      matrix=0;
      matrix_geom{       };
      pre_proc_1 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_2 {opr=NONE: arg=0: lw=-1: hi=1: };
      pre_proc_3 {opr=NONE: arg=0: lw=-1: hi=1: };
     };
    };
    network=$1$;
    data=.projects[0].data.gp[1][1]$40$;
    rmv_orphan_cols=1;
   };
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=Network;
    object_val=$1$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="epoch_mon_data";
    var_type=T_Object;
    object_type=DataTable;
    object_val=$40$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[1] {
    name="epoch_netmon";
    var_type=T_Object;
    object_type=NetMonitor;
    object_val=.projects[0].programs.gp[0][8].objs[0]$41$;
    objs_ptr=1;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
   ProgVar @[2] {
    name="epoch_timer";
    var_type=T_Object;
    object_type=TimeUsed;
    object_val=$14$;
    objs_ptr=0;
    flags=NULL_CHECK;
    desc=;
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=AssignExpr;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   AssignExpr @[0] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][8].vars[2]$42$;
    expr {
     expr="network.epoch_time";
     flags=;
     var_expr="$#0#$.epoch_time";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
   };
   MethodCall @[1] {
    desc=;
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][8].vars[1]$43$;
    method=NetMonitor::SetDataNetwork;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=DataTable_ptr;
      type="DataTable*";
      name="dt";
      expr {
       expr="epoch_mon_data";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ epoch_mon_data;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=Network_ptr;
      type="Network*";
      name="net";
      expr {
       expr="network";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[2] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$43$;
    method=taBase::CheckConfig;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="quiet";
      expr {
       expr="false";
       flags=;
       var_expr="false";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[3] {
    desc="update the monitor items and data schema";
    flags=;
    result_var=NULL;
    obj=$43$;
    method=NetMonitor::UpdateMonitors;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=bool;
      type="bool";
      name="reset_first";
      expr {
       expr="true";
       flags=;
       var_expr="true";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   MethodCall @[0] {
    desc="add a new blank row to the data";
    flags=;
    result_var=NULL;
    obj=.projects[0].programs.gp[0][8].vars[0]$44$;
    method=DataTable::AddBlankRow;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   MethodCall @[1] {
    desc="get the new monitor data.";
    flags=;
    result_var=NULL;
    obj=$43$;
    method=NetMonitor::GetMonVals;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
   AssignExpr @[2] {
    desc=;
    flags=;
    result_var=$42$;
    expr {
     expr="network.epoch_time";
     flags=;
     var_expr="$#0#$.epoch_time";
     vars {
     };
     var_names{ network;     };
     bad_vars{      };
    };
   };
   UserScript @[3] {
    desc="set the timing information from the epoch timer";
    flags=;
    script {
     expr="epoch_mon_data.SetDataByName(epoch_timer.used.GetTotSecs(), \"epoch_time_tot\");
epoch_mon_data.SetDataByName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\");

";
     flags=NO_VAR_ERRS;
     var_expr="$#0#$.SetDataByName($#1#$.used.GetTotSecs(), \"epoch_time_tot\");
epoch_mon_data.SetDataByName(epoch_timer.used.GetUsrSecs(), \"epoch_time_usr\");

";
     vars {
     };
     var_names{ epoch_mon_data;epoch_timer;     };
     bad_vars{      };
    };
   };
   MethodCall @[4] {
    desc="update after writing new data to monitor data table";
    flags=;
    result_var=NULL;
    obj=$44$;
    method=DataBlock::WriteClose;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
    };
   };
  };
 };
 Program @[9] {
  name="SaveWeights";
  desc="save network's current weight values to file using WriteWeights function, with file name based on project name + batch + epoch values";
  flags=;
  objs {
   name=;
   el_typ=taOBase;
   el_def=0;
  };
  args {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="network";
    var_type=T_Object;
    object_type=LeabraNetwork;
    object_val=$1$;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc=;
   };
  };
  vars {
   name=;
   el_typ=ProgVar;
   el_def=0;
   ProgVar @[0] {
    name="tag";
    var_type=T_String;
    string_val=;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="user-provided tag (startup script will set this!)";
   };
   ProgVar @[1] {
    name="wts_subdir";
    var_type=T_String;
    string_val=;
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="user-provided subdirectory to save weights in";
   };
   ProgVar @[2] {
    name="fname";
    var_type=T_String;
    string_val="/Users/oreilly/pdp4.0/trunk/test/leabra_ra.03_0036.wts.gz";
    objs_ptr=0;
    flags=CTRL_PANEL|NULL_CHECK;
    desc="final generated file name -- do not edit!";
   };
   ProgVar @[3] {
    name="epoch_str";
    var_type=T_String;
    string_val="0036";
    objs_ptr=0;
    flags=NULL_CHECK;
    desc="string rep of epoch with leading zeros";
   };
   ProgVar @[4] {
    name="batch_str";
    var_type=T_String;
    string_val="03";
    objs_ptr=0;
    flags=NULL_CHECK;
    desc="string rep of batch with leading zeros";
   };
   ProgVar @[5] {
    name="final_tag";
    var_type=T_String;
    string_val=".03_0036";
    objs_ptr=0;
    flags=NULL_CHECK;
    desc="batch + epoch";
   };
  };
  functions {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  load_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  init_code {
   name=;
   el_typ=ProgEl;
   el_def=0;
  };
  prog_code {
   name=;
   el_typ=MethodCall;
   el_def=0;
   IfElse @[0] {
    desc="don't save if not first dmem process";
    flags=;
    cond {
     expr="taMisc::dmem_proc > 0";
     flags=;
     var_expr="taMisc::dmem_proc > 0";
     vars {
     };
     var_names{      };
     bad_vars{      };
    };
    true_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
     UserScript @[0] {
      desc=;
      flags=;
      script {
       expr="return;";
       flags=NO_VAR_ERRS;
       var_expr="return;";
       vars {
       };
       var_names{        };
       bad_vars{ return;       };
      };
     };
    };
    false_code {
     name=;
     el_typ=ProgEl;
     el_def=0;
    };
   };
   MiscCall @[1] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][9].vars[4]$45$;
    object_type=taMisc;
    method=taMisc::LeadingZeros;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=int;
      type="int";
      name="num";
      expr {
       expr="network.batch";
       flags=;
       var_expr="$#0#$.batch";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=int;
      type="int";
      name="len";
      expr {
       expr="2";
       flags=;
       var_expr="2";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   MiscCall @[2] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][9].vars[3]$46$;
    object_type=taMisc;
    method=taMisc::LeadingZeros;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=int;
      type="int";
      name="num";
      expr {
       expr="network.epoch";
       flags=;
       var_expr="$#0#$.epoch";
       vars {
       };
       var_names{ network;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=int;
      type="int";
      name="len";
      expr {
       expr="4";
       flags=;
       var_expr="4";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   AssignExpr @[3] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][9].vars[5]$47$;
    expr {
     expr="tag + \".\" + batch_str + \"_\" + epoch_str";
     flags=;
     var_expr="$#0#$ + \".\" + batch_str + \"_\" + epoch_str";
     vars {
     };
     var_names{ tag;     };
     bad_vars{      };
    };
   };
   MethodCall @[4] {
    desc=;
    flags=;
    result_var=.projects[0].programs.gp[0][9].vars[2]$48$;
    obj=.projects[0].programs.gp[0][9].args[0]$49$;
    method=taBase::GetFileNameFmProject;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=const_taString_ref;
      type="const taString&";
      name="ext";
      expr {
       expr="\".wts.gz\"";
       flags=;
       var_expr="\".wts.gz\"";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=const_taString_ref;
      type="const taString&";
      name="tag";
      expr {
       expr="final_tag";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ final_tag;       };
       bad_vars{        };
      };
     };
     ProgArg @[2] {
      arg_type=const_taString_ref;
      type="const taString&";
      name="subdir";
      expr {
       expr="wts_subdir";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ wts_subdir;       };
       bad_vars{        };
      };
     };
     ProgArg @[3] {
      arg_type=bool;
      type="bool";
      name="dmem_proc_no";
      expr {
       expr="false";
       flags=;
       var_expr="false";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
   MethodCall @[5] {
    desc=;
    flags=;
    result_var=NULL;
    obj=$49$;
    method=Network::SaveWeights;
    meth_args {
     name=;
     el_typ=ProgArg;
     el_def=0;
     ProgArg @[0] {
      arg_type=NULL;
      type="const taString&";
      name="fname";
      expr {
       expr="fname";
       flags=;
       var_expr="$#0#$";
       vars {
       };
       var_names{ fname;       };
       bad_vars{        };
      };
     };
     ProgArg @[1] {
      arg_type=NULL;
      type="Network::WtSaveFormat";
      name="fmt";
      expr {
       expr="Network::NET_FMT";
       flags=;
       var_expr="Network::NET_FMT";
       vars {
       };
       var_names{        };
       bad_vars{        };
      };
     };
    };
   };
  };
 };
};

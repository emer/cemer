// ta_Dump File v3.0 -- code v7.8.7.0 rev9502
Program .projects[0].programs.gp[3][0] { 
 UserDataItem_List @*(.user_data_) {
  UserData_DocLink @[0] { };
  UserDataItem @[1] { };
 };

 ProgObjList @.objs = [32] {
  DataTable @[0] { 
   DataTableCols @.data = [11] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[7] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[8] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[9] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    bool_Data @[10] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[1] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   DataTableCols @.data = [6] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    bool_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[2] { 
   DataTableCols @.data = [11] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[7] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[8] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[9] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    bool_Data @[10] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[3] { 
   DataTableCols @.data = [6] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[4] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [2] {
    DataSortEl @[0] { };
    DataSortEl @[1] { };
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[5] { 
   DataTableCols @.data = [5] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [2] {
    DataSortEl @[0] { };
    DataSortEl @[1] { };
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[6] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[7] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[8] { 
   DataTableCols @.data = [4] {
    String_Data @[0] { };
    String_Data @[1] { };
    int_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[9] { 
   DataTableCols @.data = [4] {
    String_Data @[0] { };
    String_Data @[1] { };
    int_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[10] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[11] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[12] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[13] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[14] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[15] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[16] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[17] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[18] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[19] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[20] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [6] {
    DataSortEl @[0] { };
    DataSortEl @[1] { };
    DataSortEl @[2] { };
    DataSortEl @[3] { };
    DataSortEl @[4] { };
    DataSortEl @[5] { };
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[21] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [6] {
    DataSortEl @[0] { };
    DataSortEl @[1] { };
    DataSortEl @[2] { };
    DataSortEl @[3] { };
    DataSortEl @[4] { };
    DataSortEl @[5] { };
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[22] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[23] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[24] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[25] { 
   DataTableCols @.data = [7] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataGroupSpec @[26] { 
   DataOpList @.ops = [1] {
    DataGroupEl @[0] { };
   };
  };
  DataGroupSpec @[27] { 
   DataOpList @.ops = [2] {
    DataGroupEl @[0] { };
    DataGroupEl @[1] { };
   };
  };
  DataGroupSpec @[28] { 
   DataOpList @.ops = [2] {
    DataGroupEl @[0] { };
    DataGroupEl @[1] { };
   };
  };
  DataGroupSpec @[29] { 
   DataOpList @.ops = [4] {
    DataGroupEl @[0] { };
    DataGroupEl @[1] { };
    DataGroupEl @[2] { };
    DataGroupEl @[3] { };
   };
  };
  DataSelectSpec @[30] { 
   DataOpList @.ops = [1] {
    DataSelectEl @[0] { };
   };
  };
  DataSelectSpec @[31] { 
   DataOpList @.ops = [1] {
    DataSelectEl @[0] { };
   };
  };
 };

 ProgType_List @.types = [0] {
 };

 ProgVar_List @.args = [1] {
  ProgVar @[0] { };
 };

 ProgVar_List @.vars = [50] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
  ProgVar @[8] { };
  ProgVar @[9] { };
  ProgVar @[10] { };
  ProgVar @[11] { };
  ProgVar @[12] { };
  ProgVar @[13] { };
  ProgVar @[14] { };
  ProgVar @[15] { };
  ProgVar @[16] { };
  ProgVar @[17] { };
  ProgVar @[18] { };
  ProgVar @[19] { };
  ProgVar @[20] { };
  ProgVar @[21] { };
  ProgVar @[22] { };
  ProgVar @[23] { };
  ProgVar @[24] { };
  ProgVar @[25] { };
  ProgVar @[26] { };
  ProgVar @[27] { };
  ProgVar @[28] { };
  ProgVar @[29] { };
  ProgVar @[30] { };
  ProgVar @[31] { };
  ProgVar @[32] { };
  ProgVar @[33] { };
  ProgVar @[34] { };
  ProgVar @[35] { };
  ProgVar @[36] { };
  ProgVar @[37] { };
  ProgVar @[38] { };
  ProgVar @[39] { };
  ProgVar @[40] { };
  ProgVar @[41] { };
  ProgVar @[42] { };
  ProgVar @[43] { };
  ProgVar @[44] { };
  ProgVar @[45] { };
  ProgVar @[46] { };
  ProgVar @[47] { };
  ProgVar @[48] { };
  ProgVar @[49] { };
 };

 Function_List @.functions = [22] {
  Function @[0] { 
   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    Comment @[4] { };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [10] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
     };
    };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [12] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
      ProgArg @[10] { };
      ProgArg @[11] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[1] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [17] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    DataProcCall @[3] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    UserScript @[6] { };
    Comment @[7] { };
    DataProcCall @[8] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[10] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    Comment @[11] { };
    MethodCall @[12] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    ForLoop @[13] { 
     ProgEl_List @.loop_code = [3] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MatrixAssign @[2] { };
     };
    };
    UserScript @[14] { };
    MethodCall @[15] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[16] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[2] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    DataProcCall @[3] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    UserScript @[4] { };
    Comment @[5] { };
    DataProcCall @[6] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    UserScript @[7] { };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[3] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [7] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    ForLoop @[5] { 
     ProgEl_List @.loop_code = [6] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MatrixAssign @[2] { };
      AssignExpr @[3] { };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [13] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
	ProgArg @[9] { };
	ProgArg @[10] { };
	ProgArg @[11] { };
	ProgArg @[12] { };
       };
      };
      MatrixAssign @[5] { };
     };
    };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[4] { 
   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgEl_List @.fun_code = [8] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    Comment @[1] { };
    PrintVar @[2] { };
    FunctionCall @[3] { 
     ProgArg_List @.fun_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    If @[4] { 
     ProgEl_List @.true_code = [2] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      FunctionCall @[1] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    Else @[5] { 
     ProgEl_List @.else_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    FunctionCall @[6] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    FunctionCall @[7] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
   };
  };
  Function @[5] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [8] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [6] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ForLoop @[6] { 
     ProgEl_List @.loop_code = [9] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[3] { };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[5] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[6] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MatrixAssign @[7] { };
      MatrixAssign @[8] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[6] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [6] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ForLoop @[3] { 
     ProgEl_List @.loop_code = [4] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      AssignExpr @[2] { };
      MatrixAssign @[3] { };
     };
    };
   };
  };
  Function @[7] { 
   ProgVar_List @.args = [5] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
     };
    };
    If @[3] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
     };
    };
   };
  };
  Function @[8] { 
   ProgVar_List @.args = [4] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
   };

   ProgEl_List @.fun_code = [2] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    DataGenCall @[1] { 
     ProgArg_List @.meth_args = [7] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
     };
    };
   };
  };
  Function @[9] { 
   ProgVar_List @.args = [7] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
    ProgVar @[5] { };
    ProgVar @[6] { };
   };

   ProgEl_List @.fun_code = [7] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    FunctionCall @[2] { 
     ProgArg_List @.fun_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    FunctionCall @[3] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    FunctionCall @[4] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    If @[5] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [5] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
       };
      };
     };
    };
    Else @[6] { 
     ProgEl_List @.else_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
   };
  };
  Function @[10] { 
   ProgVar_List @.args = [5] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
   };

   ProgEl_List @.fun_code = [8] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [10] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
     };
    };
    DataProcCall @[3] { 
     ProgArg_List @.meth_args = [15] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
      ProgArg @[10] { };
      ProgArg @[11] { };
      ProgArg @[12] { };
      ProgArg @[13] { };
      ProgArg @[14] { };
     };
    };
    DataProcCall @[4] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    DataProcCall @[6] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[11] { 
   ProgVar_List @.args = [5] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
    ProgVar @[3] { };
    ProgVar @[4] { };
   };

   ProgEl_List @.fun_code = [17] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [10] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
     };
    };
    DataGroupProg @[3] { 
     DataOpList @.group_spec.ops = [2] {
      DataGroupEl @[0] { };
      DataGroupEl @[1] { };
     };
    };
    DataProcCall @[4] { 
     ProgArg_List @.meth_args = [15] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
      ProgArg @[10] { };
      ProgArg @[11] { };
      ProgArg @[12] { };
      ProgArg @[13] { };
      ProgArg @[14] { };
     };
    };
    DataJoinProg @[5] { };
    DataJoinProg @[6] { };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[10] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[11] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[12] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    DataProcCall @[13] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[14] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    DataProcCall @[15] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[16] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[12] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    AssignExpr @[3] { };
    If @[4] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
   };
  };
  Function @[13] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    AssignExpr @[3] { };
    If @[4] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
   };
  };
  Function @[14] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    FunctionCall @[1] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    FunctionCall @[2] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    If @[3] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  Function @[15] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [17] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [8] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    AssignExpr @[2] { };
    AssignExpr @[3] { };
    AssignExpr @[4] { };
    AssignExpr @[5] { };
    AssignExpr @[6] { };
    AssignExpr @[7] { };
    AssignExpr @[8] { };
    AssignExpr @[9] { };
    AssignExpr @[10] { };
    FunctionCall @[11] { 
     ProgArg_List @.fun_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MiscCall @[12] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    If @[13] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [7] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
       };
      };
     };
    };
    If @[14] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [5] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
       };
      };
     };
    };
    Else @[15] { 
     ProgEl_List @.else_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [5] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
       };
      };
     };
    };
    FunctionCall @[16] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
   };
  };
  Function @[16] { 
   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgEl_List @.fun_code = [7] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [10] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[4] { 
     ProgEl_List @.true_code = [2] {
      CssExpr @[0] { };
      AssignExpr @[1] { };
     };
    };
    Else @[5] { 
     ProgEl_List @.else_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    ReturnExpr @[6] { };
   };
  };
  Function @[17] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [2] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    ReturnExpr @[1] { };
   };
  };
  Function @[18] { 
   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgEl_List @.fun_code = [9] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    Comment @[5] { };
    ForLoop @[6] { 
     ProgEl_List @.loop_code = [4] {
      If @[0] { 
       ProgEl_List @.true_code = [2] {
	AssignExpr @[0] { };
	If @[1] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      AssignExpr @[3] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    AssignExpr @[8] { };
   };
  };
  Function @[19] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [2] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[1] { };
     };
    };
    Else @[2] { 
     ProgEl_List @.else_code = [2] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[1] { };
     };
    };
   };
  };
  Function @[20] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [13] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [2] {
      AssignExpr @[0] { };
      If @[1] { 
       ProgEl_List @.true_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[9] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    MethodCall @[10] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[11] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    AssignExpr @[12] { };
   };
  };
  Function @[21] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    ElseIf @[2] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    Else @[3] { 
     ProgEl_List @.else_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
   };
  };
 };

 ProgEl_List @.init_code = [4] {
  AssignExpr @[0] { };
  AssignExpr @[1] { };
  AssignExpr @[2] { };
  MemberMethodCall @[3] { 
   ProgArg_List @.meth_args = [0] {
   };
  };
 };

 ProgEl_List @.prog_code = [3] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  If @[1] { 
   ProgEl_List @.true_code = [1] {
    FunctionCall @[0] { 
     ProgArg_List @.fun_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  FunctionCall @[2] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
 };
};
Program .projects[0].programs.gp[3][0] {
 UserDataItem_List @*(.user_data_) {
  name="UserDataItem_List_1977";
  el_typ=UserData_DocLink;
  el_def=0;
  UserData_DocLink @[0] {
   name="DocLink";
   doc=.projects[0].programs.gp[3][0].doc$$;
  };
  UserDataItem @[1] {
   name="user_pinned";
   value 1 0=1;
   val_type_fixed=0;
  };
 };
 name="ObjectsEnv";
 short_nm="bjctsn";
 tags="Environment, Objects";
 desc="manages lists of objects, with training and testing lists, for object recognition models";
 flags=NO_STOP_STEP;
 stop_step_cond {
  expr=;
 };
 objs {
  name="objs";
  el_typ=taNBase;
  el_def=0;
  DataTable @[0] {
   name="ObjLists";
   desc="named object lists and associated parameters -- configurations can specify simple name";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.4160714;
       val_type_fixed=0;
      };
     };
     name="objlist_id";
     desc="identifier for this type of configuration";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=233;
     ar {
      name="ar";
     [80] "CU3D_debug";"CU3D_debug_server";"TI20_saliency";"TI20_saliency_xform";"CU3D_100_plus_lr20_u20_nb";"CU3D_100_std_train_v2pre_test";"CU3D_100_std_train_v4pre";"CU3D_100_std_train_v4pre_nov2";"CU3D_100_std_train_f1";"CU3D_100_std_train_f2";
"CU3D_100_std_train_f2_sc_1_tr15";"CU3D_100_std_train_f4";"CU3D_100_std_train_f8";"CU3D_100_std_train_f8_v2trc";"CU3D_100_std_train_f8_v4trc";"CU3D_100_std_train_f8_3alpha";"CU3D_100_std_train_f8_sc3_tr15";"CU3D_100_std_train_f8_sc3_tr15_gaus";"CU3D_100_std_train_f8_sc5_tr3";"CU3D_100_std_train_f8_sc5_tr3_gaus";
"CU3D_100_std_train_f8_sc5_tr3g_long";"CU3D_100_std_train_f8_sc5_tr15_gaus";"CU3D_100_std_train_f8_sc5_tr3_sem";"CU3D_100_std_train_f4_v2trc";"CU3D_100_std_train_f4_v4trc";"CU3D_100_std_train_f4_v2trc_pre";"CU3D_100_std_train_f4_3alpha";"CU3D_100_std_train_f4_sc5_tr15";"CU3D_100_std_train_f4_sc3_tr3_gaus";"CU3D_100_std_train_f4_sc3_tr15";
"CU3D_100_std_train_f4_sc3_tr15_gaus";"CU3D_100_std_train_f4_sc5_tr25";"CU3D_100_std_train_f4_te16_qtr";"CU3D_100_std_train_fmv4";"CU3D_100_std_train_fmv2";"CU3D_100_std_train_100";"CU3D_100_std_train_100cont";"CU3D_100_orig_trans_bg";"CU3D_100_figgr_test";"CU3D_100_std_train_context";
"CU3D_100_semantics_nooutput";"CU3D_100_std_train_identification";"CU3D_100_std_test_train_all";"CU3D_100_std_test_all";"CU3D_100_IT_attractor_test";"CU3D_100_IT_category_mask_test";"CU3D_100_blobo_test";"CU3D_100_blobo_ctxt_bias";"CU3D_100_blobo_cycletraj";"CU3D_100_ffa_train";
"TI46_digits";"TI46_full_speaker_recognition";"CU3D_100_orig_50trn_50tst";"CU3D_100_50trn_50tst_MetaTest";"CU3D_100_50trn_50tst_server";"CU3D_100_50trn_50tst_MetaTest_perirhinal";"CU3D_100_actrf_test";"CU3D_multiobj_train";"CU3D_multiobj_test";"CU3D_multiobj_binding";
"TI46_digits_actrf";"creatures_train";"Kreiman_IFP_train";"Kreiman_IFP_test";"Kreiman_IFP_bubbles";"Folstein_cars_morph";"Folstein_cars_morph_test";"maskxblob";"maskxblob_test";"pubfig83";
"pubfig83_test";"blur_debug";"CU3D_100_blur_test";"probe_Hegde_all";"probe_Hegde_All_f8_untrained";"probe_Hegde_contour";"probe_Hegde_contour_f8_untrained";"probe_Hegde_gradient";"probe_Hegde_gradient_f8_untrained";"CU3D_100_orig_lr20_u20_nb";
     };
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.5607143;
       val_type_fixed=0;
      };
     };
     name="description";
     desc="description of this configuration";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=314;
     ar {
      name="ar";
     [80] "CU3D debug lesson -- 5 cats, 5 exemplars each for training set. frequent testing variables so we don't have to wait for CU3D_100_std to load, split items, etc. (slow!)";"CU3D debug lesson with server interface (uses special OID that preallocates output units)";"TI20 using saliency feats from telluride";"TI20 using saliency feats from telluride with transformsm";"standard CU3D 100, left-right 20 deg, up 20, no backgrounds, plus extra exemplars added in 2016";"standard CU3D 100 -- train on all categs -- pretrain v2 reps only";"standard CU3D 100 -- train on all categs -- pretrain v4 reps -- loading v2 weights";"standard CU3D 100 -- train on all categs -- pretrain v4 reps -- random v2 weights";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";
"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"simultaneous v2trc and objrec training!";"simultaneous v2trc, v4trc, and objrec training!";"same as v2trc, without the trc.. control condition";"standard, scale .3:1.1, trans .15";"standard, scale .3:1.1, trans .15";"standard, scale .5:1.1, trans .3";"standard, scale .5:1.1, trans .3, gaussian";
"standard, scale .5:1.1, trans .3, gaussian, long-train case (2000 epcs)";"standard, scale .5:1.1, trans .15, gaussian";"standard, scale .5:1.1, trans .3, semantics";"simultaneous v2trc and objrec training!";"simultaneous v2trc, v4trc, and objrec training!";"simultaneous v2trc and objrec training -- pretrained weights";"same as v2trc, without the trc.. control condition";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard, scale .3:1.1, trans .3, gaussian";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";
"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs -- use TE16_qtr transforms";"standard CU3D 100 -- train on all categs -- loading v4 weights";"standard CU3D 100 -- train on all categs -- loading v4 weights";"standard CU3D 100 -- train on all categs, 2 leave out test indivs -- just for 100 epochs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs -- continue after 100 epochs";"orig + transparent backgrounds -- useful for composing object images aginst backgrounds";"figure-ground testing";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";
"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- train on all categs, 2 leave out test indivs";"standard CU3D 100 -- test on all testing AND training items";"standard CU3D 100 -- test on all testing AND training items";"standard CU3D 100 -- test on all testing AND training items";"does category masked cycle-wise IT recording. uses blobo trials";"CU3D 100 blobo test";"CU3D 100 blobo test with context bias from resp-set";"CU3D 100 blobo test with cycletraj (use cmp trial)";"CU3D 100 training with FFA activated";
"TI-46 speaker-invariant digit recognition 0-9";"TI46 invariant speaker recognition";"orig CU3D 100 3d objs with 50 trained categs and 50 test categs";"metacognitive testing with 50/50 guys -- most params don't matter -- JUST runs test on given weights file";"metacognitive testing with 50/50 guys -- most params don't matter -- for server mode";"metacognitive testing with 50/50 guys -- most params don't matter -- JUST runs test on given weights file";"CU3D actrf test -- special run prog, load train wts, no semantics, no transforms";"CU3D multiple object recognition training -- 6x5 hard training items";"CU3D multiple object recognition test on everything";"CU3D multiple object recognition binding test";
"TI-46 actrf";"creature training -- multiple OIDs that counterbalance basic/subord across families so just use one here and specify from command line otherwise";"Stimuli from Gabriel Kreiman's IFP experiments";"Load Kreiman IFP trained weights and record IT";"Load Kreiman IFP trained weights and do BubbleMask experiment ";"Jonathan Folstein's car morph dataset -- one dimension relevant, one irrelevant (specified by OID). NOTE: OID fully specifies training/testing";"Jonathan Folstein's car morph dataset -- one dimension relevant, one irrelevant (specified by OID). Testing only";"orig 3d objs, with maskxblob stimuli -- test on 2 like std_test";"train on actual maskxblob stimuli -- test on 2 like std_test";"pubfig83 ??";
"pubfig83 testing";"CU3D blur with just a few items to make the turnaround time short";"CU3D 100 blur test";"all Hegde and Van Essen probe stimuli";"collect activations for all Hegde and Van Essen probe stimuli - trials should equal number of different probes";"only the Hegde and Van Essen contour stimuli";"only the Hegde and Van Essen \"contour stimuli\" - trials should equal number of different probes";"only the Hegde and Van Essen gradient stimuli";"only the Hegde and Van Essen \"gradient stimuli\" - trials should equal number of different probes";"standard CU3D 100, left-right 20 deg, up 20, no backgrounds -- original exemplars from before 2016";
     };
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=1.1125;
       val_type_fixed=0;
      };
     };
     name="oid_filename";
     desc="full relative path (from project) to OID file containing list of objects and other parameters";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=623;
     ar {
      name="ar";
     [80] "images/CU3D_100_renders_lr20_u30_nb/CU3D_debug.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_debug_prealloc.dat";"images/sound/TI-46/ti20/ti20_telluride_saliency/all-data.dat";"images/sound/TI-46/ti20/ti20_telluride_saliency_110x110/all-data.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_renders_lr20_u30_transbg/CU3D_100_renders_lr20_u30_transbg.dat";"images/CU3D_100_renders_lr20_u30_transbg/CU3D_100_renders_lr20_u30_transbg.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/sound/TI-46/TI46_fm_emergent_DataTable_format_img_centered/TI46_digits.dat";"images/sound/TI-46/TI46_fm_emergent_DataTable_format_img_centered/TI46_speaker_recognition.oid";"images/CU3D_100_renders_lr20_u30_nb/CU3D_100_renders_lr20_u30_nb_50_train50_test50.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_100_renders_lr20_u30_nb_50_train50_test50.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_100_renders_lr20_u30_nb_50_train50_test50.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_100_renders_lr20_u30_nb_50_train50_test50.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_multiobj/CU3D_6x5_hard_train/CU3D_6x5_hard_train.dat";"images/CU3D_multiobj/CU3D_6x5_hard_test/CU3D_6x5_hard_test.dat";"images/CU3D_multiobj/CU3D_6x5_hard_test/CU3D_6x5_hard_test.dat";
"images/sound/TI-46/TI46_fm_emergent_DataTable_format_img_centered/TI46_digits.dat";"images/creatures/master/creatures_train_a_basic_s_subord_nsc_oid.dat";"images/Kreiman_IFP/images_norm/Kreiman_IFP_categorization_train_all.dat";"images/Kreiman_IFP/images_norm/Kreiman_IFP_categorization.dat";"images/Kreiman_IFP/images_norm/Kreiman_IFP_categorization.dat";"images/cars_morph_folstein/CombinedSpaceHorizBoundary.dat";"images/cars_morph_folstein/CombinedSpaceHorizBoundary.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_100_renders_lr20_u30_nb_maskxblob.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_100_renders_lr20_u30_nb_maskxblob.dat";"images/pubfig83/pubfig83_oid.dat";
"images/pubfig83/pubfig83_oid.dat";"images/CU3D_100_renders_lr20_u30_nb/CU3D_debug.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/probes/probes.dat";"images/probes/probes.dat";"images/probes/probes_contour_only.dat";"images/probes/probes_contour_only.dat";"images/probes/probes_gradient_only.dat";"images/probes/probes_gradient_only.dat";"images/CU3D_100_renders/CU3D_100_renders_lr20_u30_nb.dat";
     };
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.4482143;
       val_type_fixed=0;
      };
     };
     name="oid_filename_categs";
     desc="OID file to use for defining the full list of categories and individuals -- leave blank to use the basic oid_filename for this -- this is useful for keeping output units consistent while using subsets of items";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=251;
     ar {
      name="ar";
     [80] "images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";
"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";
"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";;;;;;;;;
;;;;;;;"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";
"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_plus_renders/CU3D_100_renders_lr20_u30_nb.dat";"images/CU3D_100_renders/CU3D_100_renders_lr20_u30_nb.dat";
     };
    };
    String_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.25;
       val_type_fixed=0;
      };
     };
     name="sound_file_path";
     desc="path for finding sound files for the names of the objects";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=140;
     ar {
      name="ar";
     [80] ;;;;;;;;;;
;;"./images/sound/cu3d_100";"./images/sound/cu3d_100";"./images/sound/cu3d_100";"./images/sound/cu3d_100";;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
     };
    };
    String_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2428571;
       val_type_fixed=0;
      };
     };
     name="sound_include_filter";
     desc="list of strings (space separated) to include in list -- file names that contain ANY of these strings will be include (OR logical op)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=136;
     ar {
      name="ar";
     [80] ;;;;;;;;;;
;;"_ro.wav";"_ro.wav";"_ro.wav _jr.wav";"_ro.wav _jr.wav _pm.wav";;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
     };
    };
    String_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2660714;
       val_type_fixed=0;
      };
     };
     name="sound_exclude_filter";
     desc="list of strings (space separated) to exclude in active list -- file names that contain ANY of these strings will be excluded";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=149;
     ar {
      name="ar";
     [80] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
     };
    };
    int_Data @[7] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1660714;
       val_type_fixed=0;
      };
     };
     name="objs_per_epc";
     desc="total number of distinct object models per epoch -- must keep this reasonably small to take advantage of preloading the objects";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=93;
     ar {
      name="ar";
     [80] -1;25;-1;-1;-1;25;25;25;25;25;
25;25;25;25;25;25;25;10;10;10;
1;20;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;-1;0;0;
0;0;0;0;0;0;0;0;0;0;
-1;-1;-1;0;0;0;0;-1;-1;0;
0;-1;-1;-1;0;-1;0;-1;0;-1;
0;0;0;-1;0;-1;0;-1;0;-1;
     };
    };
    int_Data @[8] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1232143;
       val_type_fixed=0;
      };
     };
     name="train_size";
     desc="number of items to include in the training set: set to -1 to include all the remainder after the specified number of testing items is taken out (note: train_size and test_size cannot both be -1!)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=69;
     ar {
      name="ar";
     [80] -1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;-1;0;0;
0;0;0;0;0;0;0;0;0;0;
-1;-1;-1;0;0;0;0;-1;-1;0;
0;-1;-1;-1;0;-1;0;-1;0;-1;
0;0;0;-1;0;-1;0;-1;0;-1;
     };
    };
    int_Data @[9] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.09285714;
       val_type_fixed=0;
      };
     };
     name="test_size";
     desc="number of items to include in the testing set: set to -1 to include all the remainder after the specified number of training items is taken out (note: train_size and test_size cannot both be -1!)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=52;
     ar {
      name="ar";
     [80] 2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;2;0;0;
0;0;0;0;0;0;0;0;0;0;
2;2;2;0;0;0;0;1;1;0;
0;2;1;1;0;2;0;2;0;10;
0;0;0;0;0;0;0;0;0;2;
     };
    };
    bool_Data @[10] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_1989";
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1803571;
       val_type_fixed=0;
      };
     };
     name="split_on_indivs";
     desc="perform train/test split in terms of individual objects within category+subcat, not individual images (can be multiple images per individual object)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=101;
     ar {
      name="ar";
     [80] true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;false;false;false;
false;false;false;false;false;false;false;false;false;false;
false;false;false;false;false;false;false;true;false;false;
false;false;false;false;false;false;false;false;false;false;
true;true;true;false;false;false;false;true;true;false;
false;true;true;true;false;true;false;true;false;true;
false;false;false;true;false;true;false;true;false;true;
     };
    };
   };
   data_flags=SAVE_ROWS|AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [20] 4;79;0;2;3;37;50;51;52;57;
58;61;62;63;65;67;69;73;75;77;
   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[1] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_916";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {
     name="user_pinned";
     value 1 0=0;
     val_type_fixed=0;
    };
   };
   name="ConfigTable";
   desc="different configurations of the system";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.3043995;
       val_type_fixed=0;
      };
     };
     name="config_id";
     desc="identifier for this type of configuration";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=256;
     ar {
      name="ar";
     [80] "CU3D_debug";"CU3D_debug_server";"TI20_saliency";"TI20_saliency_xform";"CU3D_100_std_train_v2pre";"CU3D_100_std_train_v2pre_test";"CU3D_100_std_train_v4pre";"CU3D_100_std_train_v4pre_nov2";"CU3D_100_std_train_f1";"CU3D_100_std_train_f2";
"CU3D_100_std_train_f2_sc_1_tr15";"CU3D_100_std_train_f4";"CU3D_100_std_train_f8";"CU3D_100_std_train_f8_v2trc";"CU3D_100_std_train_f8_v4trc";"CU3D_100_std_train_f8_3alpha";"CU3D_100_std_train_f8_sc3_tr15";"CU3D_100_std_train_f8_sc3_tr15_gaus";"CU3D_100_std_train_f8_sc5_tr3";"CU3D_100_std_train_f8_sc5_tr3_gaus";
"CU3D_100_std_train_f8_sc5_tr3g_long";"CU3D_100_std_train_f8_sc5_tr15_gaus";"CU3D_100_std_train_f8_sc5_tr3_sem";"CU3D_100_std_train_f4_v2trc";"CU3D_100_std_train_f4_v4trc";"CU3D_100_std_train_f4_v2trc_pre";"CU3D_100_std_train_f4_3alpha";"CU3D_100_std_train_f4_sc5_tr15";"CU3D_100_std_train_f4_sc3_tr3_gaus";"CU3D_100_std_train_f4_sc3_tr15";
"CU3D_100_std_train_f4_sc3_tr15_gaus";"CU3D_100_std_train_f4_sc5_tr25";"CU3D_100_std_train_f4_te16_qtr";"CU3D_100_std_train_fmv4";"CU3D_100_std_train_fmv2";"CU3D_100_std_train_100";"CU3D_100_std_train_100cont";"CU3D_100_figgr_train";"CU3D_100_figgr_test";"CU3D_100_std_train_context";
"CU3D_100_semantics_nooutput";"CU3D_100_std_train_identification";"CU3D_100_std_test_train_all";"CU3D_100_std_test_all";"CU3D_100_IT_attractor_test";"CU3D_100_IT_category_mask_test";"CU3D_100_blobo_test";"CU3D_100_blobo_ctxt_bias";"CU3D_100_blobo_cycletraj";"CU3D_100_ffa_train";
"TI46_digits";"TI46_full_speaker_recognition";"CU3D_100_50trn_50tst";"CU3D_100_50trn_50tst_MetaTest";"CU3D_100_50trn_50tst_server";"CU3D_100_50trn_50tst_MetaTest_perirhinal";"CU3D_100_actrf_test";"CU3D_multiobj_train";"CU3D_multiobj_test";"CU3D_multiobj_binding";
"TI46_digits_actrf";"creatures_train";"Kreiman_IFP_train";"Kreiman_IFP_test";"Kreiman_IFP_bubbles";"Folstein_cars_morph_train";"Folstein_cars_morph_test";"maskxblob_train";"maskxblob_test";"pubfig83_train";
"pubfig83_test";"blur_debug";"CU3D_100_blur_test";"probe_Hegde_All_f8_trained";"probe_Hegde_All_f8_untrained";"probe_Hegde_contour_f8_trained";"probe_Hegde_contour_f8_untrained";"probe_Hegde_gradient_f8_trained";"probe_Hegde_gradient_f8_untrained";"CU3D_100_std_train_v2pre";
     };
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.08085612;
       val_type_fixed=0;
      };
     };
     name="train_size";
     desc="number of items to include in the training set: set to -1 to include all the remainder after the specified number of testing items is taken out (note: train_size and test_size cannot both be -1!)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=68;
     ar {
      name="ar";
     [80] -1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
     };
    };
    int_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.07491082;
       val_type_fixed=0;
      };
     };
     name="test_size";
     desc="number of items to include in the testing set: set to -1 to include all the remainder after the specified number of training items is taken out (note: train_size and test_size cannot both be -1!)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=63;
     ar {
      name="ar";
     [80] 2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;1;1;1;
2;2;1;1;1;2;2;2;2;10;
10;2;2;0;0;0;0;0;0;2;
     };
    };
    int_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.09155767;
       val_type_fixed=0;
      };
     };
     name="train_ncats";
     desc="how many categories to use for training -- useful if you have an OID with a large number of categories but want to randomly choose a subset to train on. NOTE: default interleaved testing will test from same N categories. -1 (default) denotes use all categories";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=77;
     ar {
      name="ar";
     [80] -1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
     };
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.08680142;
       val_type_fixed=0;
      };
     };
     name="test_nreps";
     desc="number of repetitions per image with different transform params to run during testing -- the response for each such transform acts as an individual vote, and a weighted majority rule is used to decide networks overall output -- this is like making multiple saccades to an object, and integrating over them -- typically improves accuracy significantly, but costs in time, so typically just used in testing and not training.";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=73;
     ar {
      name="ar";
     [80] 7;2;1;1;7;7;7;7;7;7;
7;1;1;1;1;1;1;1;1;1;
1;1;1;1;1;1;1;1;1;1;
1;1;7;7;7;7;7;7;7;7;
7;7;1;7;1;1;7;7;1;7;
7;7;7;7;7;7;1;7;1;1;
1;7;7;25;25;1;2;7;7;7;
1;7;7;0;0;0;0;0;0;7;
     };
    };
    bool_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_1989";
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1200951;
       val_type_fixed=0;
      };
     };
     name="split_on_indivs";
     desc="perform train/test split in terms of individual objects within category+subcat, not individual images (can be multiple images per individual object)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=101;
     ar {
      name="ar";
     [80] true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;true;true;true;
true;true;true;true;true;true;true;true;true;true;
true;true;true;false;false;false;false;false;false;true;
     };
    };
   };
   data_flags=SAVE_ROWS|AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [20] 4;79;0;2;3;37;50;51;52;57;
58;61;62;63;65;67;69;73;75;77;
   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[2] {
   name="ObjLists_3Dobjs";
   desc="named object lists and associated parameters -- configurations can specify simple name";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1926278;
       val_type_fixed=0;
      };
     };
     name="objlist_id";
     desc="unique identifier used to select list of objects";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=162;
     ar {
      name="ar";
     [22] "CU3D_100_models";"CU3D_100_plus_models";"CU3D_90_models";"CU3D_80_models";"CU3D_70_models";"CU3D_60_models";"CU3D_50_models";"CU3D_50_plus_models";"CU3D_40_models";"CU3D_35_fg3";
"CU3D_30_fg4";"CU3D_20_fg";"CU3D_10_fg";"CU3D_10_fg_1spk";"CU3D_10_fg_2spk";"CU3D_10_fg_3spk";"CU3D_10_fg_allspk";"CU3D_2_fg";"CU3D_car";"CU3D_car_motorcycle";
"sphere";"CU3D_10_HighSim";     };
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.3840666;
       val_type_fixed=0;
      };
     };
     name="description";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=323;
     ar {
      name="ar";
     [22] "CU3D 100 good models";"CU3D 100 good models with new exemplars";"CU3D 90 good models";"CU3D 80 good models";"CU3D 70 good models";"CU3D 60 good models";"CU3D 50 good models";"CU3D 50 good models";"CU3D 40 good models";"specifically selected to have good surfaces for figure ground";
"specifically selected to have good surfaces for figure ground";"specifically selected to have good surfaces for figure ground";"specifically selected to have good surfaces for figure ground";"1 speaker of names (ro)";"2 speakers of names (ro, jr)";"3 speakers of names (ro, jr, pm)";"all available speakers";"specifically selected to have good surfaces for figure ground";"just 1 category (cars)";"2 categories";
"sphere";"10 random categories - 2 random exemplars";     };
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.4791915;
       val_type_fixed=0;
      };
     };
     name="oid_filename";
     desc="full relative path (from project) to OID file containing list of objects and other parameters";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=403;
     ar {
      name="ar";
     [22] "images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_90_models.dat";"images/CU3D_100_models/good/CU3D_80_models.dat";"images/CU3D_100_models/good/CU3D_70_models.dat";"images/CU3D_100_models/good/CU3D_60_models.dat";"images/CU3D_100_models/good/CU3D_50_models.dat";"images/CU3D_100_plus_models/CU3D_50_models.dat";"images/CU3D_100_models/good/CU3D_40_models.dat";"images/CU3D_100_models/good/CU3D_35_fg3_models.dat";
"images/CU3D_100_models/good/CU3D_30_fg4_models.dat";"images/CU3D_100_models/good/CU3D_20_fg_models.dat";"images/CU3D_100_models/good/CU3D_10_fg_models.dat";"images/CU3D_100_models/good/CU3D_10_fg_models.dat";"images/CU3D_100_models/good/CU3D_10_fg_models.dat";"images/CU3D_100_models/good/CU3D_10_fg_models.dat";"images/CU3D_100_models/good/CU3D_10_fg_models.dat";"images/CU3D_100_models/good/CU3D_2_fg_models.dat";"images/CU3D_100_models/good/CU3D_car.dat";"images/CU3D_100_models/good/CU3D_car_motorcycle.dat";
"images/shape_models/sphere.dat";"images/CU3D_100_models/good/CU3D_10_HighSim_models.dat";     };
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.3590963;
       val_type_fixed=0;
      };
     };
     name="oid_filename_categs";
     desc="OID file to use for defining the full list of categories and individuals -- leave blank to use the basic oid_filename for this -- this is useful for keeping output units consistent while using subsets of items";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=302;
     ar {
      name="ar";
     [22] "images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";
"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";"images/CU3D_100_models/good/CU3D_100_models.dat";
"images/CU3D_100_plus_models/CU3D_100_models.dat";"images/CU3D_100_plus_models/CU3D_100_models.dat";     };
    };
    String_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.3590963;
       val_type_fixed=0;
      };
     };
     name="sound_file_path";
     desc="path for finding sound files for the names of the objects";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=302;
     ar {
      name="ar";
     [22] ;;;;;;;;;;
;;"./images/sound/cu3d_100";"./images/sound/cu3d_100";"./images/sound/cu3d_100";"./images/sound/cu3d_100";;;;;
;;     };
    };
    String_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2187872;
       val_type_fixed=0;
      };
     };
     name="sound_include_filter";
     desc="list of strings (space separated) to include in list -- file names that contain ANY of these strings will be include (OR logical op)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=184;
     ar {
      name="ar";
     [22] ;;;;;;;;;;
;;"_ro.wav";"_ro.wav";"_ro.wav _jr.wav";"_ro.wav _jr.wav _pm.wav";;;;;
;;     };
    };
    String_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.17717;
       val_type_fixed=0;
      };
     };
     name="sound_exclude_filter";
     desc="list of strings (space separated) to exclude in active list -- file names that contain ANY of these strings will be excluded";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=149;
     ar {
      name="ar";
     [22] ;;;;;;;;;;
;;;;;;;;;;
;;     };
    };
    int_Data @[7] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1105826;
       val_type_fixed=0;
      };
     };
     name="objs_per_epc";
     desc="total number of distinct object models per epoch -- must keep this reasonably small to take advantage of preloading the objects";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=93;
     ar {
      name="ar";
     [22] 25;25;25;25;25;25;25;25;25;25;
25;25;25;25;25;25;25;10;10;10;
1;20;     };
    };
    int_Data @[8] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.08204518;
       val_type_fixed=0;
      };
     };
     name="train_size";
     desc="number of items to include in the training set: set to -1 to include all the remainder after the specified number of testing items is taken out (note: train_size and test_size cannot both be -1!)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=69;
     ar {
      name="ar";
     [22] -1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;-1;-1;-1;-1;-1;-1;-1;-1;
-1;-1;     };
    };
    int_Data @[9] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06183115;
       val_type_fixed=0;
      };
     };
     name="test_size";
     desc="number of items to include in the testing set: set to -1 to include all the remainder after the specified number of training items is taken out (note: train_size and test_size cannot both be -1!)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=52;
     ar {
      name="ar";
     [22] 2;2;2;2;2;2;2;2;2;2;
2;2;2;2;2;2;2;2;2;2;
0;0;     };
    };
    bool_Data @[10] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_1989";
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1200951;
       val_type_fixed=0;
      };
     };
     name="split_on_indivs";
     desc="perform train/test split in terms of individual objects within category+subcat, not individual images (can be multiple images per individual object)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=101;
     ar {
      name="ar";
     [22] false;false;false;false;false;false;false;false;false;false;
false;false;false;false;false;false;false;false;false;false;
false;false;     };
    };
   };
   data_flags=SAVE_ROWS|AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [22] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[3] {
   name="ObjectMiscData";
   desc="object specific parameters etc -- these are hardcoded from 3d render studio, probably best not to change";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1129608;
       val_type_fixed=0;
      };
     };
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=95;
     ar {
      name="ar";
     [101] "airplane";"anchor";"autogun";"banana";"basinsink";"bed";"bicycle";"blade";"blender";"blimp";
"boombox";"bottle";"bow";"candle";"car";"chair";"chandelier";"chessboard";"chesspiece";"compactcamera";
"cross";"cup";"dice";"domestictree";"donut";"doorhandle";"doorknob";"dresser";"drums";"dutchwindmill";
"elephant";"fan";"fireplace";"fish";"flashlight";"fryingpan";"globe";"grenade";"guitar";"hammer";
"handgun";"hat";"headphones";"heavycannon";"helicopter";"hotairballoon";"hourglass";"hydrant";"key";"ladder";
"laptop";"layercake";"lightcannon";"lock";"locomotive";"longgun";"mailbox";"microwave";"motorcycle";"pckeyboard";
"pedestalsink";"person";"piano";"plant";"plate";"pliers";"propellor";"remote";"rolltopdesk";"sailboat";
"scissors";"screwdriver";"sectionalcouch";"simpledesk";"skateboard";"skull";"slrcamera";"speaker";"spotlightlamp";"stapler";
"submarine";"synthesizer";"tablelamp";"tank";"telephone";"television";"toaster";"toilet";"trafficcone";"trafficlight";
"trex";"trombone";"tropicaltree";"trumpet";"turntable";"umbrella";"wallclock";"warningsign";"wrench";"yacht";
"sphere";     };
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1022592;
       val_type_fixed=0;
      };
     };
     name="new_category";
     desc="if nonempty, then reassign the category label in the OID file to this";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr="\"\"";
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=86;
     ar {
      name="ar";
     [101] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;     };
    };
    int_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06183115;
       val_type_fixed=0;
      };
     };
     name="exclude";
     desc="whether to exclude this object category from generation";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr="1";
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=52;
     ar {
      name="ar";
     [101] 0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;0;0;0;0;0;0;0;0;0;
0;     };
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06539834;
       val_type_fixed=0;
      };
     };
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr="\"\"";
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=55;
     ar {
      name="ar";
     [101] ;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;;;;;;;;;;
;     };
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06302021;
       val_type_fixed=0;
      };
     };
     name="z_offset";
     desc="additional z_offset for camera (need to take care of volumetric artifacts)";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=53;
     ar {
      name="ar";
     [101] -10;-15;0;0;0;0;-10;0;0;0;
0;5;5;0;0;0;-10;0;0;0;
0;0;0;-25;-20;0;-10;0;-15;-10;
-15;0;0;-5;5;0;-10;-10;0;0;
0;-15;-20;0;-10;-10;0;0;0;5;
0;-5;0;0;0;0;0;0;0;0;
-10;0;0;-15;-20;0;-15;0;0;-5;
0;5;0;0;0;-5;-15;0;0;0;
0;0;-5;0;0;0;0;-10;0;0;
0;0;-25;5;0;-25;-20;0;5;0;
0;     };
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_310";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.09393579;
       val_type_fixed=0;
      };
     };
     name="y_rot_mirror";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=79;
     ar {
      name="ar";
     [101] 1;1;1;1;0;1;1;1;1;1;
0;0;1;0;1;1;0;0;0;0;
0;1;0;0;0;0;1;0;0;0;
1;0;0;1;1;1;1;1;0;1;
1;0;0;1;1;1;0;0;1;0;
0;0;1;0;1;1;1;0;1;0;
0;0;0;0;0;1;0;0;0;1;
1;1;0;0;1;0;0;0;1;1;
1;0;0;1;0;0;0;0;0;0;
1;1;0;1;0;0;0;0;1;1;
0;     };
    };
   };
   data_flags=SAVE_ROWS|AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [101] 0;1;2;3;4;5;6;7;8;9;
10;11;12;13;14;15;16;17;18;19;
20;21;22;23;24;25;26;27;28;29;
30;31;32;33;34;35;36;37;38;39;
40;41;42;43;44;45;46;47;48;49;
50;51;52;53;54;55;56;57;58;59;
60;61;62;63;64;65;66;67;68;69;
70;71;72;73;74;75;76;77;78;79;
80;81;82;83;84;85;86;87;88;89;
90;91;92;93;94;95;96;97;98;99;
100;   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[4] {
   name="CurFullObjectList";
   desc="current full list of objects with: category, individual, ctrlflags, and filename fields -- can have other optional data after that -- can have multiple rows for each category+individual (multiple different images / renders)";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
     DataSortEl @[0] {
      col_name="category";
      name="category_up_0";
      order=ASCENDING;
     };
     DataSortEl @[1] {
      col_name="individual";
      name="individual_up_1";
      order=ASCENDING;
     };
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[5] {
   name="CategObjectList";
   desc="object list used for generating categories and individuals -- optional";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
     DataSortEl @[0] {
      col_name="category";
      name="category_up_0";
      order=ASCENDING;
     };
     DataSortEl @[1] {
      col_name="individual";
      name="individual_up_1";
      order=ASCENDING;
     };
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[6] {
   name="Category";
   desc="Full list of categories -- defines the space of possible responses -- can be larger than what is currently in  use";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[7] {
   name="CurCategs";
   desc="categories currently in use by the current set of input patterns -- can be a subset of full list in Category";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[8] {
   name="Individual";
   desc="full master list of individual objects (there may also be multiple images of same individual object below this level)";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6033";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[9] {
   name="CurIndivs";
   desc="currently-used individuals -- not the full master list";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[10] {
   name="SoundFilesRaw";
   desc="listing of individual objects (may be multiple images of same object)";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_1999";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.25;
       val_type_fixed=0;
      };
     };
     name="FileName";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=154;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2000";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.5714286;
       val_type_fixed=0;
      };
     };
     name="FilePath";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=352;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[11] {
   name="SoundFilesAll";
   desc="listing of individual objects (may be multiple images of same object)";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2004";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1623377;
       val_type_fixed=0;
      };
     };
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2001";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.612013;
       val_type_fixed=0;
      };
     };
     name="sound_file";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=377;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[12] {
   name="SoundFilesUse";
   desc="listing of individual objects (may be multiple images of same object)";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2004";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1623377;
       val_type_fixed=0;
      };
     };
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2001";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.612013;
       val_type_fixed=0;
      };
     };
     name="sound_file";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=377;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[13] {
   name="TrainItemsAll";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[14] {
   name="TestItemsAll";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[15] {
   name="TrainItemsCurList";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[16] {
   name="TestItemsCurList";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[17] {
   name="CurEpochList";
   desc="if there are constraints on number of objects per epoch, this is the list for the current epoch -- call GetCurEpochList function to update it ";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_4478";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_4477";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_4478";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[18] {
   name="CurObject";
   desc="current objects to use during this epoch";
   data {
    name="data";
    el_typ=double_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[19] {
   name="CurSoundFiles";
   desc="listing of individual objects (may be multiple images of same object)";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2004";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2006803;
       val_type_fixed=0;
      };
     };
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=95;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_2001";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1717687;
       val_type_fixed=0;
      };
     };
     name="sound_file";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=377;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[20] {
   name="TmpObjsList1";
   desc="current full list of objects with: category, individual, ctrlflags, and filename fields -- can have other optional data after that -- can have multiple rows for each category+individual (multiple different images / renders)";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
     DataSortEl @[0] {
      col_name="category";
      name="category_up_0";
      order=ASCENDING;
     };
     DataSortEl @[1] {
      col_name="individual_id";
      name="individual_id_up_1";
      order=ASCENDING;
     };
     DataSortEl @[2] {
      col_name="individual_id";
      name="individual_id_up_2";
      order=ASCENDING;
     };
     DataSortEl @[3] {
      col_name="individual_id";
      name="individual_id_up_3";
      order=ASCENDING;
     };
     DataSortEl @[4] {
      col_name="individual_id";
      name="individual_id_up_4";
      order=ASCENDING;
     };
     DataSortEl @[5] {
      col_name="individual_id";
      name="individual_id_up_5";
      order=ASCENDING;
     };
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[21] {
   name="TmpObjsList2";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
     DataSortEl @[0] {
      col_name="category";
      name="category_up_0";
      order=ASCENDING;
     };
     DataSortEl @[1] {
      col_name="individual_id";
      name="individual_id_up_1";
      order=ASCENDING;
     };
     DataSortEl @[2] {
      col_name="individual_id";
      name="individual_id_up_2";
      order=ASCENDING;
     };
     DataSortEl @[3] {
      col_name="individual_id";
      name="individual_id_up_3";
      order=ASCENDING;
     };
     DataSortEl @[4] {
      col_name="individual_id";
      name="individual_id_up_4";
      order=ASCENDING;
     };
     DataSortEl @[5] {
      col_name="individual_id";
      name="individual_id_up_5";
      order=ASCENDING;
     };
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[22] {
   name="TmpTrainList";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[23] {
   name="TmpTrainList2";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5960";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5961";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5962";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5963";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[24] {
   name="TmpTestList";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[25] {
   name="TmpTestList2";
   desc="ids of items selected for test set";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5964";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="category";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5965";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="individual";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5966";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="ctrlflags";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_5967";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6034";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="oid_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6035";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="category_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    int_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_6036";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.1785714;
       val_type_fixed=0;
      };
     };
     name="individual_id";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataGroupSpec @[26] {
   name="CategGroupSpec";
   ops {
    name="ops";
    el_typ=DataGroupEl;
    el_def=0;
    DataGroupEl @[0] {
     col_name="category";
     name="category_GROUP_0";
     agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
   };
   append_agg_name=0;
  };
  DataGroupSpec @[27] {
   name="CategGroupIdSpec";
   ops {
    name="ops";
    el_typ=DataGroupEl;
    el_def=0;
    DataGroupEl @[0] {
     col_name="category";
     name="category_GROUP_0";
     agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
    DataGroupEl @[1] {
     col_name="category_id";
     name="category_id_LAST_1";
     agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
   };
   append_agg_name=0;
  };
  DataGroupSpec @[28] {
   name="IndivGroupSpec";
   ops {
    name="ops";
    el_typ=DataGroupEl;
    el_def=0;
    DataGroupEl @[0] {
     col_name="category";
     name="category_GROUP_0";
     agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
    DataGroupEl @[1] {
     col_name="individual";
     name="individual_GROUP_1";
     agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
   };
   append_agg_name=0;
  };
  DataGroupSpec @[29] {
   name="IndivGroupIdSpec";
   ops {
    name="ops";
    el_typ=DataGroupEl;
    el_def=0;
    DataGroupEl @[0] {
     col_name="category";
     name="category_GROUP_0";
     agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
    DataGroupEl @[1] {
     col_name="individual";
     name="individual_GROUP_1";
     agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
    DataGroupEl @[2] {
     col_name="individual_id";
     name="individual_id_LAST_2";
     agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
    DataGroupEl @[3] {
     col_name="category_id";
     name="category_id_LAST_3";
     agg {name="agg": op=LAST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
    };
   };
   append_agg_name=0;
  };
  DataSelectSpec @[30] {
   name="SelectTrainItems";
   ops {
    name="ops";
    el_typ=DataSelectEl;
    el_def=0;
    DataSelectEl @[0] {
     col_name="ctrlflags";
     name="ctrlflags_EQUAL_TRAIN_0";
     on=1;
     rel=EQUAL;
     use_var=0;
     cmp 9 0="TRAIN";
     var=NULL;
     enable_var=NULL;
    };
   };
   comb_op=AND;
  };
  DataSelectSpec @[31] {
   name="SelectTestItems";
   ops {
    name="ops";
    el_typ=DataSelectEl;
    el_def=0;
    DataSelectEl @[0] {
     col_name="ctrlflags";
     name="ctrlflags_EQUAL_TRAIN_0";
     on=1;
     rel=EQUAL;
     use_var=0;
     cmp 9 0="TRAIN";
     var=NULL;
     enable_var=NULL;
    };
   };
   comb_op=AND;
  };
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="get_train_item";
   var_type=T_Bool;
   bool_val=1;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
   reference=0;
   desc="what kind of item to get (true = train, false = test)";
   init_from=NULL;
  };
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="objlist_id";
   var_type=T_String;
   string_val="CU3D_100_plus_lr20_u20_nb";
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED;
   reference=0;
   desc="id name of entry in ObjLists for which object list to use";
   init_from=.projects[0].programs.gp[4][0]$$<Program,StdGlobalsInit>;
  };
  ProgVar @[1] {
   name="obj_list_row";
   var_type=T_Int;
   flags=NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="row in ObjLists for objlist_id";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="train_permuted";
   var_type=T_Bool;
   bool_val=1;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="permute order of train items?  set this and call InitCur*List(s) if changed";
   init_from=NULL;
  };
  ProgVar @[3] {
   name="test_permuted";
   var_type=T_Bool;
   bool_val=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="permute order of test items?  set this and call InitCur*List(s) if changed";
   init_from=NULL;
  };
  ProgVar @[4] {
   name="use_epoch_list";
   var_type=T_Bool;
   bool_val=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="if true, number of objects per epoch is constrained to objs_per_epc from ObjLists -- must call GetCurEpochList at start of epoch!";
   init_from=NULL;
  };
  ProgVar @[5] {
   name="objs_per_epc";
   var_type=T_Int;
   flags=CTRL_PANEL|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="number of unique objects per epoch -- from ObjList data, see use_epoch_list";
   init_from=NULL;
  };
  ProgVar @[6] {
   name="next_train_idx";
   var_type=T_Int;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="next training index -- into TrainItemsCurList -- this is the item that will be returned by the *next* call -- current index is the ReadIndex of appropriate table";
   init_from=NULL;
  };
  ProgVar @[7] {
   name="next_test_idx";
   var_type=T_Int;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="next testing index -- into TestItemsCurList -- this is the item that will be returned by the *next* call -- current index is the ReadIndex of appropriate table";
   init_from=NULL;
  };
  ProgVar @[8] {
   name="next_epoch_idx";
   var_type=T_Int;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="next epoch index -- into CurrentEpochList -- this is the item that will be returned by the *next* call -- current index is the ReadIndex of appropriate table";
   init_from=NULL;
  };
  ProgVar @[9] {
   name="epoch_permuted";
   var_type=T_Bool;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="is epoch list permuted -- set from GetCurEpochList from train or test permuted";
   init_from=NULL;
  };
  ProgVar @[10] {
   name="cur_category";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="category name of the current object -- grab this from other projects using init_from setting pointing to this program";
   init_from=NULL;
  };
  ProgVar @[11] {
   name="cur_category_id";
   var_type=T_Int;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="category id of the current object -- grab this from other projects using init_from setting pointing to this program";
   init_from=NULL;
  };
  ProgVar @[12] {
   name="cur_individual";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|USED|EDIT_VAL;
   reference=0;
   desc="individual name of the current object -- grab this from other projects using init_from setting pointing to this program";
   init_from=NULL;
  };
  ProgVar @[13] {
   name="cur_individual_id";
   var_type=T_Int;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="individual id of the current object -- grab this from other projects using init_from setting pointing to this program";
   init_from=NULL;
  };
  ProgVar @[14] {
   name="cur_obj_filename";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="filename of the current object -- grab this from other projects using init_from setting pointing to this program";
   init_from=NULL;
  };
  ProgVar @[15] {
   name="cur_directory";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="current directory where files were loaded from";
   init_from=NULL;
  };
  ProgVar @[16] {
   name="cur_sound_file";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[17] {
   name="CurObject";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[18]$$;
   objs_ptr=1;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="this has one row containing the current object record";
   init_from=NULL;
  };
  ProgVar @[18] {
   name="ObjLists";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[0]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[19] {
   name="CurFullObjectList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[4]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[20] {
   name="CategObjectList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[5]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[21] {
   name="Category";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[6]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[22] {
   name="CurCategs";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[7]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[23] {
   name="Individual";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[8]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[24] {
   name="CurIndivs";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[9]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[25] {
   name="TrainItemsAll";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[13]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[26] {
   name="TestItemsAll";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[14]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[27] {
   name="ObjectMiscData";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[3]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[28] {
   name="SoundFilesRaw";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[10]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[29] {
   name="SoundFilesAll";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[11]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[30] {
   name="CategGroupSpec";
   var_type=T_Object;
   object_type=DataGroupSpec;
   object_val=.projects[0].programs.gp[3][0].objs[26]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[31] {
   name="CategGroupIdSpec";
   var_type=T_Object;
   object_type=DataGroupSpec;
   object_val=.projects[0].programs.gp[3][0].objs[27]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[32] {
   name="IndivGroupSpec";
   var_type=T_Object;
   object_type=DataGroupSpec;
   object_val=.projects[0].programs.gp[3][0].objs[28]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[33] {
   name="IndivGroupIdSpec";
   var_type=T_Object;
   object_type=DataGroupSpec;
   object_val=.projects[0].programs.gp[3][0].objs[29]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[34] {
   name="SoundFilesUse";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[12]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[35] {
   name="SelectTrainItems";
   var_type=T_Object;
   object_type=DataSelectSpec;
   object_val=.projects[0].programs.gp[3][0].objs[30]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[36] {
   name="SelectTestItems";
   var_type=T_Object;
   object_type=DataSelectSpec;
   object_val=.projects[0].programs.gp[3][0].objs[31]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[37] {
   name="TmpObjsList1";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[20]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[38] {
   name="TmpObjsList2";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[21]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[39] {
   name="TrainItemsCurList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[15]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[40] {
   name="TestItemsCurList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[16]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[41] {
   name="CurEpochList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[17]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[42] {
   name="CurSoundFiles";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[19]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[43] {
   name="play_sound";
   var_type=T_Bool;
   bool_val=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|EDIT_VAL;
   reference=0;
   desc="play sound when loading";
   init_from=NULL;
  };
  ProgVar @[44] {
   name="ObjLists_3Dobjs";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[2]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[45] {
   name="ConfigTable";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[1]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[46] {
   name="TmpTrainList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[22]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[47] {
   name="TmpTestList";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[24]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[48] {
   name="TmpTrainList2";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[23]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[49] {
   name="TmpTestList2";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][0].objs[25]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
  Function @[0] {
   desc="load OID file into file name and do IGNORE filtering";
   flags=CAN_REVERT_TO_CODE;
   code_string="LoadOIDFile(DataTable* oid_table, String fname) returns: int";
   pre_compile_code_string="LoadOIDFile(DataTable* oid_table, String fname) returns: int";
   name="LoadOIDFile";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="fname";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1013";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->StructUpdate(true)";
     pre_compile_code_string="oid_table->StructUpdate(true)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[0].args[0]$$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[2] {
     desc="Reset the raw data table prior to load";
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->RemoveAllCols()";
     pre_compile_code_string="oid_table->RemoveAllCols()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=DataTable::RemoveAllCols;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllCols()";
     meth_desc=" remove all columns (and data)";
    };
    MethodCall @[3] {
     desc="Load the raw .OIA file";
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->LoadData(fname, DataTable::TAB, true, -1, false)";
     pre_compile_code_string="oid_table->LoadData(fname, DataTable::TAB, true, -1, false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=DataTable::LoadData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="fname";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable::Delimiters;
       type="DataTable::Delimiters";
       name="delim";
       required=0;
       def_val="DataTable::TAB";
       prev_expr=;
       expr {
	expr="DataTable::TAB";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="quote_str";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[3] {
       arg_type=int;
       type="int";
       name="max_recs";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="-1";
       };
      };
      ProgArg @[4] {
       arg_type=bool;
       type="bool";
       name="reset_first";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void LoadData(taString& fname, DataTable::Delimiters delim = TAB, bool quote_str = true, int max_recs = -1, bool reset_first = true)";
     meth_desc=" load Emergent native format data (ONLY) - has a special header to define columns, up to max num of recs (-1 for all), with delimiter between columns and optionally quoting strings, reset_first = remove any existing data prior to loading -- this is much faster than LoadAnyData, especially noticible for very large data files";
    };
    Comment @[4] {
     desc="sort and make unique id";
     flags=CAN_REVERT_TO_CODE;
     code_string="// sort and make unique id";
     pre_compile_code_string="// sort and make unique id";
    };
    MethodCall @[5] {
     desc="get rid of IGNORE items right away";
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->Filter(\"ctrlflags\", Relation::NOT_CONTAINS, \"IGNORE\", , , , , , , )";
     pre_compile_code_string="oid_table->Filter(\"ctrlflags\", Relation::NOT_CONTAINS, \"IGNORE\", , , , , , , )";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=DataTable::Filter;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"ctrlflags\"";
       };
      };
      ProgArg @[1] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Relation::NOT_CONTAINS";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"IGNORE\"";
       };
      };
      ProgArg @[3] {
       arg_type=Relation::CombOp;
       type="Relation::CombOp";
       name="comb_op";
       required=0;
       def_val="Relation::AND";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=Variant;
       type="Variant";
       name="col2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_2";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_2";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=Variant;
       type="Variant";
       name="col3";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_3";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_3";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void Filter(Variant& col1, Relation::Relations operator_1, taString& value_1, Relation::CombOp comb_op = Relation::AND, Variant col2 = -1, Relation::Relations operator_2 = Relation::EQUAL, taString& value_2, Variant col3 = -1, Relation::Relations operator_3 = Relation::EQUAL, taString& value_3)";
     meth_desc=" Select table rows by specifying up to 3 conditions for which rows to retain in the table (hiding the ones that do not match). Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
    };
    MethodCall @[6] {
     desc="sort in categ, indiv order";
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->SortColName(\"category\", true, \"individual\", true, , , , , , , , )";
     pre_compile_code_string="oid_table->SortColName(\"category\", true, \"individual\", true, , , , , , , , )";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=DataTable::SortColName;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="ascending1";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col2";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"individual\"";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="ascending2";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col3";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=bool;
       type="bool";
       name="ascending3";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col4";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=bool;
       type="bool";
       name="ascending4";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col5";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=bool;
       type="bool";
       name="ascending5";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col6";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=bool;
       type="bool";
       name="ascending6";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void SortColName(taString& col1, bool ascending1 = true, taString& col2, bool ascending2 = true, taString& col3, bool ascending3 = true, taString& col4, bool ascending4 = true, taString& col5, bool ascending5 = true, taString& col6, bool ascending6 = true)";
     meth_desc=" sort table according to selected columns of data. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this sort you would need to run Flatten first";
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->NewColInt(\"oid_id\")";
     pre_compile_code_string="oid_table->NewColInt(\"oid_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=DataTable::NewColInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"oid_id\"";
       };
      };
     };
     meth_sig="int_Data_ptr NewColInt(taString& col_nm)";
     meth_desc=" create new column of integer-level data (= narrow display, actually stored as float)";
    };
    MethodCall @[8] {
     desc="unique id for each row of this object image data table";
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->InitValsToRowNo(\"oid_id\")";
     pre_compile_code_string="oid_table->InitValsToRowNo(\"oid_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=DataTable::InitValsToRowNo;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"oid_id\"";
       };
      };
     };
     meth_sig="bool InitValsToRowNo(Variant& col)";
     meth_desc=" initialize all values in given column to be equal to the row number -- only valid for scalar (not matrix) columns -- column can be specified as either integer index or a string that is then used to find the given column name";
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->StructUpdate(false)";
     pre_compile_code_string="oid_table->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[0].args[0]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
   };
  };
  Function @[1] {
   desc="get categories and individuals from oid table";
   flags=CAN_REVERT_TO_CODE;
   code_string="GetCategIndivs(DataTable* oid_table, DataTable* categ, DataTable* indiv) returns: int";
   pre_compile_code_string="GetCategIndivs(DataTable* oid_table, DataTable* categ, DataTable* indiv) returns: int";
   name="GetCategIndivs";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="categ";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="indiv";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_2246";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (3 vars)";
     pre_compile_code_string="LocalVars (3 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="cat";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="cat_id";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ->StructUpdate(true)";
     pre_compile_code_string="categ->StructUpdate(true)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[1].args[1]$$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->StructUpdate(true)";
     pre_compile_code_string="indiv->StructUpdate(true)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[1].args[2]$$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    DataProcCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::Group(categ, oid_table, CategGroupSpec)";
     pre_compile_code_string="taDataProc::Group(categ, oid_table, CategGroupSpec)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::Group;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="categ";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataGroupSpec_ptr;
       type="DataGroupSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CategGroupSpec";
       };
      };
     };
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ->NewColInt(\"category_id\")";
     pre_compile_code_string="categ->NewColInt(\"category_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[1]$;
     method=DataTable::NewColInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"category_id\"";
       };
      };
     };
     meth_sig="int_Data_ptr NewColInt(taString& col_nm)";
     meth_desc=" create new column of integer-level data (= narrow display, actually stored as float)";
    };
    MethodCall @[5] {
     desc="unique id for each category";
     flags=CAN_REVERT_TO_CODE;
     code_string="categ->InitValsToRowNo(\"category_id\")";
     pre_compile_code_string="categ->InitValsToRowNo(\"category_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[1]$;
     method=DataTable::InitValsToRowNo;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category_id\"";
       };
      };
     };
     meth_sig="bool InitValsToRowNo(Variant& col)";
     meth_desc=" initialize all values in given column to be equal to the row number -- only valid for scalar (not matrix) columns -- column can be specified as either integer index or a string that is then used to find the given column name";
    };
    UserScript @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ.data.category.BuildHashTable();";
     pre_compile_code_string="categ.data.category.BuildHashTable();";
     script {
      expr="categ.data.category.BuildHashTable();";
     };
    };
    Comment @[7] {
     desc="get individual";
     flags=CAN_REVERT_TO_CODE;
     code_string="// get individual";
     pre_compile_code_string="// get individual";
    };
    DataProcCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::Group(indiv, oid_table, IndivGroupSpec)";
     pre_compile_code_string="taDataProc::Group(indiv, oid_table, IndivGroupSpec)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::Group;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="indiv";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataGroupSpec_ptr;
       type="DataGroupSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="IndivGroupSpec";
       };
      };
     };
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->NewColInt(\"individual_id\")";
     pre_compile_code_string="indiv->NewColInt(\"individual_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
     method=DataTable::NewColInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"individual_id\"";
       };
      };
     };
     meth_sig="int_Data_ptr NewColInt(taString& col_nm)";
     meth_desc=" create new column of integer-level data (= narrow display, actually stored as float)";
    };
    MethodCall @[10] {
     desc="unique id for each individual";
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->InitValsToRowNo(\"individual_id\")";
     pre_compile_code_string="indiv->InitValsToRowNo(\"individual_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
     method=DataTable::InitValsToRowNo;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"individual_id\"";
       };
      };
     };
     meth_sig="bool InitValsToRowNo(Variant& col)";
     meth_desc=" initialize all values in given column to be equal to the row number -- only valid for scalar (not matrix) columns -- column can be specified as either integer index or a string that is then used to find the given column name";
    };
    Comment @[11] {
     desc="individual gets category_id";
     flags=CAN_REVERT_TO_CODE;
     code_string="// individual gets category_id";
     pre_compile_code_string="// individual gets category_id";
    };
    MethodCall @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->NewColInt(\"category_id\")";
     pre_compile_code_string="indiv->NewColInt(\"category_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
     method=DataTable::NewColInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"category_id\"";
       };
      };
     };
     meth_sig="int_Data_ptr NewColInt(taString& col_nm)";
     meth_desc=" create new column of integer-level data (= narrow display, actually stored as float)";
    };
    ForLoop @[13] {
     desc="set category_id";
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<indiv.rows; i++)";
     pre_compile_code_string="for (i=0; i<indiv.rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cat = indiv[\"category\"][i]";
       pre_compile_code_string="cat = indiv[\"category\"][i]";
       result_var=.projects[0].programs.gp[3][0].functions[1].fun_code[0].local_vars[1]$$;
       expr {
	expr="indiv[\"category\"][i]";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cat_id = categ->FindVal(cat, \"category\", 0, true)";
       pre_compile_code_string="cat_id = categ->FindVal(cat, \"category\", 0, true)";
       result_var=.projects[0].programs.gp[3][0].functions[1].fun_code[0].local_vars[2]$$;
       obj=$.projects[0].programs.gp[3][0].functions[1].args[1]$;
       method=DataTable::FindVal;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="cat";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"category\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="not_found_err";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
       meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
      };
      MatrixAssign @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="indiv[\"category_id\"][i] = cat_id";
       pre_compile_code_string="indiv[\"category_id\"][i] = cat_id";
       variable=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
       data_table=1;
       col {
	expr="\"category_id\"";
       };
       dim0 {
	expr="i";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="cat_id";
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<indiv.rows";
     };
     iter {
      expr="i++";
     };
    };
    UserScript @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv.data.individual.BuildHashTable();";
     pre_compile_code_string="indiv.data.individual.BuildHashTable();";
     script {
      expr="indiv.data.individual.BuildHashTable();";
     };
    };
    MethodCall @[15] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ->StructUpdate(false)";
     pre_compile_code_string="categ->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[1]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[16] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->StructUpdate(false)";
     pre_compile_code_string="indiv->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
   };
  };
  Function @[2] {
   desc="just get categories and individuals from table -- assume id's already in place";
   flags=CAN_REVERT_TO_CODE;
   code_string="GetCurCategIndivs(DataTable* oid_table, DataTable* categ, DataTable* indiv) returns: int";
   pre_compile_code_string="GetCurCategIndivs(DataTable* oid_table, DataTable* categ, DataTable* indiv) returns: int";
   name="GetCurCategIndivs";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="categ";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="indiv";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_2246";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (3 vars)";
     pre_compile_code_string="LocalVars (3 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="cat";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="cat_id";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ->StructUpdate(true)";
     pre_compile_code_string="categ->StructUpdate(true)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[1]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->StructUpdate(true)";
     pre_compile_code_string="indiv->StructUpdate(true)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    DataProcCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::Group(categ, oid_table, CategGroupIdSpec)";
     pre_compile_code_string="taDataProc::Group(categ, oid_table, CategGroupIdSpec)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::Group;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="categ";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataGroupSpec_ptr;
       type="DataGroupSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CategGroupIdSpec";
       };
      };
     };
    };
    UserScript @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ.data.category.BuildHashTable();";
     pre_compile_code_string="categ.data.category.BuildHashTable();";
     script {
      expr="categ.data.category.BuildHashTable();";
     };
    };
    Comment @[5] {
     desc="get individual";
     flags=CAN_REVERT_TO_CODE;
     code_string="// get individual";
     pre_compile_code_string="// get individual";
    };
    DataProcCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::Group(indiv, oid_table, IndivGroupIdSpec)";
     pre_compile_code_string="taDataProc::Group(indiv, oid_table, IndivGroupIdSpec)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::Group;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="indiv";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataGroupSpec_ptr;
       type="DataGroupSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="IndivGroupIdSpec";
       };
      };
     };
    };
    UserScript @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv.data.individual.BuildHashTable();";
     pre_compile_code_string="indiv.data.individual.BuildHashTable();";
     script {
      expr="indiv.data.individual.BuildHashTable();";
     };
    };
    MethodCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ->StructUpdate(false)";
     pre_compile_code_string="categ->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[1]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="indiv->StructUpdate(false)";
     pre_compile_code_string="indiv->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[1].args[2]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
   };
  };
  Function @[3] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="CategIndivIDsToOIDTable(DataTable* oid_table, DataTable* categ, DataTable* indiv) returns: int";
   pre_compile_code_string="CategIndivIDsToOIDTable(DataTable* oid_table, DataTable* categ, DataTable* indiv) returns: int";
   name="CategIndivIDsToOIDTable";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="categ";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="indiv";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1017";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="cat";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="ind";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="cat_id";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="ind_id";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->StructUpdate(true)";
     pre_compile_code_string="oid_table->StructUpdate(true)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[3].args[0]$$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[2] {
     desc="get rid of SKIP items now that basic info has been extracted";
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->FilterByScript(\"ctrlflags != \\\"SKIP\\\"\")";
     pre_compile_code_string="oid_table->FilterByScript(\"ctrlflags != \\\"SKIP\\\"\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[3].args[0]$;
     method=DataTable::FilterByScript;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="filter_expr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"ctrlflags != \\\"SKIP\\\"\"";
       };
      };
     };
     meth_sig="bool FilterByScript(taString& filter_expr)";
     meth_desc=" Select table rows by supplying a logical expression -- if it evaluates to true the row remains visible. Refer to columns by name. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->NewColInt(\"category_id\")";
     pre_compile_code_string="oid_table->NewColInt(\"category_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[3].args[0]$;
     method=DataTable::NewColInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"category_id\"";
       };
      };
     };
     meth_sig="int_Data_ptr NewColInt(taString& col_nm)";
     meth_desc=" create new column of integer-level data (= narrow display, actually stored as float)";
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->NewColInt(\"individual_id\")";
     pre_compile_code_string="oid_table->NewColInt(\"individual_id\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[3].args[0]$;
     method=DataTable::NewColInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"individual_id\"";
       };
      };
     };
     meth_sig="int_Data_ptr NewColInt(taString& col_nm)";
     meth_desc=" create new column of integer-level data (= narrow display, actually stored as float)";
    };
    ForLoop @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<oid_table.rows; i++)";
     pre_compile_code_string="for (i=0; i<oid_table.rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cat = oid_table[\"category\"][i]";
       pre_compile_code_string="cat = oid_table[\"category\"][i]";
       result_var=.projects[0].programs.gp[3][0].functions[3].fun_code[0].local_vars[1]$$;
       expr {
	expr="oid_table[\"category\"][i]";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cat_id = categ->FindVal(cat, \"category\", 0, true)";
       pre_compile_code_string="cat_id = categ->FindVal(cat, \"category\", 0, true)";
       result_var=.projects[0].programs.gp[3][0].functions[3].fun_code[0].local_vars[3]$$;
       obj=.projects[0].programs.gp[3][0].functions[3].args[1]$$;
       method=DataTable::FindVal;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="cat";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"category\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="not_found_err";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
       meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
      };
      MatrixAssign @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="oid_table[\"category_id\"][i] = cat_id";
       pre_compile_code_string="oid_table[\"category_id\"][i] = cat_id";
       variable=$.projects[0].programs.gp[3][0].functions[3].args[0]$;
       data_table=1;
       col {
	expr="\"category_id\"";
       };
       dim0 {
	expr="i";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="cat_id";
       };
      };
      AssignExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ind = oid_table[\"individual\"][i]";
       pre_compile_code_string="ind = oid_table[\"individual\"][i]";
       result_var=.projects[0].programs.gp[3][0].functions[3].fun_code[0].local_vars[2]$$;
       expr {
	expr="oid_table[\"individual\"][i]";
       };
      };
      MethodCall @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ind_id = indiv->FindMultiVal(0, cat, \"category\", ind, \"individual\", , , , , , , , )";
       pre_compile_code_string="ind_id = indiv->FindMultiVal(0, cat, \"category\", ind, \"individual\", , , , , , , , )";
       result_var=.projects[0].programs.gp[3][0].functions[3].fun_code[0].local_vars[4]$$;
       obj=.projects[0].programs.gp[3][0].functions[3].args[2]$$;
       method=DataTable::FindMultiVal;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=1;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val1";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="cat";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col1";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"category\"";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val2";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="ind";
	 };
	};
	ProgArg @[4] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col2";
	 required=0;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"individual\"";
	 };
	};
	ProgArg @[5] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val3";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col3";
	 required=0;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val4";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col4";
	 required=0;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[9] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="vall5";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[10] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col5";
	 required=0;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[11] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val6";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[12] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col6";
	 required=0;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="int FindMultiVal(int st_row, Variant& val1, Variant& col1, Variant& val2 = 0, Variant& col2, Variant& val3 = 0, Variant& col3, Variant& val4 = 0, Variant& col4, Variant& vall5 = 0, Variant& col5, Variant& val6 = 0, Variant& col6)";
       meth_desc=" find row number for multiple values across different columns of scalar type, starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- columns can be specified as either integer index or a string that is then used to find the given column name";
      };
      MatrixAssign @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="oid_table[\"individual_id\"][i] = ind_id";
       pre_compile_code_string="oid_table[\"individual_id\"][i] = ind_id";
       variable=$.projects[0].programs.gp[3][0].functions[3].args[0]$;
       data_table=1;
       col {
	expr="\"individual_id\"";
       };
       dim0 {
	expr="i";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="ind_id";
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<oid_table.rows";
     };
     iter {
      expr="i++";
     };
    };
    MethodCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->StructUpdate(false)";
     pre_compile_code_string="oid_table->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[3].args[0]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
   };
  };
  Function @[4] {
   desc="load a datatable file into CurFullObjectList";
   flags=CAN_REVERT_TO_CODE;
   code_string="LoadCurObjectList(String oid_filename, String oid_filename_categs) returns: int";
   pre_compile_code_string="LoadCurObjectList(String oid_filename, String oid_filename_categs) returns: int";
   name="LoadCurObjectList";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_filename";
     var_type=T_String;
     string_val="images/CU3D_100_plus_models/CU3D_100_models.dat";
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="oid_filename_categs";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1012";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    Comment @[1] {
     desc="ctrlflags tested for IGNORE = completely skip over for everything, and SKIP = record category and individual data but then exclude after that";
     flags=CAN_REVERT_TO_CODE;
     code_string="// ctrlflags tested for IGNORE = completely skip over for everything, and SKIP = record category and individual data but then exclude after that";
     pre_compile_code_string="// ctrlflags tested for IGNORE = completely skip over for everything, and SKIP = record category and individual data but then exclude after that";
    };
    PrintVar @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"Importing Object ID (OID) file: \" oid_filename";
     pre_compile_code_string="Print  \"Importing Object ID (OID) file: \" oid_filename";
     message="Importing Object ID (OID) file: ";
     print_var=.projects[0].programs.gp[3][0].functions[4].args[0]$$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
    FunctionCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LoadOIDFile(CurFullObjectList, oid_filename)";
     pre_compile_code_string="LoadOIDFile(CurFullObjectList, oid_filename)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[0]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="oid_table";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CurFullObjectList";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="fname";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_filename";
       };
      };
     };
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (oid_filename_categs.nonempty())";
     pre_compile_code_string="if (oid_filename_categs.nonempty())";
     cond {
      expr="oid_filename_categs.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="LoadOIDFile(CategObjectList, oid_filename_categs)";
       pre_compile_code_string="LoadOIDFile(CategObjectList, oid_filename_categs)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[0]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="oid_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CategObjectList";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="fname";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="oid_filename_categs";
	 };
	};
       };
      };
      FunctionCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCategIndivs(CategObjectList, Category, Individual)";
       pre_compile_code_string="GetCategIndivs(CategObjectList, Category, Individual)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[1]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="oid_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CategObjectList";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="categ";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="Category";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="indiv";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="Individual";
	 };
	};
       };
      };
     };
    };
    Else @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCategIndivs(CurFullObjectList, Category, Individual)";
       pre_compile_code_string="GetCategIndivs(CurFullObjectList, Category, Individual)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[1]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="oid_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CurFullObjectList";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="categ";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="Category";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="indiv";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="Individual";
	 };
	};
       };
      };
     };
    };
    FunctionCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CategIndivIDsToOIDTable(CurFullObjectList, Category, Individual)";
     pre_compile_code_string="CategIndivIDsToOIDTable(CurFullObjectList, Category, Individual)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[3]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="oid_table";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CurFullObjectList";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="categ";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Category";
       };
      };
      ProgArg @[2] {
       arg_type=DataTable;
       type="DataTable*";
       name="indiv";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Individual";
       };
      };
     };
    };
    FunctionCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="GetCurCategIndivs(CurFullObjectList, CurCategs, CurIndivs)";
     pre_compile_code_string="GetCurCategIndivs(CurFullObjectList, CurCategs, CurIndivs)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[2]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="oid_table";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CurFullObjectList";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="categ";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CurCategs";
       };
      };
      ProgArg @[2] {
       arg_type=DataTable;
       type="DataTable*";
       name="indiv";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CurIndivs";
       };
      };
     };
    };
   };
  };
  Function @[5] {
   desc="process raw files into a table with appropriate category names that match those in Category table";
   flags=CAN_REVERT_TO_CODE;
   code_string="FilesListToCategFiles(DataTable* categ_file_tab, DataTable* file_tab, String file_col_nm) returns: int";
   pre_compile_code_string="FilesListToCategFiles(DataTable* categ_file_tab, DataTable* file_tab, String file_col_nm) returns: int";
   name="FilesListToCategFiles";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="categ_file_tab";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="file_tab";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="file_col_nm";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (6 vars)";
     pre_compile_code_string="LocalVars (6 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="rows";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="fnm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="nm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="categ";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="obj_idx";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="rows = file_tab->rows";
     pre_compile_code_string="rows = file_tab->rows";
     result_var=.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[0]$$;
     expr {
      expr="file_tab->rows";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ_file_tab->StructUpdate(true)";
     pre_compile_code_string="categ_file_tab->StructUpdate(true)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[5].args[0]$$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ_file_tab->ResetData()";
     pre_compile_code_string="categ_file_tab->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ_file_tab->FindMakeCol(\"category\", taBase::VT_STRING)";
     pre_compile_code_string="categ_file_tab->FindMakeCol(\"category\", taBase::VT_STRING)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
     method=DataTable::FindMakeCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category\"";
       };
      };
      ProgArg @[1] {
       arg_type=taBase::ValType;
       type="taBase::ValType";
       name="val_type";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="taBase::VT_STRING";
       };
      };
     };
     meth_sig="DataCol_ptr FindMakeCol(taString& col_nm, taBase::ValType val_type)";
     meth_desc=" insures that a scalar column of the given name and val type exists, and return that col.";
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ_file_tab->FindMakeCol(file_col_nm, taBase::VT_STRING)";
     pre_compile_code_string="categ_file_tab->FindMakeCol(file_col_nm, taBase::VT_STRING)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
     method=DataTable::FindMakeCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="file_col_nm";
       };
      };
      ProgArg @[1] {
       arg_type=taBase::ValType;
       type="taBase::ValType";
       name="val_type";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="taBase::VT_STRING";
       };
      };
     };
     meth_sig="DataCol_ptr FindMakeCol(taString& col_nm, taBase::ValType val_type)";
     meth_desc=" insures that a scalar column of the given name and val type exists, and return that col.";
    };
    ForLoop @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<rows; i++)";
     pre_compile_code_string="for (i=0; i<rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="fnm = file_tab[1][i]";
       pre_compile_code_string="fnm = file_tab[1][i]";
       result_var=.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[2]$$;
       expr {
	expr="file_tab[1][i]";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="nm = fnm->after(\"/\", -1)";
       pre_compile_code_string="nm = fnm->after(\"/\", -1)";
       result_var=.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[3]$$;
       obj=$.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[2]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"/\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[2] {
       desc="note: special code here depends on filenames!";
       flags=CAN_REVERT_TO_CODE;
       code_string="nm = nm->before(\"_\", -1)";
       pre_compile_code_string="nm = nm->before(\"_\", -1)";
       result_var=$.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[3]$;
       obj=$.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[3]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"_\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      AssignExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="categ = nm";
       pre_compile_code_string="categ = nm";
       result_var=.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[4]$$;
       expr {
	expr="nm";
       };
      };
      MethodCall @[4] {
       desc="objrec categ names don't have _";
       flags=CAN_REVERT_TO_CODE;
       code_string="categ->gsub(\"_\", \"\")";
       pre_compile_code_string="categ->gsub(\"_\", \"\")";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[4]$;
       method=taString::gsub;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="pat";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"_\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="repl";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"\"";
	 };
	};
       };
       meth_sig="int gsub(taString& pat, taString& repl)";
       meth_desc=" global substitution: substitute all occurrences of pat with repl";
      };
      MethodCall @[5] {
       desc="objrec categ names don't have _";
       flags=CAN_REVERT_TO_CODE;
       code_string="categ->gsub(\"-\", \"\")";
       pre_compile_code_string="categ->gsub(\"-\", \"\")";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].functions[5].fun_code[0].local_vars[4]$;
       method=taString::gsub;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="pat";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"-\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="repl";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"\"";
	 };
	};
       };
       meth_sig="int gsub(taString& pat, taString& repl)";
       meth_desc=" global substitution: substitute all occurrences of pat with repl";
      };
      MethodCall @[6] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="categ_file_tab->AddBlankRow()";
       pre_compile_code_string="categ_file_tab->AddBlankRow()";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MatrixAssign @[7] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="categ_file_tab[\"category\"][-1] = categ";
       pre_compile_code_string="categ_file_tab[\"category\"][-1] = categ";
       variable=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
       data_table=1;
       col {
	expr="\"category\"";
       };
       dim0 {
	expr="-1";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="categ";
       };
      };
      MatrixAssign @[8] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="categ_file_tab[file_col_nm][-1] = fnm";
       pre_compile_code_string="categ_file_tab[file_col_nm][-1] = fnm";
       variable=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
       data_table=1;
       col {
	expr="file_col_nm";
       };
       dim0 {
	expr="-1";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="fnm";
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<rows";
     };
     iter {
      expr="i++";
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categ_file_tab->StructUpdate(false)";
     pre_compile_code_string="categ_file_tab->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[5].args[0]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
   };
  };
  Function @[6] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddCategFilesToOID(DataTable* oid_table, DataTable* categ_file_tab, String file_col_nm) returns: int";
   pre_compile_code_string="AddCategFilesToOID(DataTable* oid_table, DataTable* categ_file_tab, String file_col_nm) returns: int";
   name="AddCategFilesToOID";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="categ_file_tab";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="file_col_nm";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (6 vars)";
     pre_compile_code_string="LocalVars (6 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="rows";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="fnm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="nm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="categ";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="fnm_idx";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="rows = oid_table->rows";
     pre_compile_code_string="rows = oid_table->rows";
     result_var=.projects[0].programs.gp[3][0].functions[6].fun_code[0].local_vars[0]$$;
     expr {
      expr="oid_table->rows";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_table->FindMakeCol(file_col_nm, taBase::VT_STRING)";
     pre_compile_code_string="oid_table->FindMakeCol(file_col_nm, taBase::VT_STRING)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[6].args[0]$$;
     method=DataTable::FindMakeCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="file_col_nm";
       };
      };
      ProgArg @[1] {
       arg_type=taBase::ValType;
       type="taBase::ValType";
       name="val_type";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="taBase::VT_STRING";
       };
      };
     };
     meth_sig="DataCol_ptr FindMakeCol(taString& col_nm, taBase::ValType val_type)";
     meth_desc=" insures that a scalar column of the given name and val type exists, and return that col.";
    };
    ForLoop @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<rows; i++)";
     pre_compile_code_string="for (i=0; i<rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="categ = oid_table[\"category\"][i]";
       pre_compile_code_string="categ = oid_table[\"category\"][i]";
       result_var=.projects[0].programs.gp[3][0].functions[6].fun_code[0].local_vars[4]$$;
       expr {
	expr="oid_table[\"category\"][i]";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="fnm_idx = categ_file_tab->FindVal(categ, \"category\", 0, true)";
       pre_compile_code_string="fnm_idx = categ_file_tab->FindVal(categ, \"category\", 0, true)";
       result_var=.projects[0].programs.gp[3][0].functions[6].fun_code[0].local_vars[5]$$;
       obj=.projects[0].programs.gp[3][0].functions[6].args[1]$$;
       method=DataTable::FindVal;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="categ";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"category\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="not_found_err";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
       };
       meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
       meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
      };
      AssignExpr @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="fnm = categ_file_tab[file_col_nm][fnm_idx]";
       pre_compile_code_string="fnm = categ_file_tab[file_col_nm][fnm_idx]";
       result_var=.projects[0].programs.gp[3][0].functions[6].fun_code[0].local_vars[2]$$;
       expr {
	expr="categ_file_tab[file_col_nm][fnm_idx]";
       };
      };
      MatrixAssign @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="oid_table[file_col_nm][i] = fnm";
       pre_compile_code_string="oid_table[file_col_nm][i] = fnm";
       variable=$.projects[0].programs.gp[3][0].functions[6].args[0]$;
       data_table=1;
       col {
	expr="file_col_nm";
       };
       dim0 {
	expr="i";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="fnm";
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<rows";
     };
     iter {
      expr="i++";
     };
    };
   };
  };
  Function @[7] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="FilterFilesList(DataTable* categ_file_tab, DataTable* filtered_file_tab, String file_col_nm, String include_filter, String exclude_filter) returns: int";
   pre_compile_code_string="FilterFilesList(DataTable* categ_file_tab, DataTable* filtered_file_tab, String file_col_nm, String include_filter, String exclude_filter) returns: int";
   name="FilterFilesList";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="categ_file_tab";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="filtered_file_tab";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="file_col_nm";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="include_filter";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="exclude_filter";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1024";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="filtered_file_tab->CopyFrom(categ_file_tab)";
     pre_compile_code_string="filtered_file_tab->CopyFrom(categ_file_tab)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[7].args[1]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="categ_file_tab";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (include_filter.nonempty())";
     pre_compile_code_string="if (include_filter.nonempty())";
     cond {
      expr="include_filter.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="filtered_file_tab->FilterContainsList(file_col_nm, include_filter, true, \" \")";
       pre_compile_code_string="filtered_file_tab->FilterContainsList(file_col_nm, include_filter, true, \" \")";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].functions[7].args[1]$;
       method=DataTable::FilterContainsList;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="file_col_nm";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="contains_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="include_filter";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="include_matches";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="delim";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\" \"";
	 };
	};
       };
       meth_sig="void FilterContainsList(Variant& col, taString& contains_list, bool include_matches = true, taString& delim)";
       meth_desc=" Select table rows based on whether given column value contains any of the items on contains_list (space or other delim separated list of strings) -- if include_matches then those with any of the matching items on the list are included, otherwise they are excluded. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
      };
     };
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (exclude_filter.nonempty())";
     pre_compile_code_string="if (exclude_filter.nonempty())";
     cond {
      expr="exclude_filter.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="filtered_file_tab->FilterContainsList(file_col_nm, exclude_filter, false, \" \")";
       pre_compile_code_string="filtered_file_tab->FilterContainsList(file_col_nm, exclude_filter, false, \" \")";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].functions[7].args[1]$;
       method=DataTable::FilterContainsList;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="file_col_nm";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="contains_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="exclude_filter";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="include_matches";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="delim";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\" \"";
	 };
	};
       };
       meth_sig="void FilterContainsList(Variant& col, taString& contains_list, bool include_matches = true, taString& delim)";
       meth_desc=" Select table rows based on whether given column value contains any of the items on contains_list (space or other delim separated list of strings) -- if include_matches then those with any of the matching items on the list are included, otherwise they are excluded. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
      };
     };
    };
   };
  };
  Function @[8] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetFileList(DataTable* file_table, String path, String filter, bool recursive) returns: int";
   pre_compile_code_string="GetFileList(DataTable* file_table, String path, String filter, bool recursive) returns: int";
   name="GetFileList";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="file_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="path";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="filter";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="recursive";
     var_type=T_Bool;
     bool_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1016";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    DataGenCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataGen::GetDirFiles(file_table, path, filter, recursive, , , )";
     pre_compile_code_string="taDataGen::GetDirFiles(file_table, path, filter, recursive, , , )";
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::GetDirFiles;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="file_table";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="dir_path";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="path";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="filter";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="filter";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="recursive";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="recursive";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname_col_nm";
       required=0;
       def_val="FileName";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=const_taString_ref;
       type="taString&";
       name="path_col_nm";
       required=0;
       def_val="FilePath";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=bool;
       type="bool";
       name="reset_first";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
   };
  };
  Function @[9] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddNameSoundFiles(DataTable* oid_table, DataTable* snd_raw_table, DataTable* snd_cat_table, DataTable* snd_cat_table_use, String snd_path, String snd_include_filt, String snd_exclude_filt) returns: int";
   pre_compile_code_string="AddNameSoundFiles(DataTable* oid_table, DataTable* snd_raw_table, DataTable* snd_cat_table, DataTable* snd_cat_table_use, String snd_path, String snd_include_filt, String snd_exclude_filt) returns: int";
   name="AddNameSoundFiles";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="snd_raw_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="snd_cat_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="snd_cat_table_use";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="snd_path";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[5] {
     name="snd_include_filt";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[6] {
     name="snd_exclude_filt";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1021";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="file_col_nm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="file_col_nm = \"sound_file\"";
     pre_compile_code_string="file_col_nm = \"sound_file\"";
     result_var=.projects[0].programs.gp[3][0].functions[9].fun_code[0].local_vars[0]$$;
     expr {
      expr="\"sound_file\"";
     };
    };
    FunctionCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="GetFileList(snd_raw_table, snd_path, \".wav\", false)";
     pre_compile_code_string="GetFileList(snd_raw_table, snd_path, \".wav\", false)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[8]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="file_table";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="snd_raw_table";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="path";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="snd_path";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="filter";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\".wav\"";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="recursive";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
    };
    FunctionCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="FilesListToCategFiles(snd_cat_table, snd_raw_table, file_col_nm)";
     pre_compile_code_string="FilesListToCategFiles(snd_cat_table, snd_raw_table, file_col_nm)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[5]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="categ_file_tab";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="snd_cat_table";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="file_tab";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="snd_raw_table";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="file_col_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="file_col_nm";
       };
      };
     };
    };
    FunctionCall @[4] {
     desc="not actually very useful -- multiple sound files per obj";
     flags=OFF|CAN_REVERT_TO_CODE;
     code_string="AddCategFilesToOID(oid_table, snd_cat_table, file_col_nm)";
     pre_compile_code_string="AddCategFilesToOID(oid_table, snd_cat_table, file_col_nm)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[6]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable;
       type="DataTable*";
       name="oid_table";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="categ_file_tab";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="snd_cat_table";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="file_col_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="file_col_nm";
       };
      };
     };
    };
    If @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (snd_include_filt.nonempty() || snd_exclude_filt.nonempty())";
     pre_compile_code_string="if (snd_include_filt.nonempty() || snd_exclude_filt.nonempty())";
     cond {
      expr="snd_include_filt.nonempty() || snd_exclude_filt.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="FilterFilesList(snd_cat_table, snd_cat_table_use, file_col_nm, snd_include_filt, snd_exclude_filt)";
       pre_compile_code_string="FilterFilesList(snd_cat_table, snd_cat_table_use, file_col_nm, snd_include_filt, snd_exclude_filt)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[7]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="categ_file_tab";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_cat_table";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="filtered_file_tab";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_cat_table_use";
	 };
	};
	ProgArg @[2] {
	 arg_type=taString;
	 type="String";
	 name="file_col_nm";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="file_col_nm";
	 };
	};
	ProgArg @[3] {
	 arg_type=taString;
	 type="String";
	 name="include_filter";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_include_filt";
	 };
	};
	ProgArg @[4] {
	 arg_type=taString;
	 type="String";
	 name="exclude_filter";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_exclude_filt";
	 };
	};
       };
      };
     };
    };
    Else @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="snd_cat_table_use->CopyFrom(snd_cat_table)";
       pre_compile_code_string="snd_cat_table_use->CopyFrom(snd_cat_table)";
       result_var=NULL;
       obj=.projects[0].programs.gp[3][0].functions[9].args[3]$$;
       method=taBase::CopyFrom;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taBase_ptr;
	 type="taBase*";
	 name="cpy_from";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_cat_table";
	 };
	};
       };
       meth_sig="bool CopyFrom(taBase* cpy_from)";
       meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
      };
     };
    };
   };
  };
  Function @[10] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="SplitOIDTrainTest(DataTable* oid_table, DataTable* train_list, DataTable* test_list, int n_train_per_categ, int n_test_per_categ) returns: int";
   pre_compile_code_string="SplitOIDTrainTest(DataTable* oid_table, DataTable* train_list, DataTable* test_list, int n_train_per_categ, int n_test_per_categ) returns: int";
   name="SplitOIDTrainTest";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="train_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="test_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="n_train_per_categ";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="n_test_per_categ";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1032";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpObjsList1->CopyFrom(oid_table)";
     pre_compile_code_string="TmpObjsList1->CopyFrom(oid_table)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].vars[37]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpObjsList1->Filter(\"ctrlflags\", Relation::NOT_CONTAINS, \"TRAIN\", Relation::AND, \"ctrlflags\", Relation::NOT_CONTAINS, \"TEST\", , , )";
     pre_compile_code_string="TmpObjsList1->Filter(\"ctrlflags\", Relation::NOT_CONTAINS, \"TRAIN\", Relation::AND, \"ctrlflags\", Relation::NOT_CONTAINS, \"TEST\", , , )";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[37]$;
     method=DataTable::Filter;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"ctrlflags\"";
       };
      };
      ProgArg @[1] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Relation::NOT_CONTAINS";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"TRAIN\"";
       };
      };
      ProgArg @[3] {
       arg_type=Relation::CombOp;
       type="Relation::CombOp";
       name="comb_op";
       required=0;
       def_val="Relation::AND";
       prev_expr=;
       expr {
	expr="Relation::AND";
       };
      };
      ProgArg @[4] {
       arg_type=Variant;
       type="Variant";
       name="col2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="\"ctrlflags\"";
       };
      };
      ProgArg @[5] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_2";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr="Relation::NOT_CONTAINS";
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_2";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"TEST\"";
       };
      };
      ProgArg @[7] {
       arg_type=Variant;
       type="Variant";
       name="col3";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_3";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_3";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void Filter(Variant& col1, Relation::Relations operator_1, taString& value_1, Relation::CombOp comb_op = Relation::AND, Variant col2 = -1, Relation::Relations operator_2 = Relation::EQUAL, taString& value_2, Variant col3 = -1, Relation::Relations operator_3 = Relation::EQUAL, taString& value_3)";
     meth_desc=" Select table rows by specifying up to 3 conditions for which rows to retain in the table (hiding the ones that do not match). Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
    };
    DataProcCall @[3] {
     desc="anything marked TRAIN goes straight in";
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::SplitRowsNByColGroupPermuted(TmpObjsList1, \"category\", train_list, n_train_per_categ, test_list, n_test_per_categ, , , , , , , , , )";
     pre_compile_code_string="taDataProc::SplitRowsNByColGroupPermuted(TmpObjsList1, \"category\", train_list, n_train_per_categ, test_list, n_test_per_categ, , , , , , , , , )";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::SplitRowsNByColGroupPermuted;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList1";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category\"";
       };
      };
      ProgArg @[2] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="train_list";
       };
      };
      ProgArg @[3] {
       arg_type=float;
       type="float";
       name="n1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="n_train_per_categ";
       };
      };
      ProgArg @[4] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_2";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="test_list";
       };
      };
      ProgArg @[5] {
       arg_type=float;
       type="float";
       name="n2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="n_test_per_categ";
       };
      };
      ProgArg @[6] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_3";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=float;
       type="float";
       name="n3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_4";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=float;
       type="float";
       name="n4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_5";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=float;
       type="float";
       name="n5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[12] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_6";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[13] {
       arg_type=float;
       type="float";
       name="n6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[14] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    DataProcCall @[4] {
     desc="anything marked TRAIN goes straight in";
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTrainItems)";
     pre_compile_code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTrainItems)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::SelectRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataSelectSpec_ptr;
       type="DataSelectSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="SelectTrainItems";
       };
      };
     };
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="train_list->AppendRows(TmpObjsList2)";
     pre_compile_code_string="train_list->AppendRows(TmpObjsList2)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[10].args[1]$$;
     method=DataTable::AppendRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="append_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
     };
     meth_sig="bool AppendRows(DataTable* append_from)";
     meth_desc=" append rows from another data table -- this is also available in taDataProc and in the GUI as a drag-and-drop action (appends rows of dropped item onto dropped item)";
    };
    DataProcCall @[6] {
     desc="anything marked TEST goes straight in";
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTestItems)";
     pre_compile_code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTestItems)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::SelectRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataSelectSpec_ptr;
       type="DataSelectSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="SelectTestItems";
       };
      };
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="test_list->AppendRows(TmpObjsList2)";
     pre_compile_code_string="test_list->AppendRows(TmpObjsList2)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[10].args[2]$$;
     method=DataTable::AppendRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="append_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
     };
     meth_sig="bool AppendRows(DataTable* append_from)";
     meth_desc=" append rows from another data table -- this is also available in taDataProc and in the GUI as a drag-and-drop action (appends rows of dropped item onto dropped item)";
    };
   };
  };
  Function @[11] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="SplitOIDTrainTest_Indivs(DataTable* oid_table, DataTable* train_list, DataTable* test_list, int n_train_per_categ, int n_test_per_categ) returns: int";
   pre_compile_code_string="SplitOIDTrainTest_Indivs(DataTable* oid_table, DataTable* train_list, DataTable* test_list, int n_train_per_categ, int n_test_per_categ) returns: int";
   name="SplitOIDTrainTest_Indivs";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="oid_table";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="train_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="test_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[3] {
     name="n_train_per_categ";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[4] {
     name="n_test_per_categ";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1032";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpObjsList1->CopyFrom(oid_table)";
     pre_compile_code_string="TmpObjsList1->CopyFrom(oid_table)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[37]$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpObjsList1->Filter(\"ctrlflags\", Relation::NOT_CONTAINS, \"TRAIN\", Relation::AND, \"ctrlflags\", Relation::NOT_CONTAINS, \"TEST\", , , )";
     pre_compile_code_string="TmpObjsList1->Filter(\"ctrlflags\", Relation::NOT_CONTAINS, \"TRAIN\", Relation::AND, \"ctrlflags\", Relation::NOT_CONTAINS, \"TEST\", , , )";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[37]$;
     method=DataTable::Filter;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"ctrlflags\"";
       };
      };
      ProgArg @[1] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Relation::NOT_CONTAINS";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"TRAIN\"";
       };
      };
      ProgArg @[3] {
       arg_type=Relation::CombOp;
       type="Relation::CombOp";
       name="comb_op";
       required=0;
       def_val="Relation::AND";
       prev_expr=;
       expr {
	expr="Relation::AND";
       };
      };
      ProgArg @[4] {
       arg_type=Variant;
       type="Variant";
       name="col2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="\"ctrlflags\"";
       };
      };
      ProgArg @[5] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_2";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr="Relation::NOT_CONTAINS";
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_2";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\"TEST\"";
       };
      };
      ProgArg @[7] {
       arg_type=Variant;
       type="Variant";
       name="col3";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_3";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_3";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void Filter(Variant& col1, Relation::Relations operator_1, taString& value_1, Relation::CombOp comb_op = Relation::AND, Variant col2 = -1, Relation::Relations operator_2 = Relation::EQUAL, taString& value_2, Variant col3 = -1, Relation::Relations operator_3 = Relation::EQUAL, taString& value_3)";
     meth_desc=" Select table rows by specifying up to 3 conditions for which rows to retain in the table (hiding the ones that do not match). Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
    };
    DataGroupProg @[3] {
     desc="get unique individuals";
     flags=CAN_REVERT_TO_CODE;
     code_string="Group from:  src table = TmpObjsList1 dest table = TmpObjsList2";
     pre_compile_code_string="Group from:  src table = TmpObjsList1 dest table = TmpObjsList2";
     src_data_var=$.projects[0].programs.gp[3][0].vars[37]$;
     dest_data_var=.projects[0].programs.gp[3][0].vars[38]$$;
     group_spec {
      name="group_spec";
      ops {
       name="ops";
       el_typ=DataGroupEl;
       el_def=0;
       DataGroupEl @[0] {
	col_name="category";
	name="category_GROUP_0";
	agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[1] {
	col_name="individual_id";
	name="individual_id_GROUP_1";
	agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
      };
      append_agg_name=0;
     };
    };
    DataProcCall @[4] {
     desc="anything marked TRAIN goes straight in";
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::SplitRowsNByColGroupPermuted(TmpObjsList2, \"category\", TmpTrainList, n_train_per_categ, TmpTestList, n_test_per_categ, , , , , , , , , )";
     pre_compile_code_string="taDataProc::SplitRowsNByColGroupPermuted(TmpObjsList2, \"category\", TmpTrainList, n_train_per_categ, TmpTestList, n_test_per_categ, , , , , , , , , )";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::SplitRowsNByColGroupPermuted;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category\"";
       };
      };
      ProgArg @[2] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpTrainList";
       };
      };
      ProgArg @[3] {
       arg_type=float;
       type="float";
       name="n1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="n_train_per_categ";
       };
      };
      ProgArg @[4] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_2";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpTestList";
       };
      };
      ProgArg @[5] {
       arg_type=float;
       type="float";
       name="n2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="n_test_per_categ";
       };
      };
      ProgArg @[6] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_3";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=float;
       type="float";
       name="n3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_4";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=float;
       type="float";
       name="n4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_5";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=float;
       type="float";
       name="n5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[12] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest_6";
       required=0;
       def_val="__null";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[13] {
       arg_type=float;
       type="float";
       name="n6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[14] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    DataJoinProg @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Join tables:  src_a = TmpTrainList src_b = TmpObjsList1 dest table = TmpTrainList2";
     pre_compile_code_string="Join tables:  src_a = TmpTrainList src_b = TmpObjsList1 dest table = TmpTrainList2";
     src_data_var=.projects[0].programs.gp[3][0].vars[46]$$;
     dest_data_var=.projects[0].programs.gp[3][0].vars[48]$$;
     src_b_data_var=$.projects[0].programs.gp[3][0].vars[37]$;
     join_spec {
      name="join_spec";
      col_a {
       col_name="individual_id";
      };
      col_b {
       col_name="individual_id";
      };
      type=INNER;
      nomatch_warn=1;
     };
    };
    DataJoinProg @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Join tables:  src_a = TmpTestList src_b = TmpObjsList1 dest table = TmpTestList2";
     pre_compile_code_string="Join tables:  src_a = TmpTestList src_b = TmpObjsList1 dest table = TmpTestList2";
     src_data_var=.projects[0].programs.gp[3][0].vars[47]$$;
     dest_data_var=.projects[0].programs.gp[3][0].vars[49]$$;
     src_b_data_var=$.projects[0].programs.gp[3][0].vars[37]$;
     join_spec {
      name="join_spec";
      col_a {
       col_name="individual_id";
      };
      col_b {
       col_name="individual_id";
      };
      type=INNER;
      nomatch_warn=1;
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpTrainList2->RemoveCol(\"category_1\")";
     pre_compile_code_string="TmpTrainList2->RemoveCol(\"category_1\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[48]$;
     method=DataTable::RemoveCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category_1\"";
       };
      };
     };
     meth_sig="void RemoveCol(Variant& col)";
     meth_desc=" removes indicated column";
    };
    MethodCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpTrainList2->MoveCol(1, TmpTrainList2.data.size-1)";
     pre_compile_code_string="TmpTrainList2->MoveCol(1, TmpTrainList2.data.size-1)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[48]$;
     method=DataTable::MoveCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="old_index";
       required=1;
       def_val=;
       prev_expr="\"category_1\"";
       expr {
	expr="1";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="new_index";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpTrainList2.data.size-1";
       };
      };
     };
     meth_sig="void MoveCol(int old_index, int new_index)";
     meth_desc=" move the column from position old to position new";
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpTestList2->RemoveCol(\"category_1\")";
     pre_compile_code_string="TmpTestList2->RemoveCol(\"category_1\")";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[49]$;
     method=DataTable::RemoveCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category_1\"";
       };
      };
     };
     meth_sig="void RemoveCol(Variant& col)";
     meth_desc=" removes indicated column";
    };
    MethodCall @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TmpTestList2->MoveCol(1, TmpTestList2.data.size-1)";
     pre_compile_code_string="TmpTestList2->MoveCol(1, TmpTestList2.data.size-1)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[49]$;
     method=DataTable::MoveCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="old_index";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="1";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="new_index";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpTestList2.data.size-1";
       };
      };
     };
     meth_sig="void MoveCol(int old_index, int new_index)";
     meth_desc=" move the column from position old to position new";
    };
    MethodCall @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="train_list->CopyFrom(TmpTrainList2)";
     pre_compile_code_string="train_list->CopyFrom(TmpTrainList2)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[11].args[1]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpTrainList2";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    MethodCall @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="test_list->CopyFrom(TmpTestList2)";
     pre_compile_code_string="test_list->CopyFrom(TmpTestList2)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].functions[11].args[2]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpTestList2";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    DataProcCall @[13] {
     desc="anything marked TRAIN goes straight in";
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTrainItems)";
     pre_compile_code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTrainItems)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::SelectRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataSelectSpec_ptr;
       type="DataSelectSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="SelectTrainItems";
       };
      };
     };
    };
    MethodCall @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="train_list->AppendRows(TmpObjsList2)";
     pre_compile_code_string="train_list->AppendRows(TmpObjsList2)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[10].args[1]$;
     method=DataTable::AppendRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="append_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
     };
     meth_sig="bool AppendRows(DataTable* append_from)";
     meth_desc=" append rows from another data table -- this is also available in taDataProc and in the GUI as a drag-and-drop action (appends rows of dropped item onto dropped item)";
    };
    DataProcCall @[15] {
     desc="anything marked TEST goes straight in";
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTestItems)";
     pre_compile_code_string="taDataProc::SelectRows(TmpObjsList2, oid_table, SelectTestItems)";
     result_var=NULL;
     object_type=taDataProc;
     method=taDataProc::SelectRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="src";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_table";
       };
      };
      ProgArg @[2] {
       arg_type=DataSelectSpec_ptr;
       type="DataSelectSpec*";
       name="spec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="SelectTestItems";
       };
      };
     };
    };
    MethodCall @[16] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="test_list->AppendRows(TmpObjsList2)";
     pre_compile_code_string="test_list->AppendRows(TmpObjsList2)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[10].args[2]$;
     method=DataTable::AppendRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="append_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TmpObjsList2";
       };
      };
     };
     meth_sig="bool AppendRows(DataTable* append_from)";
     meth_desc=" append rows from another data table -- this is also available in taDataProc and in the GUI as a drag-and-drop action (appends rows of dropped item onto dropped item)";
    };
   };
  };
  Function @[12] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="InitCurTrainList() returns: int";
   pre_compile_code_string="InitCurTrainList() returns: int";
   name="InitCurTrainList";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_1264";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TrainItemsCurList->CopyFrom(TrainItemsAll)";
     pre_compile_code_string="TrainItemsCurList->CopyFrom(TrainItemsAll)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].vars[39]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TrainItemsAll";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (train_permuted)";
     pre_compile_code_string="if (train_permuted)";
     cond {
      expr="train_permuted";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="TrainItemsCurList->PermuteRows()";
       pre_compile_code_string="TrainItemsCurList->PermuteRows()";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].vars[39]$;
       method=DataTable::PermuteRows;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="void PermuteRows(int thr_no = -1)";
       meth_desc=" permute the order of rows in the data table -- randomly shuffles the rows -- this is very efficiently implemented by shuffling the row_indexes lookup table, not the actual rows in memory. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Permute you would need to run Flatten first -- (0 <= thr_no < 100) specifies thread or dmem proc number for parallel safe random sequences (-1 = taMisc::dmem_proc for auto-safe dmem)";
      };
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="next_train_idx = 0";
     pre_compile_code_string="next_train_idx = 0";
     result_var=.projects[0].programs.gp[3][0].vars[6]$$;
     expr {
      expr="0";
     };
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (use_epoch_list && get_train_item)";
     pre_compile_code_string="if (use_epoch_list && get_train_item)";
     cond {
      expr="use_epoch_list && get_train_item";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCurEpochList_impl(TrainItemsCurList, next_train_idx)";
       pre_compile_code_string="GetCurEpochList_impl(TrainItemsCurList, next_train_idx)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[18]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TrainItemsCurList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_train_idx";
	 };
	};
       };
      };
     };
    };
   };
  };
  Function @[13] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="InitCurTestList() returns: int";
   pre_compile_code_string="InitCurTestList() returns: int";
   name="InitCurTestList";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_1265";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="TestItemsCurList->CopyFrom(TestItemsAll)";
     pre_compile_code_string="TestItemsCurList->CopyFrom(TestItemsAll)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].vars[40]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TestItemsAll";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (test_permuted)";
     pre_compile_code_string="if (test_permuted)";
     cond {
      expr="test_permuted";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="TestItemsCurList->PermuteRows()";
       pre_compile_code_string="TestItemsCurList->PermuteRows()";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].vars[40]$;
       method=DataTable::PermuteRows;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="void PermuteRows(int thr_no = -1)";
       meth_desc=" permute the order of rows in the data table -- randomly shuffles the rows -- this is very efficiently implemented by shuffling the row_indexes lookup table, not the actual rows in memory. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Permute you would need to run Flatten first -- (0 <= thr_no < 100) specifies thread or dmem proc number for parallel safe random sequences (-1 = taMisc::dmem_proc for auto-safe dmem)";
      };
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="next_test_idx = 0";
     pre_compile_code_string="next_test_idx = 0";
     result_var=.projects[0].programs.gp[3][0].vars[7]$$;
     expr {
      expr="0";
     };
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (use_epoch_list && !get_train_item)";
     pre_compile_code_string="if (use_epoch_list && !get_train_item)";
     cond {
      expr="use_epoch_list && !get_train_item";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCurEpochList_impl(TestItemsCurList, next_test_idx)";
       pre_compile_code_string="GetCurEpochList_impl(TestItemsCurList, next_test_idx)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[18]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TestItemsCurList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_test_idx";
	 };
	};
       };
      };
     };
    };
   };
  };
  Function @[14] {
   desc="get current lists from master train / test lists";
   flags=CAN_REVERT_TO_CODE;
   code_string="InitCurLists() returns: int";
   pre_compile_code_string="InitCurLists() returns: int";
   name="InitCurLists";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_1257";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    FunctionCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="InitCurTrainList()";
     pre_compile_code_string="InitCurTrainList()";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[12]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    FunctionCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="InitCurTestList()";
     pre_compile_code_string="InitCurTestList()";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[13]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (use_epoch_list)";
     pre_compile_code_string="if (use_epoch_list)";
     cond {
      expr="use_epoch_list";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCurEpochList()";
       pre_compile_code_string="GetCurEpochList()";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[19]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
    MethodCall @[4] {
     desc="configure";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurObject->Copy_NoData(TrainItemsCurList)";
     pre_compile_code_string="CurObject->Copy_NoData(TrainItemsCurList)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].vars[17]$$;
     method=DataTable::Copy_NoData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_DataTable_ref;
       type="DataTable&";
       name="cp";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="TrainItemsCurList";
       };
      };
     };
     meth_sig="void Copy_NoData(DataTable& cp)";
     meth_desc=" copy only the column structure, but no data, from other data table";
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurObject->EnforceRows(1)";
     pre_compile_code_string="CurObject->EnforceRows(1)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[17]$;
     method=DataTable::EnforceRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="n_rows";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="1";
       };
      };
     };
     meth_sig="void EnforceRows(int n_rows)";
     meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
    };
   };
  };
  Function @[15] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LoadObjListID(String objl_id) returns: int";
   pre_compile_code_string="LoadObjListID(String objl_id) returns: int";
   name="LoadObjListID";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="objl_id";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1015";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (8 vars)";
     pre_compile_code_string="LocalVars (8 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="oid_fname";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="oid_cat_fname";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="snd_file_path";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="snd_include_filt";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="snd_exclude_filt";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="train_size";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="test_size";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="split_on_indivs";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="obj_list_row = ObjLists->FindVal(objl_id, \"objlist_id\", 0, true)";
     pre_compile_code_string="obj_list_row = ObjLists->FindVal(objl_id, \"objlist_id\", 0, true)";
     result_var=.projects[0].programs.gp[3][0].vars[1]$$;
     obj=.projects[0].programs.gp[3][0].vars[18]$$;
     method=DataTable::FindVal;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="objl_id";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"objlist_id\"";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="st_row";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="not_found_err";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
     meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_fname = ObjLists[\"oid_filename\"][obj_list_row]";
     pre_compile_code_string="oid_fname = ObjLists[\"oid_filename\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[0]$$;
     expr {
      expr="ObjLists[\"oid_filename\"][obj_list_row]";
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="oid_cat_fname = ObjLists[\"oid_filename_categs\"][obj_list_row]";
     pre_compile_code_string="oid_cat_fname = ObjLists[\"oid_filename_categs\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[1]$$;
     expr {
      expr="ObjLists[\"oid_filename_categs\"][obj_list_row]";
     };
    };
    AssignExpr @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="snd_file_path = ObjLists[\"sound_file_path\"][obj_list_row]";
     pre_compile_code_string="snd_file_path = ObjLists[\"sound_file_path\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[2]$$;
     expr {
      expr="ObjLists[\"sound_file_path\"][obj_list_row]";
     };
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="snd_include_filt = ObjLists[\"sound_include_filter\"][obj_list_row]";
     pre_compile_code_string="snd_include_filt = ObjLists[\"sound_include_filter\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[3]$$;
     expr {
      expr="ObjLists[\"sound_include_filter\"][obj_list_row]";
     };
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="snd_exclude_filt = ObjLists[\"sound_exclude_filter\"][obj_list_row]";
     pre_compile_code_string="snd_exclude_filt = ObjLists[\"sound_exclude_filter\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[4]$$;
     expr {
      expr="ObjLists[\"sound_exclude_filter\"][obj_list_row]";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="train_size = ObjLists[\"train_size\"][obj_list_row]";
     pre_compile_code_string="train_size = ObjLists[\"train_size\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[5]$$;
     expr {
      expr="ObjLists[\"train_size\"][obj_list_row]";
     };
    };
    AssignExpr @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="test_size = ObjLists[\"test_size\"][obj_list_row]";
     pre_compile_code_string="test_size = ObjLists[\"test_size\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[6]$$;
     expr {
      expr="ObjLists[\"test_size\"][obj_list_row]";
     };
    };
    AssignExpr @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="objs_per_epc = ObjLists[\"objs_per_epc\"][obj_list_row]";
     pre_compile_code_string="objs_per_epc = ObjLists[\"objs_per_epc\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].vars[5]$$;
     expr {
      expr="ObjLists[\"objs_per_epc\"][obj_list_row]";
     };
    };
    AssignExpr @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="split_on_indivs = ObjLists[\"split_on_indivs\"][obj_list_row]";
     pre_compile_code_string="split_on_indivs = ObjLists[\"split_on_indivs\"][obj_list_row]";
     result_var=.projects[0].programs.gp[3][0].functions[15].fun_code[0].local_vars[7]$$;
     expr {
      expr="ObjLists[\"split_on_indivs\"][obj_list_row]";
     };
    };
    FunctionCall @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LoadCurObjectList(oid_fname, oid_cat_fname)";
     pre_compile_code_string="LoadCurObjectList(oid_fname, oid_cat_fname)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[4]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="oid_filename";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_fname";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="oid_filename_categs";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_cat_fname";
       };
      };
     };
    };
    MiscCall @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_directory = taMisc::GetDirFmPath(oid_fname, 0)";
     pre_compile_code_string="cur_directory = taMisc::GetDirFmPath(oid_fname, 0)";
     result_var=.projects[0].programs.gp[3][0].vars[15]$$;
     object_type=taMisc;
     method=taMisc::GetDirFmPath;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="path";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="oid_fname";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="n_up";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="0";
       };
      };
     };
    };
    If @[13] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (snd_file_path.nonempty())";
     pre_compile_code_string="if (snd_file_path.nonempty())";
     cond {
      expr="snd_file_path.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddNameSoundFiles(CurFullObjectList, SoundFilesRaw, SoundFilesAll, SoundFilesUse, snd_file_path, snd_include_filt, snd_exclude_filt)";
       pre_compile_code_string="AddNameSoundFiles(CurFullObjectList, SoundFilesRaw, SoundFilesAll, SoundFilesUse, snd_file_path, snd_include_filt, snd_exclude_filt)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[9]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="oid_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CurFullObjectList";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="snd_raw_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="SoundFilesRaw";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="snd_cat_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="SoundFilesAll";
	 };
	};
	ProgArg @[3] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="snd_cat_table_use";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="SoundFilesUse";
	 };
	};
	ProgArg @[4] {
	 arg_type=taString;
	 type="String";
	 name="snd_path";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_file_path";
	 };
	};
	ProgArg @[5] {
	 arg_type=taString;
	 type="String";
	 name="snd_include_filt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_include_filt";
	 };
	};
	ProgArg @[6] {
	 arg_type=taString;
	 type="String";
	 name="snd_exclude_filt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="snd_exclude_filt";
	 };
	};
       };
      };
     };
    };
    If @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (split_on_indivs)";
     pre_compile_code_string="if (split_on_indivs)";
     cond {
      expr="split_on_indivs";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="SplitOIDTrainTest_Indivs(CurFullObjectList, TrainItemsAll, TestItemsAll, train_size, test_size)";
       pre_compile_code_string="SplitOIDTrainTest_Indivs(CurFullObjectList, TrainItemsAll, TestItemsAll, train_size, test_size)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[11]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="oid_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CurFullObjectList";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="train_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TrainItemsAll";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="test_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TestItemsAll";
	 };
	};
	ProgArg @[3] {
	 arg_type=int;
	 type="int";
	 name="n_train_per_categ";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="train_size";
	 };
	};
	ProgArg @[4] {
	 arg_type=int;
	 type="int";
	 name="n_test_per_categ";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="test_size";
	 };
	};
       };
      };
     };
    };
    Else @[15] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="SplitOIDTrainTest(CurFullObjectList, TrainItemsAll, TestItemsAll, train_size, test_size)";
       pre_compile_code_string="SplitOIDTrainTest(CurFullObjectList, TrainItemsAll, TestItemsAll, train_size, test_size)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[10]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="oid_table";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CurFullObjectList";
	 };
	};
	ProgArg @[1] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="train_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TrainItemsAll";
	 };
	};
	ProgArg @[2] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="test_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TestItemsAll";
	 };
	};
	ProgArg @[3] {
	 arg_type=int;
	 type="int";
	 name="n_train_per_categ";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="train_size";
	 };
	};
	ProgArg @[4] {
	 arg_type=int;
	 type="int";
	 name="n_test_per_categ";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="test_size";
	 };
	};
       };
      };
     };
    };
    FunctionCall @[16] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="InitCurLists()";
     pre_compile_code_string="InitCurLists()";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[14]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
  };
  Function @[16] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetSoundFileRnd_impl(DataTable* item_list, String obj_name) returns: String";
   pre_compile_code_string="GetSoundFileRnd_impl(DataTable* item_list, String obj_name) returns: String";
   name="GetSoundFileRnd_impl";
   return_type=T_String;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="item_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="obj_name";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSoundFiles->CopyFrom(item_list)";
     pre_compile_code_string="CurSoundFiles->CopyFrom(item_list)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].vars[42]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="item_list";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSoundFiles->Filter(\"category\", Relation::EQUAL, obj_name, , , , , , , )";
     pre_compile_code_string="CurSoundFiles->Filter(\"category\", Relation::EQUAL, obj_name, , , , , , , )";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[42]$;
     method=DataTable::Filter;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category\"";
       };
      };
      ProgArg @[1] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Relation::EQUAL";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="obj_name";
       };
      };
      ProgArg @[3] {
       arg_type=Relation::CombOp;
       type="Relation::CombOp";
       name="comb_op";
       required=0;
       def_val="Relation::AND";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[4] {
       arg_type=Variant;
       type="Variant";
       name="col2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_2";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_2";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=Variant;
       type="Variant";
       name="col3";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=Relation::Relations;
       type="Relation::Relations";
       name="operator_3";
       required=0;
       def_val="Relation::EQUAL";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=const_taString_ref;
       type="taString&";
       name="value_3";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void Filter(Variant& col1, Relation::Relations operator_1, taString& value_1, Relation::CombOp comb_op = Relation::AND, Variant col2 = -1, Relation::Relations operator_2 = Relation::EQUAL, taString& value_2, Variant col3 = -1, Relation::Relations operator_3 = Relation::EQUAL, taString& value_3)";
     meth_desc=" Select table rows by specifying up to 3 conditions for which rows to retain in the table (hiding the ones that do not match). Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Filter you would need to run Flatten first";
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSoundFiles->PermuteRows()";
     pre_compile_code_string="CurSoundFiles->PermuteRows()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[42]$;
     method=DataTable::PermuteRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void PermuteRows(int thr_no = -1)";
     meth_desc=" permute the order of rows in the data table -- randomly shuffles the rows -- this is very efficiently implemented by shuffling the row_indexes lookup table, not the actual rows in memory. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Permute you would need to run Flatten first -- (0 <= thr_no < 100) specifies thread or dmem proc number for parallel safe random sequences (-1 = taMisc::dmem_proc for auto-safe dmem)";
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (CurSoundFiles.rows == 0)";
     pre_compile_code_string="if (CurSoundFiles.rows == 0)";
     cond {
      expr="CurSoundFiles.rows == 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      CssExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Warning(\"word:\", obj_name, \"not found in list:\", item_list.name);";
       pre_compile_code_string="taMisc::Warning(\"word:\", obj_name, \"not found in list:\", item_list.name);";
       expr {
	expr="taMisc::Warning(\"word:\", obj_name, \"not found in list:\", item_list.name);";
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_sound_file = \"\"";
       pre_compile_code_string="cur_sound_file = \"\"";
       result_var=.projects[0].programs.gp[3][0].vars[16]$$;
       expr {
	expr="\"\"";
       };
      };
     };
    };
    Else @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_sound_file = CurSoundFiles->GetVal(\"sound_file\", 0)";
       pre_compile_code_string="cur_sound_file = CurSoundFiles->GetVal(\"sound_file\", 0)";
       result_var=$.projects[0].programs.gp[3][0].vars[16]$;
       obj=$.projects[0].programs.gp[3][0].vars[42]$;
       method=DataTable::GetVal;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"sound_file\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
       };
       meth_sig="const_Variant GetVal(Variant& col, int row)";
       meth_desc=" get data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name";
      };
     };
    };
    ReturnExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return cur_sound_file";
     pre_compile_code_string="return cur_sound_file";
     expr {
      expr="cur_sound_file";
     };
    };
   };
  };
  Function @[17] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetSoundFileRnd() returns: String";
   pre_compile_code_string="GetSoundFileRnd() returns: String";
   name="GetSoundFileRnd";
   return_type=T_String;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_2202";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    ReturnExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return GetSoundFileRnd_impl(SoundFilesUse,cur_category)";
     pre_compile_code_string="return GetSoundFileRnd_impl(SoundFilesUse,cur_category)";
     expr {
      expr="GetSoundFileRnd_impl(SoundFilesUse,cur_category)";
     };
    };
   };
  };
  Function @[18] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetCurEpochList_impl(DataTable* obj_list, int& next_idx) returns: int";
   pre_compile_code_string="GetCurEpochList_impl(DataTable* obj_list, int& next_idx) returns: int";
   name="GetCurEpochList_impl";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="obj_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="next_idx";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1263";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (obj_list.rows == 0)";
     pre_compile_code_string="if (obj_list.rows == 0)";
     cond {
      expr="obj_list.rows == 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Error(\"object list has no rows -- cannot be used!\", obj_list.name, , , , , , , )";
       pre_compile_code_string="taMisc::Error(\"object list has no rows -- cannot be used!\", obj_list.name, , , , , , , )";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"object list has no rows -- cannot be used!\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="b";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="obj_list.name";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="c";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="d";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="e";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="f";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="g";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="h";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="i";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurEpochList->StructUpdate(true)";
     pre_compile_code_string="CurEpochList->StructUpdate(true)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][0].vars[41]$$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurEpochList->ResetData()";
     pre_compile_code_string="CurEpochList->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[41]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurEpochList->Copy_NoData(obj_list)";
     pre_compile_code_string="CurEpochList->Copy_NoData(obj_list)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[41]$;
     method=DataTable::Copy_NoData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_DataTable_ref;
       type="DataTable&";
       name="cp";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="obj_list";
       };
      };
     };
     meth_sig="void Copy_NoData(DataTable& cp)";
     meth_desc=" copy only the column structure, but no data, from other data table";
    };
    Comment @[5] {
     desc="the epoch list is a \"client\" of the cur list  -- uses up its allocation and updates index, etc";
     flags=CAN_REVERT_TO_CODE;
     code_string="// the epoch list is a \"client\" of the cur list  -- uses up its allocation and updates index, etc";
     pre_compile_code_string="// the epoch list is a \"client\" of the cur list  -- uses up its allocation and updates index, etc";
    };
    ForLoop @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<objs_per_epc; i++)";
     pre_compile_code_string="for (i=0; i<objs_per_epc; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (next_idx >= obj_list.rows)";
       pre_compile_code_string="if (next_idx >= obj_list.rows)";
       cond {
	expr="next_idx >= obj_list.rows";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="next_idx = 0";
	 pre_compile_code_string="next_idx = 0";
	 result_var=.projects[0].programs.gp[3][0].functions[20].args[1]$$;
	 expr {
	  expr="0";
	 };
	};
	If @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (epoch_permuted)";
	 pre_compile_code_string="if (epoch_permuted)";
	 cond {
	  expr="epoch_permuted";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="obj_list->PermuteRows()";
	   pre_compile_code_string="obj_list->PermuteRows()";
	   result_var=NULL;
	   obj=.projects[0].programs.gp[3][0].functions[20].args[0]$$;
	   method=DataTable::PermuteRows;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="thr_no";
	     required=0;
	     def_val="-1";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="void PermuteRows(int thr_no = -1)";
	   meth_desc=" permute the order of rows in the data table -- randomly shuffles the rows -- this is very efficiently implemented by shuffling the row_indexes lookup table, not the actual rows in memory. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Permute you would need to run Flatten first -- (0 <= thr_no < 100) specifies thread or dmem proc number for parallel safe random sequences (-1 = taMisc::dmem_proc for auto-safe dmem)";
	  };
	 };
	};
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurEpochList->AddBlankRow()";
       pre_compile_code_string="CurEpochList->AddBlankRow()";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].vars[41]$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurEpochList->CopyFromRow(-1, obj_list, next_idx)";
       pre_compile_code_string="CurEpochList->CopyFromRow(-1, obj_list, next_idx)";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][0].vars[41]$;
       method=DataTable::CopyFromRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="dest_row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_DataTable_ref;
	 type="DataTable&";
	 name="cp";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="obj_list";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="src_row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_idx";
	 };
	};
       };
       meth_sig="void CopyFromRow(int dest_row, DataTable& cp, int src_row)";
       meth_desc=" copy one row from source to given row in this object: source must have exact same column structure as this!!";
      };
      AssignExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="next_idx = next_idx + 1";
       pre_compile_code_string="next_idx = next_idx + 1";
       result_var=.projects[0].programs.gp[3][0].functions[18].args[1]$$;
       expr {
	expr="next_idx + 1";
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<objs_per_epc";
     };
     iter {
      expr="i++";
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurEpochList->StructUpdate(false)";
     pre_compile_code_string="CurEpochList->StructUpdate(false)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[41]$;
     method=taBase::StructUpdate;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool;
       type="bool";
       name="begin";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="void StructUpdate(bool begin)";
     meth_desc=" bracket structural changes with (nestable) true/false calls;";
    };
    AssignExpr @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="next_epoch_idx = 0";
     pre_compile_code_string="next_epoch_idx = 0";
     result_var=.projects[0].programs.gp[3][0].vars[8]$$;
     expr {
      expr="0";
     };
    };
   };
  };
  Function @[19] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetCurEpochList() returns: int";
   pre_compile_code_string="GetCurEpochList() returns: int";
   name="GetCurEpochList";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_1275";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (get_train_item)";
     pre_compile_code_string="if (get_train_item)";
     cond {
      expr="get_train_item";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCurEpochList_impl(TrainItemsCurList, next_train_idx)";
       pre_compile_code_string="GetCurEpochList_impl(TrainItemsCurList, next_train_idx)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[18]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TrainItemsCurList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_train_idx";
	 };
	};
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_permuted = train_permuted";
       pre_compile_code_string="epoch_permuted = train_permuted";
       result_var=.projects[0].programs.gp[3][0].vars[9]$$;
       expr {
	expr="train_permuted";
       };
      };
     };
    };
    Else @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetCurEpochList_impl(TestItemsCurList, next_test_idx)";
       pre_compile_code_string="GetCurEpochList_impl(TestItemsCurList, next_test_idx)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[18]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TestItemsCurList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_test_idx";
	 };
	};
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="epoch_permuted = test_permuted";
       pre_compile_code_string="epoch_permuted = test_permuted";
       result_var=$.projects[0].programs.gp[3][0].vars[9]$;
       expr {
	expr="test_permuted";
       };
      };
     };
    };
   };
  };
  Function @[20] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetNextItem_impl(DataTable* obj_list, int& next_idx, bool permute) returns: int";
   pre_compile_code_string="GetNextItem_impl(DataTable* obj_list, int& next_idx, bool permute) returns: int";
   name="GetNextItem_impl";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="obj_list";
     var_type=T_Object;
     object_type=DataTable;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="next_idx";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="permute";
     var_type=T_Bool;
     bool_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_1266";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (obj_list.rows == 0)";
     pre_compile_code_string="if (obj_list.rows == 0)";
     cond {
      expr="obj_list.rows == 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Error(\"object list has no rows -- cannot be used!\", obj_list.name, , , , , , , )";
       pre_compile_code_string="taMisc::Error(\"object list has no rows -- cannot be used!\", obj_list.name, , , , , , , )";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"object list has no rows -- cannot be used!\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="b";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="obj_list.name";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="c";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="d";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="e";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="f";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="g";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="h";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="i";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (next_idx >= obj_list.rows)";
     pre_compile_code_string="if (next_idx >= obj_list.rows)";
     cond {
      expr="next_idx >= obj_list.rows";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="next_idx = 0";
       pre_compile_code_string="next_idx = 0";
       result_var=$.projects[0].programs.gp[3][0].functions[20].args[1]$;
       expr {
	expr="0";
       };
      };
      If @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (permute)";
       pre_compile_code_string="if (permute)";
       cond {
	expr="permute";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="obj_list->PermuteRows()";
	 pre_compile_code_string="obj_list->PermuteRows()";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
	 method=DataTable::PermuteRows;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="thr_no";
	   required=0;
	   def_val="-1";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="void PermuteRows(int thr_no = -1)";
	 meth_desc=" permute the order of rows in the data table -- randomly shuffles the rows -- this is very efficiently implemented by shuffling the row_indexes lookup table, not the actual rows in memory. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this Permute you would need to run Flatten first -- (0 <= thr_no < 100) specifies thread or dmem proc number for parallel safe random sequences (-1 = taMisc::dmem_proc for auto-safe dmem)";
	};
       };
      };
     };
    };
    MethodCall @[3] {
     desc="sets read index";
     flags=CAN_REVERT_TO_CODE;
     code_string="obj_list->ReadItem(next_idx)";
     pre_compile_code_string="obj_list->ReadItem(next_idx)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
     method=DataTable::ReadItem;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="idx";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="next_idx";
       };
      };
     };
     meth_sig="bool ReadItem(int idx)";
     meth_desc=" goes directly (random access) to row idx (- = count back from last row available, otherwise must be in range 0 <= idx < rows) so that it is now available for GetData routines (which use read_idx for their row number), returns true if row exists and was read";
    };
    MethodCall @[4] {
     desc="set some key global vars that can be accessed in other programs";
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_category = obj_list->GetData(\"category\")";
     pre_compile_code_string="cur_category = obj_list->GetData(\"category\")";
     result_var=.projects[0].programs.gp[3][0].vars[10]$$;
     obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
     method=DataTable::GetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category\"";
       };
      };
     };
     meth_sig="const_Variant GetData(Variant& col)";
     meth_desc=" get data from given column number or name at current read_idx row number -- see ReadItem, ReadNext for updating the read_idx index";
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_category_id = obj_list->GetData(\"category_id\")";
     pre_compile_code_string="cur_category_id = obj_list->GetData(\"category_id\")";
     result_var=.projects[0].programs.gp[3][0].vars[11]$$;
     obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
     method=DataTable::GetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"category_id\"";
       };
      };
     };
     meth_sig="const_Variant GetData(Variant& col)";
     meth_desc=" get data from given column number or name at current read_idx row number -- see ReadItem, ReadNext for updating the read_idx index";
    };
    MethodCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_individual = obj_list->GetData(\"individual\")";
     pre_compile_code_string="cur_individual = obj_list->GetData(\"individual\")";
     result_var=.projects[0].programs.gp[3][0].vars[12]$$;
     obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
     method=DataTable::GetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"individual\"";
       };
      };
     };
     meth_sig="const_Variant GetData(Variant& col)";
     meth_desc=" get data from given column number or name at current read_idx row number -- see ReadItem, ReadNext for updating the read_idx index";
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_individual_id = obj_list->GetData(\"individual_id\")";
     pre_compile_code_string="cur_individual_id = obj_list->GetData(\"individual_id\")";
     result_var=.projects[0].programs.gp[3][0].vars[13]$$;
     obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
     method=DataTable::GetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"individual_id\"";
       };
      };
     };
     meth_sig="const_Variant GetData(Variant& col)";
     meth_desc=" get data from given column number or name at current read_idx row number -- see ReadItem, ReadNext for updating the read_idx index";
    };
    MethodCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_obj_filename = obj_list->GetData(\"filename\")";
     pre_compile_code_string="cur_obj_filename = obj_list->GetData(\"filename\")";
     result_var=.projects[0].programs.gp[3][0].vars[14]$$;
     obj=$.projects[0].programs.gp[3][0].functions[20].args[0]$;
     method=DataTable::GetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"filename\"";
       };
      };
     };
     meth_sig="const_Variant GetData(Variant& col)";
     meth_desc=" get data from given column number or name at current read_idx row number -- see ReadItem, ReadNext for updating the read_idx index";
    };
    If @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (!cur_obj_filename.contains(cur_directory))";
     pre_compile_code_string="if (!cur_obj_filename.contains(cur_directory))";
     cond {
      expr="!cur_obj_filename.contains(cur_directory)";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_obj_filename = cur_directory + \"/\" + cur_obj_filename";
       pre_compile_code_string="cur_obj_filename = cur_directory + \"/\" + cur_obj_filename";
       result_var=$.projects[0].programs.gp[3][0].vars[14]$;
       expr {
	expr="cur_directory + \"/\" + cur_obj_filename";
       };
      };
     };
    };
    MethodCall @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurObject->EnforceRows(1)";
     pre_compile_code_string="CurObject->EnforceRows(1)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[17]$;
     method=DataTable::EnforceRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="n_rows";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="1";
       };
      };
     };
     meth_sig="void EnforceRows(int n_rows)";
     meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
    };
    MethodCall @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurObject->CopyFromRow(0, obj_list, next_idx)";
     pre_compile_code_string="CurObject->CopyFromRow(0, obj_list, next_idx)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][0].vars[17]$;
     method=DataTable::CopyFromRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="dest_row";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[1] {
       arg_type=const_DataTable_ref;
       type="DataTable&";
       name="cp";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="obj_list";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="src_row";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="next_idx";
       };
      };
     };
     meth_sig="void CopyFromRow(int dest_row, DataTable& cp, int src_row)";
     meth_desc=" copy one row from source to given row in this object: source must have exact same column structure as this!!";
    };
    AssignExpr @[12] {
     desc="increment for next time around";
     flags=CAN_REVERT_TO_CODE;
     code_string="next_idx = next_idx + 1";
     pre_compile_code_string="next_idx = next_idx + 1";
     result_var=$.projects[0].programs.gp[3][0].functions[20].args[1]$;
     expr {
      expr="next_idx + 1";
     };
    };
   };
  };
  Function @[21] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetNextItem() returns: int";
   pre_compile_code_string="GetNextItem() returns: int";
   name="GetNextItem";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_1279";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (use_epoch_list)";
     pre_compile_code_string="if (use_epoch_list)";
     cond {
      expr="use_epoch_list";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetNextItem_impl(CurEpochList, next_epoch_idx, epoch_permuted)";
       pre_compile_code_string="GetNextItem_impl(CurEpochList, next_epoch_idx, epoch_permuted)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][0].functions[20]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CurEpochList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_epoch_idx";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="permute";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="epoch_permuted";
	 };
	};
       };
      };
     };
    };
    ElseIf @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (get_train_item)";
     pre_compile_code_string="else if (get_train_item)";
     cond {
      expr="get_train_item";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetNextItem_impl(TrainItemsCurList, next_train_idx, train_permuted)";
       pre_compile_code_string="GetNextItem_impl(TrainItemsCurList, next_train_idx, train_permuted)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[20]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TrainItemsCurList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_train_idx";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="permute";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="train_permuted";
	 };
	};
       };
      };
     };
    };
    Else @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetNextItem_impl(TestItemsCurList, next_test_idx, test_permuted)";
       pre_compile_code_string="GetNextItem_impl(TestItemsCurList, next_test_idx, test_permuted)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][0].functions[20]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable;
	 type="DataTable*";
	 name="obj_list";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="TestItemsCurList";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="next_idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="next_test_idx";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="permute";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="test_permuted";
	 };
	};
       };
      };
     };
    };
   };
  };
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
  AssignExpr @[0] {
   desc="signal to init at start";
   flags=CAN_REVERT_TO_CODE;
   code_string="next_train_idx = -1";
   pre_compile_code_string="next_train_idx = -1";
   result_var=$.projects[0].programs.gp[3][0].vars[6]$;
   expr {
    expr="-1";
   };
  };
  AssignExpr @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="next_test_idx = 0";
   pre_compile_code_string="next_test_idx = 0";
   result_var=$.projects[0].programs.gp[3][0].vars[7]$;
   expr {
    expr="0";
   };
  };
  AssignExpr @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="next_epoch_idx = 0";
   pre_compile_code_string="next_epoch_idx = 0";
   result_var=$.projects[0].programs.gp[3][0].vars[8]$;
   expr {
    expr="0";
   };
  };
  MemberMethodCall @[3] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ObjectMiscData.data.category.BuildHashTable()";
   pre_compile_code_string="ObjectMiscData.data.category.BuildHashTable()";
   obj=.projects[0].programs.gp[3][0].vars[27]$$;
   path="data.category";
   result_var=NULL;
   method=DataCol::BuildHashTable;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
   };
   meth_sig="void BuildHashTable()";
   meth_desc=" build a hash table of column (scalar only) values to speed up finding in large fixed tables -- table is destroyed after any insertion or removal of rows -- it is up to the user to call this when relevant data is all in place -- system cannot track value changes";
  };
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LocalVars (0 vars)";
   pre_compile_code_string="LocalVars (0 vars)";
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  If @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="if (next_train_idx < 0)";
   pre_compile_code_string="if (next_train_idx < 0)";
   cond {
    expr="next_train_idx < 0";
   };
   true_code {
    name="true_code";
    el_typ=ProgCode;
    el_def=0;
    FunctionCall @[0] {
     desc="load and get lists all ready";
     flags=CAN_REVERT_TO_CODE;
     code_string="LoadObjListID(objlist_id)";
     pre_compile_code_string="LoadObjListID(objlist_id)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][0].functions[15]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="objl_id";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="objlist_id";
       };
      };
     };
    };
   };
  };
  FunctionCall @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetNextItem()";
   pre_compile_code_string="GetNextItem()";
   result_var=NULL;
   fun=.projects[0].programs.gp[3][0].functions[21]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
 };
 step_prog=NULL;
 step_n=1;
 doc {
  name="doc";
  desc=;
  web_doc=0;
  wiki=;
  url="local";
  full_url="local";
  text_size=1;
  text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
  html_text="<html>
<head></head>
<body>
<h2> Enter Title Here </h2>
</body>
</html>
";
 };
};

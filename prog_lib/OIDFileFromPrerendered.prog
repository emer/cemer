// ta_Dump File v3.0 -- code v8.0.4.0 rev10285
Program .projects[0].programs[2] { 
 UserDataItem_List @*(.user_data_) {
  UserData_DocLink @[0] { };
 };

 ProgObjList @.objs = [3] {
  DataTable @[0] { 
   DataTableCols @.data = [3] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    bool_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[1] { 
   DataTableCols @.data = [4] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[2] { 
   DataTableCols @.data = [1] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
 };

 ProgType_List @.types = [0] {
 };

 ProgVar_List @.args = [0] {
 };

 ProgVar_List @.vars = [8] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
 };

 Function_List @.functions = [3] {
  Function @[0] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    DataGenCall @[2] { 
     ProgArg_List @.meth_args = [7] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
   };
  };
  Function @[1] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [7] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    ForLoop @[3] { 
     ProgEl_List @.loop_code = [5] {
      AssignExpr @[0] { };
      AssignExpr @[1] { };
      PrintVar @[2] { };
      AssignExpr @[3] { };
      If @[4] { 
       ProgEl_List @.true_code = [14] {
	Comment @[0] { };
	AssignExpr @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [3] {
	  AssignExpr @[0] { };
	  MethodCall @[1] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  MethodCall @[2] { 
	   ProgArg_List @.meth_args = [3] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	   };
	  };
	 };
	};
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[4] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	AssignExpr @[5] { };
	MethodCall @[6] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[7] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[8] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	MethodCall @[9] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	MethodCall @[11] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	MethodCall @[12] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	StopStepPoint @[13] { };
       };
      };
     };
    };
   };
  };
  Function @[2] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      If @[1] { 
       ProgEl_List @.true_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
       };
      };
     };
    };
    Else @[2] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
   };
  };
 };

 ProgEl_List @.init_code = [0] {
 };

 ProgEl_List @.prog_code = [4] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  FunctionCall @[1] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  FunctionCall @[2] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  FunctionCall @[3] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
 };
};
Program .projects[0].programs[2] {
 UserDataItem_List @*(.user_data_) {
  name="UserDataItem_List_201";
  el_typ=UserData_DocLink;
  el_def=0;
  UserData_DocLink @[0] {
   name="DocLink";
   doc=.projects[0].programs[2].doc$$;
  };
 };
 name="OIDFileFromPrerendered";
 short_nm="DFFrPr";
 tags=;
 desc="Takes a directory of image files with names having the form category_001_00004.png where 001, 002, etc is the exemplar number and 00001, 00002, etc. is the render of the exemplar";
 version {
  major=0;
  minor=0;
  step=0;
 };
 author="rohrlich";
 email="john.rohrlich@colorado.edu";
 flags=NO_STOP_STEP;
 stop_step_cond {
  expr=;
 };
 objs {
  name="objs";
  el_typ=DataTable;
  el_def=0;
  DataTable @[0] {
   name="ImageFiles";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2595326;
       val_type_fixed=0;
      };
     };
     name="FileName";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=16;
     matrix_col_width=10;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.4391144;
       val_type_fixed=0;
      };
     };
     name="FilePath";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{      };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=75;
     matrix_col_width=10;
    };
    bool_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_145";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1488315;
       val_type_fixed=0;
      };
     };
     name="Include";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=7;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=75;
   keygen 4 0=0;
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[1] {
   name="ImageData";
   desc="oia data for use in simulation";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2042553;
       val_type_fixed=0;
      };
     };
     name="category";
     desc="basic level category";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=16;
     matrix_col_width=10;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2042553;
       val_type_fixed=0;
      };
     };
     name="individual";
     desc="label for single individual unique object";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr="filename.before(\"_\",-1).after(\"_\",-1)";
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=16;
     matrix_col_width=10;
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2042553;
       val_type_fixed=0;
      };
     };
     name="ctrlflags";
     desc="special control flag information to determine how this image is processed: TEST means only use for testing";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr="\"\"";
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=16;
     matrix_col_width=10;
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.3310638;
       val_type_fixed=0;
      };
     };
     name="filename";
     col_flags=SAVE_DATA;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=70;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=70;
   keygen 4 0=0;
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[2] {
   name="Categories";
   desc="All categories";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItemBase;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2042553;
       val_type_fixed=0;
      };
     };
     name="Category";
     desc="basic level category";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=16;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=50;
   keygen 4 0=0;
   last_sort_spec {
    name="DataSortSpec_70";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
   control_panel_cells {
    name="DataTableCell_List_68";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="image_files";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs[2].objs[0]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[1] {
   name="image_dir";
   var_type=T_String;
   string_val=;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="note - don't add '/' to end of path";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="file_filter";
   var_type=T_String;
   string_val="png";
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[3] {
   name="image_data";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs[2].objs[1]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[4] {
   name="filepath";
   var_type=T_String;
   string_val="/Users/rohrlich/Desktop/GenOID_Test/autogun_001_00010.png";
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="use column name";
   init_from=NULL;
  };
  ProgVar @[5] {
   name="filename";
   var_type=T_String;
   string_val="autogun_001_00010.png";
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="use column name";
   init_from=NULL;
  };
  ProgVar @[6] {
   name="categories";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs[2].objs[2]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[7] {
   name="save_to_dir";
   var_type=T_String;
   string_val=;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="where to save the images - default is the image directory";
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
  Function @[0] {
   desc=;
   flags=0;
   code_string=;
   name="GetFileNamesAndPaths";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_229";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string=;
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="image_files.RemoveAllRows()";
     result_var=NULL;
     obj=.projects[0].programs[2].vars[0]$$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
    DataGenCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taDataGen::GetDirFiles(Objects, obj_file_path, obj_file_filter, true, , , )";
     result_var=NULL;
     object_type=taDataGen;
     method=taDataGen::GetDirFiles;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dest";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="image_files";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="dir_path";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="image_dir";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="filter";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="file_filter";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="recursive";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[4] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname_col_nm";
       required=0;
       def_val="FileName";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=const_taString_ref;
       type="taString&";
       name="path_col_nm";
       required=0;
       def_val="FilePath";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=bool;
       type="bool";
       name="reset_first";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Objects->InitVals(true, \"Include\")";
     result_var=NULL;
     obj=$.projects[0].programs[2].vars[0]$;
     method=DataTable::InitVals;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="init_val";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"Include\"";
       };
      };
     };
     meth_sig="bool InitVals(Variant& init_val, Variant& col)";
     meth_desc=" initialize all values in given column to given value -- column can be specified as either integer index or a string that is then used to find the given column name";
    };
   };
  };
  Function @[1] {
   desc=;
   flags=0;
   code_string=;
   name="GenOIDTable";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_230";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string=;
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="category";
       var_type=T_String;
       string_val="airplane";
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc="current object category";
       init_from=NULL;
      };
      ProgVar @[1] {
       name="last_category";
       var_type=T_String;
       string_val=;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="individual";
       var_type=T_String;
       string_val="010";
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc="current object individual label";
       init_from=NULL;
      };
      ProgVar @[3] {
       name="cur_filename";
       var_type=T_String;
       string_val="blade_016_00006.png";
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc="current filename";
       init_from=NULL;
      };
      ProgVar @[4] {
       name="ctrl_flags";
       var_type=T_String;
       string_val=;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc="control flags - likely not used with prerendered images";
       init_from=NULL;
      };
      ProgVar @[5] {
       name="include";
       var_type=T_Bool;
       bool_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="row";
       var_type=T_Int;
       int_val=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="image_data.RemoveAllRows()";
     result_var=NULL;
     obj=.projects[0].programs[2].vars[3]$$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="categories->RemoveAllRows()";
     result_var=NULL;
     obj=.projects[0].programs[2].vars[6]$$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
    ForLoop @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<image_data.rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="filepath = image_data[\"FilePath\"][i]";
       result_var=.projects[0].programs[2].vars[4]$$;
       expr {
	expr="image_files[\"FilePath\"][row]";
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="filename = image_data[\"FileName\"][row]";
       result_var=.projects[0].programs[2].vars[5]$$;
       expr {
	expr="image_files[\"FileName\"][row]";
       };
      };
      PrintVar @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="printvar filename";
       message=;
       print_var=$.projects[0].programs[2].vars[5]$;
       print_var2=NULL;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=0;
      };
      AssignExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="filename = image_data[\"FileName\"][row]";
       result_var=.projects[0].programs[2].functions[1].fun_code[0].local_vars[5]$$;
       expr {
	expr="image_files[\"Include\"][row]";
       };
      };
      If @[4] {
       desc="all files included by default but there is a boolean column called \"Include\" so you can create an OID file of a subset";
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!Include)";
       cond {
	expr="include";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	Comment @[0] {
	 desc="the next several lines of code can be modified to work with your filename convention";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="//";
	};
	AssignExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="category = FileName.before(\"_\")";
	 result_var=.projects[0].programs[2].functions[1].fun_code[0].local_vars[0]$$;
	 expr {
	  expr="filename.before(\"_\")";
	 };
	};
	If @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (category != last_category)";
	 cond {
	  expr="category != last_category";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="last_category = category";
	   result_var=.projects[0].programs[2].functions[1].fun_code[0].local_vars[1]$$;
	   expr {
	    expr="category";
	   };
	  };
	  MethodCall @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="categories->AddBlankRow()";
	   result_var=NULL;
	   obj=$.projects[0].programs[2].vars[6]$;
	   method=DataTable::AddBlankRow;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="int AddBlankRow()";
	   meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	  };
	  MethodCall @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="categories->setval()";
	   result_var=NULL;
	   obj=$.projects[0].programs[2].vars[6]$;
	   method=DataTable::SetVal;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="val";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="category";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_Variant_ref;
	     type="Variant&";
	     name="col";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"Category\"";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=int;
	     type="int";
	     name="row";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
	   meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
	  };
	 };
	};
	MethodCall @[3] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="individual = FileName.before(\"_\",-1).after(\"_\")";
	 result_var=.projects[0].programs[2].functions[1].fun_code[0].local_vars[2]$$;
	 obj=$.projects[0].programs[2].vars[5]$;
	 method=taString::before;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"_\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr="-1";
	   };
	  };
	 };
	 meth_sig="taString before(taString& x, int startpos = 0)";
	 meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	};
	MethodCall @[4] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="individual = individual.after(\"_\")";
	 result_var=$.projects[0].programs[2].functions[1].fun_code[0].local_vars[2]$;
	 obj=$.projects[0].programs[2].functions[1].fun_code[0].local_vars[2]$;
	 method=taString::after;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"_\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString after(taString& x, int startpos = 0)";
	 meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	};
	AssignExpr @[5] {
	 desc="must have globally-unique individual in case of later reconfiguration etc";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="individual = taMisc::LeadingZeros(obj_index,5)";
	 result_var=$.projects[0].programs[2].functions[1].fun_code[0].local_vars[2]$;
	 expr {
	  expr="taMisc::LeadingZeros(individual,5)";
	 };
	};
	MethodCall @[6] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="temp = FilePath.after(obj_file_path)";
	 result_var=.projects[0].programs[2].functions[1].fun_code[0].local_vars[3]$$;
	 obj=$.projects[0].programs[2].vars[4]$;
	 method=taString::after;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="image_dir";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString after(taString& x, int startpos = 0)";
	 meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	};
	MethodCall @[7] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="filename = filename->after('/')";
	 result_var=$.projects[0].programs[2].functions[1].fun_code[0].local_vars[3]$;
	 obj=$.projects[0].programs[2].functions[1].fun_code[0].local_vars[3]$;
	 method=taString::after;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"/\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr="0";
	   };
	  };
	 };
	 meth_sig="taString after(taString& x, int startpos = 0)";
	 meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	};
	MethodCall @[8] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="image_data->AddBlankRow()";
	 result_var=NULL;
	 obj=$.projects[0].programs[2].vars[3]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	MethodCall @[9] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="image_data->SetVal()";
	 result_var=NULL;
	 obj=$.projects[0].programs[2].vars[3]$;
	 method=DataTable::SetVal;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="category";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="col";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"category\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="row";
	   };
	  };
	 };
	 meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
	 meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
	};
	MethodCall @[10] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="image_data->SetVal()";
	 result_var=NULL;
	 obj=$.projects[0].programs[2].vars[3]$;
	 method=DataTable::SetVal;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="cur_filename";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="col";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"filename\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="row";
	   };
	  };
	 };
	 meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
	 meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
	};
	MethodCall @[11] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="image_data->SetVal()";
	 result_var=NULL;
	 obj=$.projects[0].programs[2].vars[3]$;
	 method=DataTable::SetVal;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="individual";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="col";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"individual\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="row";
	   };
	  };
	 };
	 meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
	 meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
	};
	MethodCall @[12] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="image_data->SetVal()";
	 result_var=NULL;
	 obj=$.projects[0].programs[2].vars[3]$;
	 method=DataTable::SetVal;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="val";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="ctrl_flags";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_Variant_ref;
	   type="Variant&";
	   name="col";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"ctrlflags\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="row";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="row";
	   };
	  };
	 };
	 meth_sig="bool SetVal(Variant& val, Variant& col, int row)";
	 meth_desc=" set data of scalar type, in Variant form (any data type, use for Programs), for given column, row -- column can be specified as either integer index or a string that is then used to find the given column name; returns 'true' if valid access and set is successful";
	};
	StopStepPoint @[13] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Stop_Step Point";
	 cond {
	  expr=;
	 };
	};
       };
      };
     };
     init {
      expr="row=0";
     };
     test {
      expr="row<image_files.rows";
     };
     iter {
      expr="row++";
     };
    };
   };
  };
  Function @[2] {
   desc=;
   flags=0;
   code_string=;
   name="WriteOIDFile";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_236";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=0;
     code_string=;
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (save_to_dir.nonempty())";
     cond {
      expr="save_to_dir.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="save_to_dir = save_to_dir.trimr()";
       result_var=.projects[0].programs[2].vars[7]$$;
       obj=$.projects[0].programs[2].vars[7]$;
       method=taString::trimr;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="taString_ref trimr()";
       meth_desc=" trims trailing spaces (NOTE: modifies this string, and also returns the resulting string value)";
      };
      If @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (save_to_dir.lastchar() == '/')";
       cond {
	expr="save_to_dir.lastchar() == '/'";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="save_to_dir = save_to_dir.before('/', -1)";
	 result_var=$.projects[0].programs[2].vars[7]$;
	 obj=$.projects[0].programs[2].vars[7]$;
	 method=taString::before;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="'/'";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr="-1";
	   };
	  };
	 };
	 meth_sig="taString before(taString& x, int startpos = 0)";
	 meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	};
       };
      };
     };
    };
    Else @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else(save_to_dir.empty())";
     cond {
      expr=;
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="save_to_dir = \".\"";
       result_var=$.projects[0].programs[2].vars[7]$;
       expr {
	expr="image_dir";
       };
      };
     };
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ObjectImageData->SaveData(save_image_path + \"/ObjectImageData.dat\", DataTable::TAB, true, true)";
     result_var=NULL;
     obj=$.projects[0].programs[2].vars[3]$;
     method=DataTable::SaveData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="fname";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="save_to_dir + \"/\" + \"OID_data_\" + String(categories.rows) + \".dat\"";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable::Delimiters;
       type="DataTable::Delimiters";
       name="delim";
       required=0;
       def_val="DataTable::TAB";
       prev_expr=;
       expr {
	expr="DataTable::TAB";
       };
      };
      ProgArg @[2] {
       arg_type=bool;
       type="bool";
       name="quote_str";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="save_headers";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="void SaveData(taString& fname, DataTable::Delimiters delim = TAB, bool quote_str = true, bool save_headers = true)";
     meth_desc=" saves data, one line per rec, with delimiter between columns, and optionally quoting strings; if save_headers then the _H: header line is saved and data lines have _D:, else they are bare";
    };
   };
  };
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=0;
   code_string=;
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  FunctionCall @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetFileNamesAndPaths()";
   result_var=NULL;
   fun=.projects[0].programs[2].functions[0]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  FunctionCall @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GenOIDTable()";
   result_var=NULL;
   fun=.projects[0].programs[2].functions[1]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  FunctionCall @[3] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="WriteOIDFile()";
   result_var=NULL;
   fun=.projects[0].programs[2].functions[2]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
 };
 step_prog=.projects[0].programs[2]$$;
 step_n=1;
 doc {
  name="doc";
  desc=;
  web_doc=0;
  wiki=;
  url="local";
  full_url="local";
  text_size=1;
  text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
  html_text="<html>
<head></head>
<body>
<h2> Enter Title Here </h2>
</body>
</html>
";
 };
};

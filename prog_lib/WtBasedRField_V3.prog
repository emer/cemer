// ta_Dump File v3.0 -- code v8.1.1.0 rev10912
Program .projects[0].programs.gp[2][17] { 
 UserDataItem_List @*(.user_data_) {
  UserDataItem @[0] { };
  UserData_DocLink @[1] { };
 };

 ProgObjList @.objs = [5] {
  DataTable @[0] { 
   DataTableCols @.data = [1] {
    float_Data @[0] { };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };
  };
  WtBasedRF @[1] { };
  DataTable @[2] { 
   DataTableCols @.data = [1] {
    float_Data @[0] { };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };
  };
  DataTable @[3] { 
   UserDataItem_List @*(.user_data_) {
    UserDataItem @[0] { };
   };

   DataTableCols @.data = [1] {
    float_Data @[0] { };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };
  };
  DataTable @[4] { 
   DataTableCols @.data = [5] {
    String_Data @[0] { };
    float_Data @[1] { };
    float_Data @[2] { };
    float_Data @[3] { };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };
  };
 };

 ProgVar_List @.objs_vars = [5] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
 };

 ProgType_List @.types = [0] {
 };

 ProgVar_List @.args = [0] {
 };

 ProgVar_List @.vars = [10] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
  ProgVar @[8] { };
  ProgVar @[9] { };
 };

 Function_List @.functions = [4] {
  Function @[0] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [7] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    Comment @[1] { };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    Comment @[3] { };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[6] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
   };
  };
  Function @[1] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [11] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [13] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
      ProgVar @[10] { };
      ProgVar @[11] { };
      ProgVar @[12] { };
     };
    };
    AssignExpr @[1] { };
    AssignExpr @[2] { };
    AssignExpr @[3] { };
    AssignExpr @[4] { };
    AssignExpr @[5] { };
    PrintVar @[6] { };
    If @[7] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    If @[9] { 
     ProgEl_List @.true_code = [7] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[2] { };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      BlankLineEl @[4] { };
      Comment @[5] { };
      ForLoop @[6] { 
       ProgEl_List @.loop_code = [1] {
	ForLoop @[0] { 
	 ProgEl_List @.loop_code = [1] {
	  ForLoop @[0] { 
	   ProgEl_List @.loop_code = [1] {
	    ForLoop @[0] { 
	     ProgEl_List @.loop_code = [5] {
	      AssignExpr @[0] { };
	      MethodCall @[1] { 
	       ProgArg_List @.meth_args = [3] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
	       };
	      };
	      MethodCall @[2] { 
	       ProgArg_List @.meth_args = [3] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
	       };
	      };
	      AssignExpr @[3] { };
	      MethodCall @[4] { 
	       ProgArg_List @.meth_args = [4] {
		ProgArg @[0] { };
		ProgArg @[1] { };
		ProgArg @[2] { };
		ProgArg @[3] { };
	       };
	      };
	     };
	    };
	   };
	  };
	 };
	};
       };
      };
     };
    };
    Else @[10] { 
     ProgEl_List @.true_code = [1] {
      PrintExpr @[0] { };
     };
    };
   };
  };
  Function @[2] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [8] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    AssignExpr @[4] { };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    If @[6] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
     };
    };
    ForLoop @[7] { 
     ProgEl_List @.loop_code = [12] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MemberMethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      PrintVar @[3] { };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[5] { 
       ProgArg_List @.meth_args = [0] {
       };
      };
      MethodCall @[6] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[7] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[8] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      MethodCall @[9] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[10] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[11] { 
       ProgArg_List @.meth_args = [5] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
       };
      };
     };
    };
   };
  };
  Function @[3] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
   };
  };
 };

 ProgEl_List @.init_code = [1] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
 };

 ProgEl_List @.prog_code = [10] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  FunctionCall @[1] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  MethodCall @[2] { 
   ProgArg_List @.meth_args = [1] {
    ProgArg @[0] { };
   };
  };
  PrintVar @[3] { };
  Comment @[4] { };
  If @[5] { 
   ProgEl_List @.true_code = [1] {
    AssignExpr @[0] { };
   };
  };
  ElseIf @[6] { 
   ProgEl_List @.true_code = [1] {
    AssignExpr @[0] { };
   };
  };
  MethodCall @[7] { 
   ProgArg_List @.meth_args = [7] {
    ProgArg @[0] { };
    ProgArg @[1] { };
    ProgArg @[2] { };
    ProgArg @[3] { };
    ProgArg @[4] { };
    ProgArg @[5] { };
    ProgArg @[6] { };
   };
  };
  FunctionCall @[8] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  FunctionCall @[9] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
 };
};
Program .projects[0].programs.gp[2][17] {
 UserDataItem_List @*(.user_data_) {
  name=;
  el_typ=UserData_DocLink;
  el_def=0;
  UserDataItem @[0] {name="user_pinned": value=1: val_type_fixed=0: };
  UserData_DocLink @[1] {name="DocLink": doc=.doc$$: };
 };
 name="WtBasedRField_V3";
 short_nm="WBsRFl";
 tags="Statistic, Receptive Field";
 desc="Computes a weight based receptive field (RF) using WtBasedRF object type -- The calculation is based on V3 or V4 wts that are developed during training in combination with the RF data previously generated for layer V2 (see the program WtBasedRField_V2)";
 version {
  major=0;
  minor=0;
  step=0;
 };
 author="John Rohrlich";
 email="john.rohrlich@colorado.edu";
 flags=0;
 stop_step_cond {
  expr=;
 };
 objs {
  name="objs";
  el_typ=ActBasedRF;
  el_def=0;
  DataTable @[0] {
   name="WtRFData";
   desc="receptive field data -- could move this into AnalysisData if you want..";
   data {
    name="data";
    el_typ=float_Data;
    el_def=0;
    float_Data @[0] {
     name="values";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=1;
     cell_geom{ 128;128;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [2] ;;     };
     width=128;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=128;
   keygen 4 0=0;
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
  };
  WtBasedRF @[1] {
   name="WtBasedRF_Analysis";
   network=.networks["LVisNet"]$$<LeabraNetwork,LVisNet>;
   trg_layer=.networks["LVisNet"].layers.gp["V4"]["V4F16"]$$<LeabraLayer,V4F16>;
   snd_layer=.networks["LVisNet"].layers.gp["V2"]["V2mF16"]$$<LeabraLayer,V2mF16>;
   dt_trg_rf=.objs[0]$$;
   dt_snd_rf=.programs.gp["AnalysisProgs"]["WtBasedRField_V2"].objs["WtRFData"]$$<DataTable,WtRFData>;
   trg_wt_threshold=0;
  };
  DataTable @[2] {
   name="trg_layer_wts";
   desc=;
   data {
    name="data";
    el_typ=float_Data;
    el_def=0;
    float_Data @[0] {
     name="V2mF16";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=1;
     cell_geom{ 80;80;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [2] ;;     };
     width=80;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=80;
   keygen 4 0=0;
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
  };
  DataTable @[3] {
   UserDataItem_List @*(.user_data_) {
    name="UserDataItem_List_271";
    el_typ=UserDataItem;
    el_def=0;
    UserDataItem @[0] {name="user_pinned": value=0: val_type_fixed=0: };
   };
   name="TrgLayerActivations";
   desc=;
   data {
    name="data";
    el_typ=float_Data;
    el_def=0;
    float_Data @[0] {
     name="V4F16_act_m";
     col_flags=MARK|PIN|SAVE_DATA|AUTO_WIDTH;
     is_matrix=1;
     cell_geom{ 10;10;4;4;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [4] ;;;;     };
     width=11;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=50;
   keygen 4 0=0;
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
  };
  DataTable @[4] {
   name="SampleUnits";
   desc="receptive field data -- could move this into AnalysisData if you want..";
   data {
    name="data";
    el_typ=float_Data;
    el_def=0;
    String_Data @[0] {
     name="image_name";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=16;
     matrix_col_width=10;
    };
    float_Data @[1] {
     name="image";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=1;
     cell_geom{ 128;128;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [2] ;;     };
     width=144;
     matrix_col_width=10;
    };
    float_Data @[2] {
     name="values_x_act";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=1;
     cell_geom{ 128;128;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [2] ;;     };
     width=128;
     matrix_col_width=10;
    };
    float_Data @[3] {
     name="activation";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=10;
     matrix_col_width=10;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_1";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {name="NARROW": value=1: val_type_fixed=0: };
     };
     name="unit_idx_flat";
     col_flags=SAVE_DATA|AUTO_WIDTH;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=13;
     matrix_col_width=10;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   row_height=1;
   max_col_width=144;
   keygen 4 0=0;
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   row_with_hilite=-1;
  };
 };
 objs_vars {
  name="objs_vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="wt_rfdata";
   var_type=T_Object;
   object_type=DataTable;
   object_val=$.objs[0]$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="data table to record weight based receptive field values - the columns and rows will be generated by the underlying code";
   init_from=NULL;
  };
  ProgVar @[1] {
   name="wt_based_rf_analysis";
   var_type=T_Object;
   object_type=WtBasedRF;
   object_val=.objs[1]$$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="This is the object on which to call the compute method";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="trg_layer_wts";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.objs[2]$$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="these are the weights for each projection to each unit of the target layer";
   init_from=NULL;
  };
  ProgVar @[3] {
   name="trg_layer_activations";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.objs[3]$$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[4] {
   name="sample_units";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.objs[4]$$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="network";
   var_type=T_Object;
   object_type=Network;
   object_val=$.networks["LVisNet"]$;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[1] {
   name="trg_layer";
   var_type=T_Object;
   object_type=Layer;
   object_val=$.networks["LVisNet"].layers.gp["V4"]["V4F16"]$;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="target layer to get receptive field data - will usually be V3 or V4 and must be receiving from a layer for which the RF Data has already been generated.";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="snd_layer";
   var_type=T_Object;
   object_type=Layer;
   object_val=$.networks["LVisNet"].layers.gp["V2"]["V2mF16"]$;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="the layer sending to target layer - for this analysis the sending layer must have been a previous target layer as you must have the RF Data for the sending layer";
   init_from=NULL;
  };
  ProgVar @[3] {
   name="snd_rf_data";
   var_type=T_Object;
   object_type=DataTable;
   object_val=$.programs.gp["AnalysisProgs"]["WtBasedRField_V2"].objs["WtRFData"]$;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="This is the RF Data previously generated for the sending layer (when it was a target layer)";
   init_from=NULL;
  };
  ProgVar @[4] {
   name="activation_var";
   var_type=T_String;
   object_scope=NULL;
   flags=USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[5] {
   name="max_act";
   var_type=T_Real;
   real_val=0.6130033731460571;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[6] {
   name="sample_size";
   var_type=T_Int;
   int_val=20;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[7] {
   name="image_filename";
   var_type=T_String;
   string_val="images/CU3D_100_plus_renders/autogun_001_00001.png";
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[8] {
   name="v1_fovea_region_data";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.programs.gp["EnviroProgs"]["ApplyInputsImage"].objs["V1FoveaRegionData"]$$<DataTable,V1FoveaRegionData>;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[9] {
   name="objects_env";
   var_type=T_Object;
   object_type=Program;
   object_val=.programs.gp["EnviroProgs"]["ObjectsEnv"]$$<Program,ObjectsEnv>;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
  Function @[0] {
   name="ResetTables";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ResetTables() returns: int";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="fun_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars0vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    Comment @[1] {
     name="Comment_activationsdiffe_eresetthecolumn";
     desc="activations different for every image - reset the column";
     flags=CAN_REVERT_TO_CODE|NO_CODE;
     code_string="// activations different for every image - reset the column";
    };
    If @[2] {
     name="If_ifwtrfdataFindColNamevaluesxact";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (wt_rfdata->FindColName(\"values_x_act\"))";
     cond {
      expr="wt_rfdata->FindColName(\"values_x_act\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_wtrfdataRemoveColvaluesxact";
       desc="this column should be recalculated for each image";
       flags=CAN_REVERT_TO_CODE;
       code_string="wt_rfdata->RemoveCol(\"values_x_act\")";
       result_var=NULL;
       obj=.objs_vars[0]$$;
       method=DataTable::RemoveCol;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"values_x_act\"";
	 };
	};
       };
       meth_sig="void RemoveCol(Variant& col)";
       meth_desc=" removes indicated column";
      };
     };
    };
    Comment @[3] {
     name="Comment_alwaysrecreateth_aluesxactcolumn";
     desc="always recreate the values_x_act column";
     flags=CAN_REVERT_TO_CODE|NO_CODE;
     code_string="// always recreate the values_x_act column";
    };
    MethodCall @[4] {
     name="MethodCall_wtrfdataDuplicateColvalues";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="wt_rfdata->DuplicateCol(\"values\")";
     result_var=NULL;
     obj=$.objs_vars[0]$;
     method=DataTable::DuplicateCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"values\"";
       };
      };
     };
     meth_sig="void DuplicateCol(Variant& col)";
     meth_desc=" duplicates indicated column";
    };
    MethodCall @[5] {
     name="MethodCall_wtrfdataRenameCo_scopyvaluesxact";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="wt_rfdata->RenameCol(\"values_copy\", \"values_x_act\")";
     result_var=NULL;
     obj=$.objs_vars[0]$;
     method=DataTable::RenameCol;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="cur_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"values_copy\"";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="new_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"values_x_act\"";
       };
      };
     };
     meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
     meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
    };
    MethodCall @[6] {
     name="MethodCall_trglayeractivationsResetData";
     desc="these values get reset for each image";
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer_activations->ResetData()";
     result_var=NULL;
     obj=.objs_vars[3]$$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
   };
  };
  Function @[1] {
   name="MultiplyWithActivations";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="MultiplyWithActivations() returns: int";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="fun_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars13vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (13 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="act";
       var_type=T_Real;
       real_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="grp_row";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="grp_col";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="unit_row";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="unit_col";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="flat_index";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="grp_rows";
       var_type=T_Int;
       int_val=4;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="grp_cols";
       var_type=T_Int;
       int_val=4;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="unit_rows";
       var_type=T_Int;
       int_val=14;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="unit_cols";
       var_type=T_Int;
       int_val=14;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[10] {
       name="wt_rf_cell_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[11] {
       name="trg_layer_acts_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[12] {
       name="values_x_act_data_col";
       var_type=T_Object;
       object_type=float_Data;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     name="AssignExpr_wtrfcellmatrixnewfloatMatrix";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="wt_rf_cell_matrix = new float_Matrix";
     result_var=.functions[1].fun_code[0].local_vars[10]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    AssignExpr @[2] {
     name="AssignExpr_grprowstrglayergpgeomy";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="grp_rows = trg_layer.gp_geom.y";
     result_var=.functions[1].fun_code[0].local_vars[6]$$;
     expr {
      expr="trg_layer.gp_geom.y";
     };
    };
    AssignExpr @[3] {
     name="AssignExpr_grpcolstrglayergpgeomx";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="grp_cols = trg_layer.gp_geom.x";
     result_var=.functions[1].fun_code[0].local_vars[7]$$;
     expr {
      expr="trg_layer.gp_geom.x";
     };
    };
    AssignExpr @[4] {
     name="AssignExpr_unitrowstrglayerungeomy";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="unit_rows = trg_layer.un_geom.y";
     result_var=.functions[1].fun_code[0].local_vars[8]$$;
     expr {
      expr="trg_layer.un_geom.y";
     };
    };
    AssignExpr @[5] {
     name="AssignExpr_unitcolstrglayerungeomx";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="unit_cols = trg_layer.un_geom.x";
     result_var=.functions[1].fun_code[0].local_vars[9]$$;
     expr {
      expr="trg_layer.un_geom.x";
     };
    };
    PrintVar @[6] {
     name="PrintVar_Printgrprowsunitrows";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  grp_rows unit_rows";
     message=;
     print_var=$.functions[1].fun_code[0].local_vars[6]$;
     print_var2=$.functions[1].fun_code[0].local_vars[8]$;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
    If @[7] {
     name="If_ifwtrfdataFindColNamevaluesxact";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (!wt_rfdata->FindColName(\"values_x_act\"))";
     cond {
      expr="!wt_rfdata->FindColName(\"values_x_act\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_wtrfdataDuplicateColvalues";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="wt_rfdata->DuplicateCol(\"values\")";
       result_var=NULL;
       obj=$.objs_vars[0]$;
       method=DataTable::DuplicateCol;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"values\"";
	 };
	};
       };
       meth_sig="void DuplicateCol(Variant& col)";
       meth_desc=" duplicates indicated column";
      };
      MethodCall @[1] {
       name="MethodCall_wtrfdataRenameCo_scopyvaluesxact";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="wt_rfdata->RenameCol(\"values_copy\", \"values_x_act\")";
       result_var=NULL;
       obj=$.objs_vars[0]$;
       method=DataTable::RenameCol;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="cur_nm";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"values_copy\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="new_nm";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"values_x_act\"";
	 };
	};
       };
       meth_sig="bool RenameCol(taString& cur_nm, taString& new_nm)";
       meth_desc=" rename column with current name cur_nm to new name new_nm (returns false if ccur_nm not found)";
      };
     };
    };
    MethodCall @[8] {
     name="MethodCall_valuesxactdataco_lNamevaluesxact";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="values_x_act_data_col = wt_rfdata->FindColName(\"values_x_act\", )";
     result_var=.functions[1].fun_code[0].local_vars[12]$$;
     obj=$.objs_vars[0]$;
     method=DataTable::FindColName;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="col_nm";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"values_x_act\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="err_msg";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="DataCol_ptr FindColName(taString& col_nm, bool err_msg = false)";
     meth_desc=" find a column of the given name; if err_msg then generate an error if not found";
    };
    If @[9] {
     name="If_ifvaluesxactdatacol";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (values_x_act_data_col)";
     cond {
      expr="values_x_act_data_col";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_valuesxactdatacolInitVals0";
       desc="this column gets reset for each image";
       flags=CAN_REVERT_TO_CODE;
       code_string="values_x_act_data_col->InitVals(0, , )";
       result_var=NULL;
       obj=$.functions[1].fun_code[0].local_vars[12]$;
       method=DataCol::InitVals;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="init_val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="n_rows";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool InitVals(Variant& init_val, int st_row = 0, int n_rows = -1)";
       meth_desc=" initialize all values in this column to given value -- for rows as specified by starting row, and n_rows = -1 means to the end";
      };
      MethodCall @[1] {
       name="MethodCall_trglayerVarToTab_nsactivationvar";
       desc="get data to table";
       flags=CAN_REVERT_TO_CODE;
       code_string="trg_layer->VarToTable(trg_layer_activations, activation_var)";
       result_var=NULL;
       obj=.vars[1]$$;
       method=Layer::VarToTable;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=DataTable_ptr;
	 type="DataTable*";
	 name="dt";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="trg_layer_activations";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="variable";
	 required=1;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="activation_var";
	 };
	};
       };
       meth_sig="DataTable_ptr VarToTable(DataTable* dt, taString& variable)";
       meth_desc=" send given variable to data table -- number of columns depends on variable (for projection variables, specify prjns.; for connection variables, specify r. or s. (e.g., r.wt)) -- this uses a NetMonitor internally, so see documentation there for more information";
      };
      AssignExpr @[2] {
       name="AssignExpr_trglayeractsmatrixnewfloatMatrix";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="trg_layer_acts_matrix = new float_Matrix";
       result_var=.functions[1].fun_code[0].local_vars[11]$$;
       expr {
	expr="new float_Matrix";
       };
      };
      MethodCall @[3] {
       name="MethodCall_trglayeractsmatr_etValAsMatrix00";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="trg_layer_acts_matrix = trg_layer_activations->GetValAsMatrix(0, 0)";
       result_var=$.functions[1].fun_code[0].local_vars[11]$;
       obj=$.objs_vars[3]$;
       method=DataTable::GetValAsMatrix;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
       };
       meth_sig="taMatrix_ptr GetValAsMatrix(Variant& col, int row)";
       meth_desc=" get data of matrix type (multi-dimensional data within a given cell), in Matrix form, for given column, row; for Program usage, assign to a LocalVars Matrix* variable, NOT a global vars variable, at the appropriate scope where the matrix will be used, (e.g., if within a loop, put variable in the loop_code of the loop), so that the local variable will be deleted automatically, to free the memory associated with the Matrix when it is no longer needed";
      };
      BlankLineEl @[4] {
       name="BlankLineEl_";
       desc=;
       flags=CAN_REVERT_TO_CODE|NO_CODE;
       code_string=" ";
      };
      Comment @[5] {
       name="Comment_multiplyeveryV2u_dthistotheCcode";
       desc="multiply every V2 unit weight x filter x V1_activation by the current V2 activation - should add this to the C++ code";
       flags=CAN_REVERT_TO_CODE|NO_CODE;
       code_string="// multiply every V2 unit weight x filter x V1_activation by the current V2 activation - should add this to the C++ code";
      };
      ForLoop @[6] {
       name="ForLoop_forgrprow0grprowgrprowsgrprow";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (grp_row = 0; grp_row < grp_rows; grp_row++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	ForLoop @[0] {
	 name="ForLoop_forgrpcol0grpcolgrpcolsgrpcol";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (grp_col = 0; grp_col < grp_cols; grp_col++)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ForLoop @[0] {
	   name="ForLoop_forunitrow0unitr_unitrowsunitrow";
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="for (unit_row = 0; unit_row<unit_rows; unit_row++)";
	   loop_code {
	    name="loop_code";
	    el_typ=ProgCode;
	    el_def=0;
	    ForLoop @[0] {
	     name="ForLoop_forunitcol0unitc_unitcolsunitcol";
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="for (unit_col = 0; unit_col<unit_cols; unit_col++)";
	     loop_code {
	      name="loop_code";
	      el_typ=ProgCode;
	      el_def=0;
	      AssignExpr @[0] {
	       name="AssignExpr_flatindexunitcol_nitrowsunitcols";
	       desc=;
	       flags=CAN_REVERT_TO_CODE;
	       code_string="flat_index = unit_col + unit_row*unit_cols + grp_col*unit_rows*unit_cols + grp_row*grp_cols*unit_rows*unit_cols";
	       result_var=.functions[1].fun_code[0].local_vars[5]$$;
	       expr {
		expr="unit_col + unit_row*unit_cols + grp_col*unit_rows*unit_cols + grp_row*grp_cols*unit_rows*unit_cols";
	       };
	      };
	      MethodCall @[1] {
	       name="MethodCall_wtrfcellmatrixwt_valuesflatindex";
	       desc=;
	       flags=CAN_REVERT_TO_CODE;
	       code_string="wt_rf_cell_matrix = wt_rfdata->GetValAsMatrixColName(\"values\", flat_index, )";
	       result_var=$.functions[1].fun_code[0].local_vars[10]$;
	       obj=$.objs_vars[0]$;
	       method=DataTable::GetValAsMatrixColName;
	       meth_args {
		name="meth_args";
		el_typ=ProgArg;
		el_def=0;
		ProgArg @[0] {
		 arg_type=const_taString_ref;
		 type="taString&";
		 name="col_name";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="\"values\"";
		 };
		};
		ProgArg @[1] {
		 arg_type=int;
		 type="int";
		 name="row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="flat_index";
		 };
		};
		ProgArg @[2] {
		 arg_type=bool;
		 type="bool";
		 name="quiet";
		 required=0;
		 def_val="false";
		 prev_expr=;
		 expr {
		  expr=;
		 };
		};
	       };
	       meth_sig="taMatrix_ptr GetValAsMatrixColName(taString& col_name, int row, bool quiet = false)";
	       meth_desc=" get data of matrix type (multi-dimensional data within a given cell), in Matrix form, for given column, row; for Program usage, assign to a LocalVars Matrix* variable, NOT a global vars variable, at the appropriate scope where the matrix will be used, (e.g., if within a loop, put variable in the loop_code of the loop), so that the local variable will be deleted automatically, to free the memory associated with the Matrix when it is no longer needed";
	      };
	      MethodCall @[2] {
	       name="MethodCall_acttrglayeractiv_tVal00flatindex";
	       desc=;
	       flags=CAN_REVERT_TO_CODE;
	       code_string="act = trg_layer_activations->GetMatrixFlatVal(0, 0, flat_index)";
	       result_var=.functions[1].fun_code[0].local_vars[0]$$;
	       obj=$.objs_vars[3]$;
	       method=DataTable::GetMatrixFlatVal;
	       meth_args {
		name="meth_args";
		el_typ=ProgArg;
		el_def=0;
		ProgArg @[0] {
		 arg_type=const_Variant_ref;
		 type="Variant&";
		 name="col";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="0";
		 };
		};
		ProgArg @[1] {
		 arg_type=int;
		 type="int";
		 name="row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="0";
		 };
		};
		ProgArg @[2] {
		 arg_type=int;
		 type="int";
		 name="cell";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="flat_index";
		 };
		};
	       };
	       meth_sig="const_Variant GetMatrixFlatVal(Variant& col, int row, int cell)";
	       meth_desc=" get data of matrix type, in Variant form (any data type, use for Programs), for given column, row, and matrix flat cell index (regardless of dimensions) -- column can be specified as either integer index or a string that is then used to find the given column name";
	      };
	      AssignExpr @[3] {
	       name="AssignExpr_wtrfcellmatrixwtrfcellmatrixact";
	       desc=;
	       flags=CAN_REVERT_TO_CODE;
	       code_string="wt_rf_cell_matrix = wt_rf_cell_matrix * act";
	       result_var=$.functions[1].fun_code[0].local_vars[10]$;
	       expr {
		expr="wt_rf_cell_matrix * act";
	       };
	      };
	      MethodCall @[4] {
	       name="MethodCall_wtrfdataSetValAs_esxactflatindex";
	       desc=;
	       flags=CAN_REVERT_TO_CODE;
	       code_string="wt_rfdata->SetValAsMatrixColName(wt_rf_cell_matrix, \"values_x_act\", flat_index, )";
	       result_var=NULL;
	       obj=$.objs_vars[0]$;
	       method=DataTable::SetValAsMatrixColName;
	       meth_args {
		name="meth_args";
		el_typ=ProgArg;
		el_def=0;
		ProgArg @[0] {
		 arg_type=const_taMatrix_ptr;
		 type="taMatrix*";
		 name="val";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="wt_rf_cell_matrix";
		 };
		};
		ProgArg @[1] {
		 arg_type=const_taString_ref;
		 type="taString&";
		 name="col_name";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="\"values_x_act\"";
		 };
		};
		ProgArg @[2] {
		 arg_type=int;
		 type="int";
		 name="row";
		 required=1;
		 def_val=;
		 prev_expr=;
		 expr {
		  expr="flat_index";
		 };
		};
		ProgArg @[3] {
		 arg_type=bool;
		 type="bool";
		 name="quiet";
		 required=0;
		 def_val="false";
		 prev_expr=;
		 expr {
		  expr=;
		 };
		};
	       };
	       meth_sig="bool SetValAsMatrixColName(taMatrix* val, taString& col_name, int row, bool quiet = false)";
	       meth_desc=" set a matrix cell to values in given matrix val -- checks that the matrix has the proper geometry as the column's cells -- val can be of a different type than the data table column (it will just be a bit slower than if the type matches)";
	      };
	     };
	     init {
	      expr="unit_col = 0";
	     };
	     test {
	      expr="unit_col<unit_cols";
	     };
	     iter {
	      expr="unit_col++";
	     };
	    };
	   };
	   init {
	    expr="unit_row = 0";
	   };
	   test {
	    expr="unit_row<unit_rows";
	   };
	   iter {
	    expr="unit_row++";
	   };
	  };
	 };
	 init {
	  expr="grp_col = 0";
	 };
	 test {
	  expr="grp_col < grp_cols";
	 };
	 iter {
	  expr="grp_col++";
	 };
	};
       };
       init {
	expr="grp_row = 0";
       };
       test {
	expr="grp_row < grp_rows";
       };
       iter {
	expr="grp_row++";
       };
      };
     };
    };
    Else @[10] {
     name="Else_If_ifvaluesxactdatacol";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     cond {
      expr=;
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      PrintExpr @[0] {
       name="PrintExpr_Printvaluesxactc_ndandnotcreated";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print \"values_x_act column not found and not created!!!\"";
       expr {
	expr="\"values_x_act column not found and not created!!!\"";
       };
       debug=0;
      };
     };
    };
   };
  };
  Function @[2] {
   name="Sample";
   desc="Locate a sample of high activity units";
   flags=CAN_REVERT_TO_CODE;
   code_string="Sample() returns: int";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="fun_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars5vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="sample";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="max_act_flat_idx";
       var_type=T_Int;
       int_val=0;
       object_scope=NULL;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="max_act_index";
       var_type=T_Object;
       object_type=MatrixIndex;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="unit_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="trg_layer_acts_matrix";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       object_scope=NULL;
       objs_ptr=0;
       flags=LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     name="AssignExpr_maxactindexnewMatrixIndex";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="max_act_index = new MatrixIndex";
     result_var=.functions[2].fun_code[0].local_vars[2]$$;
     expr {
      expr="new MatrixIndex";
     };
    };
    MethodCall @[2] {
     name="MethodCall_trglayeractivationsResetData";
     desc="these values get reset for each image";
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer_activations->ResetData()";
     result_var=NULL;
     obj=$.objs_vars[3]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    MethodCall @[3] {
     name="MethodCall_trglayerVarToTab_nsactivationvar";
     desc="get data to table";
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer->VarToTable(trg_layer_activations, activation_var)";
     result_var=NULL;
     obj=$.vars[1]$;
     method=Layer::VarToTable;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="dt";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="trg_layer_activations";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="variable";
       required=1;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="activation_var";
       };
      };
     };
     meth_sig="DataTable_ptr VarToTable(DataTable* dt, taString& variable)";
     meth_desc=" send given variable to data table -- number of columns depends on variable (for projection variables, specify prjns.; for connection variables, specify r. or s. (e.g., r.wt)) -- this uses a NetMonitor internally, so see documentation there for more information";
    };
    AssignExpr @[4] {
     name="AssignExpr_trglayeractsmatrixnewfloatMatrix";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer_acts_matrix = new float_Matrix";
     result_var=.functions[2].fun_code[0].local_vars[4]$$;
     expr {
      expr="new float_Matrix";
     };
    };
    MethodCall @[5] {
     name="MethodCall_trglayeractsmatr_etValAsMatrix00";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer_acts_matrix = trg_layer_activations->GetValAsMatrix(0, 0)";
     result_var=$.functions[2].fun_code[0].local_vars[4]$;
     obj=$.objs_vars[3]$;
     method=DataTable::GetValAsMatrix;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="row";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="0";
       };
      };
     };
     meth_sig="taMatrix_ptr GetValAsMatrix(Variant& col, int row)";
     meth_desc=" get data of matrix type (multi-dimensional data within a given cell), in Matrix form, for given column, row; for Program usage, assign to a LocalVars Matrix* variable, NOT a global vars variable, at the appropriate scope where the matrix will be used, (e.g., if within a loop, put variable in the loop_code of the loop), so that the local variable will be deleted automatically, to free the memory associated with the Matrix when it is no longer needed";
    };
    If @[6] {
     name="If_ifnetworktrial0";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (network.trial == 0)";
     cond {
      expr="network.trial == 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       name="MethodCall_sampleunitsRemoveAllRows";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->RemoveAllRows()";
       result_var=NULL;
       obj=.objs_vars[4]$$;
       method=DataTable::RemoveAllRows;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="void RemoveAllRows()";
       meth_desc=" remove all of the rows of data, but keep the column structure";
      };
     };
    };
    ForLoop @[7] {
     name="ForLoop_forsample0samplesamplesizesample";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (sample = 0; sample < sample_size; sample++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       name="AssignExpr_maxacttrglayeractsmatrixMax";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="max_act = trg_layer_acts_matrix->Max()";
       result_var=.vars[5]$$;
       expr {
	expr="trg_layer_acts_matrix->Max()";
       };
      };
      MethodCall @[1] {
       name="MethodCall_maxactflatidxtrg_dValFlatmaxact0";
       desc="the flat index of sample unit";
       flags=CAN_REVERT_TO_CODE;
       code_string="max_act_flat_idx = trg_layer_acts_matrix->FindVal_Flat(max_act, 0)";
       result_var=.functions[2].fun_code[0].local_vars[1]$$;
       obj=$.functions[2].fun_code[0].local_vars[4]$;
       method=taMatrix::FindVal_Flat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="st_idx";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
       };
       meth_sig="int FindVal_Flat(Variant& val, int st_idx = 0)";
       meth_desc=" find a value in the matrix -- treats the matrix like a flat array, returns the flat index where the value was found, or -1 if not found. Negative st_idx will search backwards";
      };
      MemberMethodCall @[2] {
       name="MemberMethodCall_trglayeractsmatr_tidxmaxactindex";
       desc="multidimensional matrix indices of the unit";
       flags=CAN_REVERT_TO_CODE;
       code_string="trg_layer_acts_matrix.geom.DimsFmIndex(max_act_flat_idx, max_act_index)";
       obj=$.functions[2].fun_code[0].local_vars[4]$;
       path="geom";
       result_var=NULL;
       method=MatrixGeom::DimsFmIndex;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act_flat_idx";
	 };
	};
	ProgArg @[1] {
	 arg_type=MatrixIndex_ref;
	 type="MatrixIndex&";
	 name="dims";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act_index";
	 };
	};
       };
       meth_sig="void DimsFmIndex(int idx, MatrixIndex& dims)";
       meth_desc=" get dimension values from index, based on geometry represented by 'this' geom object";
      };
      PrintVar @[3] {
       name="PrintVar_Printmaxactmaxac_tidxmaxactindex";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  max_act max_act_flat_idx max_act_index";
       message=;
       print_var=$.vars[5]$;
       print_var2=$.functions[2].fun_code[0].local_vars[1]$;
       print_var3=$.functions[2].fun_code[0].local_vars[2]$;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=0;
      };
      MethodCall @[4] {
       name="MethodCall_trglayeractsmatr_t1maxactflatidx";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="trg_layer_acts_matrix->Set_Flat(-1, max_act_flat_idx)";
       result_var=NULL;
       obj=$.functions[2].fun_code[0].local_vars[4]$;
       method=taMatrixT_float_::Set_Flat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_float_ref;
	 type="float&";
	 name="item";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act_flat_idx";
	 };
	};
       };
       meth_sig="void Set_Flat(float& item, int idx)";
       meth_desc=" safely assign values to items in the matrix, treated as a flat vector";
      };
      MethodCall @[5] {
       name="MethodCall_sampleunitsAddBlankRow";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->AddBlankRow()";
       result_var=NULL;
       obj=$.objs_vars[4]$;
       method=DataTable::AddBlankRow;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
       };
       meth_sig="int AddBlankRow()";
       meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
      };
      MethodCall @[6] {
       name="MethodCall_sampleunitsSetVa_enameimagename1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->SetValAsString(image_filename, \"image_name\", -1)";
       result_var=NULL;
       obj=$.objs_vars[4]$;
       method=DataTable::SetValAsString;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="image_filename";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"image_name\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
       };
       meth_sig="bool SetValAsString(taString& val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in String form, for given column, row; does nothing if no cell; 'true if set";
      };
      MethodCall @[7] {
       name="MethodCall_unitmatrixwtrfda_ctmaxactflatidx";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="unit_matrix = wt_rfdata->GetValAsMatrixColName(\"values_x_act\", max_act_flat_idx, )";
       result_var=.functions[2].fun_code[0].local_vars[3]$$;
       obj=$.objs_vars[0]$;
       method=DataTable::GetValAsMatrixColName;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"values_x_act\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act_flat_idx";
	 };
	};
	ProgArg @[2] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taMatrix_ptr GetValAsMatrixColName(taString& col_name, int row, bool quiet = false)";
       meth_desc=" get data of matrix type (multi-dimensional data within a given cell), in Matrix form, for given column, row; for Program usage, assign to a LocalVars Matrix* variable, NOT a global vars variable, at the appropriate scope where the matrix will be used, (e.g., if within a loop, put variable in the loop_code of the loop), so that the local variable will be deleted automatically, to free the memory associated with the Matrix when it is no longer needed";
      };
      MethodCall @[8] {
       name="MethodCall_sampleunitsSetVa_trixvaluesxact1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->SetValAsMatrixColName(unit_matrix, \"values_x_act\", -1, )";
       result_var=NULL;
       obj=$.objs_vars[4]$;
       method=DataTable::SetValAsMatrixColName;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taMatrix_ptr;
	 type="taMatrix*";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="unit_matrix";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="col_name";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"values_x_act\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="quiet";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool SetValAsMatrixColName(taMatrix* val, taString& col_name, int row, bool quiet = false)";
       meth_desc=" set a matrix cell to values in given matrix val -- checks that the matrix has the proper geometry as the column's cells -- val can be of a different type than the data table column (it will just be a bit slower than if the type matches)";
      };
      MethodCall @[9] {
       name="MethodCall_sampleunitsSetVa_idxunitidxflat1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->SetValAsInt(max_act_flat_idx, \"unit_idx_flat\", -1)";
       result_var=NULL;
       obj=$.objs_vars[4]$;
       method=DataTable::SetValAsInt;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act_flat_idx";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"unit_idx_flat\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
       };
       meth_sig="bool SetValAsInt(int val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in int form, for given column, row; does nothing if no cell' 'true' if set";
      };
      MethodCall @[10] {
       name="MethodCall_sampleunitsSetVa_xactactivation1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->SetValAsFloat(max_act, \"activation\", -1)";
       result_var=NULL;
       obj=$.objs_vars[4]$;
       method=DataTable::SetValAsFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=float;
	 type="float";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="max_act";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"activation\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
       };
       meth_sig="bool SetValAsFloat(float val, Variant& col, int row)";
       meth_desc=" set data of scalar type, in float form, for given column, row; does nothing if no cell' 'true' if set";
      };
      MethodCall @[11] {
       name="MethodCall_sampleunitsCopyC_taV1lF16imager0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sample_units->CopyCell(\"image\", -1, v1_fovea_region_data, \"V1lF16_image_r\", 0)";
       result_var=NULL;
       obj=$.objs_vars[4]$;
       method=DataTable::CopyCell;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="dest_col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"image\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="dest_row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_DataTable_ref;
	 type="DataTable&";
	 name="src";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="v1_fovea_region_data";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="src_col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"V1lF16_image_r\"";
	 };
	};
	ProgArg @[4] {
	 arg_type=int;
	 type="int";
	 name="src_row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
       };
       meth_sig="bool CopyCell(Variant& dest_col, int dest_row, DataTable& src, Variant& src_col, int src_row)";
       meth_desc=" copy one cell (indexed by column, row) from source to this data table in given col,row cell -- is robust to differences in type and matrix sizing (returns false if not successful) -- column can be specified as either integer index or a string that is then used to find the given column name";
      };
     };
     init {
      expr="sample = 0";
     };
     test {
      expr="sample < sample_size";
     };
     iter {
      expr="sample++";
     };
    };
   };
  };
  Function @[3] {
   name="RemoveAllRowsAllTables";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="RemoveAllRowsAllTables() returns: int";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="fun_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars0vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    MethodCall @[1] {
     name="MethodCall_wtrfdataRemoveAllRows";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="wt_rfdata->RemoveAllRows()";
     result_var=NULL;
     obj=$.objs_vars[0]$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
    MethodCall @[2] {
     name="MethodCall_trglayerwtsRemoveAllRows";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer_wts->RemoveAllRows()";
     result_var=NULL;
     obj=.objs_vars[2]$$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
    MethodCall @[3] {
     name="MethodCall_trglayeractivationsRemoveAllRows";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="trg_layer_activations->RemoveAllRows()";
     result_var=NULL;
     obj=$.objs_vars[3]$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
    MethodCall @[4] {
     name="MethodCall_sampleunitsRemoveAllRows";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="sample_units->RemoveAllRows()";
     result_var=NULL;
     obj=$.objs_vars[4]$;
     method=DataTable::RemoveAllRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void RemoveAllRows()";
     meth_desc=" remove all of the rows of data, but keep the column structure";
    };
   };
  };
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   name="LocalVars_LocalVars0vars";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LocalVars (0 vars)";
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   name="LocalVars_LocalVars0vars";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LocalVars (0 vars)";
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  FunctionCall @[1] {
   name="FunctionCall_ResetTables";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ResetTables()";
   result_var=NULL;
   fun=.functions[0]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  MethodCall @[2] {
   name="MethodCall_imagefilenameobj_rcurobjfilename";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="image_filename = objects_env->GetVar(\"cur_obj_filename\")";
   result_var=.vars[7]$$;
   obj=.vars[9]$$;
   method=Program::GetVar;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
    ProgArg @[0] {
     arg_type=const_taString_ref;
     type="taString&";
     name="var_nm";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="\"cur_obj_filename\"";
     };
    };
   };
   meth_sig="Variant GetVar(taString& var_nm)";
   meth_desc=" get the value of a program variable (only top-level variables in vars or args) -- can be called from within a running program";
  };
  PrintVar @[3] {
   name="PrintVar_Printimagefilename";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="Print  image_filename";
   message=;
   print_var=$.vars[7]$;
   print_var2=NULL;
   print_var3=NULL;
   print_var4=NULL;
   print_var5=NULL;
   print_var6=NULL;
   debug=0;
  };
  Comment @[4] {
   name="Comment_makesuretousethe_ivationvariable";
   desc="make sure to use the correct activation variable!";
   flags=CAN_REVERT_TO_CODE|NO_CODE;
   code_string="// make sure to use the correct activation variable!";
  };
  If @[5] {
   name="If_ifnetworkInherit_omNameBpNetwork";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="if (network->InheritsFromName(\"BpNetwork\"))";
   cond {
    expr="network->InheritsFromName(\"BpNetwork\")";
   };
   true_code {
    name="true_code";
    el_typ=ProgCode;
    el_def=0;
    AssignExpr @[0] {
     name="AssignExpr_activationvaract";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="activation_var = \"act\"";
     result_var=.vars[4]$$;
     expr {
      expr="\"act\"";
     };
    };
   };
  };
  ElseIf @[6] {
   name="ElseIf_elseifnetworkInh_meLeabraNetwork";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="else if (network->InheritsFromName(\"LeabraNetwork\"))";
   cond {
    expr="network->InheritsFromName(\"LeabraNetwork\")";
   };
   true_code {
    name="true_code";
    el_typ=ProgCode;
    el_def=0;
    AssignExpr @[0] {
     name="AssignExpr_activationvaractm";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="activation_var = \"act_m\"";
     result_var=$.vars[4]$;
     expr {
      expr="\"act_m\"";
     };
    };
   };
  };
  MethodCall @[7] {
   name="MethodCall_wtbasedrfanalysi_ersndlayerfalse";
   desc="reset";
   flags=CAN_REVERT_TO_CODE;
   code_string="wt_based_rf_analysis->ComputeHigherLayerRF(network, wt_rfdata, snd_rf_data, trg_layer_wts, trg_layer, snd_layer, false)";
   result_var=NULL;
   obj=.objs_vars[1]$$;
   method=WtBasedRF::ComputeHigherLayerRF;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
    ProgArg @[0] {
     arg_type=Network_ptr;
     type="Network*";
     name="net";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="network";
     };
    };
    ProgArg @[1] {
     arg_type=DataTable_ptr;
     type="DataTable*";
     name="dt_trg";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="wt_rfdata";
     };
    };
    ProgArg @[2] {
     arg_type=DataTable_ptr;
     type="DataTable*";
     name="dt_snd";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="snd_rf_data";
     };
    };
    ProgArg @[3] {
     arg_type=DataTable_ptr;
     type="DataTable*";
     name="wts";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="trg_layer_wts";
     };
    };
    ProgArg @[4] {
     arg_type=Layer_ptr;
     type="Layer*";
     name="tlay";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="trg_layer";
     };
    };
    ProgArg @[5] {
     arg_type=Layer_ptr;
     type="Layer*";
     name="slay";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="snd_layer";
     };
    };
    ProgArg @[6] {
     arg_type=bool;
     type="bool";
     name="center_only";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="false";
     };
    };
   };
   meth_sig="bool ComputeHigherLayerRF(Network* net, DataTable* dt_trg, DataTable* dt_snd, DataTable* wts, Layer* tlay, Layer* slay, bool center_only)";
   meth_desc=" compute the rf_data for layers beyond V2. These calculations use the RF computations from all layers below (e.g. the V4 representational analysis uses the values computed for V2). Because this is computation takes a long time you pass in a group number so you don't always have to process the entire layer. Pass -1 or use default for entire layer. Group number starts with zero (lower left) and moves right and then up.";
  };
  FunctionCall @[8] {
   name="FunctionCall_MultiplyWithActivations";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="MultiplyWithActivations()";
   result_var=NULL;
   fun=.functions[1]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  FunctionCall @[9] {
   name="FunctionCall_Sample";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="Sample()";
   result_var=NULL;
   fun=.functions[2]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
 };
 step_prog=NULL;
 step_n=1;
 doc {
  name="doc";
  desc=;
  web_doc=0;
  wiki=;
  url="local";
  full_url="local";
  text_size=1;
  text="<html>
<head></head>
<body>
== Enter Title Here ==
</body>
</html>
";
  html_text="<html>
<head></head>
<body>
<h2> Enter Title Here </h2>
</body>
</html>
";
 };
};

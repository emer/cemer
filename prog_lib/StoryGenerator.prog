// ta_Dump File v3.0 -- code v7.8.6.0 rev9337
Program .projects[0].programs.gp[3][5] { 
 UserDataItem_List @*(.user_data_) {
  UserData_DocLink @[0] { };
  UserDataItem @[1] { };
 };

 ProgObjList @.objs = [8] {
  DataTable_Group @[0] = [2] { 
   DataTable @[0] { 
    DataTableCols @.data = [6] {
     String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     bool_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
       UserDataItem @[1] { };
      };
     };
     String_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [6] {
     DataSortEl @[0] { };
     DataSortEl @[1] { };
     DataSortEl @[2] { };
     DataSortEl @[3] { };
     DataSortEl @[4] { };
     DataSortEl @[5] { };
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
   DataTable @[1] { 
    DataTableCols @.data = [6] {
     String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     bool_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     float_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
       UserDataItem @[1] { };
      };
     };
     String_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[5] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [6] {
     DataSortEl @[0] { };
     DataSortEl @[1] { };
     DataSortEl @[2] { };
     DataSortEl @[3] { };
     DataSortEl @[4] { };
     DataSortEl @[5] { };
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
  DataTable @[1] { 
   DataTableCols @.data = [4] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    bool_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    float_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[2] { 
   DataTableCols @.data = [1] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[3] { 
   DataTableCols @.data = [1] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[4] { 
   DataTableCols @.data = [9] {
    int_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    float_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    bool_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[7] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    float_Data @[8] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[5] { 
   DataTableCols @.data = [9] {
    int_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    float_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    bool_Data @[6] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[7] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    float_Data @[8] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[6] { 
   DataTableCols @.data = [3] {
    int_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    int_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[7] { 
   DataTableCols @.data = [6] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    bool_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    float_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    int_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
      UserDataItem @[1] { };
     };
    };
    String_Data @[4] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[5] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
 };

 ProgType_List @.types = [0] {
 };

 ProgVar_List @.args = [1] {
  ProgVar @[0] { };
 };

 ProgVar_List @.vars = [19] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
  ProgVar @[8] { };
  ProgVar @[9] { };
  ProgVar @[10] { };
  ProgVar @[11] { };
  ProgVar @[12] { };
  ProgVar @[13] { };
  ProgVar @[14] { };
  ProgVar @[15] { };
  ProgVar @[16] { };
  ProgVar @[17] { };
  ProgVar @[18] { };
 };

 Function_List @.functions = [27] {
  Function @[0] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [2] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [6] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
     };
    };
    ForLoop @[1] { 
     ProgEl_List @.loop_code = [5] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[2] { };
      ForLoop @[3] { 
       ProgEl_List @.loop_code = [6] {
	AssignExpr @[0] { };
	If @[1] { 
	 ProgEl_List @.true_code = [1] {
	  MiscCall @[0] { 
	   ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	   };
	  };
	 };
	};
	If @[2] { 
	 ProgEl_List @.true_code = [1] {
	  MiscCall @[0] { 
	   ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	   };
	  };
	 };
	};
	If @[3] { 
	 ProgEl_List @.true_code = [1] {
	  MiscCall @[0] { 
	   ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	   };
	  };
	 };
	};
	If @[4] { 
	 ProgEl_List @.true_code = [1] {
	  VarIncr @[0] { };
	 };
	};
	If @[5] { 
	 ProgEl_List @.true_code = [1] {
	  VarIncr @[0] { };
	 };
	};
       };
      };
      If @[4] { 
       ProgEl_List @.true_code = [1] {
	MiscCall @[0] { 
	 ProgArg_List @.meth_args = [9] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	  ProgArg @[3] { };
	  ProgArg @[4] { };
	  ProgArg @[5] { };
	  ProgArg @[6] { };
	  ProgArg @[7] { };
	  ProgArg @[8] { };
	 };
	};
       };
      };
     };
    };
   };
  };
  Function @[1] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    FunctionCall @[1] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [12] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
      ProgArg @[10] { };
      ProgArg @[11] { };
     };
    };
    DataSelectRowsProg @[3] { 
     DataOpList @.select_spec.ops = [1] {
      DataSelectEl @[0] { };
     };
    };
    DataGroupProg @[4] { 
     DataOpList @.group_spec.ops = [4] {
      DataGroupEl @[0] { };
      DataGroupEl @[1] { };
      DataGroupEl @[2] { };
      DataGroupEl @[3] { };
     };
    };
    MathCall @[5] { 
     ProgArg_List @.meth_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
   };
  };
  Function @[2] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    ReturnExpr @[2] { };
   };
  };
  Function @[3] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    ReturnExpr @[3] { };
   };
  };
  Function @[4] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [3] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    ReturnExpr @[2] { };
   };
  };
  Function @[5] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    FunctionCall @[1] { 
     ProgArg_List @.fun_args = [1] {
      ProgArg @[0] { };
     };
    };
    FunctionCall @[2] { 
     ProgArg_List @.fun_args = [1] {
      ProgArg @[0] { };
     };
    };
    If @[3] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    Else @[4] { 
     ProgEl_List @.else_code = [1] {
      AssignExpr @[0] { };
     };
    };
    ReturnExpr @[5] { };
   };
  };
  Function @[6] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    ReturnExpr @[2] { };
   };
  };
  Function @[7] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    ReturnExpr @[2] { };
   };
  };
  Function @[8] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [15] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    AssignExpr @[1] { };
    AssignExpr @[2] { };
    AssignExpr @[3] { };
    AssignExpr @[4] { };
    FunctionCall @[5] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    If @[6] { 
     ProgEl_List @.true_code = [1] {
      VarIncr @[0] { };
     };
    };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MatrixAssign @[8] { };
    MatrixAssign @[9] { };
    MatrixAssign @[10] { };
    MatrixAssign @[11] { };
    MatrixAssign @[12] { };
    MatrixAssign @[13] { };
    ReturnExpr @[14] { };
   };
  };
  Function @[9] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [23] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [6] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    AssignExpr @[3] { };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    AssignExpr @[5] { };
    FunctionCall @[6] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    FunctionCall @[7] { 
     ProgArg_List @.fun_args = [1] {
      ProgArg @[0] { };
     };
    };
    MatrixAssign @[8] { };
    MatrixAssign @[9] { };
    AssignExpr @[10] { };
    AssignExpr @[11] { };
    AssignExpr @[12] { };
    MatrixAssign @[13] { };
    MatrixAssign @[14] { };
    MatrixAssign @[15] { };
    MatrixAssign @[16] { };
    MatrixAssign @[17] { };
    MatrixAssign @[18] { };
    MatrixAssign @[19] { };
    MatrixAssign @[20] { };
    MatrixAssign @[21] { };
    ReturnExpr @[22] { };
   };
  };
  Function @[10] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    If @[3] { 
     ProgEl_List @.true_code = [2] {
      AssignExpr @[0] { };
      AssignExpr @[1] { };
     };
    };
    Else @[4] { 
     ProgEl_List @.else_code = [2] {
      AssignExpr @[0] { };
      AssignExpr @[1] { };
     };
    };
    PrintVar @[5] { };
   };
  };
  Function @[11] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [12] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    AssignExpr @[2] { };
    MatrixAssign @[3] { };
    MatrixAssign @[4] { };
    If @[5] { 
     ProgEl_List @.true_code = [1] {
      MatrixAssign @[0] { };
     };
    };
    AssignExpr @[6] { };
    AssignExpr @[7] { };
    If @[8] { 
     ProgEl_List @.true_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MathCall @[1] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    AssignExpr @[9] { };
    AssignExpr @[10] { };
    FunctionCall @[11] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
   };
  };
  Function @[12] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    AssignExpr @[2] { };
    MatrixAssign @[3] { };
    AssignExpr @[4] { };
    If @[5] { 
     ProgEl_List @.true_code = [1] {
      MatrixAssign @[0] { };
     };
    };
    Else @[6] { 
     ProgEl_List @.else_code = [5] {
      AssignExpr @[0] { };
      MatrixAssign @[1] { };
      MatrixAssign @[2] { };
      VarIncr @[3] { };
      MatrixAssign @[4] { };
     };
    };
    If @[7] { 
     ProgEl_List @.true_code = [1] {
      MatrixAssign @[0] { };
     };
    };
    Else @[8] { 
     ProgEl_List @.else_code = [1] {
      MatrixAssign @[0] { };
     };
    };
    ReturnExpr @[9] { };
   };
  };
  Function @[13] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [9] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
     };
    };
    FunctionCall @[1] { 
     ProgArg_List @.fun_args = [3] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    AssignExpr @[3] { };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ForLoop @[5] { 
     ProgEl_List @.loop_code = [3] {
      AssignExpr @[0] { };
      If @[1] { 
       ProgEl_List @.true_code = [2] {
	VarIncr @[0] { };
	If @[1] { 
	 ProgEl_List @.true_code = [1] {
	  VarIncr @[0] { };
	 };
	};
       };
      };
      FunctionCall @[2] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
   };
  };
  Function @[14] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    ElseIf @[2] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
    ElseIf @[3] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    ElseIf @[4] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
    Else @[5] { 
     ProgEl_List @.else_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
   };
  };
  Function @[15] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    AssignExpr @[3] { };
    AssignExpr @[4] { };
    AssignExpr @[5] { };
    AssignExpr @[6] { };
    MethodCall @[7] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ForLoop @[9] { 
     ProgEl_List @.loop_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
   };
  };
  Function @[16] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    FunctionCall @[2] { 
     ProgArg_List @.fun_args = [1] {
      ProgArg @[0] { };
     };
    };
    AssignExpr @[3] { };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    AssignExpr @[5] { };
    AssignExpr @[6] { };
    AssignExpr @[7] { };
    AssignExpr @[8] { };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
   };
  };
  Function @[17] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    ElseIf @[3] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    If @[4] { 
     ProgEl_List @.true_code = [2] {
      VarIncr @[0] { };
      FunctionCall @[1] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
    Else @[5] { 
     ProgEl_List @.else_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
   };
  };
  Function @[18] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [7] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    DataGenCall @[1] { 
     ProgArg_List @.meth_args = [5] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
     };
    };
    AssignExpr @[2] { };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    FunctionCall @[6] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
   };
  };
  Function @[19] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [15] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [14] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
      ProgVar @[10] { };
      ProgVar @[11] { };
      ProgVar @[12] { };
      ProgVar @[13] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [5] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      FunctionCall @[2] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
      FunctionCall @[3] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
      ReturnExpr @[4] { };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [5] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      FunctionCall @[2] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
      FunctionCall @[3] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
      ReturnExpr @[4] { };
     };
    };
    AssignExpr @[3] { };
    If @[4] { 
     ProgEl_List @.true_code = [2] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
     };
    };
    AssignExpr @[5] { };
    AssignExpr @[6] { };
    AssignExpr @[7] { };
    If @[8] { 
     ProgEl_List @.true_code = [2] {
      AssignExpr @[0] { };
      If @[1] { 
       ProgEl_List @.true_code = [2] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
       };
      };
     };
    };
    ElseIf @[9] { 
     ProgEl_List @.true_code = [4] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      If @[1] { 
       ProgEl_List @.true_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
       };
      };
      ElseIf @[2] { 
       ProgEl_List @.true_code = [3] {
	AssignExpr @[0] { };
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[2] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
       };
      };
      Else @[3] { 
       ProgEl_List @.else_code = [2] {
	AssignExpr @[0] { };
	MethodCall @[1] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
       };
      };
     };
    };
    If @[10] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    PrintVar @[11] { };
    ForLoop @[12] { 
     ProgEl_List @.loop_code = [3] {
      AssignExpr @[0] { };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      If @[2] { 
       ProgEl_List @.true_code = [2] {
	If @[0] { 
	 ProgEl_List @.true_code = [1] {
	  ReturnExpr @[0] { };
	 };
	};
	ReturnExpr @[1] { };
       };
      };
     };
    };
    If @[13] { 
     ProgEl_List @.true_code = [1] {
      ReturnExpr @[0] { };
     };
    };
    ReturnExpr @[14] { };
   };
  };
  Function @[20] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [11] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [7] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
     };
    };
    AssignExpr @[1] { };
    AssignExpr @[2] { };
    If @[3] { 
     ProgEl_List @.true_code = [6] {
      AssignExpr @[0] { };
      RandomCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      ForLoop @[2] { 
       ProgEl_List @.loop_code = [3] {
	AssignExpr @[0] { };
	VarIncr @[1] { };
	IfBreak @[2] { };
       };
      };
      If @[3] { 
       ProgEl_List @.true_code = [1] {
	AssignExpr @[0] { };
       };
      };
      AssignExpr @[4] { };
      PrintVar @[5] { };
     };
    };
    Else @[4] { 
     ProgEl_List @.else_code = [3] {
      ForLoop @[0] { 
       ProgEl_List @.loop_code = [2] {
	AssignExpr @[0] { };
	IfBreak @[1] { };
       };
      };
      If @[1] { 
       ProgEl_List @.true_code = [2] {
	AssignExpr @[0] { };
	PrintVar @[1] { };
       };
      };
      Else @[2] { 
       ProgEl_List @.else_code = [3] {
	AssignExpr @[0] { };
	PrintVar @[1] { };
	ReturnExpr @[2] { };
       };
      };
     };
    };
    MethodCall @[5] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MatrixAssign @[6] { };
    MatrixAssign @[7] { };
    AssignExpr @[8] { };
    AssignExpr @[9] { };
    ReturnExpr @[10] { };
   };
  };
  Function @[21] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    AssignExpr @[1] { };
    PrintVar @[2] { };
    If @[3] { 
     ProgEl_List @.true_code = [4] {
      AssignExpr @[0] { };
      FunctionCall @[1] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
      FunctionCall @[2] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
      ReturnExpr @[3] { };
     };
    };
    AssignExpr @[4] { };
    AssignExpr @[5] { };
    VarIncr @[6] { };
    ForLoop @[7] { 
     ProgEl_List @.loop_code = [2] {
      AssignExpr @[0] { };
      IfBreak @[1] { };
     };
    };
    If @[8] { 
     ProgEl_List @.true_code = [3] {
      AssignExpr @[0] { };
      MatrixAssign @[1] { };
      PrintVar @[2] { };
     };
    };
    Else @[9] { 
     ProgEl_List @.else_code = [2] {
      AssignExpr @[0] { };
      FunctionCall @[1] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
   };
  };
  Function @[22] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [10] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [3] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [13] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
      ProgArg @[10] { };
      ProgArg @[11] { };
      ProgArg @[12] { };
     };
    };
    If @[4] { 
     ProgEl_List @.true_code = [1] {
      MiscCall @[0] { 
       ProgArg_List @.meth_args = [9] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
       };
      };
     };
    };
    PrintVar @[5] { };
    AssignExpr @[6] { };
    AssignExpr @[7] { };
    FunctionCall @[8] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    ReturnExpr @[9] { };
   };
  };
  Function @[23] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    PrintVar @[2] { };
    If @[3] { 
     ProgEl_List @.true_code = [2] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [0] {
	 };
	};
       };
      };
      Else @[1] { 
       ProgEl_List @.else_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [0] {
	 };
	};
       };
      };
     };
    };
    Else @[4] { 
     ProgEl_List @.else_code = [1] {
      AssignExpr @[0] { };
     };
    };
   };
  };
  Function @[24] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    AssignExpr @[1] { };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      VarIncr @[0] { };
     };
    };
    Else @[3] { 
     ProgEl_List @.else_code = [1] {
      AssignExpr @[0] { };
     };
    };
    MatrixAssign @[4] { };
   };
  };
  Function @[25] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [16] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [2] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [0] {
	 };
	};
       };
      };
      Else @[1] { 
       ProgEl_List @.else_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [0] {
	 };
	};
       };
      };
     };
    };
    AssignExpr @[3] { };
    AssignExpr @[4] { };
    AssignExpr @[5] { };
    PrintVar @[6] { };
    If @[7] { 
     ProgEl_List @.true_code = [2] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
      If @[1] { 
       ProgEl_List @.true_code = [2] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [0] {
	 };
	};
	ReturnExpr @[1] { };
       };
      };
     };
    };
    If @[8] { 
     ProgEl_List @.true_code = [2] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [0] {
       };
      };
      ReturnExpr @[1] { };
     };
    };
    If @[9] { 
     ProgEl_List @.true_code = [1] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	PrintVar @[0] { };
	FunctionCall @[1] { 
	 ProgArg_List @.fun_args = [0] {
	 };
	};
	ReturnExpr @[2] { };
       };
      };
     };
    };
    AssignExpr @[10] { };
    If @[11] { 
     ProgEl_List @.true_code = [1] {
      ReturnExpr @[0] { };
     };
    };
    If @[12] { 
     ProgEl_List @.true_code = [1] {
      ReturnExpr @[0] { };
     };
    };
    FunctionCall @[13] { 
     ProgArg_List @.fun_args = [1] {
      ProgArg @[0] { };
     };
    };
    FunctionCall @[14] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    ReturnExpr @[15] { };
   };
  };
  Function @[26] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    FunctionCall @[1] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    AssignExpr @[2] { };
    WhileLoop @[3] { 
     ProgEl_List @.loop_code = [1] {
      VarIncr @[0] { };
     };
    };
    ReturnExpr @[4] { };
   };
  };
 };

 ProgEl_List @.init_code = [5] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  FunctionCall @[1] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  AssignExpr @[2] { };
  AssignExpr @[3] { };
  AssignExpr @[4] { };
 };

 ProgEl_List @.prog_code = [3] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  If @[1] { 
   ProgEl_List @.true_code = [2] {
    FunctionCall @[0] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    PrintVar @[1] { };
   };
  };
  Else @[2] { 
   ProgEl_List @.else_code = [2] {
    FunctionCall @[0] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
    PrintVar @[1] { };
   };
  };
 };
};
Program .projects[0].programs.gp[3][5] {
 UserDataItem_List @*(.user_data_) {
  name="UserDataItem_List_272";
  el_typ=UserData_DocLink;
  el_def=0;
  UserData_DocLink @[0] {
   name="DocLink";
   doc=.projects[0].docs[0]$$<taDoc,StoryGenDocs>;
  };
  UserDataItem @[1] {
   name="user_pinned";
   value 1 0=0;
   val_type_fixed=0;
  };
 };
 name="StoryGenerator";
 short_nm="StrGnr";
 tags="InputData, Data, DataGen, Language";
 desc="generate stories as sequences of sentences describing events.  See https://grey.colorado.edu/emergent/index.php/StoryGenerator wiki page for full details";
 flags=NO_STOP_STEP;
 stop_step_cond {
  expr=;
 };
 objs {
  name="objs";
  el_typ=DataTable;
  el_def=0;
  DataTable_Group @[0] {
   name="Stories";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="BallStory";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_233";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.06898955;
	val_type_fixed=0;
       };
      };
      name="group";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=99;
      ar {
       name="ar";
      [20] "roll";"roll_cat";"roll_cat";"roll_cat";"roll_cat";"bounce";"drop_bounce";;;;
"drop_bounce";"$colors";"$sizes";"$dirs";"$heights";"roll_hit";"roll_hit";"roll_hit";;"roll_cat";
      };
     };
     bool_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_248";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.03344948;
	val_type_fixed=0;
       };
      };
      name="on";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=48;
      ar {
       name="ar";
      [20] true;true;true;true;true;true;true;false;false;false;
true;false;false;false;false;true;true;true;false;true;
      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_235";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.03414634;
	val_type_fixed=0;
       };
      };
      name="freq";
      desc="specify relative frequency -- will be normalized globally so you can just enter relative numbers here";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=49;
      ar {
       name="ar";
      [20] 1;1;1;1;1;1;1;1;1;1;
1;0;0;0;0;1;1;1;0;1;
      };
     };
     int_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_232";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 8 0=0.02508711;
	val_type_fixed=0;
       };
      };
      name="seq";
      desc="sequencing counter -- use this to maintain order of items -- will be sorted in this order suggest using 10,20 etc to allow for future expansion";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=36;
      ar {
       name="ar";
      [20] 0;0;10;20;30;0;0;0;0;0;
10;0;0;0;0;0;10;20;0;40;
      };
     };
     String_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_234";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.4383275;
	val_type_fixed=0;
       };
      };
      name="sentence";
      desc="enter words describing events -- use [ ] around optional elements (can be nested),  | between mutually exclusive alternatives, || between non-mutex alternatives (order independent), and |> between non-mutex alternatives (order dependent) (put space around each of these) -- use %50 (no space) e.g. to specify probability of any item (will be normalized automatically if multiple alternatives";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=629;
      ar {
       name="ar";
      [20] "the $sizes%50 $colors%50 ball:Ph rolls:V [%33 to the $dirs ] [%20 [ behind | in front of ] the block:Po ] .";"the $sizes%50 $colors%50 ball:Ph rolls:V [%33 to the $dirs ] [ behind | in front of ] the cat:Po .";"the cat:A chases:V after the ball:Ph .";"it:A hits:V the ball:Ph [%50 but misses ] .";"[?!1misses? the ball:Ph rolls:V back [?:L? to the right:L?left:L? left:L?right:L? ] . ]";"the $sizes%50 $colors%50 ball:Ph bounces:V $heights%50 [%33 to the $dirs ] .";"the $sizes%50 $colors%50 ball:Ph drops:V [%50 from the [ |%80 table:Li |%20 hand:Li ] ] .";;;;
"it:Ph bounces:V $heights%50 [%33 to the $dirs ] .";"[:J red | green | blue ]";"[:J small | medium-sized | large ]";"[:L left | right ]";"[:R high | medium-high | low ]";"the $sizes%50 $colors%50 ball:Ph rolls:V to the $dirs into the block:Po .";"it:Ph hits:V the block:Po .";"it:Ph rolls:V back to the right:L?left:L? left:L?right:L?  .";;"goto:10%50?2misses?";
      };
     };
     String_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.2926829;
	val_type_fixed=0;
       };
      };
      name="comments";
      desc="enter words describing events -- use [ ] around optional elements (can be nested) and | between alternatives (put space around each of these) -- use %50 (no space) e.g. to specify probability of an item (will be normalized automatically)";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=420;
      ar {
       name="ar";
      [20] ;"this is advanced and should be off for initial runs";;"pronoun = cat";"only rolls back if cat doesn't miss!  direction contingent on orig if specified";;;;;;
;;;;;"todo: could do \"from\" instead of to..";;;;"loop!";
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [16] 11;13;14;12;5;6;10;0;1;2;
3;4;19;15;16;17;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
      DataSortEl @[0] {
       col_name="group";
       name="group_up_0";
       order=ASCENDING;
      };
      DataSortEl @[1] {
       col_name="seq";
       name="seq_up_1";
       order=ASCENDING;
      };
      DataSortEl @[2] {
       col_name="comments";
       name="comments_up_2";
       order=ASCENDING;
      };
      DataSortEl @[3] {
       col_name="comments";
       name="comments_up_3";
       order=ASCENDING;
      };
      DataSortEl @[4] {
       col_name="comments";
       name="comments_up_4";
       order=ASCENDING;
      };
      DataSortEl @[5] {
       col_name="comments";
       name="comments_up_5";
       order=ASCENDING;
      };
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
   DataTable @[1] {
    name="DebugStory";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.06898955;
	val_type_fixed=0;
       };
      };
      name="group";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=99;
      ar {
       name="ar";
      [10] "bounce";"drop_bounce";"drop_bounce";"roll";"roll_cat";"roll_cat";"roll_cat";"roll_cat";"$colors";"$sizes";
      };
     };
     bool_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.03344948;
	val_type_fixed=0;
       };
      };
      name="on";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=48;
      ar {
       name="ar";
      [10] true;true;true;true;true;true;true;true;false;false;
      };
     };
     float_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.03414634;
	val_type_fixed=0;
       };
      };
      name="freq";
      desc="specify relative frequency -- will be normalized globally so you can just enter relative numbers here";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=49;
      ar {
       name="ar";
      [10] 1;1;1;1;1;1;1;1;0;0;
      };
     };
     int_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="NARROW";
	value 1 0=1;
	val_type_fixed=0;
       };
       UserDataItem @[1] {
	name="view_panel_wd";
	value 8 0=0.02508711;
	val_type_fixed=0;
       };
      };
      name="seq";
      desc="sequencing counter -- use this to maintain order of items -- will be sorted in this order suggest using 10,20 etc to allow for future expansion";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=36;
      ar {
       name="ar";
      [10] 0;0;10;0;0;10;20;30;0;0;
      };
     };
     String_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.497561;
	val_type_fixed=0;
       };
      };
      name="sentence";
      desc="enter words describing events -- use [ ] around optional elements (can be nested),  | between mutually exclusive alternatives, || between non-mutex alternatives (order independent), and |> between non-mutex alternatives (order dependent) (put space around each of these) -- use %50 (no space) e.g. to specify probability of any item (will be normalized automatically if multiple alternatives";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=714;
      ar {
       name="ar";
      [10] "the $sizes%50 $colors%100?0:J? ball:P rolled:V [%50 to the [:L right | left ] ||%20 [ behind | in front of ] the block:Po ] .";"the ball dropped [%50 from the [ table | hand ] ] .";"it bounced [%50 [ high | medium | low ] || to the [ right | left ] ] .";"the ball rolled [%50 to the [ right | left ] || [%20 [ behind | in front of ] the block ] .";"the ball rolled to the [ right | left ] [ behind | in front of ] the cat .";"the cat chased after the ball .";"it hit the ball [%20 but missed ] .";"the ball rolled back .";"[:J red | green | blue ]";"[:J small | medium | large ]";
      };
     };
     String_Data @[5] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.2926829;
	val_type_fixed=0;
       };
      };
      name="comments";
      desc="enter words describing events -- use [ ] around optional elements (can be nested) and | between alternatives (put space around each of these) -- use %50 (no space) e.g. to specify probability of an item (will be normalized automatically)";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=420;
      ar {
       name="ar";
      [10] ;;;;;;"pronoun";"if rolled left originally, it now rolls right, etc";;;
      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [3] 8;9;0;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
      DataSortEl @[0] {
       col_name="group";
       name="group_up_0";
       order=ASCENDING;
      };
      DataSortEl @[1] {
       col_name="seq";
       name="seq_up_1";
       order=ASCENDING;
      };
      DataSortEl @[2] {
       col_name="comments";
       name="comments_up_2";
       order=ASCENDING;
      };
      DataSortEl @[3] {
       col_name="comments";
       name="comments_up_3";
       order=ASCENDING;
      };
      DataSortEl @[4] {
       col_name="comments";
       name="comments_up_4";
       order=ASCENDING;
      };
      DataSortEl @[5] {
       col_name="comments";
       name="comments_up_5";
       order=ASCENDING;
      };
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
  DataTable @[1] {
   name="Groups";
   desc=;
   data {
    name="data";
    el_typ=DataColT;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_273";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06898955;
       val_type_fixed=0;
      };
     };
     name="group";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    bool_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_274";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.03344948;
       val_type_fixed=0;
      };
     };
     name="on";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=48;
    };
    float_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_275";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.03414634;
       val_type_fixed=0;
      };
     };
     name="freq";
     desc="specify relative frequency -- will be normalized globally so you can just enter relative numbers here";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=49;
    };
    int_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_276";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.02508711;
       val_type_fixed=0;
      };
     };
     name="N";
     desc="sequencing counter -- use this to maintain order of items -- will be sorted in this order suggest using 10,20 etc to allow for future expansion";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=36;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[2] {
   name="SentenceHistory";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_273";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06944445;
       val_type_fixed=0;
      };
     };
     name="sentence";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[3] {
   name="PrevSentenceHistory";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06944445;
       val_type_fixed=0;
      };
     };
     name="sentence";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[4] {
   name="CurSentence";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    int_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_241";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="node";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_240";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="word";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    float_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_246";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="self_p";
     desc="probability of self occuring";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_274";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="cond";
     desc="conditional expression, if any";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_256";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="next";
     desc="next node after this one (for switches, after option(s) have been selected)";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_247";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="n_opts";
     desc="number of options -- > 0 for switches only";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    bool_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_244";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="mutex";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[7] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_242";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="opt_nodes";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=1;
     cell_geom{ 10;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [1] ;     };
     width=99;
    };
    float_Data @[8] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_243";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="prob";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=1;
     cell_geom{ 10;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [1] ;     };
     width=99;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[5] {
   name="PrevSentence";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    int_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="node";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="word";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    float_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="self_p";
     desc="probability of self occuring";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="cond";
     desc="conditional expression, if any";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="next";
     desc="next node after this one (for switches, after option(s) have been selected)";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="n_opts";
     desc="number of options -- > 0 for switches only";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    bool_Data @[6] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="mutex";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[7] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="opt_nodes";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=1;
     cell_geom{ 10;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [1] ;     };
     width=99;
    };
    float_Data @[8] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="prob";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=1;
     cell_geom{ 10;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [1] ;     };
     width=99;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[6] {
   name="CurSwitchStack";
   desc="stack of switches -- current one at the end";
   data {
    name="data";
    el_typ=int_Data;
    el_def=0;
    int_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_245";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="node";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    int_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.06875;
       val_type_fixed=0;
      };
     };
     name="cur_opt";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_264";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06944445;
       val_type_fixed=0;
      };
     };
     name="cur_markup";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[7] {
   name="TmpFilt";
   desc=;
   data {
    name="data";
    el_typ=DataColT;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_271";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.06898955;
       val_type_fixed=0;
      };
     };
     name="group";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    bool_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_272";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.03344948;
       val_type_fixed=0;
      };
     };
     name="on";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=48;
    };
    float_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_273";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.03414634;
       val_type_fixed=0;
      };
     };
     name="freq";
     desc="specify relative frequency -- will be normalized globally so you can just enter relative numbers here";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=49;
    };
    int_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_274";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="NARROW";
       value 1 0=1;
       val_type_fixed=0;
      };
      UserDataItem @[1] {
       name="view_panel_wd";
       value 8 0=0.02508711;
       val_type_fixed=0;
      };
     };
     name="seq";
     desc="sequencing counter -- use this to maintain order of items -- will be sorted in this order suggest using 10,20 etc to allow for future expansion";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=36;
    };
    String_Data @[4] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_275";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.4383275;
       val_type_fixed=0;
      };
     };
     name="sentence";
     desc="enter words describing events -- use [ ] around optional elements (can be nested),  | between mutually exclusive alternatives, || between non-mutex alternatives (order independent), and |> between non-mutex alternatives (order dependent) (put space around each of these) -- use %50 (no space) e.g. to specify probability of any item (will be normalized automatically if multiple alternatives";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=629;
    };
    String_Data @[5] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_276";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2926829;
       val_type_fixed=0;
      };
     };
     name="comments";
     desc="enter words describing events -- use [ ] around optional elements (can be nested) and | between alternatives (put space around each of these) -- use %50 (no space) e.g. to specify probability of an item (will be normalized automatically)";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=420;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="get_next_word";
   var_type=T_Bool;
   bool_val=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
   reference=0;
   desc="generate a single word per call, in cur_word -- otherwise generate a whole sentence, in cur_sentence";
   init_from=NULL;
  };
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="cur_story";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[0][0]$$;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[1] {
   name="last_switch";
   var_type=T_Int;
   flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[2] {
   name="last_switch_markup";
   var_type=T_String;
   flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[3] {
   name="last_eff_node";
   var_type=T_Int;
   flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[4] {
   name="prev_popped_switch";
   var_type=T_Int;
   flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[5] {
   name="cur_group";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[6] {
   name="cur_row";
   var_type=T_Int;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[7] {
   name="cur_node";
   var_type=T_Int;
   flags=CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[8] {
   name="cur_word";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="this is the return value for get_next_word = true";
   init_from=NULL;
  };
  ProgVar @[9] {
   name="cur_sentence";
   var_type=T_String;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|USED|EDIT_VAL;
   reference=0;
   desc="this is the return value for get_next_word = false";
   init_from=NULL;
  };
  ProgVar @[10] {
   name="Groups";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[1]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[11] {
   name="CurSentence";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[4]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[12] {
   name="CurSwitchStack";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[6]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[13] {
   name="TmpFilt";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[7]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[14] {
   name="Stories";
   var_type=T_Object;
   object_type=DataTable_Group;
   object_val=.projects[0].programs.gp[3][5].objs[0]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[15] {
   name="new_sentence";
   var_type=T_Bool;
   bool_val=1;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[16] {
   name="PrevSentence";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[5]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[17] {
   name="SentenceHistory";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[2]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[18] {
   name="PrevSentenceHistory";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][5].objs[3]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
  Function @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="CheckAllSentences() returns: int";
   pre_compile_code_string="CheckAllSentences() returns: int";
   name="CheckAllSentences";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_416";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (6 vars)";
     pre_compile_code_string="LocalVars (6 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="sent";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="sary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="word";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="depth";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    ForLoop @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (row = 0; row < cur_story.rows; row++)";
     pre_compile_code_string="for (row = 0; row < cur_story.rows; row++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sent = cur_story[\"sentence\"][row]";
       pre_compile_code_string="sent = cur_story[\"sentence\"][row]";
       result_var=.projects[0].programs.gp[3][5].functions[0].fun_code[0].local_vars[1]$$;
       expr {
	expr="cur_story[\"sentence\"][row]";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sary->Split(sent, \" \")";
       pre_compile_code_string="sary->Split(sent, \" \")";
       result_var=NULL;
       obj=.projects[0].programs.gp[3][5].functions[0].fun_code[0].local_vars[2]$$;
       method=String_Array::Split;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="str";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="sent";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="delim";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\" \"";
	 };
	};
       };
       meth_sig="void Split(taString& str, taString& delim)";
       meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
      };
      AssignExpr @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="depth = 0";
       pre_compile_code_string="depth = 0";
       result_var=.projects[0].programs.gp[3][5].functions[0].fun_code[0].local_vars[5]$$;
       expr {
	expr="0";
       };
      };
      ForLoop @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i=0; i<sary.size; i++)";
       pre_compile_code_string="for (i=0; i<sary.size; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="word = sary[i]";
	 pre_compile_code_string="word = sary[i]";
	 result_var=.projects[0].programs.gp[3][5].functions[0].fun_code[0].local_vars[4]$$;
	 expr {
	  expr="sary[i]";
	 };
	};
	If @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (word.endsWith(\"]\") && !word.startsWith(\"]\"))";
	 pre_compile_code_string="if (word.endsWith(\"]\") && !word.startsWith(\"]\"))";
	 cond {
	  expr="word.endsWith(\"]\") && !word.startsWith(\"]\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MiscCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taMisc::Error(\"end of switch group ] must have space in front of it, in sentence:\", sent, \"word:\", word, , , , , )";
	   pre_compile_code_string="taMisc::Error(\"end of switch group ] must have space in front of it, in sentence:\", sent, \"word:\", word, , , , , )";
	   result_var=NULL;
	   object_type=taMisc;
	   method=taMisc::Error;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="a";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"end of switch group ] must have space in front of it, in sentence:\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="b";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="sent";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="c";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="\"word:\"";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="d";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="word";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="e";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="f";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="g";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="h";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[8] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="i";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	};
	If @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (word.endsWith(\"|\") && !word.startsWith(\"|\"))";
	 pre_compile_code_string="if (word.endsWith(\"|\") && !word.startsWith(\"|\"))";
	 cond {
	  expr="word.endsWith(\"|\") && !word.startsWith(\"|\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MiscCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taMisc::Error(\"option | must have space in front of it, in sentence:\", sent, \"word:\", word, , , , , )";
	   pre_compile_code_string="taMisc::Error(\"option | must have space in front of it, in sentence:\", sent, \"word:\", word, , , , , )";
	   result_var=NULL;
	   object_type=taMisc;
	   method=taMisc::Error;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="a";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"option | must have space in front of it, in sentence:\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="b";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="sent";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="c";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="\"word:\"";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="d";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="word";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="e";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="f";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="g";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="h";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[8] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="i";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	};
	If @[3] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (word.endsWith(\"[\") && !word.startsWith(\"[\"))";
	 pre_compile_code_string="if (word.endsWith(\"[\") && !word.startsWith(\"[\"))";
	 cond {
	  expr="word.endsWith(\"[\") && !word.startsWith(\"[\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MiscCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taMisc::Error(\"start of switch group [ must have space in front of it, in sentence:\", sent, \"word:\", word, , , , , )";
	   pre_compile_code_string="taMisc::Error(\"start of switch group [ must have space in front of it, in sentence:\", sent, \"word:\", word, , , , , )";
	   result_var=NULL;
	   object_type=taMisc;
	   method=taMisc::Error;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="a";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"start of switch group [ must have space in front of it, in sentence:\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="b";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="sent";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="c";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="\"word:\"";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="d";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="word";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="e";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="f";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="g";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="h";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[8] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="i";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	};
	If @[4] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (word.startsWith(\"[\"))";
	 pre_compile_code_string="if (word.startsWith(\"[\"))";
	 cond {
	  expr="word.startsWith(\"[\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  VarIncr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="depth += 1";
	   pre_compile_code_string="depth += 1";
	   var=$.projects[0].programs.gp[3][5].functions[0].fun_code[0].local_vars[5]$;
	   expr {
	    expr="1";
	   };
	  };
	 };
	};
	If @[5] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (word.startsWith(\"]\"))";
	 pre_compile_code_string="if (word.startsWith(\"]\"))";
	 cond {
	  expr="word.startsWith(\"]\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  VarIncr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="depth += -1";
	   pre_compile_code_string="depth += -1";
	   var=$.projects[0].programs.gp[3][5].functions[0].fun_code[0].local_vars[5]$;
	   expr {
	    expr="-1";
	   };
	  };
	 };
	};
       };
       init {
	expr="i=0";
       };
       test {
	expr="i<sary.size";
       };
       iter {
	expr="i++";
       };
      };
      If @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (depth != 0)";
       pre_compile_code_string="if (depth != 0)";
       cond {
	expr="depth != 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MiscCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="taMisc::Error(\"depth is:\", depth, \"at end of sentence -- imbalanced switch groups, in:\", sent, , , , , )";
	 pre_compile_code_string="taMisc::Error(\"depth is:\", depth, \"at end of sentence -- imbalanced switch groups, in:\", sent, , , , , )";
	 result_var=NULL;
	 object_type=taMisc;
	 method=taMisc::Error;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="a";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"depth is:\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="b";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="depth";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="c";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="\"at end of sentence -- imbalanced switch groups, in:\"";
	   };
	  };
	  ProgArg @[3] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="d";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="sent";
	   };
	  };
	  ProgArg @[4] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="e";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[5] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="f";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[6] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="g";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[7] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="h";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[8] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="i";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	};
       };
      };
     };
     init {
      expr="row = 0";
     };
     test {
      expr="row < cur_story.rows";
     };
     iter {
      expr="row++";
     };
    };
   };
  };
  Function @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="InitCurStory() returns: int";
   pre_compile_code_string="InitCurStory() returns: int";
   name="InitCurStory";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_346";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    FunctionCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CheckAllSentences()";
     pre_compile_code_string="CheckAllSentences()";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][5].functions[0]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_story->Sort(\"group\", true, \"seq\", true, , , , , , , , )";
     pre_compile_code_string="cur_story->Sort(\"group\", true, \"seq\", true, , , , , , , , )";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].vars[0]$$;
     method=DataTable::Sort;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"group\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="ascending1";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[2] {
       arg_type=Variant;
       type="Variant";
       name="col2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="\"seq\"";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="ascending2";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[4] {
       arg_type=Variant;
       type="Variant";
       name="col3";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=bool;
       type="bool";
       name="ascending3";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=Variant;
       type="Variant";
       name="col4";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=bool;
       type="bool";
       name="ascending4";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=Variant;
       type="Variant";
       name="col5";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=bool;
       type="bool";
       name="ascending5";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=Variant;
       type="Variant";
       name="col6";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=bool;
       type="bool";
       name="ascending6";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void Sort(Variant& col1, bool ascending1 = true, Variant col2 = -1, bool ascending2 = true, Variant col3 = -1, bool ascending3 = true, Variant col4 = -1, bool ascending4 = true, Variant col5 = -1, bool ascending5 = true, Variant col6 = -1, bool ascending6 = true)";
     meth_desc=" sort table according to selected columns of data. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this sort you would need to run Flatten first";
    };
    DataSelectRowsProg @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="SelectRows:  src table = cur_story  dest table = TmpFilt  comb_op = AND";
     pre_compile_code_string="SelectRows:  src table = cur_story  dest table = TmpFilt  comb_op = AND";
     src_data_var=$.projects[0].programs.gp[3][5].vars[0]$;
     dest_data_var=.projects[0].programs.gp[3][5].vars[13]$$;
     select_spec {
      name="select_spec";
      ops {
       name="ops";
       el_typ=DataSelectEl;
       el_def=0;
       DataSelectEl @[0] {
	col_name="on";
	name="on_EQUAL_true_0";
	on=1;
	rel=EQUAL;
	use_var=0;
	cmp 1 0=1;
	var=NULL;
	enable_var=NULL;
       };
      };
      comb_op=AND;
     };
    };
    DataGroupProg @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Group from:  src table = TmpFilt dest table = Groups";
     pre_compile_code_string="Group from:  src table = TmpFilt dest table = Groups";
     src_data_var=$.projects[0].programs.gp[3][5].vars[13]$;
     dest_data_var=.projects[0].programs.gp[3][5].vars[10]$$;
     group_spec {
      name="group_spec";
      ops {
       name="ops";
       el_typ=DataGroupEl;
       el_def=0;
       DataGroupEl @[0] {
	col_name="group";
	name="group_GROUP_0";
	agg {name="agg": op=GROUP: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[1] {
	col_name="on";
	name="on_FIRST_1";
	agg {name="agg": op=FIRST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[2] {
	col_name="freq";
	name="freq_FIRST_2";
	agg {name="agg": op=FIRST: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
       DataGroupEl @[3] {
	col_name="seq";
	name="seq_N_3";
	agg {name="agg": op=N: rel={name="rel": rel=LESSTHANOREQUAL: val=0: use_var=0: var=NULL: }: };
       };
      };
      append_agg_name=0;
     };
    };
    MathCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="taMath_float::vec_norm_sum(Groups.data.freq.ar, 1.0, 0.0)";
     pre_compile_code_string="taMath_float::vec_norm_sum(Groups.data.freq.ar, 1.0, 0.0)";
     result_var=NULL;
     object_type=taMath_float;
     method=taMath_float::vec_norm_sum;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=float_Matrix_ptr;
       type="float_Matrix*";
       name="vec";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Groups.data.freq.ar";
       };
      };
      ProgArg @[1] {
       arg_type=float;
       type="float";
       name="sum";
       required=0;
       def_val="1.0f";
       prev_expr=;
       expr {
	expr="1.0";
       };
      };
      ProgArg @[2] {
       arg_type=float;
       type="float";
       name="min_val";
       required=0;
       def_val="0.0f";
       prev_expr=;
       expr {
	expr="0.0";
       };
      };
     };
    };
   };
  };
  Function @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetStripProb(String& word) returns: String";
   pre_compile_code_string="GetStripProb(String& word) returns: String";
   name="GetStripProb";
   return_type=T_String;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="pstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.contains(\"%\"))";
     pre_compile_code_string="if (word.contains(\"%\"))";
     cond {
      expr="word.contains(\"%\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="pstr = word->from(\"%\", )";
       pre_compile_code_string="pstr = word->from(\"%\", )";
       result_var=.projects[0].programs.gp[3][5].functions[2].fun_code[0].local_vars[0]$$;
       obj=.projects[0].programs.gp[3][5].functions[2].args[0]$$;
       method=taString::from;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"%\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString from(taString& x, int startpos = 0)";
       meth_desc=" get substring from (including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="word = word->before(\"%\", )";
       pre_compile_code_string="word = word->before(\"%\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[2].args[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[2].args[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"%\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
     };
    };
    ReturnExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return pstr";
     pre_compile_code_string="return pstr";
     expr {
      expr="pstr";
     };
    };
   };
  };
  Function @[3] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetProb(String word) returns: double";
   pre_compile_code_string="GetProb(String word) returns: double";
   name="GetProb";
   return_type=T_Real;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prob = 100";
     pre_compile_code_string="prob = 100";
     result_var=.projects[0].programs.gp[3][5].functions[3].fun_code[0].local_vars[0]$$;
     expr {
      expr="100";
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.contains(\"%\"))";
     pre_compile_code_string="if (word.contains(\"%\"))";
     cond {
      expr="word.contains(\"%\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="prob = (float)word.after(\"%\")";
       pre_compile_code_string="prob = (float)word.after(\"%\")";
       result_var=$.projects[0].programs.gp[3][5].functions[3].fun_code[0].local_vars[0]$;
       expr {
	expr="(float)word.after(\"%\")";
       };
      };
     };
    };
    ReturnExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return prob";
     pre_compile_code_string="return prob";
     expr {
      expr="prob";
     };
    };
   };
  };
  Function @[4] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetStripCond(String& word) returns: String";
   pre_compile_code_string="GetStripCond(String& word) returns: String";
   name="GetStripCond";
   return_type=T_String;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="cstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.freq(\"?\") == 2)";
     pre_compile_code_string="if (word.freq(\"?\") == 2)";
     cond {
      expr="word.freq(\"?\") == 2";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cstr = word->after(\"?\", )";
       pre_compile_code_string="cstr = word->after(\"?\", )";
       result_var=.projects[0].programs.gp[3][5].functions[4].fun_code[0].local_vars[0]$$;
       obj=.projects[0].programs.gp[3][5].functions[4].args[0]$$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"?\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cstr = cstr->before(\"?\", -1)";
       pre_compile_code_string="cstr = cstr->before(\"?\", -1)";
       result_var=$.projects[0].programs.gp[3][5].functions[4].fun_code[0].local_vars[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[4].fun_code[0].local_vars[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"?\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="-1";
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="word = word->before(\"?\", )";
       pre_compile_code_string="word = word->before(\"?\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[4].args[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[4].args[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"?\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
     };
    };
    ReturnExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return cstr";
     pre_compile_code_string="return cstr";
     expr {
      expr="cstr";
     };
    };
   };
  };
  Function @[5] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetStripProbCond(String& word, String& probstr, String& condstr) returns: double";
   pre_compile_code_string="GetStripProbCond(String& word, String& probstr, String& condstr) returns: double";
   name="GetStripProbCond";
   return_type=T_Real;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="probstr";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="condstr";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_473";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    FunctionCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="condstr = GetStripCond(word)";
     pre_compile_code_string="condstr = GetStripCond(word)";
     result_var=.projects[0].programs.gp[3][5].functions[5].args[2]$$;
     fun=.projects[0].programs.gp[3][5].functions[4]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="word";
       };
      };
     };
    };
    FunctionCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="probstr = GetStripProb(word)";
     pre_compile_code_string="probstr = GetStripProb(word)";
     result_var=.projects[0].programs.gp[3][5].functions[5].args[1]$$;
     fun=.projects[0].programs.gp[3][5].functions[2]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="word";
       };
      };
     };
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (probstr.nonempty())";
     pre_compile_code_string="if (probstr.nonempty())";
     cond {
      expr="probstr.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="prob = (float)probstr->after(\"%\")";
       pre_compile_code_string="prob = (float)probstr->after(\"%\")";
       result_var=.projects[0].programs.gp[3][5].functions[5].fun_code[0].local_vars[0]$$;
       expr {
	expr="(float)probstr->after(\"%\")";
       };
      };
     };
    };
    Else @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="prob = 100";
       pre_compile_code_string="prob = 100";
       result_var=$.projects[0].programs.gp[3][5].functions[5].fun_code[0].local_vars[0]$;
       expr {
	expr="100";
       };
      };
     };
    };
    ReturnExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return prob";
     pre_compile_code_string="return prob";
     expr {
      expr="prob";
     };
    };
   };
  };
  Function @[6] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetWordMarkup(String word) returns: String";
   pre_compile_code_string="GetWordMarkup(String word) returns: String";
   name="GetWordMarkup";
   return_type=T_String;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="markup";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.contains(\":\"))";
     pre_compile_code_string="if (word.contains(\":\"))";
     cond {
      expr="word.contains(\":\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="markup = word->from(\":\", )";
       pre_compile_code_string="markup = word->from(\":\", )";
       result_var=.projects[0].programs.gp[3][5].functions[6].fun_code[0].local_vars[0]$$;
       obj=.projects[0].programs.gp[3][5].functions[6].args[0]$$;
       method=taString::from;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\":\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString from(taString& x, int startpos = 0)";
       meth_desc=" get substring from (including) target string. startpos = starting position (- = search from end forward)";
      };
     };
    };
    ReturnExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return markup";
     pre_compile_code_string="return markup";
     expr {
      expr="markup";
     };
    };
   };
  };
  Function @[7] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetStripWordMarkup(String& word) returns: String";
   pre_compile_code_string="GetStripWordMarkup(String& word) returns: String";
   name="GetStripWordMarkup";
   return_type=T_String;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=1;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="markup";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.contains(\":\"))";
     pre_compile_code_string="if (word.contains(\":\"))";
     cond {
      expr="word.contains(\":\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="markup = word->from(\":\", )";
       pre_compile_code_string="markup = word->from(\":\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[6].fun_code[0].local_vars[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[6].args[0]$;
       method=taString::from;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\":\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString from(taString& x, int startpos = 0)";
       meth_desc=" get substring from (including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="word = word->before(\":\", )";
       pre_compile_code_string="word = word->before(\":\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[6].args[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[6].args[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\":\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
     };
    };
    ReturnExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return markup";
     pre_compile_code_string="return markup";
     expr {
      expr="markup";
     };
    };
   };
  };
  Function @[8] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddPlainWord(String word) returns: int";
   pre_compile_code_string="AddPlainWord(String word) returns: int";
   name="AddPlainWord";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_356";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="node";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="bareword";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="condstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="probstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prev_popped_switch = -1";
     pre_compile_code_string="prev_popped_switch = -1";
     result_var=.projects[0].programs.gp[3][5].vars[4]$$;
     expr {
      expr="-1";
     };
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="node = CurSentence.rows";
     pre_compile_code_string="node = CurSentence.rows";
     result_var=.projects[0].programs.gp[3][5].functions[8].fun_code[0].local_vars[0]$$;
     expr {
      expr="CurSentence.rows";
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_eff_node = node";
     pre_compile_code_string="last_eff_node = node";
     result_var=.projects[0].programs.gp[3][5].vars[3]$$;
     expr {
      expr="node";
     };
    };
    AssignExpr @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="bareword = word";
     pre_compile_code_string="bareword = word";
     result_var=.projects[0].programs.gp[3][5].functions[8].fun_code[0].local_vars[1]$$;
     expr {
      expr="word";
     };
    };
    FunctionCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prob = GetStripProbCond(bareword, probstr, condstr)";
     pre_compile_code_string="prob = GetStripProbCond(bareword, probstr, condstr)";
     result_var=.projects[0].programs.gp[3][5].functions[8].fun_code[0].local_vars[4]$$;
     fun=.projects[0].programs.gp[3][5].functions[5]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="bareword";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="probstr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="probstr";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="condstr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="condstr";
       };
      };
     };
    };
    If @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (!bareword.contains(\":\"))";
     pre_compile_code_string="if (!bareword.contains(\":\"))";
     cond {
      expr="!bareword.contains(\":\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      VarIncr @[0] {
       desc="auto-apply markup only if none already";
       flags=CAN_REVERT_TO_CODE;
       code_string="bareword += last_switch_markup";
       pre_compile_code_string="bareword += last_switch_markup";
       var=$.projects[0].programs.gp[3][5].functions[8].fun_code[0].local_vars[1]$;
       expr {
	expr="last_switch_markup";
       };
      };
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence->AddBlankRow()";
     pre_compile_code_string="CurSentence->AddBlankRow()";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].vars[11]$$;
     method=DataTable::AddBlankRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int AddBlankRow()";
     meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
    };
    MatrixAssign @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"node\"][node] = node";
     pre_compile_code_string="CurSentence[\"node\"][node] = node";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"node\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="node";
     };
    };
    MatrixAssign @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"word\"][node] = bareword";
     pre_compile_code_string="CurSentence[\"word\"][node] = bareword";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"word\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="bareword";
     };
    };
    MatrixAssign @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"self_p\"][node] = prob";
     pre_compile_code_string="CurSentence[\"self_p\"][node] = prob";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"self_p\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="prob";
     };
    };
    MatrixAssign @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"cond\"][node] = condstr";
     pre_compile_code_string="CurSentence[\"cond\"][node] = condstr";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"cond\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="condstr";
     };
    };
    MatrixAssign @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"next\"][node] = node+1";
     pre_compile_code_string="CurSentence[\"next\"][node] = node+1";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"next\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="node+1";
     };
    };
    MatrixAssign @[13] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"n_opts\"][node] = 0";
     pre_compile_code_string="CurSentence[\"n_opts\"][node] = 0";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"n_opts\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="0";
     };
    };
    ReturnExpr @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return node";
     pre_compile_code_string="return node";
     expr {
      expr="node";
     };
    };
   };
  };
  Function @[9] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddSwitch(String word) returns: int";
   pre_compile_code_string="AddSwitch(String word) returns: int";
   name="AddSwitch";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (6 vars)";
     pre_compile_code_string="LocalVars (6 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="node";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="markup";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="bareword";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="condstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="probstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prev_popped_switch = -1";
     pre_compile_code_string="prev_popped_switch = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[4]$;
     expr {
      expr="-1";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence->AddBlankRow()";
     pre_compile_code_string="CurSentence->AddBlankRow()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[11]$;
     method=DataTable::AddBlankRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int AddBlankRow()";
     meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="node = CurSentence.rows - 1";
     pre_compile_code_string="node = CurSentence.rows - 1";
     result_var=$.projects[0].programs.gp[3][5].functions[8].fun_code[0].local_vars[0]$;
     expr {
      expr="CurSentence.rows - 1";
     };
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack->AddBlankRow()";
     pre_compile_code_string="CurSwitchStack->AddBlankRow()";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].vars[12]$$;
     method=DataTable::AddBlankRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int AddBlankRow()";
     meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="bareword = word";
     pre_compile_code_string="bareword = word";
     result_var=.projects[0].programs.gp[3][5].functions[9].fun_code[0].local_vars[2]$$;
     expr {
      expr="word";
     };
    };
    FunctionCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prob = GetStripProbCond(bareword, probstr, condstr)";
     pre_compile_code_string="prob = GetStripProbCond(bareword, probstr, condstr)";
     result_var=.projects[0].programs.gp[3][5].functions[9].fun_code[0].local_vars[5]$$;
     fun=$.projects[0].programs.gp[3][5].functions[5]$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="bareword";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="probstr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="probstr";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="condstr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="condstr";
       };
      };
     };
    };
    FunctionCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="markup = GetWordMarkup(bareword)";
     pre_compile_code_string="markup = GetWordMarkup(bareword)";
     result_var=.projects[0].programs.gp[3][5].functions[9].fun_code[0].local_vars[1]$$;
     fun=.projects[0].programs.gp[3][5].functions[6]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="bareword";
       };
      };
     };
    };
    MatrixAssign @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack[\"node\"][-1] = node";
     pre_compile_code_string="CurSwitchStack[\"node\"][-1] = node";
     variable=$.projects[0].programs.gp[3][5].vars[12]$;
     data_table=1;
     col {
      expr="\"node\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="node";
     };
    };
    MatrixAssign @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack[\"cur_markup\"][-1] = markup";
     pre_compile_code_string="CurSwitchStack[\"cur_markup\"][-1] = markup";
     variable=$.projects[0].programs.gp[3][5].vars[12]$;
     data_table=1;
     col {
      expr="\"cur_markup\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="markup";
     };
    };
    AssignExpr @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch = node";
     pre_compile_code_string="last_switch = node";
     result_var=.projects[0].programs.gp[3][5].vars[1]$$;
     expr {
      expr="node";
     };
    };
    AssignExpr @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch_markup = markup";
     pre_compile_code_string="last_switch_markup = markup";
     result_var=.projects[0].programs.gp[3][5].vars[2]$$;
     expr {
      expr="markup";
     };
    };
    AssignExpr @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_eff_node = node";
     pre_compile_code_string="last_eff_node = node";
     result_var=$.projects[0].programs.gp[3][5].vars[3]$;
     expr {
      expr="node";
     };
    };
    MatrixAssign @[13] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"node\"][node] = node";
     pre_compile_code_string="CurSentence[\"node\"][node] = node";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"node\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="node";
     };
    };
    MatrixAssign @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"word\"][node] = bareword";
     pre_compile_code_string="CurSentence[\"word\"][node] = bareword";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"word\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="bareword";
     };
    };
    MatrixAssign @[15] {
     desc="no next by default";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"next\"][node] = -1";
     pre_compile_code_string="CurSentence[\"next\"][node] = -1";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"next\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="-1";
     };
    };
    MatrixAssign @[16] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"self_p\"][node] = prob";
     pre_compile_code_string="CurSentence[\"self_p\"][node] = prob";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"self_p\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="prob";
     };
    };
    MatrixAssign @[17] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"cond\"][node] = condstr";
     pre_compile_code_string="CurSentence[\"cond\"][node] = condstr";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"cond\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="condstr";
     };
    };
    MatrixAssign @[18] {
     desc="assume true until proven otherwise";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"mutex\"][node] = true";
     pre_compile_code_string="CurSentence[\"mutex\"][node] = true";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"mutex\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="true";
     };
    };
    MatrixAssign @[19] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"n_opts\"][node] = 1";
     pre_compile_code_string="CurSentence[\"n_opts\"][node] = 1";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"n_opts\"";
     };
     dim0 {
      expr="node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="1";
     };
    };
    MatrixAssign @[20] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"opt_nodes\"][0,node] = node+1";
     pre_compile_code_string="CurSentence[\"opt_nodes\"][0,node] = node+1";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"opt_nodes\"";
     };
     dim0 {
      expr="0";
     };
     dim1 {
      expr="node";
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="node+1";
     };
    };
    MatrixAssign @[21] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"prob\"][0,node] = 100.0";
     pre_compile_code_string="CurSentence[\"prob\"][0,node] = 100.0";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"prob\"";
     };
     dim0 {
      expr="0";
     };
     dim1 {
      expr="node";
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="100.0";
     };
    };
    ReturnExpr @[22] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return node";
     pre_compile_code_string="return node";
     expr {
      expr="node";
     };
    };
   };
  };
  Function @[10] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="PopSwitchStack() returns: int";
   pre_compile_code_string="PopSwitchStack() returns: int";
   name="PopSwitchStack";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_412";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="ss_row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ss_row = CurSwitchStack.rows-1";
     pre_compile_code_string="ss_row = CurSwitchStack.rows-1";
     result_var=.projects[0].programs.gp[3][5].functions[10].fun_code[0].local_vars[0]$$;
     expr {
      expr="CurSwitchStack.rows-1";
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack->RemoveRows(ss_row, 1)";
     pre_compile_code_string="CurSwitchStack->RemoveRows(ss_row, 1)";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[12]$;
     method=DataTable::RemoveRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="st_row";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="ss_row";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="n_rows";
       required=0;
       def_val="1";
       prev_expr=;
       expr {
	expr="1";
       };
      };
     };
     meth_sig="bool RemoveRows(int st_row, int n_rows = 1)";
     meth_desc=" Remove n rows of data, starting at st_row. st_row = -1 means last row, and n_rows = -1 means remove from starting row to end";
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (ss_row > 0)";
     pre_compile_code_string="if (ss_row > 0)";
     cond {
      expr="ss_row > 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="last_switch = CurSwitchStack[\"node\"][ss_row-1]";
       pre_compile_code_string="last_switch = CurSwitchStack[\"node\"][ss_row-1]";
       result_var=$.projects[0].programs.gp[3][5].vars[1]$;
       expr {
	expr="CurSwitchStack[\"node\"][ss_row-1]";
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="last_switch_markup = CurSwitchStack[\"cur_markup\"][ss_row-1]";
       pre_compile_code_string="last_switch_markup = CurSwitchStack[\"cur_markup\"][ss_row-1]";
       result_var=$.projects[0].programs.gp[3][5].vars[2]$;
       expr {
	expr="CurSwitchStack[\"cur_markup\"][ss_row-1]";
       };
      };
     };
    };
    Else @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="last_switch = -1";
       pre_compile_code_string="last_switch = -1";
       result_var=$.projects[0].programs.gp[3][5].vars[1]$;
       expr {
	expr="-1";
       };
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="last_switch_markup = \"\"";
       pre_compile_code_string="last_switch_markup = \"\"";
       result_var=$.projects[0].programs.gp[3][5].vars[2]$;
       expr {
	expr="\"\"";
       };
      };
     };
    };
    PrintVar @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"popped switch stack:\" ss_row last_switch";
     pre_compile_code_string="Print  \"popped switch stack:\" ss_row last_switch";
     message="popped switch stack:";
     print_var=$.projects[0].programs.gp[3][5].functions[10].fun_code[0].local_vars[0]$;
     print_var2=$.projects[0].programs.gp[3][5].vars[1]$;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
   };
  };
  Function @[11] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="EndSwitch() returns: int";
   pre_compile_code_string="EndSwitch() returns: int";
   name="EndSwitch";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_367";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="ss_row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="node";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="n_opts";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="probs";
       var_type=T_Object;
       object_type=float_Matrix;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="mutex";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (last_switch < 0)";
     pre_compile_code_string="if (last_switch < 0)";
     cond {
      expr="last_switch < 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Error(\"end switch without corresponding start switch!\", , , , , , , , )";
       pre_compile_code_string="taMisc::Error(\"end switch without corresponding start switch!\", , , , , , , , )";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"end switch without corresponding start switch!\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="b";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="c";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="d";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="e";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="f";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="g";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="h";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="i";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="node = CurSentence.rows";
     pre_compile_code_string="node = CurSentence.rows";
     result_var=.projects[0].programs.gp[3][5].functions[11].fun_code[0].local_vars[1]$$;
     expr {
      expr="CurSentence.rows";
     };
    };
    MatrixAssign @[3] {
     desc="last guy has no next -- forces jump up to switch";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"next\"][node-1] = -1";
     pre_compile_code_string="CurSentence[\"next\"][node-1] = -1";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"next\"";
     };
     dim0 {
      expr="node-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="-1";
     };
    };
    MatrixAssign @[4] {
     desc="this is the next one after end of switch";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"next\"][last_switch] = node";
     pre_compile_code_string="CurSentence[\"next\"][last_switch] = node";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"next\"";
     };
     dim0 {
      expr="last_switch";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="node";
     };
    };
    If @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (prev_popped_switch > 0)";
     pre_compile_code_string="if (prev_popped_switch > 0)";
     cond {
      expr="prev_popped_switch > 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MatrixAssign @[0] {
       desc="this guy is a dead end and must pop up now!";
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"next\"][prev_popped_switch] = -1";
       pre_compile_code_string="CurSentence[\"next\"][prev_popped_switch] = -1";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"next\"";
       };
       dim0 {
	expr="prev_popped_switch";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="-1";
       };
      };
     };
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="n_opts = CurSentence[\"n_opts\"][last_switch]";
     pre_compile_code_string="n_opts = CurSentence[\"n_opts\"][last_switch]";
     result_var=.projects[0].programs.gp[3][5].functions[11].fun_code[0].local_vars[2]$$;
     expr {
      expr="CurSentence[\"n_opts\"][last_switch]";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="mutex = CurSentence[\"mutex\"][last_switch]";
     pre_compile_code_string="mutex = CurSentence[\"mutex\"][last_switch]";
     result_var=.projects[0].programs.gp[3][5].functions[11].fun_code[0].local_vars[4]$$;
     expr {
      expr="CurSentence[\"mutex\"][last_switch]";
     };
    };
    If @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (mutex)";
     pre_compile_code_string="if (mutex)";
     cond {
      expr="mutex";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="probs = CurSentence->GetValAsMatrix(\"prob\", last_switch)";
       pre_compile_code_string="probs = CurSentence->GetValAsMatrix(\"prob\", last_switch)";
       result_var=.projects[0].programs.gp[3][5].functions[11].fun_code[0].local_vars[3]$$;
       obj=$.projects[0].programs.gp[3][5].vars[11]$;
       method=DataTable::GetValAsMatrix;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"prob\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="row";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="last_switch";
	 };
	};
       };
       meth_sig="taMatrix_ptr GetValAsMatrix(Variant& col, int row)";
       meth_desc=" get data of matrix type (multi-dimensional data within a given cell), in Matrix form, for given column, row; for Program usage, assign to a LocalVars Matrix* variable, NOT a global vars variable, at the appropriate scope where the matrix will be used, (e.g., if within a loop, put variable in the loop_code of the loop), so that the local variable will be deleted automatically, to free the memory associated with the Matrix when it is no longer needed";
      };
      MathCall @[1] {
       desc="normalize probabilities";
       flags=CAN_REVERT_TO_CODE;
       code_string="taMath_float::vec_norm_sum(probs, 1.0, 0.0)";
       pre_compile_code_string="taMath_float::vec_norm_sum(probs, 1.0, 0.0)";
       result_var=NULL;
       object_type=taMath_float;
       method=taMath_float::vec_norm_sum;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=float_Matrix_ptr;
	 type="float_Matrix*";
	 name="vec";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="probs";
	 };
	};
	ProgArg @[1] {
	 arg_type=float;
	 type="float";
	 name="sum";
	 required=0;
	 def_val="1.0f";
	 prev_expr=;
	 expr {
	  expr="1.0";
	 };
	};
	ProgArg @[2] {
	 arg_type=float;
	 type="float";
	 name="min_val";
	 required=0;
	 def_val="0.0f";
	 prev_expr=;
	 expr {
	  expr="0.0";
	 };
	};
       };
      };
     };
    };
    AssignExpr @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prev_popped_switch = last_switch";
     pre_compile_code_string="prev_popped_switch = last_switch";
     result_var=$.projects[0].programs.gp[3][5].vars[4]$;
     expr {
      expr="last_switch";
     };
    };
    AssignExpr @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_eff_node = last_switch";
     pre_compile_code_string="last_eff_node = last_switch";
     result_var=$.projects[0].programs.gp[3][5].vars[3]$;
     expr {
      expr="last_switch";
     };
    };
    FunctionCall @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="PopSwitchStack()";
     pre_compile_code_string="PopSwitchStack()";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][5].functions[10]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
  };
  Function @[12] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddOption(String word) returns: int";
   pre_compile_code_string="AddOption(String word) returns: int";
   name="AddOption";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="node";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="n_opts";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (last_switch < 0)";
     pre_compile_code_string="if (last_switch < 0)";
     cond {
      expr="last_switch < 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Error(\"option without switch!\", , , , , , , , )";
       pre_compile_code_string="taMisc::Error(\"option without switch!\", , , , , , , , )";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"option without switch!\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="b";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="c";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="d";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="e";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="f";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="g";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="h";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="i";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prev_popped_switch = -1";
     pre_compile_code_string="prev_popped_switch = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[4]$;
     expr {
      expr="-1";
     };
    };
    MatrixAssign @[3] {
     desc="last guy has no next -- forces jump up to switch";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence[\"next\"][last_eff_node] = -1";
     pre_compile_code_string="CurSentence[\"next\"][last_eff_node] = -1";
     variable=$.projects[0].programs.gp[3][5].vars[11]$;
     data_table=1;
     col {
      expr="\"next\"";
     };
     dim0 {
      expr="last_eff_node";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="-1";
     };
    };
    AssignExpr @[4] {
     desc="will be the next guy -- we don't explicitly add options";
     flags=CAN_REVERT_TO_CODE;
     code_string="node = CurSentence.rows";
     pre_compile_code_string="node = CurSentence.rows";
     result_var=.projects[0].programs.gp[3][5].functions[12].fun_code[0].local_vars[0]$$;
     expr {
      expr="CurSentence.rows";
     };
    };
    If @[5] {
     desc="we are an option before any other items -- just modify probability of first item";
     flags=CAN_REVERT_TO_CODE;
     code_string="if (last_switch == node-1)";
     pre_compile_code_string="if (last_switch == node-1)";
     cond {
      expr="last_switch == node-1";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MatrixAssign @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"prob\"][0,last_switch] = GetProb(word)";
       pre_compile_code_string="CurSentence[\"prob\"][0,last_switch] = GetProb(word)";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"prob\"";
       };
       dim0 {
	expr="0";
       };
       dim1 {
	expr="last_switch";
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="GetProb(word)";
       };
      };
     };
    };
    Else @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="n_opts = CurSentence[\"n_opts\"][last_switch]";
       pre_compile_code_string="n_opts = CurSentence[\"n_opts\"][last_switch]";
       result_var=.projects[0].programs.gp[3][5].functions[12].fun_code[0].local_vars[1]$$;
       expr {
	expr="CurSentence[\"n_opts\"][last_switch]";
       };
      };
      MatrixAssign @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"opt_nodes\"][n_opts,last_switch] = node";
       pre_compile_code_string="CurSentence[\"opt_nodes\"][n_opts,last_switch] = node";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"opt_nodes\"";
       };
       dim0 {
	expr="n_opts";
       };
       dim1 {
	expr="last_switch";
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="node";
       };
      };
      MatrixAssign @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"prob\"][n_opts,last_switch] = GetProb(word)";
       pre_compile_code_string="CurSentence[\"prob\"][n_opts,last_switch] = GetProb(word)";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"prob\"";
       };
       dim0 {
	expr="n_opts";
       };
       dim1 {
	expr="last_switch";
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="GetProb(word)";
       };
      };
      VarIncr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="n_opts += 1";
       pre_compile_code_string="n_opts += 1";
       var=$.projects[0].programs.gp[3][5].functions[12].fun_code[0].local_vars[1]$;
       expr {
	expr="1";
       };
      };
      MatrixAssign @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"n_opts\"][last_switch] = n_opts";
       pre_compile_code_string="CurSentence[\"n_opts\"][last_switch] = n_opts";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"n_opts\"";
       };
       dim0 {
	expr="last_switch";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="n_opts";
       };
      };
     };
    };
    If @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.startsWith(\"||\"))";
     pre_compile_code_string="if (word.startsWith(\"||\"))";
     cond {
      expr="word.startsWith(\"||\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MatrixAssign @[0] {
       desc="proven otherwise";
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"mutex\"][last_switch] = false";
       pre_compile_code_string="CurSentence[\"mutex\"][last_switch] = false";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"mutex\"";
       };
       dim0 {
	expr="last_switch";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="false";
       };
      };
     };
    };
    Else @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      MatrixAssign @[0] {
       desc="mutex";
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSentence[\"mutex\"][last_switch] = true";
       pre_compile_code_string="CurSentence[\"mutex\"][last_switch] = true";
       variable=$.projects[0].programs.gp[3][5].vars[11]$;
       data_table=1;
       col {
	expr="\"mutex\"";
       };
       dim0 {
	expr="last_switch";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="true";
       };
      };
     };
    };
    ReturnExpr @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return node";
     pre_compile_code_string="return node";
     expr {
      expr="node";
     };
    };
   };
  };
  Function @[13] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddMacro(String word) returns: int";
   pre_compile_code_string="AddMacro(String word) returns: int";
   name="AddMacro";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_446";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (9 vars)";
     pre_compile_code_string="LocalVars (9 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="mac_row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="markup";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="probstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="condstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="mac_str";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="msary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="mword";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    FunctionCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prob = GetStripProbCond(word, probstr, condstr)";
     pre_compile_code_string="prob = GetStripProbCond(word, probstr, condstr)";
     result_var=.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[4]$$;
     fun=$.projects[0].programs.gp[3][5].functions[5]$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="word";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="probstr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="probstr";
       };
      };
      ProgArg @[2] {
       arg_type=taString;
       type="String";
       name="condstr";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="condstr";
       };
      };
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="mac_row = cur_story->FindVal(word, \"group\", 0, true)";
     pre_compile_code_string="mac_row = cur_story->FindVal(word, \"group\", 0, true)";
     result_var=.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[0]$$;
     obj=$.projects[0].programs.gp[3][5].vars[0]$;
     method=DataTable::FindVal;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="word";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"group\"";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="st_row";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="not_found_err";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
     meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="mac_str = cur_story[\"sentence\"][mac_row]";
     pre_compile_code_string="mac_str = cur_story[\"sentence\"][mac_row]";
     result_var=.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[5]$$;
     expr {
      expr="cur_story[\"sentence\"][mac_row]";
     };
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="msary->Split(mac_str, \" \")";
     pre_compile_code_string="msary->Split(mac_str, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[6]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="mac_str";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    ForLoop @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<msary.size; i++)";
     pre_compile_code_string="for (i=0; i<msary.size; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="mword = msary[i]";
       pre_compile_code_string="mword = msary[i]";
       result_var=.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[8]$$;
       expr {
	expr="msary[i]";
       };
      };
      If @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (i == 0)";
       pre_compile_code_string="if (i == 0)";
       cond {
	expr="i == 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	VarIncr @[0] {
	 desc="append probability string if any to first item";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="mword += probstr";
	 pre_compile_code_string="mword += probstr";
	 var=$.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[8]$;
	 expr {
	  expr="probstr";
	 };
	};
	If @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (condstr.nonempty())";
	 pre_compile_code_string="if (condstr.nonempty())";
	 cond {
	  expr="condstr.nonempty()";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  VarIncr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="mword += \"?\" + condstr + \"?\"";
	   pre_compile_code_string="mword += \"?\" + condstr + \"?\"";
	   var=$.projects[0].programs.gp[3][5].functions[13].fun_code[0].local_vars[8]$;
	   expr {
	    expr="\"?\" + condstr + \"?\"";
	   };
	  };
	 };
	};
       };
      };
      FunctionCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ParseWord(mword)";
       pre_compile_code_string="ParseWord(mword)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[14]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="word";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="mword";
	 };
	};
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<msary.size";
     };
     iter {
      expr="i++";
     };
    };
   };
  };
  Function @[14] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ParseWord(String word) returns: int";
   pre_compile_code_string="ParseWord(String word) returns: int";
   name="ParseWord";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_352";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.startsWith(\"[\"))";
     pre_compile_code_string="if (word.startsWith(\"[\"))";
     cond {
      expr="word.startsWith(\"[\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddSwitch(word)";
       pre_compile_code_string="AddSwitch(word)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[9]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="word";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="word";
	 };
	};
       };
      };
     };
    };
    ElseIf @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (word.startsWith(\"]\"))";
     pre_compile_code_string="else if (word.startsWith(\"]\"))";
     cond {
      expr="word.startsWith(\"]\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="EndSwitch()";
       pre_compile_code_string="EndSwitch()";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[11]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
    ElseIf @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (word.startsWith(\"|\"))";
     pre_compile_code_string="else if (word.startsWith(\"|\"))";
     cond {
      expr="word.startsWith(\"|\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddOption(word)";
       pre_compile_code_string="AddOption(word)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[12]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="word";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="word";
	 };
	};
       };
      };
     };
    };
    ElseIf @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (word.startsWith(\"$\"))";
     pre_compile_code_string="else if (word.startsWith(\"$\"))";
     cond {
      expr="word.startsWith(\"$\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddMacro(word)";
       pre_compile_code_string="AddMacro(word)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[13]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="word";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="word";
	 };
	};
       };
      };
     };
    };
    Else @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddPlainWord(word)";
       pre_compile_code_string="AddPlainWord(word)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[8]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="word";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="word";
	 };
	};
       };
      };
     };
    };
   };
  };
  Function @[15] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ParseSentence(String sent) returns: int";
   pre_compile_code_string="ParseSentence(String sent) returns: int";
   name="ParseSentence";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="sent";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_348";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="sary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="PrevSentence->CopyFrom(CurSentence)";
     pre_compile_code_string="PrevSentence->CopyFrom(CurSentence)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].vars[16]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="CurSentence";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSentence->ResetData()";
     pre_compile_code_string="CurSentence->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[11]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch = -1";
     pre_compile_code_string="last_switch = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[1]$;
     expr {
      expr="-1";
     };
    };
    AssignExpr @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch_markup = \"\"";
     pre_compile_code_string="last_switch_markup = \"\"";
     result_var=$.projects[0].programs.gp[3][5].vars[2]$;
     expr {
      expr="\"\"";
     };
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_eff_node = -1";
     pre_compile_code_string="last_eff_node = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[3]$;
     expr {
      expr="-1";
     };
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="prev_popped_switch = -1";
     pre_compile_code_string="prev_popped_switch = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[4]$;
     expr {
      expr="-1";
     };
    };
    MethodCall @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack->ResetData()";
     pre_compile_code_string="CurSwitchStack->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[12]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    MethodCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="sary->Split(sent, \" \")";
     pre_compile_code_string="sary->Split(sent, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].functions[15].fun_code[0].local_vars[0]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="sent";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    ForLoop @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i< sary.size; i++)";
     pre_compile_code_string="for (i=0; i< sary.size; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ParseWord(sary[i])";
       pre_compile_code_string="ParseWord(sary[i])";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][5].functions[14]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="word";
	 required=1;
	 def_val=;
	 prev_expr="sary[i]";
	 expr {
	  expr="sary[i]";
	 };
	};
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i< sary.size";
     };
     iter {
      expr="i++";
     };
    };
   };
  };
  Function @[16] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ParseCurRow() returns: int";
   pre_compile_code_string="ParseCurRow() returns: int";
   name="ParseCurRow";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_376";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="sent";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="sent = cur_story[\"sentence\"][cur_row]";
     pre_compile_code_string="sent = cur_story[\"sentence\"][cur_row]";
     result_var=.projects[0].programs.gp[3][5].functions[16].fun_code[0].local_vars[0]$$;
     expr {
      expr="cur_story[\"sentence\"][cur_row]";
     };
    };
    FunctionCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ParseSentence(sent)";
     pre_compile_code_string="ParseSentence(sent)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][5].functions[15]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="sent";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="sent";
       };
      };
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_node = 0";
     pre_compile_code_string="cur_node = 0";
     result_var=.projects[0].programs.gp[3][5].vars[7]$$;
     expr {
      expr="0";
     };
    };
    MethodCall @[4] {
     desc="use this for production too!";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack->ResetData()";
     pre_compile_code_string="CurSwitchStack->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[12]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch = -1";
     pre_compile_code_string="last_switch = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[1]$;
     expr {
      expr="-1";
     };
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch_markup = \"\"";
     pre_compile_code_string="last_switch_markup = \"\"";
     result_var=$.projects[0].programs.gp[3][5].vars[2]$;
     expr {
      expr="\"\"";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_eff_node = -1";
     pre_compile_code_string="last_eff_node = -1";
     result_var=$.projects[0].programs.gp[3][5].vars[3]$;
     expr {
      expr="-1";
     };
    };
    AssignExpr @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="new_sentence = true";
     pre_compile_code_string="new_sentence = true";
     result_var=.projects[0].programs.gp[3][5].vars[15]$$;
     expr {
      expr="true";
     };
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="SentenceHistory->InsertRows(0, 1)";
     pre_compile_code_string="SentenceHistory->InsertRows(0, 1)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].vars[17]$$;
     method=DataTable::InsertRows;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="st_row";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="n_rows";
       required=0;
       def_val="1";
       prev_expr=;
       expr {
	expr="1";
       };
      };
     };
     meth_sig="bool InsertRows(int st_row, int n_rows = 1)";
     meth_desc=" insert n rows at starting row number, returns true if successfully inserted";
    };
   };
  };
  Function @[17] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetNextSentence() returns: int";
   pre_compile_code_string="GetNextSentence() returns: int";
   name="GetNextSentence";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_379";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="at_end";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="at_end = false";
     pre_compile_code_string="at_end = false";
     result_var=.projects[0].programs.gp[3][5].functions[17].fun_code[0].local_vars[0]$$;
     expr {
      expr="false";
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cur_row == cur_story.rows-1)";
     pre_compile_code_string="if (cur_row == cur_story.rows-1)";
     cond {
      expr="cur_row == cur_story.rows-1";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="at_end = true";
       pre_compile_code_string="at_end = true";
       result_var=$.projects[0].programs.gp[3][5].functions[17].fun_code[0].local_vars[0]$;
       expr {
	expr="true";
       };
      };
     };
    };
    ElseIf @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (cur_story[\"group\"][cur_row+1] != cur_group)";
     pre_compile_code_string="else if (cur_story[\"group\"][cur_row+1] != cur_group)";
     cond {
      expr="cur_story[\"group\"][cur_row+1] != cur_group";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="at_end = true";
       pre_compile_code_string="at_end = true";
       result_var=$.projects[0].programs.gp[3][5].functions[17].fun_code[0].local_vars[0]$;
       expr {
	expr="true";
       };
      };
     };
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (!at_end)";
     pre_compile_code_string="if (!at_end)";
     cond {
      expr="!at_end";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      VarIncr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_row += 1";
       pre_compile_code_string="cur_row += 1";
       var=.projects[0].programs.gp[3][5].vars[6]$$;
       expr {
	expr="1";
       };
      };
      FunctionCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ParseCurRow()";
       pre_compile_code_string="ParseCurRow()";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[16]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
    Else @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ChooseGroup()";
       pre_compile_code_string="ChooseGroup()";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[18]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
   };
  };
  Function @[18] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ChooseGroup() returns: int";
   pre_compile_code_string="ChooseGroup() returns: int";
   name="ChooseGroup";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_372";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="sel_row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    DataGenCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="sel_row = taDataGen::ProbSelectRow(Groups, \"on\", \"false\", \"freq\", )";
     pre_compile_code_string="sel_row = taDataGen::ProbSelectRow(Groups, \"on\", \"false\", \"freq\", )";
     result_var=.projects[0].programs.gp[3][5].functions[18].fun_code[0].local_vars[0]$$;
     object_type=taDataGen;
     method=taDataGen::ProbSelectRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=DataTable_ptr;
       type="DataTable*";
       name="data_table";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="Groups";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="key_col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"on\"";
       };
      };
      ProgArg @[2] {
       arg_type=const_taString_ref;
       type="taString&";
       name="key_val";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"false\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_taString_ref;
       type="taString&";
       name="p_col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"freq\"";
       };
      };
      ProgArg @[4] {
       arg_type=int;
       type="int";
       name="thr_no";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_group = Groups[\"group\"][sel_row]";
     pre_compile_code_string="cur_group = Groups[\"group\"][sel_row]";
     result_var=.projects[0].programs.gp[3][5].vars[5]$$;
     expr {
      expr="Groups[\"group\"][sel_row]";
     };
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_row = cur_story->FindVal(cur_group, \"group\", 0, true)";
     pre_compile_code_string="cur_row = cur_story->FindVal(cur_group, \"group\", 0, true)";
     result_var=$.projects[0].programs.gp[3][5].vars[6]$;
     obj=$.projects[0].programs.gp[3][5].vars[0]$;
     method=DataTable::FindVal;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="cur_group";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"group\"";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="st_row";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="not_found_err";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="true";
       };
      };
     };
     meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
     meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="PrevSentenceHistory->CopyFrom(SentenceHistory)";
     pre_compile_code_string="PrevSentenceHistory->CopyFrom(SentenceHistory)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][5].vars[18]$$;
     method=taBase::CopyFrom;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taBase_ptr;
       type="taBase*";
       name="cpy_from";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="SentenceHistory";
       };
      };
     };
     meth_sig="bool CopyFrom(taBase* cpy_from)";
     meth_desc=" Copy from given object into this object (this is a safe interface to UnSafeCopy)";
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="SentenceHistory->ResetData()";
     pre_compile_code_string="SentenceHistory->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[17]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    FunctionCall @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ParseCurRow()";
     pre_compile_code_string="ParseCurRow()";
     result_var=NULL;
     fun=$.projects[0].programs.gp[3][5].functions[16]$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
  };
  Function @[19] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ProcessCond(String cond) returns: bool";
   pre_compile_code_string="ProcessCond(String cond) returns: bool";
   name="ProcessCond";
   return_type=T_Bool;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="cond";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_480";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (14 vars)";
     pre_compile_code_string="LocalVars (14 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="firstpart";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="firstval";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="secpart";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="secval";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="negate";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="chr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="restrict_row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="shist";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="rval";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[10] {
       name="no_hits";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[11] {
       name="s_start";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[12] {
       name="s_end";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[13] {
       name="chrn";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cond.contains(\"&&\"))";
     pre_compile_code_string="if (cond.contains(\"&&\"))";
     cond {
      expr="cond.contains(\"&&\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="firstpart = cond->before(\"&&\", )";
       pre_compile_code_string="firstpart = cond->before(\"&&\", )";
       result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[0]$$;
       obj=.projects[0].programs.gp[3][5].functions[19].args[0]$$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"&&\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="secpart = cond->after(\"&&\", )";
       pre_compile_code_string="secpart = cond->after(\"&&\", )";
       result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[2]$$;
       obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"&&\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      FunctionCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="firstval = ProcessCond(firstpart)";
       pre_compile_code_string="firstval = ProcessCond(firstpart)";
       result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[1]$$;
       fun=.projects[0].programs.gp[3][5].functions[19]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="cond";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="firstpart";
	 };
	};
       };
      };
      FunctionCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="secval = ProcessCond(secpart)";
       pre_compile_code_string="secval = ProcessCond(secpart)";
       result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[3]$$;
       fun=$.projects[0].programs.gp[3][5].functions[19]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="cond";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="secpart";
	 };
	};
       };
      };
      ReturnExpr @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return (firstval && secval)";
       pre_compile_code_string="return (firstval && secval)";
       expr {
	expr="(firstval && secval)";
       };
      };
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cond.contains(\"||\"))";
     pre_compile_code_string="if (cond.contains(\"||\"))";
     cond {
      expr="cond.contains(\"||\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="firstpart = cond->before(\"||\", )";
       pre_compile_code_string="firstpart = cond->before(\"||\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"||\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="secpart = cond->after(\"||\", )";
       pre_compile_code_string="secpart = cond->after(\"||\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[2]$;
       obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"||\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      FunctionCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="firstval = ProcessCond(firstpart)";
       pre_compile_code_string="firstval = ProcessCond(firstpart)";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[1]$;
       fun=$.projects[0].programs.gp[3][5].functions[19]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="cond";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="firstpart";
	 };
	};
       };
      };
      FunctionCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="secval = ProcessCond(secpart)";
       pre_compile_code_string="secval = ProcessCond(secpart)";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[3]$;
       fun=$.projects[0].programs.gp[3][5].functions[19]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="cond";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="secpart";
	 };
	};
       };
      };
      ReturnExpr @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return (firstval || secval)";
       pre_compile_code_string="return (firstval || secval)";
       expr {
	expr="(firstval || secval)";
       };
      };
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="negate = false";
     pre_compile_code_string="negate = false";
     result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[4]$$;
     expr {
      expr="false";
     };
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cond.startsWith(\"!\"))";
     pre_compile_code_string="if (cond.startsWith(\"!\"))";
     cond {
      expr="cond.startsWith(\"!\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="negate = true";
       pre_compile_code_string="negate = true";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[4]$;
       expr {
	expr="true";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cond = cond->after(\"!\", )";
       pre_compile_code_string="cond = cond->after(\"!\", )";
       result_var=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
       obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"!\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
     };
    };
    AssignExpr @[5] {
     desc="default = 1+";
     flags=CAN_REVERT_TO_CODE;
     code_string="s_start = 1";
     pre_compile_code_string="s_start = 1";
     result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[11]$$;
     expr {
      expr="1";
     };
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="s_end = SentenceHistory.rows-1";
     pre_compile_code_string="s_end = SentenceHistory.rows-1";
     result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[12]$$;
     expr {
      expr="SentenceHistory.rows-1";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="chr = cond[0]";
     pre_compile_code_string="chr = cond[0]";
     result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[5]$$;
     expr {
      expr="cond[0]";
     };
    };
    If @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (chr == \"-\")";
     pre_compile_code_string="if (chr == \"-\")";
     cond {
      expr="chr == \"-\"";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="chr = cond[1]";
       pre_compile_code_string="chr = cond[1]";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[5]$;
       expr {
	expr="cond[1]";
       };
      };
      If @[1] {
       desc="digit";
       flags=CAN_REVERT_TO_CODE;
       code_string="if (chr == \"0\" || chr.toInt() > 0)";
       pre_compile_code_string="if (chr == \"0\" || chr.toInt() > 0)";
       cond {
	expr="chr == \"0\" || chr.toInt() > 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="s_end = chr->toInt(, )";
	 pre_compile_code_string="s_end = chr->toInt(, )";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[12]$;
	 obj=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[5]$;
	 method=taString::toInt;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool_ptr;
	   type="bool*";
	   name="ok";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="base";
	   required=0;
	   def_val="10";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="int toInt(bool* ok = 0, int base = 10)";
	 meth_desc=" to integer value -- base determines base representation (hex=16, oct=8)";
	};
	MethodCall @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="cond = cond->at(2, cond.length()-2)";
	 pre_compile_code_string="cond = cond->at(2, cond.length()-2)";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 method=taString::at;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="pos";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="2";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="len";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="cond.length()-2";
	   };
	  };
	 };
	 meth_sig="taString at(int pos, int len)";
	 meth_desc=" get substring at position for length";
	};
       };
      };
     };
    };
    ElseIf @[9] {
     desc="sentence specifier";
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (chr == \"0\" || chr.toInt() > 0)";
     pre_compile_code_string="else if (chr == \"0\" || chr.toInt() > 0)";
     cond {
      expr="chr == \"0\" || chr.toInt() > 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="s_start = chr->toInt(, )";
       pre_compile_code_string="s_start = chr->toInt(, )";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[11]$;
       obj=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[5]$;
       method=taString::toInt;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="base";
	 required=0;
	 def_val="10";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="int toInt(bool* ok = 0, int base = 10)";
       meth_desc=" to integer value -- base determines base representation (hex=16, oct=8)";
      };
      If @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (cond[1] == \"+\")";
       pre_compile_code_string="if (cond[1] == \"+\")";
       cond {
	expr="cond[1] == \"+\"";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="cond = cond->at(2, cond.length()-2)";
	 pre_compile_code_string="cond = cond->at(2, cond.length()-2)";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 method=taString::at;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="pos";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="2";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="len";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="cond.length()-2";
	   };
	  };
	 };
	 meth_sig="taString at(int pos, int len)";
	 meth_desc=" get substring at position for length";
	};
       };
      };
      ElseIf @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else if (cond[1] == \"-\")";
       pre_compile_code_string="else if (cond[1] == \"-\")";
       cond {
	expr="cond[1] == \"-\"";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="chrn = cond[2]";
	 pre_compile_code_string="chrn = cond[2]";
	 result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[13]$$;
	 expr {
	  expr="cond[2]";
	 };
	};
	MethodCall @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="s_end = chrn->toInt(, )";
	 pre_compile_code_string="s_end = chrn->toInt(, )";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[12]$;
	 obj=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[13]$;
	 method=taString::toInt;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=bool_ptr;
	   type="bool*";
	   name="ok";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="base";
	   required=0;
	   def_val="10";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="int toInt(bool* ok = 0, int base = 10)";
	 meth_desc=" to integer value -- base determines base representation (hex=16, oct=8)";
	};
	MethodCall @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="cond = cond->at(3, cond.length()-3)";
	 pre_compile_code_string="cond = cond->at(3, cond.length()-3)";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 method=taString::at;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="pos";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="3";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="len";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="cond.length()-3";
	   };
	  };
	 };
	 meth_sig="taString at(int pos, int len)";
	 meth_desc=" get substring at position for length";
	};
       };
      };
      Else @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="s_end = s_start";
	 pre_compile_code_string="s_end = s_start";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[12]$;
	 expr {
	  expr="s_start";
	 };
	};
	MethodCall @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="cond = cond->at(1, cond.length()-1)";
	 pre_compile_code_string="cond = cond->at(1, cond.length()-1)";
	 result_var=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 obj=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
	 method=taString::at;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="pos";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="1";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="len";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="cond.length()-1";
	   };
	  };
	 };
	 meth_sig="taString at(int pos, int len)";
	 meth_desc=" get substring at position for length";
	};
       };
      };
     };
    };
    If @[10] {
     desc="silently fix -- more robust..";
     flags=CAN_REVERT_TO_CODE;
     code_string="if (s_end >= SentenceHistory.rows)";
     pre_compile_code_string="if (s_end >= SentenceHistory.rows)";
     cond {
      expr="s_end >= SentenceHistory.rows";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="s_end = SentenceHistory.rows-1";
       pre_compile_code_string="s_end = SentenceHistory.rows-1";
       result_var=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[12]$;
       expr {
	expr="SentenceHistory.rows-1";
       };
      };
     };
    };
    PrintVar @[11] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"probe searching for:\" cond s_start s_end";
     pre_compile_code_string="Print  \"probe searching for:\" cond s_start s_end";
     message="probe searching for:";
     print_var=$.projects[0].programs.gp[3][5].functions[19].args[0]$;
     print_var2=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[11]$;
     print_var3=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[12]$;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
    ForLoop @[12] {
     desc="search";
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=s_start; i<=s_end; i++)";
     pre_compile_code_string="for (i=s_start; i<=s_end; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="shist = SentenceHistory[0][i]";
       pre_compile_code_string="shist = SentenceHistory[0][i]";
       result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[7]$$;
       expr {
	expr="SentenceHistory[0][i]";
       };
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rval = shist->contains(cond, )";
       pre_compile_code_string="rval = shist->contains(cond, )";
       result_var=.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[8]$$;
       obj=$.projects[0].programs.gp[3][5].functions[19].fun_code[0].local_vars[7]$;
       method=taString::contains;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="y";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="cond";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="bool contains(taString& y, int startpos = 0)";
       meth_desc=" return 'true' if target appears anywhere in String. startpos = starting position (- = search from end forward)";
      };
      If @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (rval)";
       pre_compile_code_string="if (rval)";
       cond {
	expr="rval";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	If @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (negate)";
	 pre_compile_code_string="if (negate)";
	 cond {
	  expr="negate";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  ReturnExpr @[0] {
	   desc="got a hit, so negation is false";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="return false";
	   pre_compile_code_string="return false";
	   expr {
	    expr="false";
	   };
	  };
	 };
	};
	ReturnExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="return true";
	 pre_compile_code_string="return true";
	 expr {
	  expr="true";
	 };
	};
       };
      };
     };
     init {
      expr="i=s_start";
     };
     test {
      expr="i<=s_end";
     };
     iter {
      expr="i++";
     };
    };
    If @[13] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (negate)";
     pre_compile_code_string="if (negate)";
     cond {
      expr="negate";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ReturnExpr @[0] {
       desc="didn't get any hits";
       flags=CAN_REVERT_TO_CODE;
       code_string="return true";
       pre_compile_code_string="return true";
       expr {
	expr="true";
       };
      };
     };
    };
    ReturnExpr @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return false";
     pre_compile_code_string="return false";
     expr {
      expr="false";
     };
    };
   };
  };
  Function @[20] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ProcessSwitch() returns: String";
   pre_compile_code_string="ProcessSwitch() returns: String";
   name="ProcessSwitch";
   return_type=T_String;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_388";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (7 vars)";
     pre_compile_code_string="LocalVars (7 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="cum_prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="n_opts";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="rnd_no";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="next_node";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="mutex";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="n_opts = CurSentence[\"n_opts\"][cur_node]";
     pre_compile_code_string="n_opts = CurSentence[\"n_opts\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[2]$$;
     expr {
      expr="CurSentence[\"n_opts\"][cur_node]";
     };
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="mutex = CurSentence[\"mutex\"][cur_node]";
     pre_compile_code_string="mutex = CurSentence[\"mutex\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[6]$$;
     expr {
      expr="CurSentence[\"mutex\"][cur_node]";
     };
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (mutex)";
     pre_compile_code_string="if (mutex)";
     cond {
      expr="mutex";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cum_prob = 0";
       pre_compile_code_string="cum_prob = 0";
       result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[0]$$;
       expr {
	expr="0";
       };
      };
      RandomCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rnd_no = Random::ZeroOne()";
       pre_compile_code_string="rnd_no = Random::ZeroOne()";
       result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[4]$$;
       object_type=Random;
       method=Random::ZeroOne;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      ForLoop @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i=0; i<n_opts; i++)";
       pre_compile_code_string="for (i=0; i<n_opts; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="prob = CurSentence[\"prob\"][i, cur_node]";
	 pre_compile_code_string="prob = CurSentence[\"prob\"][i, cur_node]";
	 result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[3]$$;
	 expr {
	  expr="CurSentence[\"prob\"][i, cur_node]";
	 };
	};
	VarIncr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="cum_prob += prob";
	 pre_compile_code_string="cum_prob += prob";
	 var=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[0]$;
	 expr {
	  expr="prob";
	 };
	};
	IfBreak @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if(cum_prob >= rnd_no) break";
	 pre_compile_code_string="if(cum_prob >= rnd_no) break";
	 cond {
	  expr="cum_prob >= rnd_no";
	 };
	};
       };
       init {
	expr="i=0";
       };
       test {
	expr="i<n_opts";
       };
       iter {
	expr="i++";
       };
      };
      If @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (i>=n_opts)";
       pre_compile_code_string="if (i>=n_opts)";
       cond {
	expr="i>=n_opts";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="i = n_opts-1";
	 pre_compile_code_string="i = n_opts-1";
	 result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[1]$$;
	 expr {
	  expr="n_opts-1";
	 };
	};
       };
      };
      AssignExpr @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="next_node = CurSentence[\"opt_nodes\"][i,cur_node]";
       pre_compile_code_string="next_node = CurSentence[\"opt_nodes\"][i,cur_node]";
       result_var=.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[5]$$;
       expr {
	expr="CurSentence[\"opt_nodes\"][i,cur_node]";
       };
      };
      PrintVar @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  \"mutex next node:\" next_node cur_node i";
       pre_compile_code_string="Print  \"mutex next node:\" next_node cur_node i";
       message="mutex next node:";
       print_var=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[5]$;
       print_var2=$.projects[0].programs.gp[3][5].vars[7]$;
       print_var3=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[1]$;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=1;
      };
     };
    };
    Else @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      ForLoop @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i=0; i<n_opts; i++)";
       pre_compile_code_string="for (i=0; i<n_opts; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="prob = CurSentence[\"prob\"][i, cur_node]";
	 pre_compile_code_string="prob = CurSentence[\"prob\"][i, cur_node]";
	 result_var=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[3]$;
	 expr {
	  expr="CurSentence[\"prob\"][i, cur_node]";
	 };
	};
	IfBreak @[1] {
	 desc="non-mutex probs are non-normalized raw 0-100 values";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if(Random::BoolProb(prob / 100.0)) break";
	 pre_compile_code_string="if(Random::BoolProb(prob / 100.0)) break";
	 cond {
	  expr="Random::BoolProb(prob / 100.0)";
	 };
	};
       };
       init {
	expr="i=0";
       };
       test {
	expr="i<n_opts";
       };
       iter {
	expr="i++";
       };
      };
      If @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (i < n_opts)";
       pre_compile_code_string="if (i < n_opts)";
       cond {
	expr="i < n_opts";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="next_node = CurSentence[\"opt_nodes\"][i,cur_node]";
	 pre_compile_code_string="next_node = CurSentence[\"opt_nodes\"][i,cur_node]";
	 result_var=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[5]$;
	 expr {
	  expr="CurSentence[\"opt_nodes\"][i,cur_node]";
	 };
	};
	PrintVar @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  \"non-mutex next node:\" next_node cur_node i";
	 pre_compile_code_string="Print  \"non-mutex next node:\" next_node cur_node i";
	 message="non-mutex next node:";
	 print_var=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[5]$;
	 print_var2=$.projects[0].programs.gp[3][5].vars[7]$;
	 print_var3=$.projects[0].programs.gp[3][5].functions[20].fun_code[0].local_vars[1]$;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=1;
	};
       };
      };
      Else @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc="bail out of switch";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="cur_node = CurSentence[\"next\"][cur_node]";
	 pre_compile_code_string="cur_node = CurSentence[\"next\"][cur_node]";
	 result_var=$.projects[0].programs.gp[3][5].vars[7]$;
	 expr {
	  expr="CurSentence[\"next\"][cur_node]";
	 };
	};
	PrintVar @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  \"failed to find non-mutex next node\" cur_node";
	 pre_compile_code_string="Print  \"failed to find non-mutex next node\" cur_node";
	 message="failed to find non-mutex next node";
	 print_var=$.projects[0].programs.gp[3][5].vars[7]$;
	 print_var2=NULL;
	 print_var3=NULL;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=1;
	};
	ReturnExpr @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="return GetCurWord()";
	 pre_compile_code_string="return GetCurWord()";
	 expr {
	  expr="GetCurWord()";
	 };
	};
       };
      };
     };
    };
    MethodCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack->AddBlankRow()";
     pre_compile_code_string="CurSwitchStack->AddBlankRow()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][5].vars[12]$;
     method=DataTable::AddBlankRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int AddBlankRow()";
     meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
    };
    MatrixAssign @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack[\"node\"][-1] = cur_node";
     pre_compile_code_string="CurSwitchStack[\"node\"][-1] = cur_node";
     variable=$.projects[0].programs.gp[3][5].vars[12]$;
     data_table=1;
     col {
      expr="\"node\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="cur_node";
     };
    };
    MatrixAssign @[7] {
     desc="cur_opt";
     flags=CAN_REVERT_TO_CODE;
     code_string="CurSwitchStack[\"cur_opt\"][-1] = i";
     pre_compile_code_string="CurSwitchStack[\"cur_opt\"][-1] = i";
     variable=$.projects[0].programs.gp[3][5].vars[12]$;
     data_table=1;
     col {
      expr="\"cur_opt\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="i";
     };
    };
    AssignExpr @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="last_switch = cur_node";
     pre_compile_code_string="last_switch = cur_node";
     result_var=$.projects[0].programs.gp[3][5].vars[1]$;
     expr {
      expr="cur_node";
     };
    };
    AssignExpr @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_node = next_node";
     pre_compile_code_string="cur_node = next_node";
     result_var=$.projects[0].programs.gp[3][5].vars[7]$;
     expr {
      expr="next_node";
     };
    };
    ReturnExpr @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return GetCurWord()";
     pre_compile_code_string="return GetCurWord()";
     expr {
      expr="GetCurWord()";
     };
    };
   };
  };
  Function @[21] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="PopSwitch() returns: int";
   pre_compile_code_string="PopSwitch() returns: int";
   name="PopSwitch";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_398";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="mutex";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="cur_opt";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="n_opts";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="prob";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="mutex = CurSentence[\"mutex\"][last_switch]";
     pre_compile_code_string="mutex = CurSentence[\"mutex\"][last_switch]";
     result_var=.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[0]$$;
     expr {
      expr="CurSentence[\"mutex\"][last_switch]";
     };
    };
    PrintVar @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"pop switch, mutex:\" mutex";
     pre_compile_code_string="Print  \"pop switch, mutex:\" mutex";
     message="pop switch, mutex:";
     print_var=$.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[0]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (mutex)";
     pre_compile_code_string="if (mutex)";
     cond {
      expr="mutex";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc="bail out of switch";
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_node = last_switch";
       pre_compile_code_string="cur_node = last_switch";
       result_var=$.projects[0].programs.gp[3][5].vars[7]$;
       expr {
	expr="last_switch";
       };
      };
      FunctionCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="PopSwitchStack()";
       pre_compile_code_string="PopSwitchStack()";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][5].functions[10]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
      FunctionCall @[2] {
       desc="get from last_switch";
       flags=CAN_REVERT_TO_CODE;
       code_string="GetNextNode()";
       pre_compile_code_string="GetNextNode()";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][5].functions[23]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
      ReturnExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return ";
       pre_compile_code_string="return ";
       expr {
	expr=;
       };
      };
     };
    };
    AssignExpr @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="n_opts = CurSentence[\"n_opts\"][last_switch]";
     pre_compile_code_string="n_opts = CurSentence[\"n_opts\"][last_switch]";
     result_var=.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[3]$$;
     expr {
      expr="CurSentence[\"n_opts\"][last_switch]";
     };
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_opt = CurSwitchStack[\"cur_opt\"][-1]";
     pre_compile_code_string="cur_opt = CurSwitchStack[\"cur_opt\"][-1]";
     result_var=.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[1]$$;
     expr {
      expr="CurSwitchStack[\"cur_opt\"][-1]";
     };
    };
    VarIncr @[6] {
     desc="goto next";
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_opt += 1";
     pre_compile_code_string="cur_opt += 1";
     var=$.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[1]$;
     expr {
      expr="1";
     };
    };
    ForLoop @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=cur_opt; i<n_opts; i++)";
     pre_compile_code_string="for (i=cur_opt; i<n_opts; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="prob = CurSentence[\"prob\"][i, last_switch]";
       pre_compile_code_string="prob = CurSentence[\"prob\"][i, last_switch]";
       result_var=.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[4]$$;
       expr {
	expr="CurSentence[\"prob\"][i, last_switch]";
       };
      };
      IfBreak @[1] {
       desc="non-mutex probs are non-normalized 0-100";
       flags=CAN_REVERT_TO_CODE;
       code_string="if(Random::BoolProb(prob / 100.0)) break";
       pre_compile_code_string="if(Random::BoolProb(prob / 100.0)) break";
       cond {
	expr="Random::BoolProb(prob / 100.0)";
       };
      };
     };
     init {
      expr="i=cur_opt";
     };
     test {
      expr="i<n_opts";
     };
     iter {
      expr="i++";
     };
    };
    If @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (i < n_opts)";
     pre_compile_code_string="if (i < n_opts)";
     cond {
      expr="i < n_opts";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_node = CurSentence[\"opt_nodes\"][i,last_switch]";
       pre_compile_code_string="cur_node = CurSentence[\"opt_nodes\"][i,last_switch]";
       result_var=$.projects[0].programs.gp[3][5].vars[7]$;
       expr {
	expr="CurSentence[\"opt_nodes\"][i,last_switch]";
       };
      };
      MatrixAssign @[1] {
       desc="update cur";
       flags=CAN_REVERT_TO_CODE;
       code_string="CurSwitchStack[\"cur_opt\"][-1] = i";
       pre_compile_code_string="CurSwitchStack[\"cur_opt\"][-1] = i";
       variable=$.projects[0].programs.gp[3][5].vars[12]$;
       data_table=1;
       col {
	expr="\"cur_opt\"";
       };
       dim0 {
	expr="-1";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="i";
       };
      };
      PrintVar @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="Print  \"wrote cur_opt to non-mutex switch\" i cur_opt";
       pre_compile_code_string="Print  \"wrote cur_opt to non-mutex switch\" i cur_opt";
       message="wrote cur_opt to non-mutex switch";
       print_var=.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[2]$$;
       print_var2=$.projects[0].programs.gp[3][5].functions[21].fun_code[0].local_vars[1]$;
       print_var3=NULL;
       print_var4=NULL;
       print_var5=NULL;
       print_var6=NULL;
       debug=1;
      };
     };
    };
    Else @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc="bail out of switch";
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_node = CurSentence[\"next\"][last_switch]";
       pre_compile_code_string="cur_node = CurSentence[\"next\"][last_switch]";
       result_var=$.projects[0].programs.gp[3][5].vars[7]$;
       expr {
	expr="CurSentence[\"next\"][last_switch]";
       };
      };
      FunctionCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="PopSwitchStack()";
       pre_compile_code_string="PopSwitchStack()";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][5].functions[10]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
   };
  };
  Function @[22] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GotoLine(String word) returns: String";
   pre_compile_code_string="GotoLine(String word) returns: String";
   name="GotoLine";
   return_type=T_String;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_511";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (3 vars)";
     pre_compile_code_string="LocalVars (3 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="gostr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="goln";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="gorow";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="gostr = word->after(\"goto:\", )";
     pre_compile_code_string="gostr = word->after(\"goto:\", )";
     result_var=.projects[0].programs.gp[3][5].functions[22].fun_code[0].local_vars[0]$$;
     obj=.projects[0].programs.gp[3][5].functions[22].args[0]$$;
     method=taString::after;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="x";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"goto:\"";
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="startpos";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="taString after(taString& x, int startpos = 0)";
     meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="goln = gostr->toInt(, )";
     pre_compile_code_string="goln = gostr->toInt(, )";
     result_var=.projects[0].programs.gp[3][5].functions[22].fun_code[0].local_vars[1]$$;
     obj=$.projects[0].programs.gp[3][5].functions[22].fun_code[0].local_vars[0]$;
     method=taString::toInt;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=bool_ptr;
       type="bool*";
       name="ok";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[1] {
       arg_type=int;
       type="int";
       name="base";
       required=0;
       def_val="10";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="int toInt(bool* ok = 0, int base = 10)";
     meth_desc=" to integer value -- base determines base representation (hex=16, oct=8)";
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="gorow = cur_story->FindMultiVal(0, cur_group, \"group\", goln, \"seq\", , , , , , , , )";
     pre_compile_code_string="gorow = cur_story->FindMultiVal(0, cur_group, \"group\", goln, \"seq\", , , , , , , , )";
     result_var=.projects[0].programs.gp[3][5].functions[22].fun_code[0].local_vars[2]$$;
     obj=$.projects[0].programs.gp[3][5].vars[0]$;
     method=DataTable::FindMultiVal;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=int;
       type="int";
       name="st_row";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="cur_group";
       };
      };
      ProgArg @[2] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"group\"";
       };
      };
      ProgArg @[3] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val2";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="goln";
       };
      };
      ProgArg @[4] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col2";
       required=0;
       def_val=;
       prev_expr=;
       expr {
	expr="\"seq\"";
       };
      };
      ProgArg @[5] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val3";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col3";
       required=0;
       def_val=;
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val4";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col4";
       required=0;
       def_val=;
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="vall5";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col5";
       required=0;
       def_val=;
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val6";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[12] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col6";
       required=0;
       def_val=;
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="int FindMultiVal(int st_row, Variant& val1, Variant& col1, Variant& val2 = 0, Variant& col2, Variant& val3 = 0, Variant& col3, Variant& val4 = 0, Variant& col4, Variant& vall5 = 0, Variant& col5, Variant& val6 = 0, Variant& col6)";
     meth_desc=" find row number for multiple values across different columns of scalar type, starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- columns can be specified as either integer index or a string that is then used to find the given column name";
    };
    If @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (gorow < 0)";
     pre_compile_code_string="if (gorow < 0)";
     cond {
      expr="gorow < 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MiscCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="taMisc::Error(\"goto line:\", String(goln), \"not found in group:\", cur_group, , , , , )";
       pre_compile_code_string="taMisc::Error(\"goto line:\", String(goln), \"not found in group:\", cur_group, , , , , )";
       result_var=NULL;
       object_type=taMisc;
       method=taMisc::Error;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="a";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"goto line:\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="b";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="String(goln)";
	 };
	};
	ProgArg @[2] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="c";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="\"not found in group:\"";
	 };
	};
	ProgArg @[3] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="d";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr="cur_group";
	 };
	};
	ProgArg @[4] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="e";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="f";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="g";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="h";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="i";
	 required=0;
	 def_val="\"\"";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
     };
    };
    PrintVar @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"going to line:\" goln gorow";
     pre_compile_code_string="Print  \"going to line:\" goln gorow";
     message="going to line:";
     print_var=$.projects[0].programs.gp[3][5].functions[22].fun_code[0].local_vars[1]$;
     print_var2=$.projects[0].programs.gp[3][5].functions[22].fun_code[0].local_vars[2]$;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
    AssignExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_row = gorow";
     pre_compile_code_string="cur_row = gorow";
     result_var=$.projects[0].programs.gp[3][5].vars[6]$;
     expr {
      expr="gorow";
     };
    };
    AssignExpr @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_node = 0";
     pre_compile_code_string="cur_node = 0";
     result_var=$.projects[0].programs.gp[3][5].vars[7]$;
     expr {
      expr="0";
     };
    };
    FunctionCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ParseCurRow()";
     pre_compile_code_string="ParseCurRow()";
     result_var=NULL;
     fun=$.projects[0].programs.gp[3][5].functions[16]$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    ReturnExpr @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return GetCurWord()";
     pre_compile_code_string="return GetCurWord()";
     expr {
      expr="GetCurWord()";
     };
    };
   };
  };
  Function @[23] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetNextNode() returns: int";
   pre_compile_code_string="GetNextNode() returns: int";
   name="GetNextNode";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_392";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="next_node";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="next_node = CurSentence[\"next\"][cur_node]";
     pre_compile_code_string="next_node = CurSentence[\"next\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[23].fun_code[0].local_vars[0]$$;
     expr {
      expr="CurSentence[\"next\"][cur_node]";
     };
    };
    PrintVar @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"get next node on: \" next_node";
     pre_compile_code_string="Print  \"get next node on: \" next_node";
     message="get next node on: ";
     print_var=$.projects[0].programs.gp[3][5].functions[23].fun_code[0].local_vars[0]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
    If @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (next_node < 0 || next_node >= CurSentence.rows)";
     pre_compile_code_string="if (next_node < 0 || next_node >= CurSentence.rows)";
     cond {
      expr="next_node < 0 || next_node >= CurSentence.rows";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (last_switch > 0)";
       pre_compile_code_string="if (last_switch > 0)";
       cond {
	expr="last_switch > 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="PopSwitch()";
	 pre_compile_code_string="PopSwitch()";
	 result_var=NULL;
	 fun=.projects[0].programs.gp[3][5].functions[21]$$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	};
       };
      };
      Else @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc="done with current";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="GetNextSentence()";
	 pre_compile_code_string="GetNextSentence()";
	 result_var=NULL;
	 fun=.projects[0].programs.gp[3][5].functions[17]$$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	};
       };
      };
     };
    };
    Else @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="cur_node = next_node";
       pre_compile_code_string="cur_node = next_node";
       result_var=$.projects[0].programs.gp[3][5].vars[7]$;
       expr {
	expr="next_node";
       };
      };
     };
    };
   };
  };
  Function @[24] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddWordToHistory(String word) returns: int";
   pre_compile_code_string="AddWordToHistory(String word) returns: int";
   name="AddWordToHistory";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="word";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_476";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="curhist";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="curhist = SentenceHistory[0][0]";
     pre_compile_code_string="curhist = SentenceHistory[0][0]";
     result_var=.projects[0].programs.gp[3][5].functions[24].fun_code[0].local_vars[0]$$;
     expr {
      expr="SentenceHistory[0][0]";
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (curhist.nonempty())";
     pre_compile_code_string="if (curhist.nonempty())";
     cond {
      expr="curhist.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      VarIncr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="curhist += \" \" + word";
       pre_compile_code_string="curhist += \" \" + word";
       var=$.projects[0].programs.gp[3][5].functions[24].fun_code[0].local_vars[0]$;
       expr {
	expr="\" \" + word";
       };
      };
     };
    };
    Else @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="curhist = word";
       pre_compile_code_string="curhist = word";
       result_var=$.projects[0].programs.gp[3][5].functions[24].fun_code[0].local_vars[0]$;
       expr {
	expr="word";
       };
      };
     };
    };
    MatrixAssign @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="SentenceHistory[0][0] = curhist";
     pre_compile_code_string="SentenceHistory[0][0] = curhist";
     variable=$.projects[0].programs.gp[3][5].vars[17]$;
     data_table=1;
     col {
      expr="0";
     };
     dim0 {
      expr="0";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="curhist";
     };
    };
   };
  };
  Function @[25] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetCurWord() returns: String";
   pre_compile_code_string="GetCurWord() returns: String";
   name="GetCurWord";
   return_type=T_String;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_373";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="word";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="n_opts";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="self_p";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="cond";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="condval";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cur_row < 0 || cur_group.empty())";
     pre_compile_code_string="if (cur_row < 0 || cur_group.empty())";
     cond {
      expr="cur_row < 0 || cur_group.empty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="ChooseGroup()";
       pre_compile_code_string="ChooseGroup()";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][5].functions[18]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cur_node >= CurSentence.rows || cur_node < 0)";
     pre_compile_code_string="if (cur_node >= CurSentence.rows || cur_node < 0)";
     cond {
      expr="cur_node >= CurSentence.rows || cur_node < 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (last_switch > 0)";
       pre_compile_code_string="if (last_switch > 0)";
       cond {
	expr="last_switch > 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="PopSwitch()";
	 pre_compile_code_string="PopSwitch()";
	 result_var=NULL;
	 fun=$.projects[0].programs.gp[3][5].functions[21]$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	};
       };
      };
      Else @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="GetNextSentence()";
	 pre_compile_code_string="GetNextSentence()";
	 result_var=NULL;
	 fun=$.projects[0].programs.gp[3][5].functions[17]$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	};
       };
      };
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="word = CurSentence[\"word\"][cur_node]";
     pre_compile_code_string="word = CurSentence[\"word\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[0]$$;
     expr {
      expr="CurSentence[\"word\"][cur_node]";
     };
    };
    AssignExpr @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="self_p = CurSentence[\"self_p\"][cur_node]";
     pre_compile_code_string="self_p = CurSentence[\"self_p\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[2]$$;
     expr {
      expr="CurSentence[\"self_p\"][cur_node]";
     };
    };
    AssignExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cond = CurSentence[\"cond\"][cur_node]";
     pre_compile_code_string="cond = CurSentence[\"cond\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[3]$$;
     expr {
      expr="CurSentence[\"cond\"][cur_node]";
     };
    };
    PrintVar @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  \"get cur word on:\" word cur_node self_p cond";
     pre_compile_code_string="Print  \"get cur word on:\" word cur_node self_p cond";
     message="get cur word on:";
     print_var=$.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[0]$;
     print_var2=$.projects[0].programs.gp[3][5].vars[7]$;
     print_var3=$.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[2]$;
     print_var4=$.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[3]$;
     print_var5=NULL;
     print_var6=NULL;
     debug=1;
    };
    If @[7] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (cond.nonempty())";
     pre_compile_code_string="if (cond.nonempty())";
     cond {
      expr="cond.nonempty()";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="condval = ProcessCond(cond)";
       pre_compile_code_string="condval = ProcessCond(cond)";
       result_var=.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[4]$$;
       fun=$.projects[0].programs.gp[3][5].functions[19]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="cond";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="cond";
	 };
	};
       };
      };
      If @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!condval)";
       pre_compile_code_string="if (!condval)";
       cond {
	expr="!condval";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="GetNextNode()";
	 pre_compile_code_string="GetNextNode()";
	 result_var=NULL;
	 fun=$.projects[0].programs.gp[3][5].functions[23]$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	};
	ReturnExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="return GetCurWord()";
	 pre_compile_code_string="return GetCurWord()";
	 expr {
	  expr="GetCurWord()";
	 };
	};
       };
      };
     };
    };
    If @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (self_p == 0)";
     pre_compile_code_string="if (self_p == 0)";
     cond {
      expr="self_p == 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="GetNextNode()";
       pre_compile_code_string="GetNextNode()";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][5].functions[23]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
       };
      };
      ReturnExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return GetCurWord()";
       pre_compile_code_string="return GetCurWord()";
       expr {
	expr="GetCurWord()";
       };
      };
     };
    };
    If @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (self_p < 100)";
     pre_compile_code_string="if (self_p < 100)";
     cond {
      expr="self_p < 100";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!Random::BoolProb(self_p / 100.0))";
       pre_compile_code_string="if (!Random::BoolProb(self_p / 100.0))";
       cond {
	expr="!Random::BoolProb(self_p / 100.0)";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	PrintVar @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="Print  \"not generating due to self_p\" self_p word";
	 pre_compile_code_string="Print  \"not generating due to self_p\" self_p word";
	 message="not generating due to self_p";
	 print_var=$.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[2]$;
	 print_var2=$.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[0]$;
	 print_var3=NULL;
	 print_var4=NULL;
	 print_var5=NULL;
	 print_var6=NULL;
	 debug=1;
	};
	FunctionCall @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="GetNextNode()";
	 pre_compile_code_string="GetNextNode()";
	 result_var=NULL;
	 fun=$.projects[0].programs.gp[3][5].functions[23]$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	};
	ReturnExpr @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="return GetCurWord()";
	 pre_compile_code_string="return GetCurWord()";
	 expr {
	  expr="GetCurWord()";
	 };
	};
       };
      };
     };
    };
    AssignExpr @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="n_opts = CurSentence[\"n_opts\"][cur_node]";
     pre_compile_code_string="n_opts = CurSentence[\"n_opts\"][cur_node]";
     result_var=.projects[0].programs.gp[3][5].functions[25].fun_code[0].local_vars[1]$$;
     expr {
      expr="CurSentence[\"n_opts\"][cur_node]";
     };
    };
    If @[11] {
     desc="is a switch";
     flags=CAN_REVERT_TO_CODE;
     code_string="if (n_opts > 0)";
     pre_compile_code_string="if (n_opts > 0)";
     cond {
      expr="n_opts > 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ReturnExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return ProcessSwitch()";
       pre_compile_code_string="return ProcessSwitch()";
       expr {
	expr="ProcessSwitch()";
       };
      };
     };
    };
    If @[12] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (word.startsWith(\"goto:\") && cur_node == 0)";
     pre_compile_code_string="if (word.startsWith(\"goto:\") && cur_node == 0)";
     cond {
      expr="word.startsWith(\"goto:\") && cur_node == 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ReturnExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return GotoLine(word)";
       pre_compile_code_string="return GotoLine(word)";
       expr {
	expr="GotoLine(word)";
       };
      };
     };
    };
    FunctionCall @[13] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="AddWordToHistory(word)";
     pre_compile_code_string="AddWordToHistory(word)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][5].functions[24]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="word";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="word";
       };
      };
     };
    };
    FunctionCall @[14] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="GetNextNode()";
     pre_compile_code_string="GetNextNode()";
     result_var=NULL;
     fun=$.projects[0].programs.gp[3][5].functions[23]$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    ReturnExpr @[15] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return word";
     pre_compile_code_string="return word";
     expr {
      expr="word";
     };
    };
   };
  };
  Function @[26] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetCurSentence() returns: String";
   pre_compile_code_string="GetCurSentence() returns: String";
   name="GetCurSentence";
   return_type=T_String;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_461";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="sent";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="sent_row";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    FunctionCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="sent = GetCurWord()";
     pre_compile_code_string="sent = GetCurWord()";
     result_var=.projects[0].programs.gp[3][5].functions[26].fun_code[0].local_vars[0]$$;
     fun=.projects[0].programs.gp[3][5].functions[25]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    AssignExpr @[2] {
     desc="will be false until a row is parsed";
     flags=CAN_REVERT_TO_CODE;
     code_string="new_sentence = false";
     pre_compile_code_string="new_sentence = false";
     result_var=$.projects[0].programs.gp[3][5].vars[15]$;
     expr {
      expr="false";
     };
    };
    WhileLoop @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="while (!new_sentence)";
     pre_compile_code_string="while (!new_sentence)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      VarIncr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="sent += \" \" + GetCurWord()";
       pre_compile_code_string="sent += \" \" + GetCurWord()";
       var=$.projects[0].programs.gp[3][5].functions[26].fun_code[0].local_vars[0]$;
       expr {
	expr="\" \" + GetCurWord()";
       };
      };
     };
     test {
      expr="!new_sentence";
     };
    };
    ReturnExpr @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return sent";
     pre_compile_code_string="return sent";
     expr {
      expr="sent";
     };
    };
   };
  };
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LocalVars (0 vars)";
   pre_compile_code_string="LocalVars (0 vars)";
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  FunctionCall @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="InitCurStory()";
   pre_compile_code_string="InitCurStory()";
   result_var=NULL;
   fun=.projects[0].programs.gp[3][5].functions[1]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  AssignExpr @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="cur_row = -1";
   pre_compile_code_string="cur_row = -1";
   result_var=$.projects[0].programs.gp[3][5].vars[6]$;
   expr {
    expr="-1";
   };
  };
  AssignExpr @[3] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="cur_group = \"\"";
   pre_compile_code_string="cur_group = \"\"";
   result_var=$.projects[0].programs.gp[3][5].vars[5]$;
   expr {
    expr="\"\"";
   };
  };
  AssignExpr @[4] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="cur_word = \"\"";
   pre_compile_code_string="cur_word = \"\"";
   result_var=.projects[0].programs.gp[3][5].vars[8]$$;
   expr {
    expr="\"\"";
   };
  };
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LocalVars (0 vars)";
   pre_compile_code_string="LocalVars (0 vars)";
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  If @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="if (get_next_word)";
   pre_compile_code_string="if (get_next_word)";
   cond {
    expr="get_next_word";
   };
   true_code {
    name="true_code";
    el_typ=ProgCode;
    el_def=0;
    FunctionCall @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_word = GetCurWord()";
     pre_compile_code_string="cur_word = GetCurWord()";
     result_var=$.projects[0].programs.gp[3][5].vars[8]$;
     fun=$.projects[0].programs.gp[3][5].functions[25]$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    PrintVar @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  cur_word";
     pre_compile_code_string="Print  cur_word";
     message=;
     print_var=$.projects[0].programs.gp[3][5].vars[8]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
   };
  };
  Else @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="else";
   pre_compile_code_string="else";
   else_code {
    name="else_code";
    el_typ=ProgCode;
    el_def=0;
    FunctionCall @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="cur_sentence = GetCurSentence()";
     pre_compile_code_string="cur_sentence = GetCurSentence()";
     result_var=.projects[0].programs.gp[3][5].vars[9]$$;
     fun=.projects[0].programs.gp[3][5].functions[26]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
    PrintVar @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print  cur_sentence";
     pre_compile_code_string="Print  cur_sentence";
     message=;
     print_var=$.projects[0].programs.gp[3][5].vars[9]$;
     print_var2=NULL;
     print_var3=NULL;
     print_var4=NULL;
     print_var5=NULL;
     print_var6=NULL;
     debug=0;
    };
   };
  };
 };
 step_prog=NULL;
 step_n=1;
};

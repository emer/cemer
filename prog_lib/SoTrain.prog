// ta_Dump File v3.0 -- code v8.0.10.0 rev10813
Program .projects[0].programs.gp[0][1] { 
 UserDataItem_List @*(.user_data_) {
  UserData_DocLink @[0] { };
 };

 ProgObjList @.objs = [2] {
  RndSeed_List @[0] { 
   taList @.seeds = [25] {
    RndSeed @[0] { };
    RndSeed @[1] { };
    RndSeed @[2] { };
    RndSeed @[3] { };
    RndSeed @[4] { };
    RndSeed @[5] { };
    RndSeed @[6] { };
    RndSeed @[7] { };
    RndSeed @[8] { };
    RndSeed @[9] { };
    RndSeed @[10] { };
    RndSeed @[11] { };
    RndSeed @[12] { };
    RndSeed @[13] { };
    RndSeed @[14] { };
    RndSeed @[15] { };
    RndSeed @[16] { };
    RndSeed @[17] { };
    RndSeed @[18] { };
    RndSeed @[19] { };
    RndSeed @[20] { };
    RndSeed @[21] { };
    RndSeed @[22] { };
    RndSeed @[23] { };
    RndSeed @[24] { };
   };
  };
  RndSeed @[1] { };
 };

 ProgVar_List @.objs_vars = [0] {
 };

 ProgType_List @.types = [1] {
  DynEnumType @[0] { 
   DynEnumItem_List @.enums = [3] {
    DynEnumItem @[0] { };
    DynEnumItem @[1] { };
    DynEnumItem @[2] { };
   };
  };
 };

 ProgVar_List @.args = [3] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
 };

 ProgVar_List @.vars = [12] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
  ProgVar @[8] { };
  ProgVar @[9] { };
  ProgVar @[10] { };
  ProgVar @[11] { };
 };

 Function_List @.functions = [1] {
  Function @[0] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [2] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    Switch @[1] { 
     ProgEl_List @.cases = [3] {
      CaseBlock @[0] { 
       ProgEl_List @.prog_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      CaseBlock @[1] { 
       ProgEl_List @.prog_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
       };
      };
      CaseBlock @[2] { 
       ProgEl_List @.prog_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
   };
  };
 };

 ProgEl_List @.init_code = [7] {
  AssignExpr @[0] { };
  MethodCall @[1] { 
   ProgArg_List @.meth_args = [1] {
    ProgArg @[0] { };
   };
  };
  AssignExpr @[2] { };
  AssignExpr @[3] { };
  FunctionCall @[4] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  WtInitPrompt @[5] { 
   ProgEl_List @.yes_code = [2] {
    MethodCall @[0] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    PrintExpr @[1] { };
   };
  };
  AssignExpr @[6] { };
 };

 ProgEl_List @.prog_code = [10] {
  AssignExpr @[0] { };
  MethodCall @[1] { 
   ProgArg_List @.meth_args = [1] {
    ProgArg @[0] { };
   };
  };
  AssignExpr @[2] { };
  MemberAssign @[3] { };
  FunctionCall @[4] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
  If @[5] { 
   ProgEl_List @.true_code = [2] {
    MethodCall @[0] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    PrintExpr @[1] { };
   };
  };
  AssignExpr @[6] { };
  WhileLoop @[7] { 
   ProgEl_List @.loop_code = [5] {
    ProgramCall @[0] { 
     ProgArg_List @.prog_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    NetCounterIncr @[1] { };
    If @[2] { 
     ProgEl_List @.true_code = [2] {
      VarIncr @[0] { };
      IfBreak @[1] { };
     };
    };
    Else @[3] { 
     ProgEl_List @.true_code = [1] {
      AssignExpr @[0] { };
     };
    };
    If @[4] { 
     ProgEl_List @.true_code = [1] {
      If @[0] { 
       ProgEl_List @.true_code = [1] {
	ProgramCall @[0] { 
	 ProgArg_List @.prog_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
   };
  };
  If @[8] { 
   ProgEl_List @.true_code = [1] {
    ProgramCall @[0] { 
     ProgArg_List @.prog_args = [1] {
      ProgArg @[0] { };
     };
    };
   };
  };
  MethodCall @[9] { 
   ProgArg_List @.meth_args = [0] {
   };
  };
 };
};
Program .projects[0].programs.gp[0][1] {
 UserDataItem_List @*(.user_data_) {
  name=;
  el_typ=UserData_DocLink;
  el_def=0;
  UserData_DocLink @[0] {name="DocLink": doc=.doc$$: };
 };
 name="SoTrain";
 short_nm="Train";
 tags="So, Std";
 desc="A complete training run of a self organizing network: iterating over epochs until the network has learned the task";
 version {
  major=8;
  minor=0;
  step=0;
 };
 author="Randall C. O'Reilly";
 email="emergent-users@grey.colorado.edu";
 flags=OBJS_UPDT_GUI;
 stop_step_cond {
  expr=;
 };
 objs {
  name="objs";
  el_typ=RndSeed;
  el_def=0;
  RndSeed_List @[0] {
   name="rnd_seeds";
   seeds {
    name="seeds";
    el_typ=RndSeed;
    el_def=0;
    RndSeed @[0] {
     name="RndSeed_1";
     rnd_seed=3077877348;
    };
    RndSeed @[1] {
     name="RndSeed_2";
     rnd_seed=3077877349;
    };
    RndSeed @[2] {
     name="RndSeed_3";
     rnd_seed=3077877350;
    };
    RndSeed @[3] {
     name="RndSeed_4";
     rnd_seed=3077877351;
    };
    RndSeed @[4] {
     name="RndSeed_5";
     rnd_seed=3077877352;
    };
    RndSeed @[5] {
     name="RndSeed_6";
     rnd_seed=3077877353;
    };
    RndSeed @[6] {
     name="RndSeed_7";
     rnd_seed=3077877354;
    };
    RndSeed @[7] {
     name="RndSeed_8";
     rnd_seed=3077877355;
    };
    RndSeed @[8] {
     name="RndSeed_9";
     rnd_seed=3077877356;
    };
    RndSeed @[9] {
     name="RndSeed_10";
     rnd_seed=3077877357;
    };
    RndSeed @[10] {
     name="RndSeed_11";
     rnd_seed=3077877358;
    };
    RndSeed @[11] {
     name="RndSeed_12";
     rnd_seed=3077877359;
    };
    RndSeed @[12] {
     name="RndSeed_13";
     rnd_seed=3077877360;
    };
    RndSeed @[13] {
     name="RndSeed_14";
     rnd_seed=3077877361;
    };
    RndSeed @[14] {
     name="RndSeed_15";
     rnd_seed=3077877362;
    };
    RndSeed @[15] {
     name="RndSeed_16";
     rnd_seed=3077877363;
    };
    RndSeed @[16] {
     name="RndSeed_17";
     rnd_seed=3077877364;
    };
    RndSeed @[17] {
     name="RndSeed_18";
     rnd_seed=3077877365;
    };
    RndSeed @[18] {
     name="RndSeed_19";
     rnd_seed=3077877366;
    };
    RndSeed @[19] {
     name="RndSeed_20";
     rnd_seed=3077877367;
    };
    RndSeed @[20] {
     name="RndSeed_21";
     rnd_seed=3077877368;
    };
    RndSeed @[21] {
     name="RndSeed_22";
     rnd_seed=3077877369;
    };
    RndSeed @[22] {
     name="RndSeed_23";
     rnd_seed=3077877370;
    };
    RndSeed @[23] {
     name="RndSeed_24";
     rnd_seed=3077877371;
    };
    RndSeed @[24] {
     name="RndSeed_25";
     rnd_seed=3077877372;
    };
   };
  };
  RndSeed @[1] {
   name="rnd_seed";
   rnd_seed=3681816228;
  };
 };
 objs_vars {
  name="objs_vars";
  el_typ=ProgVar;
  el_def=0;
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
  DynEnumType @[0] {
   name="RndInitType";
   desc=;
   enums {
    name="enums";
    el_typ=DynEnumItem;
    el_def=0;
    DynEnumItem @[0] {
     name="OLD_SEED";
     value=0;
     desc="use stored random seed value (recreates same sequence every time)";
    };
    DynEnumItem @[1] {
     name="NEW_SEED";
     value=1;
     desc="generate new random seed (new sequence of random numbers)";
    };
    DynEnumItem @[2] {
     name="BATCH_SEEDS";
     value=2;
     desc="use a fixed list of random seeds with the current batch number selecting the seed to use -- provides a consistent set of initial conditions for each batch regardless..";
    };
   };
   bits=0;
  };
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="network";
   var_type=T_Object;
   object_type=SoNetwork;
   object_val=.networks["Network_0"]$$<SoNetwork,Network_0>;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
   reference=0;
   desc="network to train";
   init_from=NULL;
  };
  ProgVar @[1] {
   name="input_data";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.data.gp["InputData"]["StdInputData"]$$<DataTable,StdInputData>;
   object_scope=NULL;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
   reference=0;
   desc="datatable with training patterns";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="no_prompts";
   var_type=T_Bool;
   bool_val=0;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
   reference=0;
   desc="If train is called by other programs (e.g., Batch), they should set this to true -- otherwise it is reset to false in Init";
   init_from=NULL;
  };
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="max_epoch";
   var_type=T_Int;
   int_val=100;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="maximum number of epochs to run";
   init_from=NULL;
  };
  ProgVar @[1] {
   name="epoch";
   var_type=T_Int;
   int_val=0;
   object_scope=NULL;
   flags=CTRL_PANEL|CTRL_READ_ONLY|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="current epoch -- local copy, which is used to update network's epoch counter";
   init_from=NULL;
  };
  ProgVar @[2] {
   name="train_mode";
   var_type=T_HardEnum;
   int_val=1;
   object_scope=NULL;
   hard_enum_type=Network::TrainMode;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="TRAIN = update weights (learn), TEST = just record network's responses but don't learn";
   init_from=NULL;
  };
  ProgVar @[3] {
   name="rnd_init";
   var_type=T_DynEnum;
   object_scope=NULL;
   dyn_enum_val {
    user_data_=NULL;
    enum_type=.types[0]$$;
    value=2;
   };
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="how to initialize the random numbers when the Init button is pressed";
   init_from=NULL;
  };
  ProgVar @[4] {
   name="err_stopcrit";
   var_type=T_Real;
   real_val=-1;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="stopping criterion -- when error measure (count of trials with a non-zero error by defult)
goes <= this value, stop training (set to -1 to disable stopping criterion, and always train to max_epoch epochs)";
   init_from=NULL;
  };
  ProgVar @[5] {
   name="n_under_thr";
   var_type=T_Int;
   int_val=1;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="number of times network needs to be under stopcrit threshold to actually stop";
   init_from=NULL;
  };
  ProgVar @[6] {
   name="save_final_wts";
   var_type=T_Bool;
   bool_val=0;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="save the network's weights at the end of training?  ";
   init_from=NULL;
  };
  ProgVar @[7] {
   name="save_wts_interval";
   var_type=T_Int;
   int_val=-1;
   object_scope=NULL;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="save the weights every this many epochs, if number is >= 1 (otherwise do not save weights)";
   init_from=NULL;
  };
  ProgVar @[8] {
   name="n_under_cnt";
   var_type=T_Int;
   int_val=0;
   object_scope=NULL;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="current under threshold counter";
   init_from=NULL;
  };
  ProgVar @[9] {
   name="rnd_seeds";
   var_type=T_Object;
   object_type=RndSeed_List;
   object_val=.objs[0]$$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[10] {
   name="train_timer";
   var_type=T_Object;
   object_type=TimeUsed;
   object_val=.networks["Network_0"].train_time$$<TimeUsed,train_time>;
   object_scope=NULL;
   objs_ptr=0;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="records time used to train network (object lives on network -- this is a pointer to it)";
   init_from=NULL;
  };
  ProgVar @[11] {
   name="rnd_seed";
   var_type=T_Object;
   object_type=RndSeed;
   object_val=.objs[1]$$;
   object_scope=NULL;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc="random seed that is used at start of training -- if OldSeed is called";
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
  Function @[0] {
   name="GetRandomSeed";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="GetRandomSeed() returns: int";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="args";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="fun_code";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     name="LocalVars_LocalVars0vars";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    Switch @[1] {
     name="Switch_switchrndinit";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="switch(rnd_init)";
     switch_var=.vars[3]$$;
     cases {
      name="cases";
      el_typ=CaseBlock;
      el_def=0;
      CaseBlock @[0] {
       name="CaseBlock_caseOLDSEED";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: OLD_SEED";
       prog_code {
	name="prog_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_rndseedOldSeed";
	 desc="restore previous random seed (all runs produce same results) -- click on rnd_seed object to generate a new seed to use for this if you want";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="rnd_seed->OldSeed()";
	 result_var=NULL;
	 obj=.vars[11]$$;
	 method=RndSeed::OldSeed;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void OldSeed()";
	 meth_desc=" restore current seed to random num generator";
	};
       };
       case_val {
	expr="OLD_SEED";
       };
       is_default=0;
      };
      CaseBlock @[1] {
       name="CaseBlock_caseNEWSEED";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: NEW_SEED";
       prog_code {
	name="prog_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_rndseedNewSeed";
	 desc="new random numbers each time";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="rnd_seed->NewSeed()";
	 result_var=NULL;
	 obj=$.vars[11]$;
	 method=RndSeed::NewSeed;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="void NewSeed()";
	 meth_desc=" set the seed to a new random value (based on time and process id)";
	};
       };
       case_val {
	expr="NEW_SEED";
       };
       is_default=0;
      };
      CaseBlock @[2] {
       name="CaseBlock_caseBATCHSEEDS";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="case: BATCH_SEEDS";
       prog_code {
	name="prog_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 name="MethodCall_rndseedsUseSeedn_dseedsseedssize";
	 desc="restore previous random seed (all runs produce same results); change to NewSeed to have new random numbers each time";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="rnd_seeds->UseSeed(network.batch % rnd_seeds.seeds.size)";
	 result_var=NULL;
	 obj=.vars[9]$$;
	 method=RndSeed_List::UseSeed;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="idx";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network.batch % rnd_seeds.seeds.size";
	   };
	  };
	 };
	 meth_sig="void UseSeed(int idx)";
	 meth_desc=" use seed at given index in the list (does OldSeed on it); wraps around (modulus) if idx is > list size (issues warning)";
	};
       };
       case_val {
	expr="BATCH_SEEDS";
       };
       is_default=0;
      };
     };
    };
   };
  };
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
  AssignExpr @[0] {
   name="AssignExpr_nopromptsfalse";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="no_prompts = false";
   result_var=.args[2]$$;
   expr {
    expr="false";
   };
  };
  MethodCall @[1] {
   name="MethodCall_networkCheckConfigfalse";
   desc="check network to make sure it is ready to be run";
   flags=CAN_REVERT_TO_CODE;
   code_string="network->CheckConfig(false)";
   result_var=NULL;
   obj=.args[0]$$;
   method=taBase::CheckConfig;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
    ProgArg @[0] {
     arg_type=bool;
     type="bool";
     name="quiet";
     required=0;
     def_val="false";
     prev_expr=;
     expr {
      expr="false";
     };
    };
   };
   meth_sig="bool CheckConfig(bool quiet = false)";
   meth_desc=" check the configuration of this object and all its children (defaults to no confirm of success)";
  };
  AssignExpr @[2] {
   name="AssignExpr_traintimernetworktraintime";
   desc="get our pointer to the network training time object";
   flags=CAN_REVERT_TO_CODE;
   code_string="train_timer = network.train_time";
   result_var=.vars[10]$$;
   expr {
    expr="network.train_time";
   };
  };
  AssignExpr @[3] {
   name="AssignExpr_nundercnt0";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="n_under_cnt = 0";
   result_var=.vars[8]$$;
   expr {
    expr="0";
   };
  };
  FunctionCall @[4] {
   name="FunctionCall_GetRandomSeed";
   desc="initialize random seed";
   flags=CAN_REVERT_TO_CODE;
   code_string="GetRandomSeed()";
   result_var=NULL;
   fun=.functions[0]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  WtInitPrompt @[5] {
   name="WtInitPrompt_ifguiDoyouwantto_eNetworkWeights";
   desc="don't initialize weights without checking";
   flags=CAN_REVERT_TO_CODE;
   code_string="if (gui && \"Do you want to Initialize Network Weights\")";
   prompt="Do you want to Initialize Network Weights";
   yes_label="Yes";
   no_label="No";
   yes_code {
    name="yes_code";
    el_typ=ProgCode;
    el_def=0;
    MethodCall @[0] {
     name="MethodCall_networkInitWeights";
     desc="initialize network weights: could also load pre-set weights or something else here";
     flags=CAN_REVERT_TO_CODE;
     code_string="network->Init_Weights()";
     result_var=NULL;
     obj=$.args[0]$;
     method=Network::Init_Weights;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Init_Weights()";
     meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
    };
    PrintExpr @[1] {
     name="PrintExpr_Printnetworkname_ghtsInitialized";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print network.name << \" Weights Initialized\"";
     expr {
      expr="network.name << \" Weights Initialized\"";
     };
     debug=0;
    };
   };
  };
  AssignExpr @[6] {
   name="AssignExpr_epochnetworkepoch";
   desc="grab the official network epoch counter: will be initialized if needed by now";
   flags=CAN_REVERT_TO_CODE;
   code_string="epoch = network.epoch";
   result_var=.vars[1]$$;
   expr {
    expr="network.epoch";
   };
  };
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  AssignExpr @[0] {
   name="AssignExpr_traintimernetworktraintime";
   desc="get our pointer to the network training time object";
   flags=CAN_REVERT_TO_CODE;
   code_string="train_timer = network.train_time";
   result_var=$.vars[10]$;
   expr {
    expr="network.train_time";
   };
  };
  MethodCall @[1] {
   name="MethodCall_traintimerStartTimertrue";
   desc="start timer to keep track of how long it takes to run entire training run";
   flags=CAN_REVERT_TO_CODE;
   code_string="train_timer->StartTimer(true)";
   result_var=NULL;
   obj=$.vars[10]$;
   method=TimeUsed::StartTimer;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
    ProgArg @[0] {
     arg_type=bool;
     type="bool";
     name="reset_used";
     required=0;
     def_val="true";
     prev_expr=;
     expr {
      expr="true";
     };
    };
   };
   meth_sig="void StartTimer(bool reset_used = true)";
   meth_desc=" record the current time as the starting time, and optionally reset the time used information";
  };
  AssignExpr @[2] {
   name="AssignExpr_nundercnt0";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="n_under_cnt = 0";
   result_var=$.vars[8]$;
   expr {
    expr="0";
   };
  };
  MemberAssign @[3] {
   name="MemberAssign_networktrainmodetrainmode";
   desc="set network's training mode to our local value";
   flags=CAN_REVERT_TO_CODE;
   code_string="network.train_mode = train_mode";
   obj=$.args[0]$;
   path="train_mode";
   expr {
    expr="train_mode";
   };
   update_after=0;
  };
  FunctionCall @[4] {
   name="FunctionCall_GetRandomSeed";
   desc="initialize random seed";
   flags=CAN_REVERT_TO_CODE;
   code_string="GetRandomSeed()";
   result_var=NULL;
   fun=$.functions[0]$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
  If @[5] {
   name="If_ifnoprompts";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="if (no_prompts)";
   cond {
    expr="no_prompts";
   };
   true_code {
    name="true_code";
    el_typ=ProgCode;
    el_def=0;
    MethodCall @[0] {
     name="MethodCall_networkInitWeights";
     desc="initialize network weights: could also load pre-set weights or something else here";
     flags=CAN_REVERT_TO_CODE;
     code_string="network->Init_Weights()";
     result_var=NULL;
     obj=$.args[0]$;
     method=Network::Init_Weights;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Init_Weights()";
     meth_desc=" Initialize the weights -- also inits acts, counters and stats -- does unit level threaded and then does Layers after";
    };
    PrintExpr @[1] {
     name="PrintExpr_Printnetworkname_ghtsInitialized";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="Print network.name << \" Weights Initialized\"";
     expr {
      expr="network.name << \" Weights Initialized\"";
     };
     debug=0;
    };
   };
  };
  AssignExpr @[6] {
   name="AssignExpr_epochnetworkepoch";
   desc="grab the official network epoch counter: will be initialized if needed by now";
   flags=CAN_REVERT_TO_CODE;
   code_string="epoch = network.epoch";
   result_var=$.vars[1]$;
   expr {
    expr="network.epoch";
   };
  };
  WhileLoop @[7] {
   name="WhileLoop_whileepochmaxepoch";
   desc="main loop over epochs of training";
   flags=CAN_REVERT_TO_CODE;
   code_string="while (epoch < max_epoch)";
   loop_code {
    name="loop_code";
    el_typ=ProgCode;
    el_def=0;
    ProgramCall @[0] {
     name="ProgramCall_SoEpochnetworkinputdata";
     desc="run the epoch program (one epoch), passes our network and input_data";
     flags=CAN_REVERT_TO_CODE;
     code_string="SoEpoch(network, input_data)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=SoNetwork;
       type="SoNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
      ProgArg @[1] {
       arg_type=DataTable;
       type="DataTable*";
       name="input_data";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="input_data";
       };
      };
     };
     target=.programs.gp["SoAll_Std"]["SoEpoch"]$$<Program,SoEpoch>;
     targ_ld_init="*SoEpoch*";
    };
    NetCounterIncr @[1] {
     name="NetCounterIncr_NetCounterIncrepoch";
     desc="increment the epoch counter (locally and on network)";
     flags=CAN_REVERT_TO_CODE;
     code_string="Net Counter Incr: epoch";
     network_var=$.args[0]$;
     local_ctr_var=$.vars[1]$;
     counter=Network::epoch;
     update_after=0;
    };
    If @[2] {
     name="If_ifnetworkavgsseavgerrstopcrit";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (network.avg_sse.avg <= err_stopcrit)";
     cond {
      expr="network.avg_sse.avg <= err_stopcrit";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      VarIncr @[0] {
       name="VarIncr_nundercnt1";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="n_under_cnt += 1";
       var=$.vars[8]$;
       expr {
	expr="1";
       };
      };
      IfBreak @[1] {
       name="IfBreak_ifnundercntnunderthrbreak";
       desc="stop if errors go below stopping criterion (note: could use sse or avg_sse here too)";
       flags=CAN_REVERT_TO_CODE;
       code_string="if(n_under_cnt >=  n_under_thr) break";
       cond {
	expr="n_under_cnt >=  n_under_thr";
       };
      };
     };
    };
    Else @[3] {
     name="Else_If_ifnetworkavgsseavgerrstopcrit";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     cond {
      expr=;
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      AssignExpr @[0] {
       name="AssignExpr_nundercnt0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="n_under_cnt = 0";
       result_var=$.vars[8]$;
       expr {
	expr="0";
       };
      };
     };
    };
    If @[4] {
     name="If_ifsavewtsinterval1";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (save_wts_interval >= 1)";
     cond {
      expr="save_wts_interval >= 1";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       name="If_ifepochsavewtsinterval0";
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (epoch % save_wts_interval == 0)";
       cond {
	expr="epoch % save_wts_interval == 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	ProgramCall @[0] {
	 name="ProgramCall_SaveWeightsnetwork";
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="SaveWeights(network)";
	 prog_args {
	  name="prog_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=Network;
	   type="SoNetwork*";
	   name="network";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="network";
	   };
	  };
	 };
	 target=.programs.gp["SoAll_Std"]["SaveWeights"]$$<Program,SaveWeights>;
	 targ_ld_init="*SaveWeights*";
	};
       };
      };
     };
    };
   };
   test {
    expr="epoch < max_epoch";
   };
  };
  If @[8] {
   name="If_ifsavefinalwts";
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="if (save_final_wts)";
   cond {
    expr="save_final_wts";
   };
   true_code {
    name="true_code";
    el_typ=ProgCode;
    el_def=0;
    ProgramCall @[0] {
     name="ProgramCall_SaveWeightsnetwork";
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="SaveWeights(network)";
     prog_args {
      name="prog_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=Network;
       type="SoNetwork*";
       name="network";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="network";
       };
      };
     };
     target=$.programs.gp["SoAll_Std"]["SaveWeights"]$;
     targ_ld_init="*SaveWeights*";
    };
   };
  };
  MethodCall @[9] {
   name="MethodCall_traintimerEndTimer";
   desc="stop the timer -- time elapsed is now recorded in this object, and can be displayed or recorded to a data table";
   flags=CAN_REVERT_TO_CODE;
   code_string="train_timer->EndTimer()";
   result_var=NULL;
   obj=$.vars[10]$;
   method=TimeUsed::EndTimer;
   meth_args {
    name="meth_args";
    el_typ=ProgArg;
    el_def=0;
   };
   meth_sig="void EndTimer()";
   meth_desc=" record the current time as the ending time, and compute difference as the time used";
  };
 };
 step_prog=NULL;
 step_n=1;
 doc {
  name="doc";
  desc=;
  web_doc=1;
  wiki="emergent";
  url="LeabraTrain";
  full_url="https://grey.colorado.edu/emergent/index.php/LeabraTrain";
  text_size=1;
  text=;
  html_text=;
 };
};

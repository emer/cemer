// ta_Dump File v3.0 -- code v7.8.6.0 rev9341
Program .projects[0].programs.gp[3][6] { 
 ProgObjList @.objs = [7] {
  DataTable_Group @[0] = [1] { 
   DataTable @[0] { 
    DataTableCols @.data = [5] {
     int_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     bool_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[4] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [6] {
     DataSortEl @[0] { };
     DataSortEl @[1] { };
     DataSortEl @[2] { };
     DataSortEl @[3] { };
     DataSortEl @[4] { };
     DataSortEl @[5] { };
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
  DataTable_Group @[1] = [1] { 
   DataTable @[0] { 
    DataTableCols @.data = [4] {
     String_Data @[0] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     int_Data @[1] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[2] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
     String_Data @[3] { 
      UserDataItem_List @*(.user_data_) {
       UserDataItem @[0] { };
      };
     };
    };

    DataOpList @.last_sort_spec.ops = [0] {
    };

    DataTableCell_List @.control_panel_cells = [0] {
    };
   };
  };
  DataBlock @[2] { 
   DataTableCols @.data = [0] {
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[3] { 
   DataTableCols @.data = [2] {
    String_Data @[0] { };
    String_Data @[1] { };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[4] { 
   DataTableCols @.data = [6] {
    String_Data @[0] { };
    String_Data @[1] { };
    String_Data @[2] { };
    String_Data @[3] { };
    String_Data @[4] { };
    String_Data @[5] { };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[5] { 
   DataTableCols @.data = [3] {
    int_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [6] {
    DataSortEl @[0] { };
    DataSortEl @[1] { };
    DataSortEl @[2] { };
    DataSortEl @[3] { };
    DataSortEl @[4] { };
    DataSortEl @[5] { };
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
  DataTable @[6] { 
   DataTableCols @.data = [4] {
    String_Data @[0] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[1] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[2] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
    String_Data @[3] { 
     UserDataItem_List @*(.user_data_) {
      UserDataItem @[0] { };
     };
    };
   };

   DataOpList @.last_sort_spec.ops = [0] {
   };

   DataTableCell_List @.control_panel_cells = [0] {
   };
  };
 };

 ProgType_List @.types = [0] {
 };

 ProgVar_List @.args = [1] {
  ProgVar @[0] { };
 };

 ProgVar_List @.vars = [8] {
  ProgVar @[0] { };
  ProgVar @[1] { };
  ProgVar @[2] { };
  ProgVar @[3] { };
  ProgVar @[4] { };
  ProgVar @[5] { };
  ProgVar @[6] { };
  ProgVar @[7] { };
 };

 Function_List @.functions = [11] {
  Function @[0] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      BlankLineEl @[0] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MatrixAssign @[3] { };
    MatrixAssign @[4] { };
    MatrixAssign @[5] { };
   };
  };
  Function @[1] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [11] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [31] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
      ProgVar @[10] { };
      ProgVar @[11] { };
      ProgVar @[12] { };
      ProgVar @[13] { };
      ProgVar @[14] { };
      ProgVar @[15] { };
      ProgVar @[16] { };
      ProgVar @[17] { };
      ProgVar @[18] { };
      ProgVar @[19] { };
      ProgVar @[20] { };
      ProgVar @[21] { };
      ProgVar @[22] { };
      ProgVar @[23] { };
      ProgVar @[24] { };
      ProgVar @[25] { };
      ProgVar @[26] { };
      ProgVar @[27] { };
      ProgVar @[28] { };
      ProgVar @[29] { };
      ProgVar @[30] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    ForeachLoop @[5] { 
     ProgEl_List @.loop_code = [2] {
      If @[0] { 
       ProgEl_List @.true_code = [12] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	If @[1] { 
	 ProgEl_List @.true_code = [1] {
	  MiscCall @[0] { 
	   ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	   };
	  };
	 };
	};
	MethodCall @[2] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	AssignExpr @[3] { };
	AssignExpr @[4] { };
	If @[5] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
	If @[6] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
	MethodCall @[7] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[8] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	If @[9] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
	ForLoop @[10] { 
	 ProgEl_List @.loop_code = [1] {
	  MatrixAssign @[0] { };
	 };
	};
	MethodCall @[11] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
      Else @[1] { 
       ProgEl_List @.else_code = [2] {
	If @[0] { 
	 ProgEl_List @.true_code = [1] {
	  AssignExpr @[0] { };
	 };
	};
	Else @[1] { 
	 ProgEl_List @.else_code = [1] {
	  VarIncr @[0] { };
	 };
	};
       };
      };
     };
    };
    ForeachLoop @[6] { 
     ProgEl_List @.loop_code = [6] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      If @[2] { 
       ProgEl_List @.true_code = [15] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
	If @[1] { 
	 ProgEl_List @.true_code = [1] {
	  MiscCall @[0] { 
	   ProgArg_List @.meth_args = [9] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	    ProgArg @[2] { };
	    ProgArg @[3] { };
	    ProgArg @[4] { };
	    ProgArg @[5] { };
	    ProgArg @[6] { };
	    ProgArg @[7] { };
	    ProgArg @[8] { };
	   };
	  };
	 };
	};
	MethodCall @[2] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	AssignExpr @[4] { };
	AssignExpr @[5] { };
	If @[6] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
	If @[7] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
	MethodCall @[8] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	AssignExpr @[9] { };
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	MethodCall @[11] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	If @[12] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
	MethodCall @[13] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	ForLoop @[14] { 
	 ProgEl_List @.loop_code = [1] {
	  MatrixAssign @[0] { };
	 };
	};
       };
      };
      Else @[3] { 
       ProgEl_List @.else_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
      If @[4] { 
       ProgEl_List @.true_code = [12] {
	AssignExpr @[0] { };
	AssignExpr @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
	MethodCall @[3] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	If @[4] { 
	 ProgEl_List @.true_code = [5] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	  MethodCall @[1] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	  MethodCall @[2] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	  If @[3] { 
	   ProgEl_List @.true_code = [1] {
	    MethodCall @[0] { 
	     ProgArg_List @.meth_args = [2] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	     };
	    };
	   };
	  };
	  MethodCall @[4] { 
	   ProgArg_List @.meth_args = [2] {
	    ProgArg @[0] { };
	    ProgArg @[1] { };
	   };
	  };
	 };
	};
	Else @[5] { 
	 ProgEl_List @.else_code = [4] {
	  MemberMethodCall @[0] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  If @[1] { 
	   ProgEl_List @.true_code = [1] {
	    MiscCall @[0] { 
	     ProgArg_List @.meth_args = [9] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	      ProgArg @[4] { };
	      ProgArg @[5] { };
	      ProgArg @[6] { };
	      ProgArg @[7] { };
	      ProgArg @[8] { };
	     };
	    };
	   };
	  };
	  MethodCall @[2] { 
	   ProgArg_List @.meth_args = [0] {
	   };
	  };
	  ForLoop @[3] { 
	   ProgEl_List @.loop_code = [3] {
	    AssignExpr @[0] { };
	    IfBreak @[1] { };
	    MethodCall @[2] { 
	     ProgArg_List @.meth_args = [1] {
	      ProgArg @[0] { };
	     };
	    };
	   };
	  };
	 };
	};
	AssignExpr @[6] { };
	MethodCall @[7] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	MethodCall @[8] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	If @[9] { 
	 ProgEl_List @.true_code = [1] {
	  MethodCall @[0] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	 };
	};
	MethodCall @[10] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
	ForLoop @[11] { 
	 ProgEl_List @.loop_code = [1] {
	  MatrixAssign @[0] { };
	 };
	};
       };
      };
      Else @[5] { 
       ProgEl_List @.else_code = [1] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [1] {
	  ProgArg @[0] { };
	 };
	};
       };
      };
     };
    };
    Comment @[7] { };
    MethodCall @[8] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[9] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    ForLoop @[10] { 
     ProgEl_List @.loop_code = [6] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      AssignExpr @[1] { };
      ForLoop @[2] { 
       ProgEl_List @.loop_code = [1] {
	VarIncr @[0] { };
       };
      };
      AssignExpr @[3] { };
      ForLoop @[4] { 
       ProgEl_List @.loop_code = [5] {
	AssignExpr @[0] { };
	AssignExpr @[1] { };
	If @[2] { 
	 ProgEl_List @.true_code = [5] {
	  AssignExpr @[0] { };
	  MemberMethodCall @[1] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  If @[2] { 
	   ProgEl_List @.true_code = [1] {
	    MiscCall @[0] { 
	     ProgArg_List @.meth_args = [9] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	      ProgArg @[4] { };
	      ProgArg @[5] { };
	      ProgArg @[6] { };
	      ProgArg @[7] { };
	      ProgArg @[8] { };
	     };
	    };
	   };
	  };
	  MethodCall @[3] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  AssignExpr @[4] { };
	 };
	};
	If @[3] { 
	 ProgEl_List @.true_code = [5] {
	  AssignExpr @[0] { };
	  MemberMethodCall @[1] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  If @[2] { 
	   ProgEl_List @.true_code = [1] {
	    MiscCall @[0] { 
	     ProgArg_List @.meth_args = [9] {
	      ProgArg @[0] { };
	      ProgArg @[1] { };
	      ProgArg @[2] { };
	      ProgArg @[3] { };
	      ProgArg @[4] { };
	      ProgArg @[5] { };
	      ProgArg @[6] { };
	      ProgArg @[7] { };
	      ProgArg @[8] { };
	     };
	    };
	   };
	  };
	  MethodCall @[3] { 
	   ProgArg_List @.meth_args = [1] {
	    ProgArg @[0] { };
	   };
	  };
	  AssignExpr @[4] { };
	 };
	};
	VarIncr @[4] { };
       };
      };
      FunctionCall @[5] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
   };
  };
  Function @[2] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [0] {
     };
    };
    If @[1] { 
     ProgEl_List @.true_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    Else @[2] { 
     ProgEl_List @.else_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
   };
  };
  Function @[3] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [4] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    ForeachLoop @[2] { 
     ProgEl_List @.loop_code = [2] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [12] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
	ProgArg @[4] { };
	ProgArg @[5] { };
	ProgArg @[6] { };
	ProgArg @[7] { };
	ProgArg @[8] { };
	ProgArg @[9] { };
	ProgArg @[10] { };
	ProgArg @[11] { };
       };
      };
      ForLoop @[1] { 
       ProgEl_List @.loop_code = [1] {
	FunctionCall @[0] { 
	 ProgArg_List @.fun_args = [3] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	  ProgArg @[2] { };
	 };
	};
       };
      };
     };
    };
    MethodCall @[3] { 
     ProgArg_List @.meth_args = [12] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
      ProgArg @[4] { };
      ProgArg @[5] { };
      ProgArg @[6] { };
      ProgArg @[7] { };
      ProgArg @[8] { };
      ProgArg @[9] { };
      ProgArg @[10] { };
      ProgArg @[11] { };
     };
    };
   };
  };
  Function @[4] { 
   ProgVar_List @.args = [2] {
    ProgVar @[0] { };
    ProgVar @[1] { };
   };

   ProgEl_List @.fun_code = [3] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [5] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ForeachLoop @[2] { 
     ProgEl_List @.loop_code = [6] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [4] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
	ProgArg @[3] { };
       };
      };
      If @[3] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [0] {
	 };
	};
	AssignExpr @[1] { };
	MatrixAssign @[2] { };
       };
      };
      MatrixAssign @[4] { };
      MatrixAssign @[5] { };
     };
    };
   };
  };
  Function @[5] { 
   ProgVar_List @.args = [3] {
    ProgVar @[0] { };
    ProgVar @[1] { };
    ProgVar @[2] { };
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [6] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    AssignExpr @[2] { };
    ForeachLoop @[3] { 
     ProgEl_List @.loop_code = [3] {
      If @[0] { 
       ProgEl_List @.true_code = [3] {
	MethodCall @[0] { 
	 ProgArg_List @.meth_args = [2] {
	  ProgArg @[0] { };
	  ProgArg @[1] { };
	 };
	};
	AssignExpr @[1] { };
	ForeachLoop @[2] { 
	 ProgEl_List @.loop_code = [1] {
	  If @[0] { 
	   ProgEl_List @.true_code = [2] {
	    AssignExpr @[0] { };
	    IfBreak @[1] { };
	   };
	  };
	 };
	};
       };
      };
      Else @[1] { 
       ProgEl_List @.else_code = [2] {
	AssignExpr @[0] { };
	ForeachLoop @[1] { 
	 ProgEl_List @.loop_code = [1] {
	  If @[0] { 
	   ProgEl_List @.true_code = [2] {
	    AssignExpr @[0] { };
	    IfBreak @[1] { };
	   };
	  };
	 };
	};
       };
      };
      If @[2] { 
       ProgEl_List @.true_code = [2] {
	AssignExpr @[0] { };
	IfBreak @[1] { };
       };
      };
     };
    };
    IfReturn @[4] { };
    FunctionCall @[5] { 
     ProgArg_List @.fun_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
   };
  };
  Function @[6] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [5] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [0] {
     };
    };
    MethodCall @[2] { 
     ProgArg_List @.meth_args = [2] {
      ProgArg @[0] { };
      ProgArg @[1] { };
     };
    };
    ForLoop @[3] { 
     ProgEl_List @.loop_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
     };
    };
    FunctionCall @[4] { 
     ProgArg_List @.fun_args = [0] {
     };
    };
   };
  };
  Function @[7] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [7] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [11] {
      ProgVar @[0] { };
      ProgVar @[1] { };
      ProgVar @[2] { };
      ProgVar @[3] { };
      ProgVar @[4] { };
      ProgVar @[5] { };
      ProgVar @[6] { };
      ProgVar @[7] { };
      ProgVar @[8] { };
      ProgVar @[9] { };
      ProgVar @[10] { };
     };
    };
    AssignExpr @[1] { };
    If @[2] { 
     ProgEl_List @.true_code = [6] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      RandomCall @[4] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      AssignExpr @[5] { };
     };
    };
    ElseIf @[3] { 
     ProgEl_List @.true_code = [6] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      RandomCall @[4] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      AssignExpr @[5] { };
     };
    };
    ElseIf @[4] { 
     ProgEl_List @.true_code = [7] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      RandomCall @[4] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      VarIncr @[5] { };
      AssignExpr @[6] { };
     };
    };
    ElseIf @[5] { 
     ProgEl_List @.true_code = [7] {
      MethodCall @[0] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      MethodCall @[1] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[2] { 
       ProgArg_List @.meth_args = [2] {
	ProgArg @[0] { };
	ProgArg @[1] { };
       };
      };
      MethodCall @[3] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      MethodCall @[4] { 
       ProgArg_List @.meth_args = [1] {
	ProgArg @[0] { };
       };
      };
      RandomCall @[5] { 
       ProgArg_List @.meth_args = [3] {
	ProgArg @[0] { };
	ProgArg @[1] { };
	ProgArg @[2] { };
       };
      };
      AssignExpr @[6] { };
     };
    };
    ReturnExpr @[6] { };
   };
  };
  Function @[8] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [2] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    ForLoop @[1] { 
     ProgEl_List @.loop_code = [2] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
      MatrixAssign @[1] { };
     };
    };
   };
  };
  Function @[9] { 
   ProgVar_List @.args = [1] {
    ProgVar @[0] { };
   };

   ProgEl_List @.fun_code = [6] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [2] {
      ProgVar @[0] { };
      ProgVar @[1] { };
     };
    };
    MethodCall @[1] { 
     ProgArg_List @.meth_args = [4] {
      ProgArg @[0] { };
      ProgArg @[1] { };
      ProgArg @[2] { };
      ProgArg @[3] { };
     };
    };
    If @[2] { 
     ProgEl_List @.true_code = [1] {
      ReturnExpr @[0] { };
     };
    };
    AssignExpr @[3] { };
    MethodCall @[4] { 
     ProgArg_List @.meth_args = [1] {
      ProgArg @[0] { };
     };
    };
    ReturnExpr @[5] { };
   };
  };
  Function @[10] { 
   ProgVar_List @.args = [0] {
   };

   ProgEl_List @.fun_code = [2] {
    LocalVars @[0] { 
     ProgVar_List @.local_vars = [1] {
      ProgVar @[0] { };
     };
    };
    ForeachLoop @[1] { 
     ProgEl_List @.loop_code = [1] {
      FunctionCall @[0] { 
       ProgArg_List @.fun_args = [1] {
	ProgArg @[0] { };
       };
      };
     };
    };
   };
  };
 };

 ProgEl_List @.init_code = [1] {
  FunctionCall @[0] { 
   ProgArg_List @.fun_args = [0] {
   };
  };
 };

 ProgEl_List @.prog_code = [2] {
  LocalVars @[0] { 
   ProgVar_List @.local_vars = [0] {
   };
  };
  FunctionCall @[1] { 
   ProgArg_List @.fun_args = [1] {
    ProgArg @[0] { };
   };
  };
 };
};
Program .projects[0].programs.gp[3][6] {
 name="StoryParambulator";
 short_nm="StrPrm";
 tags="InputData, Data, DataGen, Language";
 desc="translates story sentences into specific parameters to be used in rendering scenes from stories.  see https://grey.colorado.edu/emergent/index.php/StoryParambulator for full details";
 flags=NO_STOP_STEP;
 stop_step_cond {
  expr=;
 };
 objs {
  name="objs";
  el_typ=taNBase;
  el_def=0;
  DataTable_Group @[0] {
   name="ActiveSceneSpecs";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="BallSceneSpecs";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     int_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_266";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.08064516;
	val_type_fixed=0;
       };
      };
      name="priority";
      desc="this determines sort order of items and matching is done in sort order, so later items (higher priority) override earlier things -- put basic defaults first then more specific override conditions later";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=55;
      ar {
       name="ar";
      [14] 20;10;10;20;10;10;30;10;0;0;
30;0;10;1;      };
     };
     bool_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_284";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.09970675;
	val_type_fixed=0;
       };
      };
      name="on";
      desc="whether to include this item";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=68;
      ar {
       name="ar";
      [14] true;false;false;true;false;false;true;false;false;false;
false;true;true;false;      };
     };
     String_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_265";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.4296188;
	val_type_fixed=0;
       };
      };
      name="keywords";
      desc="words that must appear in a sentence in order for these params to apply";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=293;
      ar {
       name="ar";
      [14] "ball:$po=[Ph|Po] $sz=[small|medium-sized|large]:J";"ball:[O|S] medium-sized:A";"ball:[O|S] large:A";"ball:$po=[Ph|Po] $color=[red|green|blue]:J";"ball:[O|S] green:A";"ball:[O|S] blue:A";"ball:$po=[Ph|Po] rolls:V $dir=[left|right]:L";"ball:Ph drops:V";;;
"ball:Ph rolls:V right:L";"<p> ball:$po=[Ph|Po]";"ball:$po=[Ph|Po]";"ball:Po";      };
     };
     String_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name="UserDataItem_List_267";
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.856305;
	val_type_fixed=0;
       };
      };
      name="params";
      desc="parameter values as name=value, space delimted, where name are parameter names for s_=subject o_= object, etc -- see vars in program for all -- can specify ranges for random values as [min:max] or enumerated lists [1,2,3]";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=584;
      ar {
       name="ar";
      [14] "$po[p|o]_size=$sz[0.1|0.2|0.3]&.05";"[o|s]_size=0.2";"[o|s]_size=0.3";"$po[p|o]_color=$color";"[o|s]_color=green";"[o|s]_color=blue";"$po[p|o]_start_x=$dir[0.9|0.1]&.05 $po[p|o]_start_y=[0.1:0.6] $po[p|o]_vel_x=$dir[[-0.15:-0.1]|[0.1:0.15]] $po[p|o]_vel_y=0 atrials=[8:10]";"p_start_y=0.15%.05";;;
"p_start_x=0.1%.05 p_start_y=[0.1:0.6] p_vel_x=[0.15:0.1] p_vel_y=0 atrials=[3:5]";"atrials=10 p_size=0.2&.05 p_color=black p_start_x=0.5&.1 p_start_y=0.5&.1 p_vel_x=0 p_vel_y=0 o_size=0.1 o_color=blue o_start_x=0.2 o_start_y=0.5 o_vel_x=0 o_vel_y=0";"$po[p|o]_obj=ball aud_word=ball aud_start=1";"o_obj=ball";      };
     };
     String_Data @[4] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.5821114;
	val_type_fixed=0;
       };
      };
      name="notes";
      desc="parameter values as name=value, space delimted, where name are parameter names for s_=subject o_= object, etc -- see vars in program for all -- can specify ranges for random values as [min:max] or enumerated lists [1,2,3]";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=397;
      ar {
       name="ar";
      [14] ;;;;;;;;;;
;"<p> = start of new story sequence -- these are all cases in which a ball is a Patient theme (Ph) or a Co-Patient (Po)";;;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [5] 11;12;3;0;6;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
      DataSortEl @[0] {
       col_name="priority";
       name="priority_up_0";
       order=ASCENDING;
      };
      DataSortEl @[1] {
       col_name="keywords";
       name="keywords_up_1";
       order=ASCENDING;
      };
      DataSortEl @[2] {
       col_name="notes";
       name="notes_up_2";
       order=ASCENDING;
      };
      DataSortEl @[3] {
       col_name="notes";
       name="notes_up_3";
       order=ASCENDING;
      };
      DataSortEl @[4] {
       col_name="notes";
       name="notes_up_4";
       order=ASCENDING;
      };
      DataSortEl @[5] {
       col_name="notes";
       name="notes_up_5";
       order=ASCENDING;
      };
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
  DataTable_Group @[1] {
   name="InactiveSceneSpecs";
   el_typ=DataTable;
   el_def=0;
   save_tables=1;
   DataTable @[0] {
    name="TempSceneSpecs";
    desc=;
    data {
     name="data";
     el_typ=String_Data;
     el_def=0;
     String_Data @[0] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.2041812;
	val_type_fixed=0;
       };
      };
      name="keywords";
      desc="words that must appear in a sentence in order for these params to apply";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=293;
      ar {
       name="ar";
      [7] ;"ball:Ph";"ball:Po";"ball:$po=[Ph|Po] $sz=[small|medium-sized|large]:J";"ball:$po=[Ph|Po] $color=[red|green|blue]:J";"ball:Ph rolls:V left:L";"ball:Ph rolls:V right:L";      };
     };
     int_Data @[1] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.03832753;
	val_type_fixed=0;
       };
      };
      name="priority";
      desc="this determines sort order of items and matching is done in sort order, so later items (higher priority) override earlier things -- put basic defaults first then more specific override conditions later";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=55;
      ar {
       name="ar";
      [7] 0;1;1;10;10;10;10;      };
     };
     String_Data @[2] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.3463415;
	val_type_fixed=0;
       };
      };
      name="params";
      desc="parameter values as name=value, space delimted, where name are parameter names for s_=subject o_= object, etc -- see vars in program for all -- can specify ranges for random values as [min:max] or enumerated lists [1,2,3]";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=497;
      ar {
       name="ar";
      [7] "atrials=3 p_size=0.2%.05 p_color=black p_start_x=0.5%.1 p_start_y=0.5%.1 p_vel_x=0 p_vel_y=0 o_size=0.1 o_color=blue o_start_x=0.2 o_start_y=0.5 o_vel_x=0 o_vel_y=0";"p_obj=ball";"o_obj=ball";"$po[p|o]_size=$sz[0.1|0.2|0.3]%.05";"$po[p|o]_color=$color";"p_start_x=0.9%.05 p_start_y=[0.1:0.6] p_vel_x=[-0.15:-0.1] p_vel_y=0 atrials=[3:5]";"p_start_x=0.1%.05 p_start_y=[0.1:0.6] p_vel_x=[0.15:0.1] p_vel_y=0 atrials=[3:5]";      };
     };
     String_Data @[3] {
      UserDataItem_List @*(.user_data_) {
       name=;
       el_typ=UserDataItem;
       el_def=0;
       UserDataItem @[0] {
	name="view_panel_wd";
	value 8 0=0.276655;
	val_type_fixed=0;
       };
      };
      name="notes";
      desc="parameter values as name=value, space delimted, where name are parameter names for s_=subject o_= object, etc -- see vars in program for all -- can specify ranges for random values as [min:max] or enumerated lists [1,2,3]";
      col_flags=SAVE_DATA|CHECKBOX;
      is_matrix=0;
      cell_geom{ 1;      };
      calc_expr {
       expr=;
      };
      dim_names {
       name="dim_names";
      [0]       };
      width=397;
      ar {
       name="ar";
      [7] ;;;;;;;      };
     };
    };
    data_flags=SAVE_ROWS|AUTO_CALC;
    auto_load=NO_AUTO_LOAD;
    auto_load_file=;
    keygen 4 0=0;
    row_indexes {
     name="row_indexes";
    [7] 0;1;2;3;4;5;6;    };
    last_sort_spec {
     name="last_sort_spec";
     ops {
      name="ops";
      el_typ=DataSortEl;
      el_def=0;
     };
    };
    control_panel_cells {
     name="control_panel_cells";
     el_typ=DataTableCell;
     el_def=0;
    };
   };
  };
  DataBlock @[2] {
   name="TmpFilt";
   desc=;
   data {
    name="data";
    el_typ=DataColT;
    el_def=0;
   };
   data_flags=SAVE_ROWS|AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [0]    };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[3] {
   name="KeyCombos";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     name="po";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="dir";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [2] 0;1;   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[4] {
   name="ParamCombos";
   desc=;
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     name="p0";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[1] {
     name="p1";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[2] {
     name="p2";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[3] {
     name="p3";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[4] {
     name="p4";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
    String_Data @[5] {
     name="p5";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=0;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [2] 0;1;   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[5] {
   name="CompiledSpecs";
   desc="fully explicit literal specs built from current specs";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    int_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.03838102;
       val_type_fixed=0;
      };
     };
     name="priority";
     desc="this determines sort order of items and matching is done in sort order, so later items (higher priority) override earlier things -- put basic defaults first then more specific override conditions later";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=55;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2044661;
       val_type_fixed=0;
      };
     };
     name="keywords";
     desc="words that must appear in a sentence in order for these params to apply";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=293;
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.6085136;
       val_type_fixed=0;
      };
     };
     name="params";
     desc="parameter values as name=value, space delimted, where name are parameter names for s_=subject o_= object, etc -- see vars in program for all -- can specify ranges for random values as [min:max] or enumerated lists [1,2,3]";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=872;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [20] 0;1;2;3;8;6;14;12;4;10;
9;7;15;13;5;11;16;18;17;19;
   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
     DataSortEl @[0] {
      col_name="priority";
      name="priority_up_0";
      order=ASCENDING;
     };
     DataSortEl @[1] {
      col_name="keywords";
      name="keywords_up_1";
      order=ASCENDING;
     };
     DataSortEl @[2] {
      col_name="params";
      name="params_up_2";
      order=ASCENDING;
     };
     DataSortEl @[3] {
      col_name="params";
      name="params_up_3";
      order=ASCENDING;
     };
     DataSortEl @[4] {
      col_name="params";
      name="params_up_4";
      order=ASCENDING;
     };
     DataSortEl @[5] {
      col_name="params";
      name="params_up_5";
      order=ASCENDING;
     };
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
  DataTable @[6] {
   name="CurParams";
   desc="current scene parameters integrated from scene specs";
   data {
    name="data";
    el_typ=String_Data;
    el_def=0;
    String_Data @[0] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_270";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.1451613;
       val_type_fixed=0;
      };
     };
     name="name";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=99;
    };
    String_Data @[1] {
     UserDataItem_List @*(.user_data_) {
      name="UserDataItem_List_271";
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2096774;
       val_type_fixed=0;
      };
     };
     name="value";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=143;
    };
    String_Data @[2] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.2096774;
       val_type_fixed=0;
      };
     };
     name="valstr";
     desc="original string representation of the value -- includes random generation specs before they are turned into a specific value";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=143;
    };
    String_Data @[3] {
     UserDataItem_List @*(.user_data_) {
      name=;
      el_typ=UserDataItem;
      el_def=0;
      UserDataItem @[0] {
       name="view_panel_wd";
       value 8 0=0.3533724;
       val_type_fixed=0;
      };
     };
     name="matched";
     desc="shows the keys that last matched for this parameter, and thus were the ones that set this parameter value";
     col_flags=SAVE_DATA|CHECKBOX;
     is_matrix=0;
     cell_geom{ 1;     };
     calc_expr {
      expr=;
     };
     dim_names {
      name="dim_names";
     [0]      };
     width=241;
    };
   };
   data_flags=AUTO_CALC;
   auto_load=NO_AUTO_LOAD;
   auto_load_file=;
   keygen 4 0=0;
   row_indexes {
    name="row_indexes";
   [3] 0;1;2;   };
   last_sort_spec {
    name="last_sort_spec";
    ops {
     name="ops";
     el_typ=DataSortEl;
     el_def=0;
    };
   };
   control_panel_cells {
    name="control_panel_cells";
    el_typ=DataTableCell;
    el_def=0;
   };
  };
 };
 types {
  name="types";
  el_typ=DynEnumType;
  el_def=0;
 };
 args {
  name="args";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="input_sentence";
   var_type=T_String;
   string_val="the ball:Ph hits:V the block:Po .";
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL|PGRM_ARG;
   reference=0;
   desc="the sentence to generate paramters from";
   init_from=NULL;
  };
 };
 vars {
  name="vars";
  el_typ=ProgVar;
  el_def=0;
  ProgVar @[0] {
   name="ActiveSceneSpecs";
   var_type=T_Object;
   object_type=DataTable_Group;
   object_val=.projects[0].programs.gp[3][6].objs[0]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[1] {
   name="CompiledSpecs";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][6].objs[5]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[2] {
   name="CurParams";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][6].objs[6]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[3] {
   name="InactiveSceneSpecs";
   var_type=T_Object;
   object_type=DataTable_Group;
   object_val=.projects[0].programs.gp[3][6].objs[1]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[4] {
   name="KeyCombos";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][6].objs[3]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[5] {
   name="ParamCombos";
   var_type=T_Object;
   object_type=DataTable;
   object_val=.projects[0].programs.gp[3][6].objs[4]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[6] {
   name="TmpFilt";
   var_type=T_Object;
   object_type=DataBlock;
   object_val=.projects[0].programs.gp[3][6].objs[2]$$;
   objs_ptr=1;
   flags=NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
  ProgVar @[7] {
   name="cur_params";
   var_type=T_Object;
   object_type=DataTable;
   object_val=$.projects[0].programs.gp[3][6].objs[6]$;
   objs_ptr=0;
   flags=CTRL_PANEL|NULL_CHECK|SAVE_VAL|USED|EDIT_VAL;
   reference=0;
   desc=;
   init_from=NULL;
  };
 };
 functions {
  name="functions";
  el_typ=Function;
  el_def=0;
  Function @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddCompileRow(String keys, int pri, String params) returns: int";
   pre_compile_code_string="AddCompileRow(String keys, int pri, String params) returns: int";
   name="AddCompileRow";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="keys";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="pri";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="params";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (keys.contains(\"$\"))";
     pre_compile_code_string="if (keys.contains(\"$\"))";
     cond {
      expr="keys.contains(\"$\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      BlankLineEl @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string=" ";
       pre_compile_code_string=" ";
      };
     };
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CompiledSpecs->AddBlankRow()";
     pre_compile_code_string="CompiledSpecs->AddBlankRow()";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].vars[1]$$;
     method=DataTable::AddBlankRow;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int AddBlankRow()";
     meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
    };
    MatrixAssign @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CompiledSpecs[\"keywords\"][-1] = keys.trim()";
     pre_compile_code_string="CompiledSpecs[\"keywords\"][-1] = keys.trim()";
     variable=$.projects[0].programs.gp[3][6].vars[1]$;
     data_table=1;
     col {
      expr="\"keywords\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="keys.trim()";
     };
    };
    MatrixAssign @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CompiledSpecs[\"priority\"][-1] = pri";
     pre_compile_code_string="CompiledSpecs[\"priority\"][-1] = pri";
     variable=$.projects[0].programs.gp[3][6].vars[1]$;
     data_table=1;
     col {
      expr="\"priority\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="pri";
     };
    };
    MatrixAssign @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CompiledSpecs[\"params\"][-1] = params.trim()";
     pre_compile_code_string="CompiledSpecs[\"params\"][-1] = params.trim()";
     variable=$.projects[0].programs.gp[3][6].vars[1]$;
     data_table=1;
     col {
      expr="\"params\"";
     };
     dim0 {
      expr="-1";
     };
     dim1 {
      expr=;
     };
     dim2 {
      expr=;
     };
     dim3 {
      expr=;
     };
     dim4 {
      expr=;
     };
     dim5 {
      expr=;
     };
     expr {
      expr="params.trim()";
     };
    };
   };
  };
  Function @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="CompileSpecVar(String keys, int pri, String params) returns: int";
   pre_compile_code_string="CompileSpecVar(String keys, int pri, String params) returns: int";
   name="CompileSpecVar";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name=;
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="keys";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="pri";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="params";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name=;
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (31 vars)";
     pre_compile_code_string="LocalVars (31 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="kary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="pary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="vary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="prmvars";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="pnames";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="pvalues";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="vardims";
       var_type=T_Object;
       object_type=MatrixGeom;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="varidx";
       var_type=T_Object;
       object_type=MatrixIndex;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="key";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="varnm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[10] {
       name="varvals";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[11] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[12] {
       name="fixedkeys";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[13] {
       name="max_idx";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[14] {
       name="newkey";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[15] {
       name="d";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[16] {
       name="n_dims";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[17] {
       name="startkey";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[18] {
       name="endkey";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[19] {
       name="prm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[20] {
       name="startprm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[21] {
       name="endprm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[22] {
       name="pcol";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[23] {
       name="newprm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[24] {
       name="varval";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[25] {
       name="vi";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[26] {
       name="pnm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[27] {
       name="pval";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[28] {
       name="pv";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[29] {
       name="j";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[30] {
       name="val";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="kary->Split(keys, \" \")";
     pre_compile_code_string="kary->Split(keys, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[0]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="keys";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="pary->Split(params, \" \")";
     pre_compile_code_string="pary->Split(params, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[1]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="params";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    MethodCall @[3] {
     desc="rows and columns";
     flags=CAN_REVERT_TO_CODE;
     code_string="KeyCombos->Reset()";
     pre_compile_code_string="KeyCombos->Reset()";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].vars[4]$$;
     method=DataTable::Reset;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Reset()";
     meth_desc=" remove all columns (and data) -- this cannot be undone!";
    };
    MethodCall @[4] {
     desc="rows and columns";
     flags=CAN_REVERT_TO_CODE;
     code_string="ParamCombos->Reset()";
     pre_compile_code_string="ParamCombos->Reset()";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].vars[5]$$;
     method=DataTable::Reset;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void Reset()";
     meth_desc=" remove all columns (and data) -- this cannot be undone!";
    };
    ForeachLoop @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(key in kary)";
     pre_compile_code_string="foreach(key in kary)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (key.contains(\"$\"))";
       pre_compile_code_string="if (key.contains(\"$\"))";
       cond {
	expr="key.contains(\"$\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="varnm = key->between(\"$\", \"=\", )";
	 pre_compile_code_string="varnm = key->between(\"$\", \"=\", )";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[9]$$;
	 obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[8]$$;
	 method=taString::between;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="st_str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"$\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ed_str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"=\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString between(taString& st_str, taString& ed_str, int startpos = 0)";
	 meth_desc=" get substring between (not including) target strings. startpos = starting position (- = search from end forward)";
	};
	If @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (varnm.empty() || !key.contains(\"=[\"))";
	 pre_compile_code_string="if (varnm.empty() || !key.contains(\"=[\"))";
	 cond {
	  expr="varnm.empty() || !key.contains(\"=[\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MiscCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taMisc::Error(\"keyword syntax error for var:\", varnm, \"does not contain =[ expression in key:\", key, , , , , )";
	   pre_compile_code_string="taMisc::Error(\"keyword syntax error for var:\", varnm, \"does not contain =[ expression in key:\", key, , , , , )";
	   result_var=NULL;
	   object_type=taMisc;
	   method=taMisc::Error;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="a";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"keyword syntax error for var:\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="b";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="varnm";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="c";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="\"does not contain =[ expression in key:\"";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="d";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="key";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="e";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="f";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="g";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="h";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[8] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="i";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	};
	MethodCall @[2] {
	 desc="todo: some error reporting..";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="varvals = key->between(\"=[\", \"]\", )";
	 pre_compile_code_string="varvals = key->between(\"=[\", \"]\", )";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$$;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[8]$;
	 method=taString::between;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="st_str";
	   required=1;
	   def_val=;
	   prev_expr="\"=[\"";
	   expr {
	    expr="\"=[\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ed_str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"]\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString between(taString& st_str, taString& ed_str, int startpos = 0)";
	 meth_desc=" get substring between (not including) target strings. startpos = starting position (- = search from end forward)";
	};
	AssignExpr @[3] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="startkey = \"\"";
	 pre_compile_code_string="startkey = \"\"";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[17]$$;
	 expr {
	  expr="\"\"";
	 };
	};
	AssignExpr @[4] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="endkey = \"\"";
	 pre_compile_code_string="endkey = \"\"";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[18]$$;
	 expr {
	  expr="\"\"";
	 };
	};
	If @[5] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (!key.startsWith(\"$\"))";
	 pre_compile_code_string="if (!key.startsWith(\"$\"))";
	 cond {
	  expr="!key.startsWith(\"$\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="startkey = key->before(\"$\", )";
	   pre_compile_code_string="startkey = key->before(\"$\", )";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[17]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[8]$;
	   method=taString::before;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"$\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="taString before(taString& x, int startpos = 0)";
	   meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	 };
	};
	If @[6] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (!key.endsWith(\"]\"))";
	 pre_compile_code_string="if (!key.endsWith(\"]\"))";
	 cond {
	  expr="!key.endsWith(\"]\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="endkey = key->after(\"]\", -1)";
	   pre_compile_code_string="endkey = key->after(\"]\", -1)";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[18]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[8]$;
	   method=taString::after;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"]\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="taString after(taString& x, int startpos = 0)";
	   meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	 };
	};
	MethodCall @[7] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="vary->Split(varvals, \"|\")";
	 pre_compile_code_string="vary->Split(varvals, \"|\")";
	 result_var=NULL;
	 obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[2]$$;
	 method=String_Array::Split;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="varvals";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="delim";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="\"|\"";
	   };
	  };
	 };
	 meth_sig="void Split(taString& str, taString& delim)";
	 meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
	};
	MethodCall @[8] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="KeyCombos->NewColString(varnm)";
	 pre_compile_code_string="KeyCombos->NewColString(varnm)";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].vars[4]$;
	 method=DataTable::NewColString;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="col_nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="varnm";
	   };
	  };
	 };
	 meth_sig="String_Data_ptr NewColString(taString& col_nm)";
	 meth_desc=" create new column of string data";
	};
	If @[9] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (KeyCombos.rows < vary.size)";
	 pre_compile_code_string="if (KeyCombos.rows < vary.size)";
	 cond {
	  expr="KeyCombos.rows < vary.size";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="KeyCombos->EnforceRows(vary.size)";
	   pre_compile_code_string="KeyCombos->EnforceRows(vary.size)";
	   result_var=NULL;
	   obj=$.projects[0].programs.gp[3][6].vars[4]$;
	   method=DataTable::EnforceRows;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="n_rows";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="vary.size";
	     };
	    };
	   };
	   meth_sig="void EnforceRows(int n_rows)";
	   meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
	  };
	 };
	};
	ForLoop @[10] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (i=0; i<vary.size; i++)";
	 pre_compile_code_string="for (i=0; i<vary.size; i++)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MatrixAssign @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="KeyCombos[varnm][i] = startkey + vary[i] + endkey";
	   pre_compile_code_string="KeyCombos[varnm][i] = startkey + vary[i] + endkey";
	   variable=$.projects[0].programs.gp[3][6].vars[4]$;
	   data_table=1;
	   col {
	    expr="varnm";
	   };
	   dim0 {
	    expr="i";
	   };
	   dim1 {
	    expr=;
	   };
	   dim2 {
	    expr=;
	   };
	   dim3 {
	    expr=;
	   };
	   dim4 {
	    expr=;
	   };
	   dim5 {
	    expr=;
	   };
	   expr {
	    expr="startkey + vary[i] + endkey";
	   };
	  };
	 };
	 init {
	  expr="i=0";
	 };
	 test {
	  expr="i<vary.size";
	 };
	 iter {
	  expr="i++";
	 };
	};
	MethodCall @[11] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="vardims->AddDim(vary.size)";
	 pre_compile_code_string="vardims->AddDim(vary.size)";
	 result_var=NULL;
	 obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[6]$$;
	 method=MatrixGeom::AddDim;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=int;
	   type="int";
	   name="value";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="vary.size";
	   };
	  };
	 };
	 meth_sig="void AddDim(int value)";
	 meth_desc=" safely add a new dimension with given value";
	};
       };
      };
      Else @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	If @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (fixedkeys.empty())";
	 pre_compile_code_string="if (fixedkeys.empty())";
	 cond {
	  expr="fixedkeys.empty()";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="fixedkeys = key";
	   pre_compile_code_string="fixedkeys = key";
	   result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[12]$$;
	   expr {
	    expr="key";
	   };
	  };
	 };
	};
	Else @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="else";
	 pre_compile_code_string="else";
	 else_code {
	  name="else_code";
	  el_typ=ProgCode;
	  el_def=0;
	  VarIncr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="fixedkeys += \" \" + key";
	   pre_compile_code_string="fixedkeys += \" \" + key";
	   var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[12]$;
	   expr {
	    expr="\" \" + key";
	   };
	  };
	 };
	};
       };
      };
     };
     el_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[8]$;
     in {
      expr="kary";
     };
    };
    ForeachLoop @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(prm in pary)";
     pre_compile_code_string="foreach(prm in pary)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="pnm = prm->before(\"=\", )";
       pre_compile_code_string="pnm = prm->before(\"=\", )";
       result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$$;
       obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[19]$$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"=\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="pval = prm->after(\"=\", )";
       pre_compile_code_string="pval = prm->after(\"=\", )";
       result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$$;
       obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[19]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"=\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      If @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (pnm.contains(\"$\"))";
       pre_compile_code_string="if (pnm.contains(\"$\"))";
       cond {
	expr="pnm.contains(\"$\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="varnm = pnm->between(\"$\", \"[\", )";
	 pre_compile_code_string="varnm = pnm->between(\"$\", \"[\", )";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[9]$;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$;
	 method=taString::between;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="st_str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"$\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="ed_str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"[\"";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString between(taString& st_str, taString& ed_str, int startpos = 0)";
	 meth_desc=" get substring between (not including) target strings. startpos = starting position (- = search from end forward)";
	};
	If @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (varnm.empty())";
	 pre_compile_code_string="if (varnm.empty())";
	 cond {
	  expr="varnm.empty()";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MiscCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="taMisc::Error(\"param syntax error for var:\", varnm, \"does not contain [ expression in param name:\", pnm, , , , , )";
	   pre_compile_code_string="taMisc::Error(\"param syntax error for var:\", varnm, \"does not contain [ expression in param name:\", pnm, , , , , )";
	   result_var=NULL;
	   object_type=taMisc;
	   method=taMisc::Error;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="a";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"param syntax error for var:\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="b";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="varnm";
	     };
	    };
	    ProgArg @[2] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="c";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="\"does not contain [ expression in param name:\"";
	     };
	    };
	    ProgArg @[3] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="d";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="pnm";
	     };
	    };
	    ProgArg @[4] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="e";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[5] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="f";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[6] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="g";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[7] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="h";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	    ProgArg @[8] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="i";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	};
	MethodCall @[2] {
	 desc="todo: some error reporting..";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="varvals = pnm->after(\"[\", )";
	 pre_compile_code_string="varvals = pnm->after(\"[\", )";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$;
	 method=taString::after;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr="\"=[\"";
	   expr {
	    expr="\"[\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr="\"]\"";
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString after(taString& x, int startpos = 0)";
	 meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	};
	MethodCall @[3] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="varvals = varvals->before(\"]\", -1)";
	 pre_compile_code_string="varvals = varvals->before(\"]\", -1)";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$;
	 method=taString::before;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"]\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr="-1";
	   };
	  };
	 };
	 meth_sig="taString before(taString& x, int startpos = 0)";
	 meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	};
	AssignExpr @[4] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="startprm = \"\"";
	 pre_compile_code_string="startprm = \"\"";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[20]$$;
	 expr {
	  expr="\"\"";
	 };
	};
	AssignExpr @[5] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="endprm = \"\"";
	 pre_compile_code_string="endprm = \"\"";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[21]$$;
	 expr {
	  expr="\"\"";
	 };
	};
	If @[6] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (!pnm.startsWith(\"$\"))";
	 pre_compile_code_string="if (!pnm.startsWith(\"$\"))";
	 cond {
	  expr="!pnm.startsWith(\"$\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="startprm = pnm->before(\"$\", )";
	   pre_compile_code_string="startprm = pnm->before(\"$\", )";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[20]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$;
	   method=taString::before;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"$\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="taString before(taString& x, int startpos = 0)";
	   meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	 };
	};
	If @[7] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (!pnm.endsWith(\"]\"))";
	 pre_compile_code_string="if (!pnm.endsWith(\"]\"))";
	 cond {
	  expr="!pnm.endsWith(\"]\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="endprm = pnm->after(\"]\", -1)";
	   pre_compile_code_string="endprm = pnm->after(\"]\", -1)";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[21]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$;
	   method=taString::after;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"]\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="taString after(taString& x, int startpos = 0)";
	   meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	 };
	};
	MethodCall @[8] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="vary->Split(varvals, \"|\")";
	 pre_compile_code_string="vary->Split(varvals, \"|\")";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[2]$;
	 method=String_Array::Split;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="str";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="varvals";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="delim";
	   required=0;
	   def_val="\"\"";
	   prev_expr=;
	   expr {
	    expr="\"|\"";
	   };
	  };
	 };
	 meth_sig="void Split(taString& str, taString& delim)";
	 meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
	};
	AssignExpr @[9] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pcol = prmvars.size";
	 pre_compile_code_string="pcol = prmvars.size";
	 result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[22]$$;
	 expr {
	  expr="prmvars.size";
	 };
	};
	MethodCall @[10] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pnames->Add(\"$\" + String(pcol))";
	 pre_compile_code_string="pnames->Add(\"$\" + String(pcol))";
	 result_var=NULL;
	 obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[4]$$;
	 method=taArray_taString_::Add;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="item";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"$\" + String(pcol)";
	   };
	  };
	 };
	 meth_sig="void Add(taString& item)";
	 meth_desc=" add the item to the array";
	};
	MethodCall @[11] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ParamCombos->NewColString(\"p\"+(String)pcol)";
	 pre_compile_code_string="ParamCombos->NewColString(\"p\"+(String)pcol)";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].vars[5]$;
	 method=DataTable::NewColString;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="col_nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"p\"+(String)pcol";
	   };
	  };
	 };
	 meth_sig="String_Data_ptr NewColString(taString& col_nm)";
	 meth_desc=" create new column of string data";
	};
	If @[12] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (ParamCombos.rows < vary.size)";
	 pre_compile_code_string="if (ParamCombos.rows < vary.size)";
	 cond {
	  expr="ParamCombos.rows < vary.size";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="ParamCombos->EnforceRows(vary.size)";
	   pre_compile_code_string="ParamCombos->EnforceRows(vary.size)";
	   result_var=NULL;
	   obj=$.projects[0].programs.gp[3][6].vars[5]$;
	   method=DataTable::EnforceRows;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="n_rows";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="vary.size";
	     };
	    };
	   };
	   meth_sig="void EnforceRows(int n_rows)";
	   meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
	  };
	 };
	};
	MethodCall @[13] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="prmvars->Add(varnm)";
	 pre_compile_code_string="prmvars->Add(varnm)";
	 result_var=NULL;
	 obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[3]$$;
	 method=taArray_taString_::Add;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="item";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="varnm";
	   };
	  };
	 };
	 meth_sig="void Add(taString& item)";
	 meth_desc=" add the item to the array";
	};
	ForLoop @[14] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (i=0; i<vary.size; i++)";
	 pre_compile_code_string="for (i=0; i<vary.size; i++)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MatrixAssign @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="ParamCombos[pcol][i] = startprm + vary[i] + endprm";
	   pre_compile_code_string="ParamCombos[pcol][i] = startprm + vary[i] + endprm";
	   variable=$.projects[0].programs.gp[3][6].vars[5]$;
	   data_table=1;
	   col {
	    expr="pcol";
	   };
	   dim0 {
	    expr="i";
	   };
	   dim1 {
	    expr=;
	   };
	   dim2 {
	    expr=;
	   };
	   dim3 {
	    expr=;
	   };
	   dim4 {
	    expr=;
	   };
	   dim5 {
	    expr=;
	   };
	   expr {
	    expr="startprm + vary[i] + endprm";
	   };
	  };
	 };
	 init {
	  expr="i=0";
	 };
	 test {
	  expr="i<vary.size";
	 };
	 iter {
	  expr="i++";
	 };
	};
       };
      };
      Else @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pnames->Add(pnm)";
	 pre_compile_code_string="pnames->Add(pnm)";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[4]$;
	 method=taArray_taString_::Add;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="item";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="pnm";
	   };
	  };
	 };
	 meth_sig="void Add(taString& item)";
	 meth_desc=" add the item to the array";
	};
       };
      };
      If @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (pval.contains(\"$\"))";
       pre_compile_code_string="if (pval.contains(\"$\"))";
       cond {
	expr="pval.contains(\"$\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="startprm = \"\"";
	 pre_compile_code_string="startprm = \"\"";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[20]$;
	 expr {
	  expr="\"\"";
	 };
	};
	AssignExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="endprm = \"\"";
	 pre_compile_code_string="endprm = \"\"";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[21]$;
	 expr {
	  expr="\"\"";
	 };
	};
	If @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (!pval.startsWith(\"$\"))";
	 pre_compile_code_string="if (!pval.startsWith(\"$\"))";
	 cond {
	  expr="!pval.startsWith(\"$\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="startprm = pval->before(\"$\", )";
	   pre_compile_code_string="startprm = pval->before(\"$\", )";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[20]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$;
	   method=taString::before;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"$\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="taString before(taString& x, int startpos = 0)";
	   meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	 };
	};
	MethodCall @[3] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="varnm = pval->after(\"$\", )";
	 pre_compile_code_string="varnm = pval->after(\"$\", )";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[9]$;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$;
	 method=taString::after;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr="\"$\"";
	   expr {
	    expr="\"$\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr="\"[\"";
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString after(taString& x, int startpos = 0)";
	 meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	};
	If @[4] {
	 desc="has its own enums";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (varnm.contains(\"[\"))";
	 pre_compile_code_string="if (varnm.contains(\"[\"))";
	 cond {
	  expr="varnm.contains(\"[\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="varnm = varnm->before(\"[\", )";
	   pre_compile_code_string="varnm = varnm->before(\"[\", )";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[9]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[9]$;
	   method=taString::before;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"[\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="taString before(taString& x, int startpos = 0)";
	   meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	  MethodCall @[1] {
	   desc="todo: some error reporting..";
	   flags=CAN_REVERT_TO_CODE;
	   code_string="varvals = pval->after(\"[\", )";
	   pre_compile_code_string="varvals = pval->after(\"[\", )";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$;
	   method=taString::after;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"[\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr=;
	     };
	    };
	   };
	   meth_sig="taString after(taString& x, int startpos = 0)";
	   meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	  MethodCall @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="varvals = varvals->before(\"]\", -1)";
	   pre_compile_code_string="varvals = varvals->before(\"]\", -1)";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[10]$;
	   method=taString::before;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="x";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="\"]\"";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=int;
	     type="int";
	     name="startpos";
	     required=0;
	     def_val="0";
	     prev_expr=;
	     expr {
	      expr="-1";
	     };
	    };
	   };
	   meth_sig="taString before(taString& x, int startpos = 0)";
	   meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
	  };
	  If @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (!pval.endsWith(\"]\"))";
	   pre_compile_code_string="if (!pval.endsWith(\"]\"))";
	   cond {
	    expr="!pval.endsWith(\"]\")";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    MethodCall @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="endprm = pval->after(\"]\", -1)";
	     pre_compile_code_string="endprm = pval->after(\"]\", -1)";
	     result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[21]$;
	     obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$;
	     method=taString::after;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="x";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"]\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=int;
	       type="int";
	       name="startpos";
	       required=0;
	       def_val="0";
	       prev_expr=;
	       expr {
		expr="-1";
	       };
	      };
	     };
	     meth_sig="taString after(taString& x, int startpos = 0)";
	     meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	    };
	   };
	  };
	  MethodCall @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="vary->Split(varvals, \"|\")";
	   pre_compile_code_string="vary->Split(varvals, \"|\")";
	   result_var=NULL;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[2]$;
	   method=String_Array::Split;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="str";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="varvals";
	     };
	    };
	    ProgArg @[1] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="delim";
	     required=0;
	     def_val="\"\"";
	     prev_expr=;
	     expr {
	      expr="\"|\"";
	     };
	    };
	   };
	   meth_sig="void Split(taString& str, taString& delim)";
	   meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
	  };
	 };
	};
	Else @[5] {
	 desc="get values from var";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="else";
	 pre_compile_code_string="else";
	 else_code {
	  name="else_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MemberMethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="vi = KeyCombos.data.FindNameIdx(varnm)";
	   pre_compile_code_string="vi = KeyCombos.data.FindNameIdx(varnm)";
	   obj=$.projects[0].programs.gp[3][6].vars[4]$;
	   path="data";
	   result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[25]$$;
	   method=taList_impl::FindNameIdx;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="it";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="varnm";
	     };
	    };
	   };
	   meth_sig="int FindNameIdx(taString& it)";
	   meth_desc=" return the index of the item with given name on the list";
	  };
	  If @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (vi < 0)";
	   pre_compile_code_string="if (vi < 0)";
	   cond {
	    expr="vi < 0";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    MiscCall @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="taMisc::Error(\"parameter refers to variable:\", varnm, \"that was not defined in keywords\", , , , , , )";
	     pre_compile_code_string="taMisc::Error(\"parameter refers to variable:\", varnm, \"that was not defined in keywords\", , , , , , )";
	     result_var=NULL;
	     object_type=taMisc;
	     method=taMisc::Error;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="a";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"parameter refers to variable:\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="b";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr="varnm";
	       };
	      };
	      ProgArg @[2] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="c";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr="\"that was not defined in keywords\"";
	       };
	      };
	      ProgArg @[3] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="d";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[4] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="e";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[5] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="f";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[6] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="g";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[7] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="h";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[8] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="i";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	     };
	    };
	   };
	  };
	  MethodCall @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="vary->Reset()";
	   pre_compile_code_string="vary->Reset()";
	   result_var=NULL;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[2]$;
	   method=taArray_base::Reset;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	   };
	   meth_sig="void Reset()";
	   meth_desc=" reset the list to zero size (does not free memory)";
	  };
	  ForLoop @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="for (j=0; j<KeyCombos.rows; j++)";
	   pre_compile_code_string="for (j=0; j<KeyCombos.rows; j++)";
	   loop_code {
	    name="loop_code";
	    el_typ=ProgCode;
	    el_def=0;
	    AssignExpr @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="val = KeyCombos[vi][j]";
	     pre_compile_code_string="val = KeyCombos[vi][j]";
	     result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[30]$$;
	     expr {
	      expr="KeyCombos[vi][j]";
	     };
	    };
	    IfBreak @[1] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="if(val.empty()) break";
	     pre_compile_code_string="if(val.empty()) break";
	     cond {
	      expr="val.empty()";
	     };
	    };
	    MethodCall @[2] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="vary->Add(val)";
	     pre_compile_code_string="vary->Add(val)";
	     result_var=NULL;
	     obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[2]$;
	     method=taArray_taString_::Add;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="item";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="val";
	       };
	      };
	     };
	     meth_sig="void Add(taString& item)";
	     meth_desc=" add the item to the array";
	    };
	   };
	   init {
	    expr="j=0";
	   };
	   test {
	    expr="j<KeyCombos.rows";
	   };
	   iter {
	    expr="j++";
	   };
	  };
	 };
	};
	AssignExpr @[6] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pcol = prmvars.size";
	 pre_compile_code_string="pcol = prmvars.size";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[22]$;
	 expr {
	  expr="prmvars.size";
	 };
	};
	MethodCall @[7] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pvalues->Add(\"$\" + String(pcol))";
	 pre_compile_code_string="pvalues->Add(\"$\" + String(pcol))";
	 result_var=NULL;
	 obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[5]$$;
	 method=taArray_taString_::Add;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="item";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"$\" + String(pcol)";
	   };
	  };
	 };
	 meth_sig="void Add(taString& item)";
	 meth_desc=" add the item to the array";
	};
	MethodCall @[8] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="ParamCombos->NewColString(\"p\"+(String)pcol)";
	 pre_compile_code_string="ParamCombos->NewColString(\"p\"+(String)pcol)";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].vars[5]$;
	 method=DataTable::NewColString;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="col_nm";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"p\"+(String)pcol";
	   };
	  };
	 };
	 meth_sig="String_Data_ptr NewColString(taString& col_nm)";
	 meth_desc=" create new column of string data";
	};
	If @[9] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (ParamCombos.rows < vary.size)";
	 pre_compile_code_string="if (ParamCombos.rows < vary.size)";
	 cond {
	  expr="ParamCombos.rows < vary.size";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MethodCall @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="ParamCombos->EnforceRows(vary.size)";
	   pre_compile_code_string="ParamCombos->EnforceRows(vary.size)";
	   result_var=NULL;
	   obj=$.projects[0].programs.gp[3][6].vars[5]$;
	   method=DataTable::EnforceRows;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="n_rows";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="vary.size";
	     };
	    };
	   };
	   meth_sig="void EnforceRows(int n_rows)";
	   meth_desc=" ensure that there are exactly n_rows in the table, removing or adding as needed";
	  };
	 };
	};
	MethodCall @[10] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="prmvars->Add(varnm)";
	 pre_compile_code_string="prmvars->Add(varnm)";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[3]$;
	 method=taArray_taString_::Add;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="item";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="varnm";
	   };
	  };
	 };
	 meth_sig="void Add(taString& item)";
	 meth_desc=" add the item to the array";
	};
	ForLoop @[11] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="for (i=0; i<vary.size; i++)";
	 pre_compile_code_string="for (i=0; i<vary.size; i++)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  MatrixAssign @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="ParamCombos[pcol][i] = startprm + vary[i] + endprm";
	   pre_compile_code_string="ParamCombos[pcol][i] = startprm + vary[i] + endprm";
	   variable=$.projects[0].programs.gp[3][6].vars[5]$;
	   data_table=1;
	   col {
	    expr="pcol";
	   };
	   dim0 {
	    expr="i";
	   };
	   dim1 {
	    expr=;
	   };
	   dim2 {
	    expr=;
	   };
	   dim3 {
	    expr=;
	   };
	   dim4 {
	    expr=;
	   };
	   dim5 {
	    expr=;
	   };
	   expr {
	    expr="startprm + vary[i] + endprm";
	   };
	  };
	 };
	 init {
	  expr="i=0";
	 };
	 test {
	  expr="i<vary.size";
	 };
	 iter {
	  expr="i++";
	 };
	};
       };
      };
      Else @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pvalues->Add(pval)";
	 pre_compile_code_string="pvalues->Add(pval)";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[5]$;
	 method=taArray_taString_::Add;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="item";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="pval";
	   };
	  };
	 };
	 meth_sig="void Add(taString& item)";
	 meth_desc=" add the item to the array";
	};
       };
      };
     };
     el_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[19]$;
     in {
      expr="pary";
     };
    };
    Comment @[7] {
     desc="now generate all the combinations in combinatorics";
     flags=CAN_REVERT_TO_CODE;
     code_string="// now generate all the combinations in combinatorics";
     pre_compile_code_string="// now generate all the combinations in combinatorics";
    };
    MethodCall @[8] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="max_idx = vardims->Product()";
     pre_compile_code_string="max_idx = vardims->Product()";
     result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[13]$$;
     obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[6]$;
     method=MatrixGeom::Product;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int Product()";
     meth_desc=" returns product of all dimension values (i.e., total size of geometry)";
    };
    MethodCall @[9] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="n_dims = vardims->dims()";
     pre_compile_code_string="n_dims = vardims->dims()";
     result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[16]$$;
     obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[6]$;
     method=MatrixGeom::dims;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="int dims()";
     meth_desc=" number of dimensions represented in this geom";
    };
    ForLoop @[10] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<max_idx; i++)";
     pre_compile_code_string="for (i=0; i<max_idx; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="vardims->DimsFmIndex(i, varidx)";
       pre_compile_code_string="vardims->DimsFmIndex(i, varidx)";
       result_var=NULL;
       obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[6]$;
       method=MatrixGeom::DimsFmIndex;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=int;
	 type="int";
	 name="idx";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="i";
	 };
	};
	ProgArg @[1] {
	 arg_type=MatrixIndex_ref;
	 type="MatrixIndex&";
	 name="dims";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="varidx";
	 };
	};
       };
       meth_sig="void DimsFmIndex(int idx, MatrixIndex& dims)";
       meth_desc=" get dimension values from index, based on geometry represented by 'this' geom object";
      };
      AssignExpr @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="newkey = fixedkeys";
       pre_compile_code_string="newkey = fixedkeys";
       result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[14]$$;
       expr {
	expr="fixedkeys";
       };
      };
      ForLoop @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (d = 0; d < n_dims; d++)";
       pre_compile_code_string="for (d = 0; d < n_dims; d++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	VarIncr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="newkey += \" \" + KeyCombos[d][varidx.dim(d)]";
	 pre_compile_code_string="newkey += \" \" + KeyCombos[d][varidx.dim(d)]";
	 var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[14]$;
	 expr {
	  expr="\" \" + KeyCombos[d][varidx.dim(d)]";
	 };
	};
       };
       init {
	expr="d = 0";
       };
       test {
	expr="d < n_dims";
       };
       iter {
	expr="d++";
       };
      };
      AssignExpr @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="newprm = \"\"";
       pre_compile_code_string="newprm = \"\"";
       result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[23]$$;
       expr {
	expr="\"\"";
       };
      };
      ForLoop @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (pv = 0; pv < pvalues.size; pv++)";
       pre_compile_code_string="for (pv = 0; pv < pvalues.size; pv++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pnm = pnames[pv]";
	 pre_compile_code_string="pnm = pnames[pv]";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$;
	 expr {
	  expr="pnames[pv]";
	 };
	};
	AssignExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="pval = pvalues[pv]";
	 pre_compile_code_string="pval = pvalues[pv]";
	 result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$;
	 expr {
	  expr="pvalues[pv]";
	 };
	};
	If @[2] {
	 desc="variable number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (pnm.startsWith(\"$\"))";
	 pre_compile_code_string="if (pnm.startsWith(\"$\"))";
	 cond {
	  expr="pnm.startsWith(\"$\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="d = (int)pnm->after(\"$\")";
	   pre_compile_code_string="d = (int)pnm->after(\"$\")";
	   result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[15]$$;
	   expr {
	    expr="(int)pnm->after(\"$\")";
	   };
	  };
	  MemberMethodCall @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="vi = KeyCombos.data.FindNameIdx(prmvars[d])";
	   pre_compile_code_string="vi = KeyCombos.data.FindNameIdx(prmvars[d])";
	   obj=$.projects[0].programs.gp[3][6].vars[4]$;
	   path="data";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[25]$;
	   method=taList_impl::FindNameIdx;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="it";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="prmvars[d]";
	     };
	    };
	   };
	   meth_sig="int FindNameIdx(taString& it)";
	   meth_desc=" return the index of the item with given name on the list";
	  };
	  If @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (vi < 0)";
	   pre_compile_code_string="if (vi < 0)";
	   cond {
	    expr="vi < 0";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    MiscCall @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="taMisc::Error(\"parameter refers to variable:\", prmvars[d], \"that was not defined in keywords\", , , , , , )";
	     pre_compile_code_string="taMisc::Error(\"parameter refers to variable:\", prmvars[d], \"that was not defined in keywords\", , , , , , )";
	     result_var=NULL;
	     object_type=taMisc;
	     method=taMisc::Error;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="a";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"parameter refers to variable:\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="b";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr="prmvars[d]";
	       };
	      };
	      ProgArg @[2] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="c";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr="\"that was not defined in keywords\"";
	       };
	      };
	      ProgArg @[3] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="d";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[4] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="e";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[5] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="f";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[6] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="g";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[7] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="h";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[8] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="i";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	     };
	    };
	   };
	  };
	  MethodCall @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="varval = varidx->dim(vi)";
	   pre_compile_code_string="varval = varidx->dim(vi)";
	   result_var=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[24]$$;
	   obj=.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[7]$$;
	   method=MatrixIndex::dim;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="i";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="vi";
	     };
	    };
	   };
	   meth_sig="int dim(int i)";
	   meth_desc=" return index along given dimension";
	  };
	  AssignExpr @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="pnm = ParamCombos[d][varval]";
	   pre_compile_code_string="pnm = ParamCombos[d][varval]";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[26]$;
	   expr {
	    expr="ParamCombos[d][varval]";
	   };
	  };
	 };
	};
	If @[3] {
	 desc="variable number";
	 flags=CAN_REVERT_TO_CODE;
	 code_string="if (pval.startsWith(\"$\"))";
	 pre_compile_code_string="if (pval.startsWith(\"$\"))";
	 cond {
	  expr="pval.startsWith(\"$\")";
	 };
	 true_code {
	  name="true_code";
	  el_typ=ProgCode;
	  el_def=0;
	  AssignExpr @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="d = (int)pval->after(\"$\")";
	   pre_compile_code_string="d = (int)pval->after(\"$\")";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[15]$;
	   expr {
	    expr="(int)pval->after(\"$\")";
	   };
	  };
	  MemberMethodCall @[1] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="vi = KeyCombos.data.FindNameIdx(prmvars[d])";
	   pre_compile_code_string="vi = KeyCombos.data.FindNameIdx(prmvars[d])";
	   obj=$.projects[0].programs.gp[3][6].vars[4]$;
	   path="data";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[25]$;
	   method=taList_impl::FindNameIdx;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=const_taString_ref;
	     type="taString&";
	     name="it";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="prmvars[d]";
	     };
	    };
	   };
	   meth_sig="int FindNameIdx(taString& it)";
	   meth_desc=" return the index of the item with given name on the list";
	  };
	  If @[2] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (vi < 0)";
	   pre_compile_code_string="if (vi < 0)";
	   cond {
	    expr="vi < 0";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    MiscCall @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="taMisc::Error(\"parameter refers to variable:\", prmvars[d], \"that was not defined in keywords\", , , , , , )";
	     pre_compile_code_string="taMisc::Error(\"parameter refers to variable:\", prmvars[d], \"that was not defined in keywords\", , , , , , )";
	     result_var=NULL;
	     object_type=taMisc;
	     method=taMisc::Error;
	     meth_args {
	      name="meth_args";
	      el_typ=ProgArg;
	      el_def=0;
	      ProgArg @[0] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="a";
	       required=1;
	       def_val=;
	       prev_expr=;
	       expr {
		expr="\"parameter refers to variable:\"";
	       };
	      };
	      ProgArg @[1] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="b";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr="prmvars[d]";
	       };
	      };
	      ProgArg @[2] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="c";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr="\"that was not defined in keywords\"";
	       };
	      };
	      ProgArg @[3] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="d";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[4] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="e";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[5] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="f";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[6] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="g";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[7] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="h";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	      ProgArg @[8] {
	       arg_type=const_taString_ref;
	       type="taString&";
	       name="i";
	       required=0;
	       def_val="\"\"";
	       prev_expr=;
	       expr {
		expr=;
	       };
	      };
	     };
	    };
	   };
	  };
	  MethodCall @[3] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="varval = varidx->dim(vi)";
	   pre_compile_code_string="varval = varidx->dim(vi)";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[24]$;
	   obj=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[7]$;
	   method=MatrixIndex::dim;
	   meth_args {
	    name="meth_args";
	    el_typ=ProgArg;
	    el_def=0;
	    ProgArg @[0] {
	     arg_type=int;
	     type="int";
	     name="i";
	     required=1;
	     def_val=;
	     prev_expr=;
	     expr {
	      expr="vi";
	     };
	    };
	   };
	   meth_sig="int dim(int i)";
	   meth_desc=" return index along given dimension";
	  };
	  AssignExpr @[4] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="pval = ParamCombos[d][varval]";
	   pre_compile_code_string="pval = ParamCombos[d][varval]";
	   result_var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[27]$;
	   expr {
	    expr="ParamCombos[d][varval]";
	   };
	  };
	 };
	};
	VarIncr @[4] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="newprm += \" \" + pnm + \"=\" + pval";
	 pre_compile_code_string="newprm += \" \" + pnm + \"=\" + pval";
	 var=$.projects[0].programs.gp[3][6].functions[1].fun_code[0].local_vars[23]$;
	 expr {
	  expr="\" \" + pnm + \"=\" + pval";
	 };
	};
       };
       init {
	expr="pv = 0";
       };
       test {
	expr="pv < pvalues.size";
       };
       iter {
	expr="pv++";
       };
      };
      FunctionCall @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddCompileRow(newkey, pri, newprm)";
       pre_compile_code_string="AddCompileRow(newkey, pri, newprm)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][6].functions[0]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="keys";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="newkey";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="pri";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="pri";
	 };
	};
	ProgArg @[2] {
	 arg_type=taString;
	 type="String";
	 name="params";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="newprm";
	 };
	};
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<max_idx";
     };
     iter {
      expr="i++";
     };
    };
   };
  };
  Function @[2] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="CompileSpec(String keys, int pri, String params) returns: int";
   pre_compile_code_string="CompileSpec(String keys, int pri, String params) returns: int";
   name="CompileSpec";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="keys";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="pri";
     var_type=T_Int;
     int_val=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="params";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_520";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (0 vars)";
     pre_compile_code_string="LocalVars (0 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
     };
    };
    If @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (keys.contains(\"$\"))";
     pre_compile_code_string="if (keys.contains(\"$\"))";
     cond {
      expr="keys.contains(\"$\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CompileSpecVar(keys, pri, params)";
       pre_compile_code_string="CompileSpecVar(keys, pri, params)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][6].functions[1]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="keys";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="keys";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="pri";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="pri";
	 };
	};
	ProgArg @[2] {
	 arg_type=taString;
	 type="String";
	 name="params";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="params";
	 };
	};
       };
      };
     };
    };
    Else @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else";
     pre_compile_code_string="else";
     else_code {
      name="else_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="AddCompileRow(keys, pri, params)";
       pre_compile_code_string="AddCompileRow(keys, pri, params)";
       result_var=NULL;
       fun=$.projects[0].programs.gp[3][6].functions[0]$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="keys";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="keys";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="pri";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="pri";
	 };
	};
	ProgArg @[2] {
	 arg_type=taString;
	 type="String";
	 name="params";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="params";
	 };
	};
       };
      };
     };
    };
   };
  };
  Function @[3] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="CompileSpecs() returns: int";
   pre_compile_code_string="CompileSpecs() returns: int";
   name="CompileSpecs";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_518";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="spec";
       var_type=T_Object;
       object_type=DataTable;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CompiledSpecs->ResetData()";
     pre_compile_code_string="CompiledSpecs->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][6].vars[1]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    ForeachLoop @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(spec in ActiveSceneSpecs)";
     pre_compile_code_string="foreach(spec in ActiveSceneSpecs)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="spec->Sort(\"priority\", true, \"keywords\", true, , , , , , , , )";
       pre_compile_code_string="spec->Sort(\"priority\", true, \"keywords\", true, , , , , , , , )";
       result_var=NULL;
       obj=.projects[0].programs.gp[3][6].functions[3].fun_code[0].local_vars[1]$$;
       method=DataTable::Sort;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col1";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"priority\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=bool;
	 type="bool";
	 name="ascending1";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
	ProgArg @[2] {
	 arg_type=Variant;
	 type="Variant";
	 name="col2";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr="\"keywords\"";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="ascending2";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr="true";
	 };
	};
	ProgArg @[4] {
	 arg_type=Variant;
	 type="Variant";
	 name="col3";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[5] {
	 arg_type=bool;
	 type="bool";
	 name="ascending3";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[6] {
	 arg_type=Variant;
	 type="Variant";
	 name="col4";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[7] {
	 arg_type=bool;
	 type="bool";
	 name="ascending4";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[8] {
	 arg_type=Variant;
	 type="Variant";
	 name="col5";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[9] {
	 arg_type=bool;
	 type="bool";
	 name="ascending5";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[10] {
	 arg_type=Variant;
	 type="Variant";
	 name="col6";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
	ProgArg @[11] {
	 arg_type=bool;
	 type="bool";
	 name="ascending6";
	 required=0;
	 def_val="true";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="void Sort(Variant& col1, bool ascending1 = true, Variant col2 = -1, bool ascending2 = true, Variant col3 = -1, bool ascending3 = true, Variant col4 = -1, bool ascending4 = true, Variant col5 = -1, bool ascending5 = true, Variant col6 = -1, bool ascending6 = true)";
       meth_desc=" sort table according to selected columns of data. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this sort you would need to run Flatten first";
      };
      ForLoop @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="for (i=0; i<spec.rows; i++)";
       pre_compile_code_string="for (i=0; i<spec.rows; i++)";
       loop_code {
	name="loop_code";
	el_typ=ProgCode;
	el_def=0;
	FunctionCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="CompileSpec(spec[\"keywords\"][i], spec[\"priority\"][i], spec[\"params\"][i])";
	 pre_compile_code_string="CompileSpec(spec[\"keywords\"][i], spec[\"priority\"][i], spec[\"params\"][i])";
	 result_var=NULL;
	 fun=.projects[0].programs.gp[3][6].functions[2]$$;
	 fun_args {
	  name="fun_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=taString;
	   type="String";
	   name="keys";
	   required=1;
	   def_val=;
	   prev_expr="spec[\"keywords\"][i]";
	   expr {
	    expr="spec[\"keywords\"][i]";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="pri";
	   required=1;
	   def_val=;
	   prev_expr="spec[\"priority\"][i]";
	   expr {
	    expr="spec[\"priority\"][i]";
	   };
	  };
	  ProgArg @[2] {
	   arg_type=taString;
	   type="String";
	   name="params";
	   required=1;
	   def_val=;
	   prev_expr="spec[\"params\"][i]";
	   expr {
	    expr="spec[\"params\"][i]";
	   };
	  };
	 };
	};
       };
       init {
	expr="i=0";
       };
       test {
	expr="i<spec.rows";
       };
       iter {
	expr="i++";
       };
      };
     };
     el_var=$.projects[0].programs.gp[3][6].functions[3].fun_code[0].local_vars[1]$;
     in {
      expr="ActiveSceneSpecs";
     };
    };
    MethodCall @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CompiledSpecs->Sort(\"priority\", true, \"keywords\", true, , , , , , , , )";
     pre_compile_code_string="CompiledSpecs->Sort(\"priority\", true, \"keywords\", true, , , , , , , , )";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][6].vars[1]$;
     method=DataTable::Sort;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col1";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"priority\"";
       };
      };
      ProgArg @[1] {
       arg_type=bool;
       type="bool";
       name="ascending1";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[2] {
       arg_type=Variant;
       type="Variant";
       name="col2";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr="\"keywords\"";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="ascending2";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr="true";
       };
      };
      ProgArg @[4] {
       arg_type=Variant;
       type="Variant";
       name="col3";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[5] {
       arg_type=bool;
       type="bool";
       name="ascending3";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[6] {
       arg_type=Variant;
       type="Variant";
       name="col4";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[7] {
       arg_type=bool;
       type="bool";
       name="ascending4";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[8] {
       arg_type=Variant;
       type="Variant";
       name="col5";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[9] {
       arg_type=bool;
       type="bool";
       name="ascending5";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[10] {
       arg_type=Variant;
       type="Variant";
       name="col6";
       required=0;
       def_val="-1";
       prev_expr=;
       expr {
	expr=;
       };
      };
      ProgArg @[11] {
       arg_type=bool;
       type="bool";
       name="ascending6";
       required=0;
       def_val="true";
       prev_expr=;
       expr {
	expr=;
       };
      };
     };
     meth_sig="void Sort(Variant& col1, bool ascending1 = true, Variant col2 = -1, bool ascending2 = true, Variant col3 = -1, bool ascending3 = true, Variant col4 = -1, bool ascending4 = true, Variant col5 = -1, bool ascending5 = true, Variant col6 = -1, bool ascending6 = true)";
     meth_desc=" sort table according to selected columns of data. Note: you can instantly recover the original full set of rows, unsorted and unfiltered, by using ShowAllRows on the DataTable -- see that function for more details -- to be be able to undo just this sort you would need to run Flatten first";
    };
   };
  };
  Function @[4] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="AddParams(String params, String key) returns: int";
   pre_compile_code_string="AddParams(String params, String key) returns: int";
   name="AddParams";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="params";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="key";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_591";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (5 vars)";
     pre_compile_code_string="LocalVars (5 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="pary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="prm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="pnm";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="pval";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="prow";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="pary->Split(params, \" \")";
     pre_compile_code_string="pary->Split(params, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[0]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="params";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    ForeachLoop @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(prm in pary)";
     pre_compile_code_string="foreach(prm in pary)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="pnm = prm->before(\"=\", )";
       pre_compile_code_string="pnm = prm->before(\"=\", )";
       result_var=.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[2]$$;
       obj=.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[1]$$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"=\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="pval = prm->after(\"=\", )";
       pre_compile_code_string="pval = prm->after(\"=\", )";
       result_var=.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[3]$$;
       obj=$.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[1]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"=\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="prow = CurParams->FindVal(pnm, \"name\", 0, false)";
       pre_compile_code_string="prow = CurParams->FindVal(pnm, \"name\", 0, false)";
       result_var=.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[4]$$;
       obj=.projects[0].programs.gp[3][6].vars[2]$$;
       method=DataTable::FindVal;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="val";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="pnm";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_Variant_ref;
	 type="Variant&";
	 name="col";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"name\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="st_row";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr="0";
	 };
	};
	ProgArg @[3] {
	 arg_type=bool;
	 type="bool";
	 name="not_found_err";
	 required=0;
	 def_val="false";
	 prev_expr=;
	 expr {
	  expr="false";
	 };
	};
       };
       meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
       meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
      };
      If @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (prow < 0)";
       pre_compile_code_string="if (prow < 0)";
       cond {
	expr="prow < 0";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="CurParams->AddBlankRow()";
	 pre_compile_code_string="CurParams->AddBlankRow()";
	 result_var=NULL;
	 obj=$.projects[0].programs.gp[3][6].vars[2]$;
	 method=DataTable::AddBlankRow;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	 };
	 meth_sig="int AddBlankRow()";
	 meth_desc=" add a new row to the data table, sets read (source) and write (sink) index to this last row (as in ReadItem or WriteItem), so that subsequent data routines refer to this new row, and returns row ";
	};
	AssignExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="prow = -1";
	 pre_compile_code_string="prow = -1";
	 result_var=$.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[4]$;
	 expr {
	  expr="-1";
	 };
	};
	MatrixAssign @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="CurParams[\"name\"][-1] = pnm";
	 pre_compile_code_string="CurParams[\"name\"][-1] = pnm";
	 variable=$.projects[0].programs.gp[3][6].vars[2]$;
	 data_table=1;
	 col {
	  expr="\"name\"";
	 };
	 dim0 {
	  expr="-1";
	 };
	 dim1 {
	  expr=;
	 };
	 dim2 {
	  expr=;
	 };
	 dim3 {
	  expr=;
	 };
	 dim4 {
	  expr=;
	 };
	 dim5 {
	  expr=;
	 };
	 expr {
	  expr="pnm";
	 };
	};
       };
      };
      MatrixAssign @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurParams[\"valstr\"][prow] = pval";
       pre_compile_code_string="CurParams[\"valstr\"][prow] = pval";
       variable=$.projects[0].programs.gp[3][6].vars[2]$;
       data_table=1;
       col {
	expr="\"valstr\"";
       };
       dim0 {
	expr="prow";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="pval";
       };
      };
      MatrixAssign @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurParams[\"matched\"][prow] = key";
       pre_compile_code_string="CurParams[\"matched\"][prow] = key";
       variable=$.projects[0].programs.gp[3][6].vars[2]$;
       data_table=1;
       col {
	expr="\"matched\"";
       };
       dim0 {
	expr="prow";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="key";
       };
      };
     };
     el_var=$.projects[0].programs.gp[3][6].functions[4].fun_code[0].local_vars[1]$;
     in {
      expr="pary";
     };
    };
   };
  };
  Function @[5] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="MatchSentence(String_Array* sary, String keys, String params) returns: int";
   pre_compile_code_string="MatchSentence(String_Array* sary, String keys, String params) returns: int";
   name="MatchSentence";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="sary";
     var_type=T_Object;
     object_type=String_Array;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[1] {
     name="keys";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
    ProgVar @[2] {
     name="params";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_587";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (6 vars)";
     pre_compile_code_string="LocalVars (6 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="kary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="key";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="matched";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="word";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="kmatch";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="neg";
       var_type=T_Bool;
       bool_val=0;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="kary->Split(keys, \" \")";
     pre_compile_code_string="kary->Split(keys, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[0]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="keys";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    AssignExpr @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="matched = true";
     pre_compile_code_string="matched = true";
     result_var=.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[2]$$;
     expr {
      expr="true";
     };
    };
    ForeachLoop @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(key in kary)";
     pre_compile_code_string="foreach(key in kary)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      If @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (key.startsWith(\"!\"))";
       pre_compile_code_string="if (key.startsWith(\"!\"))";
       cond {
	expr="key.startsWith(\"!\")";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	MethodCall @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="key = key->after(\"!\", )";
	 pre_compile_code_string="key = key->after(\"!\", )";
	 result_var=.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[1]$$;
	 obj=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[1]$;
	 method=taString::after;
	 meth_args {
	  name="meth_args";
	  el_typ=ProgArg;
	  el_def=0;
	  ProgArg @[0] {
	   arg_type=const_taString_ref;
	   type="taString&";
	   name="x";
	   required=1;
	   def_val=;
	   prev_expr=;
	   expr {
	    expr="\"!\"";
	   };
	  };
	  ProgArg @[1] {
	   arg_type=int;
	   type="int";
	   name="startpos";
	   required=0;
	   def_val="0";
	   prev_expr=;
	   expr {
	    expr=;
	   };
	  };
	 };
	 meth_sig="taString after(taString& x, int startpos = 0)";
	 meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
	};
	AssignExpr @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="kmatch = true";
	 pre_compile_code_string="kmatch = true";
	 result_var=.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[4]$$;
	 expr {
	  expr="true";
	 };
	};
	ForeachLoop @[2] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="foreach(word in sary)";
	 pre_compile_code_string="foreach(word in sary)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  If @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (word.startsWith(key))";
	   pre_compile_code_string="if (word.startsWith(key))";
	   cond {
	    expr="word.startsWith(key)";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    AssignExpr @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="kmatch = false";
	     pre_compile_code_string="kmatch = false";
	     result_var=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[4]$;
	     expr {
	      expr="false";
	     };
	    };
	    IfBreak @[1] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="break";
	     pre_compile_code_string="break";
	     cond {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	 el_var=.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[3]$$;
	 in {
	  expr="sary";
	 };
	};
       };
      };
      Else @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="else";
       pre_compile_code_string="else";
       else_code {
	name="else_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="kmatch = false";
	 pre_compile_code_string="kmatch = false";
	 result_var=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[4]$;
	 expr {
	  expr="false";
	 };
	};
	ForeachLoop @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="foreach(word in sary)";
	 pre_compile_code_string="foreach(word in sary)";
	 loop_code {
	  name="loop_code";
	  el_typ=ProgCode;
	  el_def=0;
	  If @[0] {
	   desc=;
	   flags=CAN_REVERT_TO_CODE;
	   code_string="if (word.startsWith(key))";
	   pre_compile_code_string="if (word.startsWith(key))";
	   cond {
	    expr="word.startsWith(key)";
	   };
	   true_code {
	    name="true_code";
	    el_typ=ProgCode;
	    el_def=0;
	    AssignExpr @[0] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="kmatch = true";
	     pre_compile_code_string="kmatch = true";
	     result_var=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[4]$;
	     expr {
	      expr="true";
	     };
	    };
	    IfBreak @[1] {
	     desc=;
	     flags=CAN_REVERT_TO_CODE;
	     code_string="break";
	     pre_compile_code_string="break";
	     cond {
	      expr=;
	     };
	    };
	   };
	  };
	 };
	 el_var=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[3]$;
	 in {
	  expr="sary";
	 };
	};
       };
      };
      If @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="if (!kmatch)";
       pre_compile_code_string="if (!kmatch)";
       cond {
	expr="!kmatch";
       };
       true_code {
	name="true_code";
	el_typ=ProgCode;
	el_def=0;
	AssignExpr @[0] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="matched = false";
	 pre_compile_code_string="matched = false";
	 result_var=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[2]$;
	 expr {
	  expr="false";
	 };
	};
	IfBreak @[1] {
	 desc=;
	 flags=CAN_REVERT_TO_CODE;
	 code_string="break";
	 pre_compile_code_string="break";
	 cond {
	  expr=;
	 };
	};
       };
      };
     };
     el_var=$.projects[0].programs.gp[3][6].functions[5].fun_code[0].local_vars[1]$;
     in {
      expr="kary";
     };
    };
    IfReturn @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if(!matched) return";
     pre_compile_code_string="if(!matched) return";
     cond {
      expr="!matched";
     };
    };
    FunctionCall @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="AddParams(params, keys)";
     pre_compile_code_string="AddParams(params, keys)";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][6].functions[4]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=taString;
       type="String";
       name="params";
       required=1;
       def_val=;
       prev_expr="params";
       expr {
	expr="params";
       };
      };
      ProgArg @[1] {
       arg_type=taString;
       type="String";
       name="key";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="keys";
       };
      };
     };
    };
   };
  };
  Function @[6] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ProcessSentence(String sent) returns: int";
   pre_compile_code_string="ProcessSentence(String sent) returns: int";
   name="ProcessSentence";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="sent";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_585";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="sary";
       var_type=T_Object;
       object_type=String_Array;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|NEW_OBJ|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="CurParams->ResetData()";
     pre_compile_code_string="CurParams->ResetData()";
     result_var=NULL;
     obj=$.projects[0].programs.gp[3][6].vars[2]$;
     method=DataTable::ResetData;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
     };
     meth_sig="void ResetData()";
     meth_desc=" deletes all the data (rows), but keeps the column structure -- this cannot be undone!";
    };
    MethodCall @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="sary->Split(sent, \" \")";
     pre_compile_code_string="sary->Split(sent, \" \")";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].functions[6].fun_code[0].local_vars[1]$$;
     method=String_Array::Split;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_taString_ref;
       type="taString&";
       name="str";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="sent";
       };
      };
      ProgArg @[1] {
       arg_type=const_taString_ref;
       type="taString&";
       name="delim";
       required=0;
       def_val="\"\"";
       prev_expr=;
       expr {
	expr="\" \"";
       };
      };
     };
     meth_sig="void Split(taString& str, taString& delim)";
     meth_desc=" Convenience method that calls FmDelimString for splitting a string into an array. Splits on every character by default.";
    };
    ForLoop @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<CompiledSpecs.rows; i++)";
     pre_compile_code_string="for (i=0; i<CompiledSpecs.rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="MatchSentence(sary, CompiledSpecs[\"keywords\"][i], CompiledSpecs[\"params\"][i])";
       pre_compile_code_string="MatchSentence(sary, CompiledSpecs[\"keywords\"][i], CompiledSpecs[\"params\"][i])";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][6].functions[5]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=String_Array;
	 type="String_Array*";
	 name="sary";
	 required=1;
	 def_val=;
	 prev_expr="sent";
	 expr {
	  expr="sary";
	 };
	};
	ProgArg @[1] {
	 arg_type=taString;
	 type="String";
	 name="keys";
	 required=1;
	 def_val=;
	 prev_expr="CompiledSpecs[\"keywords\"][i]";
	 expr {
	  expr="CompiledSpecs[\"keywords\"][i]";
	 };
	};
	ProgArg @[2] {
	 arg_type=taString;
	 type="String";
	 name="params";
	 required=1;
	 def_val=;
	 prev_expr="CompiledSpecs[\"params\"][i]";
	 expr {
	  expr="CompiledSpecs[\"params\"][i]";
	 };
	};
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<CompiledSpecs.rows";
     };
     iter {
      expr="i++";
     };
    };
    FunctionCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="ProcessParams()";
     pre_compile_code_string="ProcessParams()";
     result_var=NULL;
     fun=.projects[0].programs.gp[3][6].functions[8]$$;
     fun_args {
      name="fun_args";
      el_typ=ProgArg;
      el_def=0;
     };
    };
   };
  };
  Function @[7] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ProcessParamVal(String valstr) returns: String";
   pre_compile_code_string="ProcessParamVal(String valstr) returns: String";
   name="ProcessParamVal";
   return_type=T_String;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="valstr";
     var_type=T_String;
     string_val=;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_606";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (11 vars)";
     pre_compile_code_string="LocalVars (11 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="val";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="valp";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[2] {
       name="rndp";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[3] {
       name="rnd";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[4] {
       name="rval";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[5] {
       name="rvalstr";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[6] {
       name="valp_6";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[7] {
       name="stvalp";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[8] {
       name="evalp";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[9] {
       name="stval";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[10] {
       name="eval";
       var_type=T_Real;
       real_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    AssignExpr @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="rvalstr = valstr";
     pre_compile_code_string="rvalstr = valstr";
     result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[5]$$;
     expr {
      expr="valstr";
     };
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (valstr.contains(\"%\"))";
     pre_compile_code_string="if (valstr.contains(\"%\"))";
     cond {
      expr="valstr.contains(\"%\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="valp = valstr->before(\"%\", )";
       pre_compile_code_string="valp = valstr->before(\"%\", )";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$$;
       obj=.projects[0].programs.gp[3][6].functions[7].args[0]$$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"%\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="val = valp->toFloat()";
       pre_compile_code_string="val = valp->toFloat()";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[0]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rndp = valstr->after(\"%\", )";
       pre_compile_code_string="rndp = valstr->after(\"%\", )";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[2]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].args[0]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"%\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rnd = rndp->toFloat()";
       pre_compile_code_string="rnd = rndp->toFloat()";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[3]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[2]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      RandomCall @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rval = Random::UniformMeanRange(val, val * rnd, )";
       pre_compile_code_string="rval = Random::UniformMeanRange(val, val * rnd, )";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[4]$$;
       object_type=Random;
       method=Random::UniformMeanRange;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=double;
	 type="double";
	 name="mean";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="val";
	 };
	};
	ProgArg @[1] {
	 arg_type=double;
	 type="double";
	 name="range";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="val * rnd";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      AssignExpr @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rvalstr = (String)rval";
       pre_compile_code_string="rvalstr = (String)rval";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[5]$;
       expr {
	expr="(String)rval";
       };
      };
     };
    };
    ElseIf @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (valstr.contains(\"&\"))";
     pre_compile_code_string="else if (valstr.contains(\"&\"))";
     cond {
      expr="valstr.contains(\"&\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="valp = valstr->before(\"&\", )";
       pre_compile_code_string="valp = valstr->before(\"&\", )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].args[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"&\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="val = valp->toFloat()";
       pre_compile_code_string="val = valp->toFloat()";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[0]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rndp = valstr->after(\"&\", )";
       pre_compile_code_string="rndp = valstr->after(\"&\", )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[2]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].args[0]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"&\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rnd = rndp->toFloat()";
       pre_compile_code_string="rnd = rndp->toFloat()";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[3]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[2]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      RandomCall @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rval = Random::UniformMeanRange(val, rnd, )";
       pre_compile_code_string="rval = Random::UniformMeanRange(val, rnd, )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[4]$;
       object_type=Random;
       method=Random::UniformMeanRange;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=double;
	 type="double";
	 name="mean";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="val";
	 };
	};
	ProgArg @[1] {
	 arg_type=double;
	 type="double";
	 name="range";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="rnd";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      AssignExpr @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rvalstr = (String)rval";
       pre_compile_code_string="rvalstr = (String)rval";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[5]$;
       expr {
	expr="(String)rval";
       };
      };
     };
    };
    ElseIf @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (valstr.contains(\"*\"))";
     pre_compile_code_string="else if (valstr.contains(\"*\"))";
     cond {
      expr="valstr.contains(\"*\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="valp = valstr->before(\"*\", )";
       pre_compile_code_string="valp = valstr->before(\"*\", )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].args[0]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"*\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="val = valp->toFloat()";
       pre_compile_code_string="val = valp->toFloat()";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[0]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rndp = valstr->after(\"*\", )";
       pre_compile_code_string="rndp = valstr->after(\"*\", )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[2]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].args[0]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"*\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rnd = rndp->toFloat()";
       pre_compile_code_string="rnd = rndp->toFloat()";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[3]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[2]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      RandomCall @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rval = Random::Gauss(rnd, )";
       pre_compile_code_string="rval = Random::Gauss(rnd, )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[4]$;
       object_type=Random;
       method=Random::Gauss;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=double;
	 type="double";
	 name="stdev";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="rnd";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      VarIncr @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rval += val";
       pre_compile_code_string="rval += val";
       var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[4]$;
       expr {
	expr="val";
       };
      };
      AssignExpr @[6] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rvalstr = (String)rval";
       pre_compile_code_string="rvalstr = (String)rval";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[5]$;
       expr {
	expr="(String)rval";
       };
      };
     };
    };
    ElseIf @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="else if (valstr.contains(\"[\") && valstr.contains(\"]\") && valstr.contains(\":\"))";
     pre_compile_code_string="else if (valstr.contains(\"[\") && valstr.contains(\"]\") && valstr.contains(\":\"))";
     cond {
      expr="valstr.contains(\"[\") && valstr.contains(\"]\") && valstr.contains(\":\")";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      MethodCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="valp = valstr->between(\"[\", \"]\", )";
       pre_compile_code_string="valp = valstr->between(\"[\", \"]\", )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       obj=$.projects[0].programs.gp[3][6].functions[7].args[0]$;
       method=taString::between;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="st_str";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"[\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="ed_str";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\"]\"";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString between(taString& st_str, taString& ed_str, int startpos = 0)";
       meth_desc=" get substring between (not including) target strings. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="stvalp = valp->before(\":\", )";
       pre_compile_code_string="stvalp = valp->before(\":\", )";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[7]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       method=taString::before;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\":\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString before(taString& x, int startpos = 0)";
       meth_desc=" get substring before (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[2] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="evalp = valp->after(\":\", )";
       pre_compile_code_string="evalp = valp->after(\":\", )";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[8]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[1]$;
       method=taString::after;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=const_taString_ref;
	 type="taString&";
	 name="x";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="\":\"";
	 };
	};
	ProgArg @[1] {
	 arg_type=int;
	 type="int";
	 name="startpos";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="taString after(taString& x, int startpos = 0)";
       meth_desc=" get substring after (not including) target string. startpos = starting position (- = search from end forward)";
      };
      MethodCall @[3] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="stval = stvalp->toFloat()";
       pre_compile_code_string="stval = stvalp->toFloat()";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[9]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[7]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      MethodCall @[4] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="eval = evalp->toFloat()";
       pre_compile_code_string="eval = evalp->toFloat()";
       result_var=.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[10]$$;
       obj=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[8]$;
       method=taString::toFloat;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=bool_ptr;
	 type="bool*";
	 name="ok";
	 required=0;
	 def_val="0";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
       meth_sig="float toFloat(bool* ok = 0)";
       meth_desc=" to floating point (single precision) value";
      };
      RandomCall @[5] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rval = Random::UniformMinMax(stval, eval, )";
       pre_compile_code_string="rval = Random::UniformMinMax(stval, eval, )";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[4]$;
       object_type=Random;
       method=Random::UniformMinMax;
       meth_args {
	name="meth_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=double;
	 type="double";
	 name="min";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="stval";
	 };
	};
	ProgArg @[1] {
	 arg_type=double;
	 type="double";
	 name="max";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="eval";
	 };
	};
	ProgArg @[2] {
	 arg_type=int;
	 type="int";
	 name="thr_no";
	 required=0;
	 def_val="-1";
	 prev_expr=;
	 expr {
	  expr=;
	 };
	};
       };
      };
      AssignExpr @[6] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="rvalstr = (String)rval";
       pre_compile_code_string="rvalstr = (String)rval";
       result_var=$.projects[0].programs.gp[3][6].functions[7].fun_code[0].local_vars[5]$;
       expr {
	expr="(String)rval";
       };
      };
     };
    };
    ReturnExpr @[6] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return rvalstr";
     pre_compile_code_string="return rvalstr";
     expr {
      expr="rvalstr";
     };
    };
   };
  };
  Function @[8] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ProcessParams() returns: int";
   pre_compile_code_string="ProcessParams() returns: int";
   name="ProcessParams";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_604";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="i";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="val";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    ForLoop @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="for (i=0; i<CurParams.rows; i++)";
     pre_compile_code_string="for (i=0; i<CurParams.rows; i++)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="val = ProcessParamVal(CurParams[\"valstr\"][i])";
       pre_compile_code_string="val = ProcessParamVal(CurParams[\"valstr\"][i])";
       result_var=.projects[0].programs.gp[3][6].functions[8].fun_code[0].local_vars[1]$$;
       fun=.projects[0].programs.gp[3][6].functions[7]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=taString;
	 type="String";
	 name="valstr";
	 required=1;
	 def_val=;
	 prev_expr=;
	 expr {
	  expr="CurParams[\"valstr\"][i]";
	 };
	};
       };
      };
      MatrixAssign @[1] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="CurParams[\"value\"][i] = val";
       pre_compile_code_string="CurParams[\"value\"][i] = val";
       variable=$.projects[0].programs.gp[3][6].vars[2]$;
       data_table=1;
       col {
	expr="\"value\"";
       };
       dim0 {
	expr="i";
       };
       dim1 {
	expr=;
       };
       dim2 {
	expr=;
       };
       dim3 {
	expr=;
       };
       dim4 {
	expr=;
       };
       dim5 {
	expr=;
       };
       expr {
	expr="val";
       };
      };
     };
     init {
      expr="i=0";
     };
     test {
      expr="i<CurParams.rows";
     };
     iter {
      expr="i++";
     };
    };
   };
  };
  Function @[9] {
   desc="gets current parameter value for given variable -- returns true if a value found, false if not";
   flags=CAN_REVERT_TO_CODE;
   code_string="GetParamValue(ProgVar* var) returns: bool";
   pre_compile_code_string="GetParamValue(ProgVar* var) returns: bool";
   name="GetParamValue";
   return_type=T_Bool;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
    ProgVar @[0] {
     name="var";
     var_type=T_Object;
     object_type=ProgVar;
     object_val=NULL;
     objs_ptr=0;
     flags=SAVE_VAL|LOCAL_VAR|FUN_ARG|USED|EDIT_VAL;
     reference=0;
     desc=;
     init_from=NULL;
    };
   };
   fun_code {
    name="ProgEl_List_578";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (2 vars)";
     pre_compile_code_string="LocalVars (2 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="pidx";
       var_type=T_Int;
       int_val=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
      ProgVar @[1] {
       name="val";
       var_type=T_String;
       string_val=;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    MethodCall @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="pidx = cur_params->FindVal(var.name, \"name\", 0, false)";
     pre_compile_code_string="pidx = cur_params->FindVal(var.name, \"name\", 0, false)";
     result_var=.projects[0].programs.gp[3][6].functions[9].fun_code[0].local_vars[0]$$;
     obj=.projects[0].programs.gp[3][6].vars[7]$$;
     method=DataTable::FindVal;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="val";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="var.name";
       };
      };
      ProgArg @[1] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="col";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="\"name\"";
       };
      };
      ProgArg @[2] {
       arg_type=int;
       type="int";
       name="st_row";
       required=0;
       def_val="0";
       prev_expr=;
       expr {
	expr="0";
       };
      };
      ProgArg @[3] {
       arg_type=bool;
       type="bool";
       name="not_found_err";
       required=0;
       def_val="false";
       prev_expr=;
       expr {
	expr="false";
       };
      };
     };
     meth_sig="int FindVal(Variant& val, Variant& col, int st_row = 0, bool not_found_err = false)";
     meth_desc=" find row number for given value within column col of scalar type (use for Programs), starting at given starting row number. if st_row < 0 then the search proceeds backwards from that many rows from end (-1 = end) -- column can be specified as either integer index or a string that is then used to find the given column name. returns -1 if not found, and issues error if not_found_err is true";
    };
    If @[2] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="if (pidx < 0)";
     pre_compile_code_string="if (pidx < 0)";
     cond {
      expr="pidx < 0";
     };
     true_code {
      name="true_code";
      el_typ=ProgCode;
      el_def=0;
      ReturnExpr @[0] {
       desc=;
       flags=CAN_REVERT_TO_CODE;
       code_string="return false";
       pre_compile_code_string="return false";
       expr {
	expr="false";
       };
      };
     };
    };
    AssignExpr @[3] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="val = cur_params[\"value\"][pidx]";
     pre_compile_code_string="val = cur_params[\"value\"][pidx]";
     result_var=.projects[0].programs.gp[3][6].functions[9].fun_code[0].local_vars[1]$$;
     expr {
      expr="cur_params[\"value\"][pidx]";
     };
    };
    MethodCall @[4] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="var->SetVar(val)";
     pre_compile_code_string="var->SetVar(val)";
     result_var=NULL;
     obj=.projects[0].programs.gp[3][6].functions[9].args[0]$$;
     method=ProgVar::SetVar;
     meth_args {
      name="meth_args";
      el_typ=ProgArg;
      el_def=0;
      ProgArg @[0] {
       arg_type=const_Variant_ref;
       type="Variant&";
       name="value";
       required=1;
       def_val=;
       prev_expr=;
       expr {
	expr="val";
       };
      };
     };
     meth_sig="void SetVar(Variant& value)";
     meth_desc=" set from variant value (general purpose variable setting) -- does not change type of variable, just sets from variant value";
    };
    ReturnExpr @[5] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="return true";
     pre_compile_code_string="return true";
     expr {
      expr="true";
     };
    };
   };
  };
  Function @[10] {
   desc="this gets all the parameter values for any variable present in the .vars section -- no err if not foun";
   flags=CAN_REVERT_TO_CODE;
   code_string="GetAllParams() returns: int";
   pre_compile_code_string="GetAllParams() returns: int";
   name="GetAllParams";
   return_type=T_Int;
   object_type=taOBase;
   args {
    name="ProgVar_List_1";
    el_typ=ProgVar;
    el_def=0;
   };
   fun_code {
    name="ProgEl_List_590";
    el_typ=ProgCode;
    el_def=0;
    LocalVars @[0] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="LocalVars (1 vars)";
     pre_compile_code_string="LocalVars (1 vars)";
     local_vars {
      name="local_vars";
      el_typ=ProgVar;
      el_def=0;
      ProgVar @[0] {
       name="pvar";
       var_type=T_Object;
       object_type=ProgVar;
       object_val=NULL;
       objs_ptr=0;
       flags=SAVE_VAL|LOCAL_VAR|USED|EDIT_VAL;
       reference=0;
       desc=;
       init_from=NULL;
      };
     };
    };
    ForeachLoop @[1] {
     desc=;
     flags=CAN_REVERT_TO_CODE;
     code_string="foreach(pvar in this.vars)";
     pre_compile_code_string="foreach(pvar in this.vars)";
     loop_code {
      name="loop_code";
      el_typ=ProgCode;
      el_def=0;
      FunctionCall @[0] {
       desc="just try them all and see what sticks!";
       flags=CAN_REVERT_TO_CODE;
       code_string="GetParamValue(pvar)";
       pre_compile_code_string="GetParamValue(pvar)";
       result_var=NULL;
       fun=.projects[0].programs.gp[3][6].functions[9]$$;
       fun_args {
	name="fun_args";
	el_typ=ProgArg;
	el_def=0;
	ProgArg @[0] {
	 arg_type=ProgVar;
	 type="ProgVar*";
	 name="var";
	 required=1;
	 def_val=;
	 prev_expr="pvar";
	 expr {
	  expr="pvar";
	 };
	};
       };
      };
     };
     el_var=.projects[0].programs.gp[3][6].functions[10].fun_code[0].local_vars[0]$$;
     in {
      expr="this.vars";
     };
    };
   };
  };
 };
 init_code {
  name="init_code";
  el_typ=ProgCode;
  el_def=0;
  FunctionCall @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="CompileSpecs()";
   pre_compile_code_string="CompileSpecs()";
   result_var=NULL;
   fun=.projects[0].programs.gp[3][6].functions[3]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
   };
  };
 };
 prog_code {
  name="prog_code";
  el_typ=ProgCode;
  el_def=0;
  LocalVars @[0] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="LocalVars (0 vars)";
   pre_compile_code_string="LocalVars (0 vars)";
   local_vars {
    name="local_vars";
    el_typ=ProgVar;
    el_def=0;
   };
  };
  FunctionCall @[1] {
   desc=;
   flags=CAN_REVERT_TO_CODE;
   code_string="ProcessSentence(input_sentence)";
   pre_compile_code_string="ProcessSentence(input_sentence)";
   result_var=NULL;
   fun=.projects[0].programs.gp[3][6].functions[6]$$;
   fun_args {
    name="fun_args";
    el_typ=ProgArg;
    el_def=0;
    ProgArg @[0] {
     arg_type=taString;
     type="String";
     name="sent";
     required=1;
     def_val=;
     prev_expr=;
     expr {
      expr="input_sentence";
     };
    };
   };
  };
 };
 step_prog=NULL;
 step_n=1;
};
